/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0  
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/*!----------------- TypeScript ThirdPartyNotices -------------------------------------------------------

The TypeScript software is based on or incorporates material and code from the projects listed below 
(collectively "Third Party Code"). Microsoft is not the original author of the 
Third Party Code. The original copyright notice and the license, under which 
Microsoft received such Third Party Code, are set forth below. Such license and 
notices are provided for informational purposes only. Microsoft licenses the Third 
Party Code to you under the terms of the Apache 2.0 License.
All Third Party Code licensed by Microsoft under the Apache License, Version 2.0 (the "License"); you 
may not use this file except in compliance with the License. You may obtain a copy 
of the License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR 
CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT. 

See the Apache Version 2.0 License for specific language governing permissions and 
limitations under the License.
---------------------------------------------
Third Party Code Components
--------------------------------------------
---- Mozilla Developer Code---------
The following Mozilla Developer Code is under Public Domain as updated after Aug. 20, 2012, see, https://developer.mozilla.org/en-US/docs/Project:Copyrights
1. Array filter Compatibility Method, 
Available at https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/filter
Any copyright is dedicated to the Public Domain.

2. Array forEach Compatibility Method, 
Available at https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach
Any copyright is dedicated to the Public Domain.

3. Array indexOf Compatibility Method, 
Available at https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf
Any copyright is dedicated to the Public Domain.

4. Array map Compatibility Method, 
Available at https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/map
Any copyright is dedicated to the Public Domain.

5. Array Reduce Compatibility Method, 
Available at https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/Reduce
Any copyright is dedicated to the Public Domain.

6. String Trim Compatibility Method, 
Available at https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/Trim
Any copyright is dedicated to the Public Domain.

7. Date now Compatibility Method, 
Available at https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now
Any copyright is dedicated to the Public Domain.

------------JSON2 Script------------------------
json2.js 2012-10-08
Public Domain.
NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
See, http://www.JSON.org/js.html

--------------r.js----------------------
Copyright (c) 2010-2011 Dojo Foundation. All Rights Reserved.
Originally License under MIT License
-------------------------------------------------------------------------
Provided for Informational Purposes Only
MIT License

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--------------------------------------------------------------------------------------

------------- End of ThirdPartyNotices --------------------------------------------------- */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TypeScript;
(function (TypeScript) {
    TypeScript.DiagnosticCode = {
        error_TS_0_1: 'error TS{0}: {1}',
        warning_TS_0_1: 'warning TS{0}: {1}',
        Unrecognized_escape_sequence: 'Unrecognized escape sequence.',
        Unexpected_character_0: 'Unexpected character {0}.',
        Missing_close_quote_character: 'Missing close quote character.',
        Identifier_expected: 'Identifier expected.',
        _0_keyword_expected: "'{0}' keyword expected.",
        _0_expected: "'{0}' expected.",
        Identifier_expected_0_is_a_keyword: "Identifier expected; '{0}' is a keyword.",
        Automatic_semicolon_insertion_not_allowed: 'Automatic semicolon insertion not allowed.',
        Unexpected_token_0_expected: "Unexpected token; '{0}' expected.",
        Trailing_separator_not_allowed: 'Trailing separator not allowed.',
        AsteriskSlash_expected: "'*/' expected.",
        public_or_private_modifier_must_precede_static: "'public' or 'private' modifier must precede 'static'.",
        Unexpected_token: 'Unexpected token.',
        Catch_clause_parameter_cannot_have_a_type_annotation: 'Catch clause parameter cannot have a type annotation.',
        Rest_parameter_must_be_last_in_list: 'Rest parameter must be last in list.',
        Parameter_cannot_have_question_mark_and_initializer: 'Parameter cannot have question mark and initializer.',
        Required_parameter_cannot_follow_optional_parameter: 'Required parameter cannot follow optional parameter.',
        Index_signatures_cannot_have_rest_parameters: 'Index signatures cannot have rest parameters.',
        Index_signature_parameter_cannot_have_accessibility_modifiers: 'Index signature parameter cannot have accessibility modifiers.',
        Index_signature_parameter_cannot_have_a_question_mark: 'Index signature parameter cannot have a question mark.',
        Index_signature_parameter_cannot_have_an_initializer: 'Index signature parameter cannot have an initializer.',
        Index_signature_must_have_a_type_annotation: 'Index signature must have a type annotation.',
        Index_signature_parameter_must_have_a_type_annotation: 'Index signature parameter must have a type annotation.',
        Index_signature_parameter_type_must_be_string_or_number: "Index signature parameter type must be 'string' or 'number'.",
        extends_clause_already_seen: "'extends' clause already seen.",
        extends_clause_must_precede_implements_clause: "'extends' clause must precede 'implements' clause.",
        Classes_can_only_extend_a_single_class: 'Classes can only extend a single class.',
        implements_clause_already_seen: "'implements' clause already seen.",
        Accessibility_modifier_already_seen: 'Accessibility modifier already seen.',
        _0_modifier_must_precede_1_modifier: "'{0}' modifier must precede '{1}' modifier.",
        _0_modifier_already_seen: "'{0}' modifier already seen.",
        _0_modifier_cannot_appear_on_a_class_element: "'{0}' modifier cannot appear on a class element.",
        Interface_declaration_cannot_have_implements_clause: "Interface declaration cannot have 'implements' clause.",
        super_invocation_cannot_have_type_arguments: "'super' invocation cannot have type arguments.",
        Only_ambient_modules_can_use_quoted_names: 'Only ambient modules can use quoted names.',
        Statements_are_not_allowed_in_ambient_contexts: 'Statements are not allowed in ambient contexts.',
        Implementations_are_not_allowed_in_ambient_contexts: 'Implementations are not allowed in ambient contexts.',
        declare_modifier_not_allowed_for_code_already_in_an_ambient_context: "'declare' modifier not allowed for code already in an ambient context.",
        Initializers_are_not_allowed_in_ambient_contexts: 'Initializers are not allowed in ambient contexts.',
        Parameter_property_declarations_can_only_be_used_in_constructors: 'Parameter property declarations can only be used in constructors.',
        Function_implementation_expected: 'Function implementation expected.',
        Constructor_implementation_expected: 'Constructor implementation expected.',
        Function_overload_name_must_be_0: "Function overload name must be '{0}'.",
        _0_modifier_cannot_appear_on_a_module_element: "'{0}' modifier cannot appear on a module element.",
        declare_modifier_cannot_appear_on_an_interface_declaration: "'declare' modifier cannot appear on an interface declaration.",
        declare_modifier_required_for_top_level_element: "'declare' modifier required for top level element.",
        Rest_parameter_cannot_be_optional: 'Rest parameter cannot be optional.',
        Rest_parameter_cannot_have_an_initializer: 'Rest parameter cannot have an initializer.',
        set_accessor_must_have_one_and_only_one_parameter: "'set' accessor must have one and only one parameter.",
        set_accessor_parameter_cannot_be_optional: "'set' accessor parameter cannot be optional.",
        set_accessor_parameter_cannot_have_an_initializer: "'set' accessor parameter cannot have an initializer.",
        set_accessor_cannot_have_rest_parameter: "'set' accessor cannot have rest parameter.",
        get_accessor_cannot_have_parameters: "'get' accessor cannot have parameters.",
        Modifiers_cannot_appear_here: 'Modifiers cannot appear here.',
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: 'Accessors are only available when targeting ECMAScript 5 and higher.',
        Class_name_cannot_be_0: "Class name cannot be '{0}'.",
        Interface_name_cannot_be_0: "Interface name cannot be '{0}'.",
        Enum_name_cannot_be_0: "Enum name cannot be '{0}'.",
        Module_name_cannot_be_0: "Module name cannot be '{0}'.",
        Enum_member_must_have_initializer: 'Enum member must have initializer.',
        Export_assignment_cannot_be_used_in_internal_modules: 'Export assignment cannot be used in internal modules.',
        Export_assignment_not_allowed_in_module_with_exported_element: 'Export assignment not allowed in module with exported element.',
        Module_cannot_have_multiple_export_assignments: 'Module cannot have multiple export assignments.',
        Ambient_enum_elements_can_only_have_integer_literal_initializers: 'Ambient enum elements can only have integer literal initializers.',
        module_class_interface_enum_import_or_statement: 'module, class, interface, enum, import or statement',
        constructor_function_accessor_or_variable: 'constructor, function, accessor or variable',
        statement: 'statement',
        case_or_default_clause: 'case or default clause',
        identifier: 'identifier',
        call_construct_index_property_or_function_signature: 'call, construct, index, property or function signature',
        expression: 'expression',
        type_name: 'type name',
        property_or_accessor: 'property or accessor',
        parameter: 'parameter',
        type: 'type',
        type_parameter: 'type parameter',
        declare_modifier_not_allowed_on_import_declaration: "'declare' modifier not allowed on import declaration.",
        Function_overload_must_be_static: 'Function overload must be static.',
        Function_overload_must_not_be_static: 'Function overload must not be static.',
        Parameter_property_declarations_cannot_be_used_in_an_ambient_context: 'Parameter property declarations cannot be used in an ambient context.',
        Parameter_property_declarations_cannot_be_used_in_a_constructor_overload: 'Parameter property declarations cannot be used in a constructor overload.',
        Invalid_reference_directive_syntax: "Invalid 'reference' directive syntax.",
        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher: 'Octal literals are not available when targeting ECMAScript 5 and higher.',
        Accessors_are_not_allowed_in_ambient_contexts: 'Accessors are not allowed in ambient contexts.',
        _0_modifier_cannot_appear_on_a_constructor_declaration: "'{0}' modifier cannot appear on a constructor declaration.",
        _0_modifier_cannot_appear_on_a_parameter: "'{0}' modifier cannot appear on a parameter.",
        Duplicate_identifier_0: "Duplicate identifier '{0}'.",
        The_name_0_does_not_exist_in_the_current_scope: "The name '{0}' does not exist in the current scope.",
        The_name_0_does_not_refer_to_a_value: "The name '{0}' does not refer to a value.",
        super_can_only_be_used_inside_a_class_instance_method: "'super' can only be used inside a class instance method.",
        The_left_hand_side_of_an_assignment_expression_must_be_a_variable_property_or_indexer: 'The left-hand side of an assignment expression must be a variable, property or indexer.',
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: "Value of type '{0}' is not callable. Did you mean to include 'new'?",
        Value_of_type_0_is_not_callable: "Value of type '{0}' is not callable.",
        Value_of_type_0_is_not_newable: "Value of type '{0}' is not newable.",
        Value_of_type_0_is_not_indexable_by_type_1: "Value of type '{0}' is not indexable by type '{1}'.",
        Operator_0_cannot_be_applied_to_types_1_and_2: "Operator '{0}' cannot be applied to types '{1}' and '{2}'.",
        Operator_0_cannot_be_applied_to_types_1_and_2_3: "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}",
        Cannot_convert_0_to_1: "Cannot convert '{0}' to '{1}'.",
        Cannot_convert_0_to_1_NL_2: "Cannot convert '{0}' to '{1}':{NL}{2}",
        Expected_var_class_interface_or_module: 'Expected var, class, interface, or module.',
        Operator_0_cannot_be_applied_to_type_1: "Operator '{0}' cannot be applied to type '{1}'.",
        Getter_0_already_declared: "Getter '{0}' already declared.",
        Setter_0_already_declared: "Setter '{0}' already declared.",
        Exported_class_0_extends_private_class_1: "Exported class '{0}' extends private class '{1}'.",
        Exported_class_0_implements_private_interface_1: "Exported class '{0}' implements private interface '{1}'.",
        Exported_interface_0_extends_private_interface_1: "Exported interface '{0}' extends private interface '{1}'.",
        Exported_class_0_extends_class_from_inaccessible_module_1: "Exported class '{0}' extends class from inaccessible module {1}.",
        Exported_class_0_implements_interface_from_inaccessible_module_1: "Exported class '{0}' implements interface from inaccessible module {1}.",
        Exported_interface_0_extends_interface_from_inaccessible_module_1: "Exported interface '{0}' extends interface from inaccessible module {1}.",
        Public_static_property_0_of_exported_class_has_or_is_using_private_type_1: "Public static property '{0}' of exported class has or is using private type '{1}'.",
        Public_property_0_of_exported_class_has_or_is_using_private_type_1: "Public property '{0}' of exported class has or is using private type '{1}'.",
        Property_0_of_exported_interface_has_or_is_using_private_type_1: "Property '{0}' of exported interface has or is using private type '{1}'.",
        Exported_variable_0_has_or_is_using_private_type_1: "Exported variable '{0}' has or is using private type '{1}'.",
        Public_static_property_0_of_exported_class_is_using_inaccessible_module_1: "Public static property '{0}' of exported class is using inaccessible module {1}.",
        Public_property_0_of_exported_class_is_using_inaccessible_module_1: "Public property '{0}' of exported class is using inaccessible module {1}.",
        Property_0_of_exported_interface_is_using_inaccessible_module_1: "Property '{0}' of exported interface is using inaccessible module {1}.",
        Exported_variable_0_is_using_inaccessible_module_1: "Exported variable '{0}' is using inaccessible module {1}.",
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public method from exported class has or is using private type '{1}'.",
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of method from exported interface has or is using private type '{1}'.",
        Parameter_0_of_exported_function_has_or_is_using_private_type_1: "Parameter '{0}' of exported function has or is using private type '{1}'.",
        Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
        Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}",
        Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public method from exported class is using inaccessible module {1}.",
        Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of method from exported interface is using inaccessible module {1}.",
        Parameter_0_of_exported_function_is_using_inaccessible_module_1: "Parameter '{0}' of exported function is using inaccessible module {1}.",
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public static property getter from exported class has or is using private type '{0}'.",
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public property getter from exported class has or is using private type '{0}'.",
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of constructor signature from exported interface has or is using private type '{0}'.",
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of call signature from exported interface has or is using private type '{0}'.",
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of index signature from exported interface has or is using private type '{0}'.",
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public static method from exported class has or is using private type '{0}'.",
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public method from exported class has or is using private type '{0}'.",
        Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0: "Return type of method from exported interface has or is using private type '{0}'.",
        Return_type_of_exported_function_has_or_is_using_private_type_0: "Return type of exported function has or is using private type '{0}'.",
        Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0: 'Return type of public static property getter from exported class is using inaccessible module {0}.',
        Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0: 'Return type of public property getter from exported class is using inaccessible module {0}.',
        Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0: 'Return type of constructor signature from exported interface is using inaccessible module {0}.',
        Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0: 'Return type of call signature from exported interface is using inaccessible module {0}.',
        Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0: 'Return type of index signature from exported interface is using inaccessible module {0}.',
        Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0: 'Return type of public static method from exported class is using inaccessible module {0}.',
        Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0: 'Return type of public method from exported class is using inaccessible module {0}.',
        Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0: 'Return type of method from exported interface is using inaccessible module {0}.',
        Return_type_of_exported_function_is_using_inaccessible_module_0: 'Return type of exported function is using inaccessible module {0}.',
        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.",
        A_parameter_list_must_follow_a_generic_type_argument_list_expected: "A parameter list must follow a generic type argument list. '(' expected.",
        Multiple_constructor_implementations_are_not_allowed: 'Multiple constructor implementations are not allowed.',
        Unable_to_resolve_external_module_0: "Unable to resolve external module '{0}'.",
        Module_cannot_be_aliased_to_a_non_module_type: 'Module cannot be aliased to a non-module type.',
        A_class_may_only_extend_another_class: 'A class may only extend another class.',
        A_class_may_only_implement_another_class_or_interface: 'A class may only implement another class or interface.',
        An_interface_may_only_extend_another_class_or_interface: 'An interface may only extend another class or interface.',
        Unable_to_resolve_type: 'Unable to resolve type.',
        Unable_to_resolve_type_of_0: "Unable to resolve type of '{0}'.",
        Unable_to_resolve_type_parameter_constraint: 'Unable to resolve type parameter constraint.',
        Type_parameter_constraint_cannot_be_a_primitive_type: 'Type parameter constraint cannot be a primitive type.',
        Supplied_parameters_do_not_match_any_signature_of_call_target: 'Supplied parameters do not match any signature of call target.',
        Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0: 'Supplied parameters do not match any signature of call target:{NL}{0}',
        Invalid_new_expression: "Invalid 'new' expression.",
        Call_signatures_used_in_a_new_expression_must_have_a_void_return_type: "Call signatures used in a 'new' expression must have a 'void' return type.",
        Could_not_select_overload_for_new_expression: "Could not select overload for 'new' expression.",
        Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2: "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.",
        Could_not_select_overload_for_call_expression: "Could not select overload for 'call' expression.",
        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: 'Cannot invoke an expression whose type lacks a call signature.',
        Calls_to_super_are_only_valid_inside_a_class: "Calls to 'super' are only valid inside a class.",
        Generic_type_0_requires_1_type_argument_s: "Generic type '{0}' requires {1} type argument(s).",
        Type_of_array_literal_cannot_be_determined_Best_common_type_could_not_be_found_for_array_elements: 'Type of array literal cannot be determined. Best common type could not be found for array elements.',
        Could_not_find_enclosing_symbol_for_dotted_name_0: "Could not find enclosing symbol for dotted name '{0}'.",
        The_property_0_does_not_exist_on_value_of_type_1: "The property '{0}' does not exist on value of type '{1}'.",
        Could_not_find_symbol_0: "Could not find symbol '{0}'.",
        get_and_set_accessor_must_have_the_same_type: "'get' and 'set' accessor must have the same type.",
        this_cannot_be_referenced_in_current_location: "'this' cannot be referenced in current location.",
        Static_methods_cannot_reference_class_type_parameters: 'Static methods cannot reference class type parameters.',
        Class_0_is_recursively_referenced_as_a_base_type_of_itself: "Class '{0}' is recursively referenced as a base type of itself.",
        Interface_0_is_recursively_referenced_as_a_base_type_of_itself: "Interface '{0}' is recursively referenced as a base type of itself.",
        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.",
        super_cannot_be_referenced_in_non_derived_classes: "'super' cannot be referenced in non-derived classes.",
        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.",
        Constructors_for_derived_classes_must_contain_a_super_call: "Constructors for derived classes must contain a 'super' call.",
        Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors: 'Super calls are not permitted outside constructors or in local functions inside constructors.',
        _0_1_is_inaccessible: "'{0}.{1}' is inaccessible.",
        this_cannot_be_referenced_within_module_bodies: "'this' cannot be referenced within module bodies.",
        Invalid_expression_types_not_known_to_support_the_addition_operator: "Invalid '+' expression - types not known to support the addition operator.",
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type_any_number_or_an_enum_type: "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.",
        Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation: "Variable declarations of a 'for' statement cannot use a type annotation.",
        Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any: "Variable declarations of a 'for' statement must be of types 'string' or 'any'.",
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number: "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.",
        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.",
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_a_subtype_of_the_Function_interface_type: "The right-hand side of an 'instanceof' expression must be of type 'any' or a subtype of the 'Function' interface type.",
        Setters_cannot_return_a_value: 'Setters cannot return a value.',
        Tried_to_query_type_of_uninitialized_module_0: "Tried to query type of uninitialized module '{0}'.",
        Tried_to_set_variable_type_to_uninitialized_module_type_0: "Tried to set variable type to uninitialized module type '{0}'.",
        Function_0_declared_a_non_void_return_type_but_has_no_return_expression: "Function '{0}' declared a non-void return type, but has no return expression.",
        Getters_must_return_a_value: 'Getters must return a value.',
        Getter_and_setter_accessors_do_not_agree_in_visibility: 'Getter and setter accessors do not agree in visibility.',
        Invalid_left_hand_side_of_assignment_expression: 'Invalid left-hand side of assignment expression.',
        Function_declared_a_non_void_return_type_but_has_no_return_expression: 'Function declared a non-void return type, but has no return expression.',
        Cannot_resolve_return_type_reference: 'Cannot resolve return type reference.',
        Constructors_cannot_have_a_return_type_of_void: "Constructors cannot have a return type of 'void'.",
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.",
        All_symbols_within_a_with_block_will_be_resolved_to_any: "All symbols within a with block will be resolved to 'any'.",
        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: 'Import declarations in an internal module cannot reference an external module.',
        Class_0_declares_interface_1_but_does_not_implement_it_NL_2: 'Class {0} declares interface {1} but does not implement it:{NL}{2}',
        Class_0_declares_class_1_as_an_interface_but_does_not_implement_it_NL_2: 'Class {0} declares class {1} as an interface but does not implement it:{NL}{2}',
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: 'The operand of an increment or decrement operator must be a variable, property or indexer.',
        this_cannot_be_referenced_in_static_initializers_in_a_class_body: "'this' cannot be referenced in static initializers in a class body.",
        Class_0_cannot_extend_class_1_NL_2: "Class '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_class_1_NL_2: "Interface '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_interface_1_NL_2: "Interface '{0}' cannot extend interface '{1}':{NL}{2}",
        Duplicate_overload_signature_for_0: "Duplicate overload signature for '{0}'.",
        Duplicate_constructor_overload_signature: 'Duplicate constructor overload signature.',
        Duplicate_overload_call_signature: 'Duplicate overload call signature.',
        Duplicate_overload_construct_signature: 'Duplicate overload construct signature.',
        Overload_signature_is_not_compatible_with_function_definition: 'Overload signature is not compatible with function definition.',
        Overload_signature_is_not_compatible_with_function_definition_NL_0: 'Overload signature is not compatible with function definition:{NL}{0}',
        Overload_signatures_must_all_be_public_or_private: 'Overload signatures must all be public or private.',
        Overload_signatures_must_all_be_exported_or_not_exported: 'Overload signatures must all be exported or not exported.',
        Overload_signatures_must_all_be_ambient_or_non_ambient: 'Overload signatures must all be ambient or non-ambient.',
        Overload_signatures_must_all_be_optional_or_required: 'Overload signatures must all be optional or required.',
        Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature: 'Specialized overload signature is not subtype of any non-specialized signature.',
        this_cannot_be_referenced_in_constructor_arguments: "'this' cannot be referenced in constructor arguments.",
        Instance_member_cannot_be_accessed_off_a_class: 'Instance member cannot be accessed off a class.',
        Untyped_function_calls_may_not_accept_type_arguments: 'Untyped function calls may not accept type arguments.',
        Non_generic_functions_may_not_accept_type_arguments: 'Non-generic functions may not accept type arguments.',
        A_generic_type_may_not_reference_itself_with_a_wrapped_form_of_its_own_type_parameters: 'A generic type may not reference itself with a wrapped form of its own type parameters.',
        Rest_parameters_must_be_array_types: 'Rest parameters must be array types.',
        Overload_signature_implementation_cannot_use_specialized_type: 'Overload signature implementation cannot use specialized type.',
        Export_assignments_may_only_be_used_at_the_top_level_of_external_modules: 'Export assignments may only be used at the top-level of external modules.',
        Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: 'Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.',
        Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword: "Only public methods of the base class are accessible via the 'super' keyword.",
        Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1: "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}'.",
        Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1_NL_2: "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}':{NL}{2}",
        All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0: "All numerically named properties must be subtypes of numeric indexer type '{0}'.",
        All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0_NL_1: "All numerically named properties must be subtypes of numeric indexer type '{0}':{NL}{1}",
        All_named_properties_must_be_subtypes_of_string_indexer_type_0: "All named properties must be subtypes of string indexer type '{0}'.",
        All_named_properties_must_be_subtypes_of_string_indexer_type_0_NL_1: "All named properties must be subtypes of string indexer type '{0}':{NL}{1}",
        Generic_type_references_must_include_all_type_arguments: 'Generic type references must include all type arguments.',
        Default_arguments_are_not_allowed_in_an_overload_parameter: 'Default arguments are not allowed in an overload parameter.',
        Overloads_cannot_differ_only_by_return_type: 'Overloads cannot differ only by return type.',
        Function_expression_declared_a_non_void_return_type_but_has_no_return_expression: 'Function expression declared a non-void return type, but has no return expression.',
        Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: 'Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.',
        Could_not_find_symbol_0_in_module_1: "Could not find symbol '{0}' in module '{1}'.",
        Unable_to_resolve_module_reference_0: "Unable to resolve module reference '{0}'.",
        Could_not_find_module_0_in_module_1: "Could not find module '{0}' in module '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.",
        Type_reference_0_in_extends_clause_does_not_reference_constructor_function_for_1: "Type reference '{0}' in extends clause does not reference constructor function for '{1}'.",
        Internal_module_reference_0_in_import_declaration_does_not_reference_module_instance_for_1: "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.",
        Module_0_cannot_merge_with_previous_declaration_of_1_in_a_different_file_2: "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.",
        Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3: "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}",
        Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.",
        Ambient_external_module_declaration_cannot_be_reopened: 'Ambient external module declaration cannot be reopened.',
        All_declarations_of_merged_declaration_0_must_be_exported_or_not_exported: "All declarations of merged declaration '{0}' must be exported or not exported.",
        super_cannot_be_referenced_in_constructor_arguments: "'super' cannot be referenced in constructor arguments.",
        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: 'Return type of constructor signature must be assignable to the instance type of the class.',
        Ambient_external_module_declaration_must_be_defined_in_global_context: 'Ambient external module declaration must be defined in global context.',
        Ambient_external_module_declaration_cannot_specify_relative_module_name: 'Ambient external module declaration cannot specify relative module name.',
        Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name: 'Import declaration in an ambient external module declaration cannot reference external module through relative external module name.',
        Could_not_find_the_best_common_type_of_types_of_all_return_statement_expressions: 'Could not find the best common type of types of all return statement expressions.',
        Import_declaration_cannot_refer_to_external_module_reference_when_noResolve_option_is_set: 'Import declaration cannot refer to external module reference when --noResolve option is set.',
        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.",
        continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: "'continue' statement can only be used within an enclosing iteration statement.",
        break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: "'break' statement can only be used within an enclosing iteration or switch statement.",
        Jump_target_not_found: 'Jump target not found.',
        Jump_target_cannot_cross_function_boundary: 'Jump target cannot cross function boundary.',
        Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.",
        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.",
        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: "Expression resolves to '_super' that compiler uses to capture base class reference.",
        TypeParameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.",
        TypeParameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.",
        TypeParameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_exported_function_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported function has or is using private type '{1}'.",
        TypeParameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
        TypeParameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}",
        TypeParameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.",
        TypeParameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.",
        TypeParameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.",
        TypeParameter_0_of_exported_function_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported function is using inaccessible module {1}.",
        TypeParameter_0_of_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported class has or is using private type '{1}'.",
        TypeParameter_0_of_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported class is using inaccessible module {1}.",
        TypeParameter_0_of_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported interface is using inaccessible module {1}.",
        Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter: "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.",
        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.",
        Type_of_conditional_0_must_be_identical_to_1_or_2: "Type of conditional '{0}' must be identical to '{1}' or '{2}'.",
        Type_of_conditional_0_must_be_identical_to_1_2_or_3: "Type of conditional '{0}' must be identical to '{1}', '{2}' or '{3}'.",
        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module: "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.",
        Type_0_is_missing_property_1_from_type_2: "Type '{0}' is missing property '{1}' from type '{2}'.",
        Types_of_property_0_of_types_1_and_2_are_incompatible: "Types of property '{0}' of types '{1}' and '{2}' are incompatible.",
        Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3: "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}",
        Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.",
        Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.",
        Types_0_and_1_define_property_2_as_private: "Types '{0}' and '{1}' define property '{2}' as private.",
        Call_signatures_of_types_0_and_1_are_incompatible: "Call signatures of types '{0}' and '{1}' are incompatible.",
        Call_signatures_of_types_0_and_1_are_incompatible_NL_2: "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_call_signature_but_type_1_lacks_one: "Type '{0}' requires a call signature, but type '{1}' lacks one.",
        Construct_signatures_of_types_0_and_1_are_incompatible: "Construct signatures of types '{0}' and '{1}' are incompatible.",
        Construct_signatures_of_types_0_and_1_are_incompatible_NL_2: "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_construct_signature_but_type_1_lacks_one: "Type '{0}' requires a construct signature, but type '{1}' lacks one.",
        Index_signatures_of_types_0_and_1_are_incompatible: "Index signatures of types '{0}' and '{1}' are incompatible.",
        Index_signatures_of_types_0_and_1_are_incompatible_NL_2: "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Call_signature_expects_0_or_fewer_parameters: 'Call signature expects {0} or fewer parameters.',
        Could_not_apply_type_0_to_argument_1_which_is_of_type_2: "Could not apply type '{0}' to argument {1} which is of type '{2}'.",
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}",
        Type_reference_cannot_refer_to_container_0: "Type reference cannot refer to container '{0}'.",
        Type_reference_must_refer_to_type: 'Type reference must refer to type.',
        Enums_with_multiple_declarations_must_provide_an_initializer_for_the_first_enum_element: 'Enums with multiple declarations must provide an initializer for the first enum element.',
        _0_overload_s: ' (+ {0} overload(s))',
        Variable_declaration_cannot_have_the_same_name_as_an_import_declaration: 'Variable declaration cannot have the same name as an import declaration.',
        Signature_expected_0_type_arguments_got_1_instead: 'Signature expected {0} type arguments, got {1} instead.',
        Property_0_defined_as_optional_in_type_1_but_is_required_in_type_2: "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.",
        Types_0_and_1_originating_in_inifinitely_expanding_type_reference_do_not_refer_to_same_named_type: "Types '{0}' and '{1}' originating in inifinitely expanding type reference do not refer to same named type.",
        Types_0_and_1_originating_in_inifinitely_expanding_type_reference_have_incompatible_type_arguments: "Types '{0}' and '{1}' originating in inifinitely expanding type reference have incompatible type arguments.",
        Types_0_and_1_originating_in_inifinitely_expanding_type_reference_have_incompatible_type_arguments_NL_2: "Types '{0}' and '{1}' originating in inifinitely expanding type reference have incompatible type arguments:{NL}{2}",
        Types_of_property_0_of_types_1_and_2_are_not_identical: "Types of property '{0}' of types '{1}' and '{2}' are not identical.",
        Types_of_string_indexer_of_types_0_and_1_are_not_identical: "Types of string indexer of types '{0}' and '{1}' are not identical.",
        Types_of_number_indexer_of_types_0_and_1_are_not_identical: "Types of number indexer of types '{0}' and '{1}' are not identical.",
        Type_of_number_indexer_in_type_0_is_not_a_subtype_of_string_indexer_type_in_type_1_NL_2: "Type of number indexer in type '{0}' is not a subtype of string indexer type in type '{1}'.{NL}{2}",
        Type_of_property_0_in_type_1_is_not_a_subtype_of_string_indexer_type_in_type_2_NL_3: "Type of property '{0}' in type '{1}' is not a subtype of string indexer type in type '{2}'.{NL}{3}",
        Type_of_property_0_in_type_1_is_not_a_subtype_of_number_indexer_type_in_type_2_NL_3: "Type of property '{0}' in type '{1}' is not a subtype of number indexer type in type '{2}'.{NL}{3}",
        Current_host_does_not_support_0_option: "Current host does not support '{0}' option.",
        ECMAScript_target_version_0_not_supported_Specify_a_valid_target_version_1_default_or_2: "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'",
        Module_code_generation_0_not_supported: "Module code generation '{0}' not supported.",
        Could_not_find_file_0: "Could not find file: '{0}'.",
        A_file_cannot_have_a_reference_to_itself: 'A file cannot have a reference to itself.',
        Cannot_resolve_referenced_file_0: "Cannot resolve referenced file: '{0}'.",
        Cannot_find_the_common_subdirectory_path_for_the_input_files: 'Cannot find the common subdirectory path for the input files.',
        Emit_Error_0: 'Emit Error: {0}.',
        Cannot_read_file_0_1: "Cannot read file '{0}': {1}",
        Unsupported_file_encoding: 'Unsupported file encoding.',
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.",
        Unsupported_locale_0: "Unsupported locale: '{0}'.",
        Execution_Failed_NL: 'Execution Failed.{NL}',
        Invalid_call_to_up: "Invalid call to 'up'",
        Invalid_call_to_down: "Invalid call to 'down'",
        Base64_value_0_finished_with_a_continuation_bit: "Base64 value '{0}' finished with a continuation bit.",
        Unknown_option_0: "Unknown option '{0}'",
        Expected_0_arguments_to_message_got_1_instead: 'Expected {0} arguments to message, got {1} instead.',
        Expected_the_message_0_to_have_1_arguments_but_it_had_2: "Expected the message '{0}' to have {1} arguments, but it had {2}",
        Could_not_delete_file_0: "Could not delete file '{0}'",
        Could_not_create_directory_0: "Could not create directory '{0}'",
        Error_while_executing_file_0: "Error while executing file '{0}': ",
        Cannot_compile_external_modules_unless_the_module_flag_is_provided: "Cannot compile external modules unless the '--module' flag is provided.",
        Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: 'Option mapRoot cannot be specified without specifying sourcemap option.',
        Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: 'Option sourceRoot cannot be specified without specifying sourcemap option.',
        Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: 'Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.',
        Option_0_specified_without_1: "Option '{0}' specified without '{1}'",
        codepage_option_not_supported_on_current_platform: "'codepage' option not supported on current platform.",
        Concatenate_and_emit_output_to_single_file: 'Concatenate and emit output to single file.',
        Generates_corresponding_0_file: 'Generates corresponding {0} file.',
        Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: 'Specifies the location where debugger should locate map files instead of generated locations.',
        Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: 'Specifies the location where debugger should locate TypeScript files instead of source locations.',
        Watch_input_files: 'Watch input files.',
        Redirect_output_structure_to_the_directory: 'Redirect output structure to the directory.',
        Do_not_emit_comments_to_output: 'Do not emit comments to output.',
        Skip_resolution_and_preprocessing: 'Skip resolution and preprocessing.',
        Specify_ECMAScript_target_version_0_default_or_1: "Specify ECMAScript target version: '{0}' (default), or '{1}'",
        Specify_module_code_generation_0_or_1: "Specify module code generation: '{0}' or '{1}'",
        Print_this_message: 'Print this message.',
        Print_the_compiler_s_version_0: "Print the compiler's base\\research version: {0}\\{1}",
        Allow_use_of_deprecated_0_keyword_when_referencing_an_external_module: "Allow use of deprecated '{0}' keyword when referencing an external module.",
        Specify_locale_for_errors_and_messages_For_example_0_or_1: "Specify locale for errors and messages. For example '{0}' or '{1}'",
        Syntax_0: 'Syntax:   {0}',
        options: 'options',
        file1: 'file',
        Examples: 'Examples:',
        Options: 'Options:',
        Insert_command_line_options_and_files_from_a_file: 'Insert command line options and files from a file.',
        Version_0: 'Version {0}',
        ResearchVersion_0: 'Research version {0}',
        Use_the_0_flag_to_see_options: "Use the '{0}' flag to see options.",
        NL_Recompiling_0: '{NL}Recompiling ({0}):',
        STRING: 'STRING',
        KIND: 'KIND',
        file2: 'FILE',
        VERSION: 'VERSION',
        LOCATION: 'LOCATION',
        DIRECTORY: 'DIRECTORY',
        NUMBER: 'NUMBER',
        Specify_the_codepage_to_use_when_opening_source_files: 'Specify the codepage to use when opening source files.',
        This_version_of_the_Javascript_runtime_does_not_support_the_0_function: "This version of the Javascript runtime does not support the '{0}' function.",
        Unknown_rule: 'Unknown rule.',
        Invalid_line_number_0: 'Invalid line number ({0})',
        Warn_on_expressions_and_declarations_with_an_implied_any_type: "Warn on expressions and declarations with an implied 'any' type.",
        Variable_0_implicitly_has_an_any_type: "Variable '{0}' implicitly has an 'any' type.",
        Parameter_0_of_1_implicitly_has_an_any_type: "Parameter '{0}' of '{1}' implicitly has an 'any' type.",
        Parameter_0_of_function_type_implicitly_has_an_any_type: "Parameter '{0}' of function type implicitly has an 'any' type.",
        Member_0_of_object_type_implicitly_has_an_any_type: "Member '{0}' of object type implicitly has an 'any' type.",
        new_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type: "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.",
        _0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.",
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.",
        Parameter_0_of_lambda_function_implicitly_has_an_any_type: "Parameter '{0}' of lambda function implicitly has an 'any' type.",
        Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.",
        Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.",
        Array_Literal_implicitly_has_an_any_type_from_widening: "Array Literal implicitly has an 'any' type from widening.",
        _0_which_lacks_get_accessor_and_parameter_type_annotation_on_set_accessor_implicitly_has_an_any_type: "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.",
        SEC_Function_return_type: 'Safe TS: Expected return type {0}; but computed return type {1}',
        SEC_Object_literal_type_mismatch: 'Safe TS: Expected object of type {0}; but got object of type {1}',
        SEC_Projecting_nonexistent_field: "Safe TS: Projecting field '{0}' from a value of type {1} is not safe",
        SEC_Projection_from_non_records: "Safe TS: Projecting a field from a value of non-record type is not safe; got type '{0}'",
        SEC_ElementAccess_from_non_any: 'Safe TS: Dynamic field access from a non-any-typed object or with a non-any-typed key is not allowed; type of object is {0}; type of key is {1}',
        SEC_Dynamic_call_with_un_typed_argument: "Safe TS: All arguments in a dynamically-typed call must have type 'any'; some argument here includes a type 'un'",
        SEC_Arity_mismatch: 'Safe TS: Function expected {0} arguments but is provided {1}',
        SEC_Argument_type_mismatch: 'Safe TS: Function expected an argument of type {0} but given an argument of type {1}',
        SEC_Cannot_apply_a_non_function: 'Safe TS: Cannot apply a non-function of type {0}',
        SEC_TypeOf_un: 'Safe TS: typeof is not safe on an un-typed value',
        SEC_Variable_not_found: "Safe TS: '{0}' is not in the current scope",
        SEC_Variable_assignment_incompatible_type: "Safe TS: Variable '{0}' of type '{1}' cannot be assigned a value of type '{2}'",
        SEC_Assigning_to_nonexistent_field: "Safe TS: Unsafe assignment; field '{0}' does not exists in a value of type {1}",
        SEC_Assigning_incompatible_value_to_field: "Safe TS: Field '{0}' of type '{1}' cannot be assigned a value of type '{2}'",
        SEC_Assigning_to_immutable_field: "Safe TS: Field '{0}' is immutable",
        SEC_Assigning_to_non_record: "Safe TS: Assigning to a field '{0}' of a non-record value of type '{1}'",
        SEC_Assigning_to_a_non_lvalue: "Safe TS: Assignment to a '{0}' is not allowed; must be either an identifier, member access or element access expression",
        SEC_Dynamic_field_assignment_all_not_any: 'Safe TS: All three objects in a dynamic assignment form (o[f]=v) must have type any;got {0}, {1} and {2}',
        SEC_Variable_shadowing: "Safe TS: Multiple declarations of the same variable name within the same scope are not allowed; '{0}' is declared more than once, shadowing a declaration at {1}",
        SEC_Array_element_type: 'Safe TS: Expected array element of type {0}; got {1}',
        SEC_Unary_operator_expects_an_un_free_type: 'Safe TS: Unary operator expects an un-free argument; got {0}',
        SEC_Binary_operator_expects_both_any: 'Safe TS: Binary operator expects both arguments to have type any; got {0} and {1}',
        SEC_Conditional_guard_not_any: 'Safe TS: Conditional guard expects type any; got {0}',
        SEC_Conditional_branch: 'Safe TS: This branch was expected to have type {0}; got {1}',
        SEC_Property_iteration_on_non_any: 'Safe TS: For-in loops are only permitted on any-typed objects; got {0}',
        SEC_Invalid_lval_iteration: 'Safe TS: Invalid iteration variable in for-in loop; {0}',
        SEC_Throw_not_any: 'Safe TS: Exception value must have type any; got {0}',
        SEC_Switch_guard_not_primitive: 'Safe TS: Switching on non-primitive values is not supported; got a value of type {0}',
        SEC_Switch_case_incompatible: 'Safe TS: Type of the switch case does not match the type of the guard; expected {0} got {1}',
        SEC_Increment_operators_only_on_number: 'Safe TS: Increment/decrement operators are only available on the number type; got {0}',
        SEC_Invalid_LHS_self_increment: 'Safe TS: Invalid LHS for increment/decrement operator',
        SEC_Missing_return: "Safe TS: Missing a 'return' statement on some code paths",
        SEC_Uninitialized_variable: 'Safe TS: Variables of type {0} must be initialized',
        SEC_Invalid_extends_clause: 'Safe TS: Invalid extends clause; {0}',
        SEC_Invalid_new_target: "Safe TS: 'new' expression expects a class-typed value as the target; got {0}",
        SEC_Arguments_is_a_reserved_name: "Safe TS: 'arguments' is a reserved name in JavaScript; use another name",
        SEC_This_not_in_scope: "Safe TS: 'this' is not in scope",
        SEC_Super_not_in_scope: "Safe TS: 'super' is not in scope",
        SEC_Uninitialized_member: "Safe TS: member '{0}' may not be initialized",
        SEC_Implicit_conversion_from_any: "Safe TS: Implicit conversion from 'any' to '{0}' was applied",
        SEC_Implicit_coercion: "Safe TS: Implicit conversion from '{0}' to '{1}' was applied",
        SEC_Array_index_not_a_number: 'Safe TS: Array index not a number; got {0}',
        SEC_Unsafe_assignment: 'Safe TS: Type of LHS ({0}) is not compatible with type of RHS ({1})',
        SEC_Assignment_with_op_expects_undotted_arguments: 'Safe TS: Assignment with an operator expects both operands to have undotted type; got {0} and {1}',
        SEC_Reserved_name: 'Safe TS: {0} is a reserved name',
        SEC_Assignment_with_addition_requires_number_or_string: 'Safe TS: Assignment with addition requires number or string; got {0}',
        SEC_Inferred_type_incompatible_with_sound_type: "Safe TS: Inferred type '{0}' is incompatible with the soundly computed type '{1}'",
        SEC_Duplicate_interface_declaration: "Safe TS: Interface '{0}' may be declared more than once",
        SEC_Generic_types_unsupported: 'Safe TS: Generic types are as yet unsupported; {0} is generic',
        SEC_Feature_not_supported: 'Safe TS: Does not yet support this feature: {0}',
        SEC_Missing_argument: "Safe TS: Required argument '{0}:{1}' is missing",
        SEC_Module_name_clash: 'Safe TS: Module name {0} was previously used for a non-module',
        SEC_Module_overlapping_field: 'Safe TS: Module {0} was previously declared to include a {1} field (at location {2})',
        SEC_Interface_overlapping_field: 'Safe TS: Interface {0} was previously declared to include a {1} field',
        SEC_Delete_operator_expects_any: "Safe TS: Delete operator expects an 'any'-typed argument; got {0}",
        SEC_Delete_operator_expects_member_or_element_access: 'Safe TS: Delete operator expects a member- or element-access expression',
        SEC_Unexpected_property_assignment: 'Safe TS: Unexpected property assignment in an object literal: {0}',
        SEC_Index_map_key_type_mismatch: "Safe TS: Index map expected a key of type '{0}'; got '{1}'",
        SEC_Index_map_elt_type_mismatch: "Safe TS: Index map expected an element of type '{0}'; got '{1}'",
        SEC_Interface_declaration_mismatch: "Safe TS: Interface declaration '{0}' has type '{1}' which is inconsistent with '{2}'",
        SEC_Unexpected_type_arguments: 'Safe TS: Unexpected type arguments to a mono-type: {0} (Selected overload #{1} but given type arguments {2})',
        SEC_Unexpected_class_element: 'Safe TS: Unexpected class element: {0}',
        SEC_Initializer_may_rely_on_uninitialized_top_level_names: 'Safe TS: Initializer may rely on uninitialized top-level variables (function invocation may not be safe for top-level initializers)',
        SEC_Unsafe_circular_dependence_on_variable: "Safe TS: Unsafe circular dependence on variable '{0}' defined at '{1}'",
        SEC_Could_not_infer_type_arguments: "Safe TS: Could not infer type arguments; defaulting to 'any'",
        SEC_Assignment_to_index_of_immutable_array_is_not_allowed: "Safe TS: Assignment to index of an immutable array of type '{0}' is not allowed",
        SEC_noGetter_flag_getter_found: 'Safe TS: noGetters command line flag but code uses a get accessor',
        SEC_type_instantiation_not_subtype_constraint: "Safe TS: Instantiated type '{0}' is not a subtype of constraint on '{1}'",
    };
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ArrayUtilities = (function () {
        function ArrayUtilities() {
        }
        ArrayUtilities.isArray = function (value) {
            return (value instanceof Array);
        };
        ArrayUtilities.sequenceEquals = function (array1, array2, equals) {
            if (array1 === array2) {
                return true;
            }
            if (array1 === null || array2 === null) {
                return false;
            }
            if (array1.length !== array2.length) {
                return false;
            }
            for (var i = 0, n = array1.length; i < n; i++) {
                if (!equals(array1[i], array2[i])) {
                    return false;
                }
            }
            return true;
        };
        ArrayUtilities.contains = function (array, value) {
            for (var i = 0; i < array.length; i++) {
                if (array[i] === value) {
                    return true;
                }
            }
            return false;
        };
        ArrayUtilities.groupBy = function (array, func) {
            var result = {};
            for (var i = 0, n = array.length; i < n; i++) {
                var v = array[i];
                var k = func(v);
                var list = result[k] || [];
                list.push(v);
                result[k] = list;
            }
            return result;
        };
        ArrayUtilities.distinct = function (array, equalsFn) {
            var result = [];
            for (var i = 0, n = array.length; i < n; i++) {
                var current = array[i];
                for (var j = 0; j < result.length; j++) {
                    if (equalsFn(result[j], current)) {
                        break;
                    }
                }
                if (j === result.length) {
                    result.push(current);
                }
            }
            return result;
        };
        ArrayUtilities.min = function (array, func) {
            var min = func(array[0]);
            for (var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next < min) {
                    min = next;
                }
            }
            return min;
        };
        ArrayUtilities.max = function (array, func) {
            var max = func(array[0]);
            for (var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next > max) {
                    max = next;
                }
            }
            return max;
        };
        ArrayUtilities.last = function (array) {
            if (array.length === 0) {
                throw TypeScript.Errors.argumentOutOfRange('array');
            }
            return array[array.length - 1];
        };
        ArrayUtilities.lastOrDefault = function (array, predicate) {
            for (var i = array.length - 1; i >= 0; i--) {
                var v = array[i];
                if (predicate(v, i)) {
                    return v;
                }
            }
            return null;
        };
        ArrayUtilities.firstOrDefault = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (func(value, i)) {
                    return value;
                }
            }
            return null;
        };
        ArrayUtilities.first = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (!func || func(value, i)) {
                    return value;
                }
            }
            throw TypeScript.Errors.invalidOperation();
        };
        ArrayUtilities.sum = function (array, func) {
            var result = 0;
            for (var i = 0, n = array.length; i < n; i++) {
                result += func(array[i]);
            }
            return result;
        };
        ArrayUtilities.select = function (values, func) {
            var result = new Array(values.length);
            for (var i = 0; i < values.length; i++) {
                result[i] = func(values[i]);
            }
            return result;
        };
        ArrayUtilities.where = function (values, func) {
            var result = new Array();
            for (var i = 0; i < values.length; i++) {
                if (func(values[i])) {
                    result.push(values[i]);
                }
            }
            return result;
        };
        ArrayUtilities.any = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (func(array[i])) {
                    return true;
                }
            }
            return false;
        };
        ArrayUtilities.all = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (!func(array[i])) {
                    return false;
                }
            }
            return true;
        };
        ArrayUtilities.binarySearch = function (array, value) {
            var low = 0;
            var high = array.length - 1;
            while (low <= high) {
                var middle = low + ((high - low) >> 1);
                var midValue = array[middle];
                if (midValue === value) {
                    return middle;
                }
                else if (midValue > value) {
                    high = middle - 1;
                }
                else {
                    low = middle + 1;
                }
            }
            return ~low;
        };
        ArrayUtilities.createArray = function (length, defaultValue) {
            var result = new Array(length);
            for (var i = 0; i < length; i++) {
                result[i] = defaultValue;
            }
            return result;
        };
        ArrayUtilities.grow = function (array, length, defaultValue) {
            var count = length - array.length;
            for (var i = 0; i < count; i++) {
                array.push(defaultValue);
            }
        };
        ArrayUtilities.copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
            for (var i = 0; i < length; i++) {
                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
            }
        };
        ArrayUtilities.indexOf = function (array, predicate) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (predicate(array[i])) {
                    return i;
                }
            }
            return -1;
        };
        return ArrayUtilities;
    }());
    TypeScript.ArrayUtilities = ArrayUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var BitVector;
    (function (BitVector) {
        var pool = [];
        var Constants;
        (function (Constants) {
            Constants[Constants["MaxBitsPerEncodedNumber"] = 30] = "MaxBitsPerEncodedNumber";
            Constants[Constants["BitsPerEncodedBiStateValue"] = 1] = "BitsPerEncodedBiStateValue";
            Constants[Constants["BitsPerEncodedTriStateValue"] = 2] = "BitsPerEncodedTriStateValue";
            Constants[Constants["BiStateEncodedTrue"] = 1] = "BiStateEncodedTrue";
            Constants[Constants["BiStateClearBitsMask"] = 1] = "BiStateClearBitsMask";
            Constants[Constants["TriStateEncodedFalse"] = 1] = "TriStateEncodedFalse";
            Constants[Constants["TriStateEncodedTrue"] = 2] = "TriStateEncodedTrue";
            Constants[Constants["TriStateClearBitsMask"] = 3] = "TriStateClearBitsMask";
        })(Constants || (Constants = {}));
        var BitVectorImpl = (function () {
            function BitVectorImpl(allowUndefinedValues) {
                this.allowUndefinedValues = allowUndefinedValues;
                this.isReleased = false;
                this.bits = [];
            }
            BitVectorImpl.prototype.computeTriStateArrayIndex = function (index) {
                var encodedValuesPerNumber = Constants.MaxBitsPerEncodedNumber / Constants.BitsPerEncodedTriStateValue;
                return (index / encodedValuesPerNumber) >>> 0;
            };
            BitVectorImpl.prototype.computeBiStateArrayIndex = function (index) {
                var encodedValuesPerNumber = Constants.MaxBitsPerEncodedNumber / Constants.BitsPerEncodedBiStateValue;
                return (index / encodedValuesPerNumber) >>> 0;
            };
            BitVectorImpl.prototype.computeTriStateEncodedValueIndex = function (index) {
                var encodedValuesPerNumber = Constants.MaxBitsPerEncodedNumber / Constants.BitsPerEncodedTriStateValue;
                return (index % encodedValuesPerNumber) * Constants.BitsPerEncodedTriStateValue;
            };
            BitVectorImpl.prototype.computeBiStateEncodedValueIndex = function (index) {
                var encodedValuesPerNumber = Constants.MaxBitsPerEncodedNumber / Constants.BitsPerEncodedBiStateValue;
                return (index % encodedValuesPerNumber) * Constants.BitsPerEncodedBiStateValue;
            };
            BitVectorImpl.prototype.valueAt = function (index) {
                TypeScript.Debug.assert(!this.isReleased, "Should not use a released bitvector");
                if (this.allowUndefinedValues) {
                    var arrayIndex = this.computeTriStateArrayIndex(index);
                    var encoded = this.bits[arrayIndex];
                    if (encoded === undefined) {
                        return undefined;
                    }
                    var bitIndex = this.computeTriStateEncodedValueIndex(index);
                    if (encoded & (Constants.TriStateEncodedTrue << bitIndex)) {
                        return true;
                    }
                    else if (encoded & (Constants.TriStateEncodedFalse << bitIndex)) {
                        return false;
                    }
                    else {
                        return undefined;
                    }
                }
                else {
                    var arrayIndex = this.computeBiStateArrayIndex(index);
                    var encoded = this.bits[arrayIndex];
                    if (encoded === undefined) {
                        return false;
                    }
                    var bitIndex = this.computeBiStateEncodedValueIndex(index);
                    if (encoded & (Constants.BiStateEncodedTrue << bitIndex)) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            };
            BitVectorImpl.prototype.setValueAt = function (index, value) {
                TypeScript.Debug.assert(!this.isReleased, "Should not use a released bitvector");
                if (this.allowUndefinedValues) {
                    TypeScript.Debug.assert(value === true || value === false || value === undefined, "value must only be true, false or undefined.");
                    var arrayIndex = this.computeTriStateArrayIndex(index);
                    var encoded = this.bits[arrayIndex];
                    if (encoded === undefined) {
                        if (value === undefined) {
                            return;
                        }
                        encoded = 0;
                    }
                    var bitIndex = this.computeTriStateEncodedValueIndex(index);
                    var clearMask = ~(Constants.TriStateClearBitsMask << bitIndex);
                    encoded = encoded & clearMask;
                    if (value === true) {
                        encoded = encoded | (Constants.TriStateEncodedTrue << bitIndex);
                    }
                    else if (value === false) {
                        encoded = encoded | (Constants.TriStateEncodedFalse << bitIndex);
                    }
                    this.bits[arrayIndex] = encoded;
                }
                else {
                    TypeScript.Debug.assert(value === true || value === false, "value must only be true or false.");
                    var arrayIndex = this.computeBiStateArrayIndex(index);
                    var encoded = this.bits[arrayIndex];
                    if (encoded === undefined) {
                        if (value === false) {
                            return;
                        }
                        encoded = 0;
                    }
                    var bitIndex = this.computeBiStateEncodedValueIndex(index);
                    encoded = encoded & ~(Constants.BiStateClearBitsMask << bitIndex);
                    if (value) {
                        encoded = encoded | (Constants.BiStateEncodedTrue << bitIndex);
                    }
                    this.bits[arrayIndex] = encoded;
                }
            };
            BitVectorImpl.prototype.release = function () {
                TypeScript.Debug.assert(!this.isReleased, "Should not use a released bitvector");
                this.isReleased = true;
                this.bits.length = 0;
                pool.push(this);
            };
            return BitVectorImpl;
        }());
        function getBitVector(allowUndefinedValues) {
            if (pool.length === 0) {
                return new BitVectorImpl(allowUndefinedValues);
            }
            var vector = pool.pop();
            vector.isReleased = false;
            vector.allowUndefinedValues = allowUndefinedValues;
            return vector;
        }
        BitVector.getBitVector = getBitVector;
    })(BitVector = TypeScript.BitVector || (TypeScript.BitVector = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var BitMatrix;
    (function (BitMatrix) {
        var pool = [];
        var BitMatrixImpl = (function () {
            function BitMatrixImpl(allowUndefinedValues) {
                this.allowUndefinedValues = allowUndefinedValues;
                this.isReleased = false;
                this.vectors = [];
            }
            BitMatrixImpl.prototype.valueAt = function (x, y) {
                TypeScript.Debug.assert(!this.isReleased, "Should not use a released bitvector");
                var vector = this.vectors[x];
                if (!vector) {
                    return this.allowUndefinedValues ? undefined : false;
                }
                return vector.valueAt(y);
            };
            BitMatrixImpl.prototype.setValueAt = function (x, y, value) {
                TypeScript.Debug.assert(!this.isReleased, "Should not use a released bitvector");
                var vector = this.vectors[x];
                if (!vector) {
                    if (value === undefined) {
                        return;
                    }
                    vector = TypeScript.BitVector.getBitVector(this.allowUndefinedValues);
                    this.vectors[x] = vector;
                }
                vector.setValueAt(y, value);
            };
            BitMatrixImpl.prototype.release = function () {
                TypeScript.Debug.assert(!this.isReleased, "Should not use a released bitvector");
                this.isReleased = true;
                for (var name in this.vectors) {
                    if (this.vectors.hasOwnProperty(name)) {
                        var vector = this.vectors[name];
                        vector.release();
                    }
                }
                this.vectors.length = 0;
                pool.push(this);
            };
            return BitMatrixImpl;
        }());
        function getBitMatrix(allowUndefinedValues) {
            if (pool.length === 0) {
                return new BitMatrixImpl(allowUndefinedValues);
            }
            var matrix = pool.pop();
            matrix.isReleased = false;
            matrix.allowUndefinedValues = allowUndefinedValues;
            return matrix;
        }
        BitMatrix.getBitMatrix = getBitMatrix;
    })(BitMatrix = TypeScript.BitMatrix || (TypeScript.BitMatrix = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Constants;
    (function (Constants) {
        Constants[Constants["Max31BitInteger"] = 1073741823] = "Max31BitInteger";
        Constants[Constants["Min31BitInteger"] = -1073741824] = "Min31BitInteger";
    })(Constants = TypeScript.Constants || (TypeScript.Constants = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var AssertionLevel;
    (function (AssertionLevel) {
        AssertionLevel[AssertionLevel["None"] = 0] = "None";
        AssertionLevel[AssertionLevel["Normal"] = 1] = "Normal";
        AssertionLevel[AssertionLevel["Aggressive"] = 2] = "Aggressive";
        AssertionLevel[AssertionLevel["VeryAggressive"] = 3] = "VeryAggressive";
    })(AssertionLevel = TypeScript.AssertionLevel || (TypeScript.AssertionLevel = {}));
    var Debug = (function () {
        function Debug() {
        }
        Debug.shouldAssert = function (level) {
            return this.currentAssertionLevel >= level;
        };
        Debug.assert = function (expression, message, verboseDebugInfo) {
            if (message === void 0) { message = ""; }
            if (verboseDebugInfo === void 0) { verboseDebugInfo = null; }
            if (!expression) {
                var verboseDebugString = "";
                if (verboseDebugInfo) {
                    verboseDebugString = "\r\nVerbose Debug Information:" + verboseDebugInfo();
                }
                throw new Error("Debug Failure. False expression: " + message + verboseDebugString);
            }
        };
        Debug.fail = function (message) {
            Debug.assert(false, message);
        };
        Debug.currentAssertionLevel = AssertionLevel.None;
        return Debug;
    }());
    TypeScript.Debug = Debug;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.LocalizedDiagnosticMessages = null;
    var Diagnostic = (function () {
        function Diagnostic(fileName, lineMap, start, length, diagnosticKey, args) {
            if (args === void 0) { args = null; }
            this._diagnosticKey = diagnosticKey;
            this._arguments = (args && args.length > 0) ? args : null;
            this._fileName = fileName;
            this._lineMap = lineMap;
            this._start = start;
            this._length = length;
        }
        Diagnostic.prototype.toJSON = function (key) {
            var result = {};
            result.start = this.start();
            result.length = this.length();
            result.diagnosticCode = this._diagnosticKey;
            var args = this.arguments();
            if (args && args.length > 0) {
                result.arguments = args;
            }
            return result;
        };
        Diagnostic.prototype.fileName = function () {
            return this._fileName;
        };
        Diagnostic.prototype.line = function () {
            return this._lineMap ? this._lineMap.getLineNumberFromPosition(this.start()) : 0;
        };
        Diagnostic.prototype.character = function () {
            return this._lineMap ? this._lineMap.getLineAndCharacterFromPosition(this.start()).character() : 0;
        };
        Diagnostic.prototype.start = function () {
            return this._start;
        };
        Diagnostic.prototype.length = function () {
            return this._length;
        };
        Diagnostic.prototype.diagnosticKey = function () {
            return this._diagnosticKey;
        };
        Diagnostic.prototype.arguments = function () {
            return this._arguments;
        };
        Diagnostic.prototype.text = function () {
            return TypeScript.getLocalizedText(this._diagnosticKey, this._arguments);
        };
        Diagnostic.prototype.message = function () {
            return TypeScript.getDiagnosticMessage(this._diagnosticKey, this._arguments);
        };
        Diagnostic.prototype.additionalLocations = function () {
            return [];
        };
        Diagnostic.equals = function (diagnostic1, diagnostic2) {
            return diagnostic1._fileName === diagnostic2._fileName &&
                diagnostic1._start === diagnostic2._start &&
                diagnostic1._length === diagnostic2._length &&
                diagnostic1._diagnosticKey === diagnostic2._diagnosticKey &&
                TypeScript.ArrayUtilities.sequenceEquals(diagnostic1._arguments, diagnostic2._arguments, function (v1, v2) { return v1 === v2; });
        };
        Diagnostic.prototype.info = function () {
            return getDiagnosticInfoFromKey(this.diagnosticKey());
        };
        return Diagnostic;
    }());
    TypeScript.Diagnostic = Diagnostic;
    function newLine() {
        return TypeScript.Environment ? TypeScript.Environment.newLine : "\r\n";
    }
    TypeScript.newLine = newLine;
    function getLargestIndex(diagnostic) {
        var largest = -1;
        var regex = /\{(\d+)\}/g;
        var match;
        while ((match = regex.exec(diagnostic)) != null) {
            var val = parseInt(match[1]);
            if (!isNaN(val) && val > largest) {
                largest = val;
            }
        }
        return largest;
    }
    function getDiagnosticInfoFromKey(diagnosticKey) {
        var result = TypeScript.diagnosticInformationMap[diagnosticKey];
        TypeScript.Debug.assert(result);
        return result;
    }
    function getLocalizedText(diagnosticKey, args) {
        if (TypeScript.LocalizedDiagnosticMessages) {
        }
        var diagnosticMessageText = TypeScript.LocalizedDiagnosticMessages ? TypeScript.LocalizedDiagnosticMessages[diagnosticKey] : diagnosticKey;
        TypeScript.Debug.assert(diagnosticMessageText !== undefined && diagnosticMessageText !== null);
        var actualCount = args ? args.length : 0;
        var expectedCount = 1 + getLargestIndex(diagnosticKey);
        if (expectedCount !== actualCount) {
            throw new Error(diagnosticKey + " :: " + getLocalizedText(TypeScript.DiagnosticCode.Expected_0_arguments_to_message_got_1_instead, [expectedCount.toString(), actualCount.toString()]));
        }
        var valueCount = 1 + getLargestIndex(diagnosticMessageText);
        if (valueCount !== expectedCount) {
            throw new Error(diagnosticKey + " :: " + getLocalizedText(TypeScript.DiagnosticCode.Expected_the_message_0_to_have_1_arguments_but_it_had_2, [diagnosticMessageText, expectedCount.toString(), valueCount.toString()]));
        }
        diagnosticMessageText = diagnosticMessageText.replace(/{(\d+)}/g, function (match, num) {
            return typeof args[num] !== 'undefined'
                ? args[num]
                : match;
        });
        diagnosticMessageText = diagnosticMessageText.replace(/{(NL)}/g, function (match) {
            return TypeScript.newLine();
        });
        return diagnosticMessageText;
    }
    TypeScript.getLocalizedText = getLocalizedText;
    function getDiagnosticMessage(diagnosticKey, args) {
        var diagnostic = getDiagnosticInfoFromKey(diagnosticKey);
        var diagnosticMessageText = getLocalizedText(diagnosticKey, args);
        var message;
        if (diagnostic.category === TypeScript.DiagnosticCategory.Error) {
            message = getLocalizedText(TypeScript.DiagnosticCode.error_TS_0_1, [diagnostic.code.toString(), diagnosticMessageText]);
        }
        else if (diagnostic.category === TypeScript.DiagnosticCategory.Warning) {
            message = getLocalizedText(TypeScript.DiagnosticCode.warning_TS_0_1, [diagnostic.code.toString(), diagnosticMessageText]);
        }
        else {
            message = diagnosticMessageText;
        }
        return message;
    }
    TypeScript.getDiagnosticMessage = getDiagnosticMessage;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Errors = (function () {
        function Errors() {
        }
        Errors.argument = function (argument, message) {
            return new Error("Invalid argument: " + argument + ". " + message);
        };
        Errors.argumentOutOfRange = function (argument) {
            return new Error("Argument out of range: " + argument);
        };
        Errors.argumentNull = function (argument) {
            return new Error("Argument null: " + argument);
        };
        Errors.abstract = function () {
            return new Error("Operation not implemented properly by subclass.");
        };
        Errors.notYetImplemented = function () {
            return new Error("Not yet implemented.");
        };
        Errors.invalidOperation = function (message) {
            return new Error("Invalid operation: " + message);
        };
        return Errors;
    }());
    TypeScript.Errors = Errors;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Hash = (function () {
        function Hash() {
        }
        Hash.computeFnv1aCharArrayHashCode = function (text, start, len) {
            var hashCode = Hash.FNV_BASE;
            var end = start + len;
            for (var i = start; i < end; i++) {
                hashCode = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(hashCode ^ text[i], Hash.FNV_PRIME);
            }
            return hashCode;
        };
        Hash.computeSimple31BitCharArrayHashCode = function (key, start, len) {
            var hash = 0;
            for (var i = 0; i < len; i++) {
                var ch = key[start + i];
                hash = ((((hash << 5) - hash) | 0) + ch) | 0;
            }
            return hash & 0x7FFFFFFF;
        };
        Hash.computeSimple31BitStringHashCode = function (key) {
            var hash = 0;
            var start = 0;
            var len = key.length;
            for (var i = 0; i < len; i++) {
                var ch = key.charCodeAt(start + i);
                hash = ((((hash << 5) - hash) | 0) + ch) | 0;
            }
            return hash & 0x7FFFFFFF;
        };
        Hash.computeMurmur2StringHashCode = function (key, seed) {
            var m = 0x5bd1e995;
            var r = 24;
            var numberOfCharsLeft = key.length;
            var h = Math.abs(seed ^ numberOfCharsLeft);
            var index = 0;
            while (numberOfCharsLeft >= 2) {
                var c1 = key.charCodeAt(index);
                var c2 = key.charCodeAt(index + 1);
                var k = Math.abs(c1 | (c2 << 16));
                k = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(k, m);
                k ^= k >> r;
                k = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(k, m);
                h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
                h ^= k;
                index += 2;
                numberOfCharsLeft -= 2;
            }
            if (numberOfCharsLeft == 1) {
                h ^= key.charCodeAt(index);
                h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
            }
            h ^= h >> 13;
            h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
            h ^= h >> 15;
            return h;
        };
        Hash.getPrime = function (min) {
            for (var i = 0; i < Hash.primes.length; i++) {
                var num = Hash.primes[i];
                if (num >= min) {
                    return num;
                }
            }
            throw TypeScript.Errors.notYetImplemented();
        };
        Hash.expandPrime = function (oldSize) {
            var num = oldSize << 1;
            if (num > 2146435069 && 2146435069 > oldSize) {
                return 2146435069;
            }
            return Hash.getPrime(num);
        };
        Hash.combine = function (value, currentHash) {
            return (((currentHash << 5) + currentHash) + value) & 0x7FFFFFFF;
        };
        Hash.FNV_BASE = 2166136261;
        Hash.FNV_PRIME = 16777619;
        Hash.primes = [3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521,
            631, 761, 919, 1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419,
            10103, 12143, 14591, 17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431,
            90523, 108631, 130363, 156437, 187751, 225307, 270371, 324449, 389357, 467237, 560689,
            672827, 807403, 968897, 1162687, 1395263, 1674319, 2009191, 2411033, 2893249, 3471899,
            4166287, 4999559, 5999471, 7199369];
        return Hash;
    }());
    TypeScript.Hash = Hash;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Collections;
    (function (Collections) {
        Collections.DefaultHashTableCapacity = 1024;
        var HashTableEntry = (function () {
            function HashTableEntry(Key, Value, HashCode, Next) {
                this.Key = Key;
                this.Value = Value;
                this.HashCode = HashCode;
                this.Next = Next;
            }
            return HashTableEntry;
        }());
        var HashTable = (function () {
            function HashTable(capacity, hash) {
                this.hash = hash;
                this.count = 0;
                var size = TypeScript.Hash.getPrime(capacity);
                this.entries = TypeScript.ArrayUtilities.createArray(size, null);
            }
            HashTable.prototype.set = function (key, value) {
                this.addOrSet(key, value, false);
            };
            HashTable.prototype.add = function (key, value) {
                this.addOrSet(key, value, true);
            };
            HashTable.prototype.containsKey = function (key) {
                var hashCode = this.computeHashCode(key);
                var entry = this.findEntry(key, hashCode);
                return entry !== null;
            };
            HashTable.prototype.get = function (key) {
                var hashCode = this.computeHashCode(key);
                var entry = this.findEntry(key, hashCode);
                return entry === null ? null : entry.Value;
            };
            HashTable.prototype.computeHashCode = function (key) {
                var hashCode = this.hash === null
                    ? key.hashCode
                    : this.hash(key);
                hashCode = hashCode & 0x7FFFFFFF;
                TypeScript.Debug.assert(hashCode >= 0);
                return hashCode;
            };
            HashTable.prototype.addOrSet = function (key, value, throwOnExistingEntry) {
                var hashCode = this.computeHashCode(key);
                var entry = this.findEntry(key, hashCode);
                if (entry !== null) {
                    if (throwOnExistingEntry) {
                        throw TypeScript.Errors.argument('key', "Key was already in table.");
                    }
                    entry.Key = key;
                    entry.Value = value;
                    return;
                }
                return this.addEntry(key, value, hashCode);
            };
            HashTable.prototype.findEntry = function (key, hashCode) {
                for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                    if (e.HashCode === hashCode &&
                        key === e.Key) {
                        return e;
                    }
                }
                return null;
            };
            HashTable.prototype.addEntry = function (key, value, hashCode) {
                var index = hashCode % this.entries.length;
                var e = new HashTableEntry(key, value, hashCode, this.entries[index]);
                this.entries[index] = e;
                if (this.count >= (this.entries.length / 2)) {
                    this.grow();
                }
                this.count++;
                return e.Key;
            };
            HashTable.prototype.grow = function () {
                var newSize = TypeScript.Hash.expandPrime(this.entries.length);
                var oldEntries = this.entries;
                var newEntries = TypeScript.ArrayUtilities.createArray(newSize, null);
                this.entries = newEntries;
                for (var i = 0; i < oldEntries.length; i++) {
                    var e = oldEntries[i];
                    while (e !== null) {
                        var newIndex = e.HashCode % newSize;
                        var tmp = e.Next;
                        e.Next = newEntries[newIndex];
                        newEntries[newIndex] = e;
                        e = tmp;
                    }
                }
            };
            return HashTable;
        }());
        Collections.HashTable = HashTable;
        function createHashTable(capacity, hash) {
            if (capacity === void 0) { capacity = Collections.DefaultHashTableCapacity; }
            if (hash === void 0) { hash = null; }
            return new HashTable(capacity, hash);
        }
        Collections.createHashTable = createHashTable;
        var currentHashCode = 1;
        function identityHashCode(value) {
            if (value.__hash === undefined) {
                value.__hash = currentHashCode;
                currentHashCode++;
            }
            return value.__hash;
        }
        Collections.identityHashCode = identityHashCode;
    })(Collections = TypeScript.Collections || (TypeScript.Collections = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.nodeMakeDirectoryTime = 0;
    TypeScript.nodeCreateBufferTime = 0;
    TypeScript.nodeWriteFileSyncTime = 0;
    var ByteOrderMark;
    (function (ByteOrderMark) {
        ByteOrderMark[ByteOrderMark["None"] = 0] = "None";
        ByteOrderMark[ByteOrderMark["Utf8"] = 1] = "Utf8";
        ByteOrderMark[ByteOrderMark["Utf16BigEndian"] = 2] = "Utf16BigEndian";
        ByteOrderMark[ByteOrderMark["Utf16LittleEndian"] = 3] = "Utf16LittleEndian";
    })(ByteOrderMark = TypeScript.ByteOrderMark || (TypeScript.ByteOrderMark = {}));
    var FileInformation = (function () {
        function FileInformation(contents, byteOrderMark) {
            this.contents = contents;
            this.byteOrderMark = byteOrderMark;
        }
        return FileInformation;
    }());
    TypeScript.FileInformation = FileInformation;
    TypeScript.Environment = (function () {
        function getWindowsScriptHostEnvironment() {
            try {
                var fso = new ActiveXObject("Scripting.FileSystemObject");
            }
            catch (e) {
                return null;
            }
            var streamObjectPool = [];
            function getStreamObject() {
                if (streamObjectPool.length > 0) {
                    return streamObjectPool.pop();
                }
                else {
                    return new ActiveXObject("ADODB.Stream");
                }
            }
            function releaseStreamObject(obj) {
                streamObjectPool.push(obj);
            }
            var args = [];
            for (var i = 0; i < WScript.Arguments.length; i++) {
                args[i] = WScript.Arguments.Item(i);
            }
            return {
                newLine: "\r\n",
                currentDirectory: function () {
                    return WScript.CreateObject("WScript.Shell").CurrentDirectory;
                },
                supportsCodePage: function () {
                    return WScript.ReadFile;
                },
                readFile: function (path, codepage) {
                    try {
                        if (codepage !== null && this.supportsCodePage()) {
                            try {
                                var contents = WScript.ReadFile(path, codepage);
                                return new FileInformation(contents, ByteOrderMark.None);
                            }
                            catch (e) {
                            }
                        }
                        var streamObj = getStreamObject();
                        streamObj.Open();
                        streamObj.Type = 2;
                        streamObj.Charset = 'x-ansi';
                        streamObj.LoadFromFile(path);
                        var bomChar = streamObj.ReadText(2);
                        streamObj.Position = 0;
                        var byteOrderMark = ByteOrderMark.None;
                        if (bomChar.charCodeAt(0) === 0xFE && bomChar.charCodeAt(1) === 0xFF) {
                            streamObj.Charset = 'unicode';
                            byteOrderMark = ByteOrderMark.Utf16BigEndian;
                        }
                        else if (bomChar.charCodeAt(0) === 0xFF && bomChar.charCodeAt(1) === 0xFE) {
                            streamObj.Charset = 'unicode';
                            byteOrderMark = ByteOrderMark.Utf16LittleEndian;
                        }
                        else if (bomChar.charCodeAt(0) === 0xEF && bomChar.charCodeAt(1) === 0xBB) {
                            streamObj.Charset = 'utf-8';
                            byteOrderMark = ByteOrderMark.Utf8;
                        }
                        else {
                            streamObj.Charset = 'utf-8';
                        }
                        var contents = streamObj.ReadText(-1);
                        streamObj.Close();
                        releaseStreamObject(streamObj);
                        return new FileInformation(contents, byteOrderMark);
                    }
                    catch (err) {
                        var message;
                        if (err.number === -2147024809) {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unsupported_file_encoding, null);
                        }
                        else {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_read_file_0_1, [path, ("" + err.message)]);
                        }
                        throw new Error(message);
                    }
                },
                writeFile: function (path, contents, writeByteOrderMark) {
                    var textStream = getStreamObject();
                    textStream.Charset = 'utf-8';
                    textStream.Open();
                    textStream.WriteText(contents, 0);
                    if (!writeByteOrderMark) {
                        textStream.Position = 3;
                    }
                    else {
                        textStream.Position = 0;
                    }
                    var fileStream = getStreamObject();
                    fileStream.Type = 1;
                    fileStream.Open();
                    textStream.CopyTo(fileStream);
                    fileStream.Flush();
                    fileStream.SaveToFile(path, 2);
                    fileStream.Close();
                    textStream.Flush();
                    textStream.Close();
                },
                fileExists: function (path) {
                    return fso.FileExists(path);
                },
                deleteFile: function (path) {
                    if (fso.FileExists(path)) {
                        fso.DeleteFile(path, true);
                    }
                },
                directoryExists: function (path) {
                    return fso.FolderExists(path);
                },
                listFiles: function (path, spec, options) {
                    options = options || {};
                    function filesInFolder(folder, root) {
                        var paths = [];
                        var fc;
                        if (options.recursive) {
                            fc = new Enumerator(folder.subfolders);
                            for (; !fc.atEnd(); fc.moveNext()) {
                                paths = paths.concat(filesInFolder(fc.item(), root + "\\" + fc.item().Name));
                            }
                        }
                        fc = new Enumerator(folder.files);
                        for (; !fc.atEnd(); fc.moveNext()) {
                            if (!spec || fc.item().Name.match(spec)) {
                                paths.push(root + "\\" + fc.item().Name);
                            }
                        }
                        return paths;
                    }
                    var folder = fso.GetFolder(path);
                    var paths = [];
                    return filesInFolder(folder, path);
                },
                arguments: args,
                standardOut: WScript.StdOut,
            };
        }
        ;
        function getNodeEnvironment() {
            var _fs = require('fs');
            var _path = require('path');
            var _module = require('module');
            var _os = require('os');
            return {
                newLine: _os.EOL,
                currentDirectory: function () {
                    return process.cwd();
                },
                supportsCodePage: function () { return false; },
                readFile: function (file, codepage) {
                    if (codepage !== null) {
                        throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.codepage_option_not_supported_on_current_platform, null));
                    }
                    var buffer = _fs.readFileSync(file);
                    switch (buffer[0]) {
                        case 0xFE:
                            if (buffer[1] === 0xFF) {
                                var i = 0;
                                while ((i + 1) < buffer.length) {
                                    var temp = buffer[i];
                                    buffer[i] = buffer[i + 1];
                                    buffer[i + 1] = temp;
                                    i += 2;
                                }
                                return new FileInformation(buffer.toString("ucs2", 2), ByteOrderMark.Utf16BigEndian);
                            }
                            break;
                        case 0xFF:
                            if (buffer[1] === 0xFE) {
                                return new FileInformation(buffer.toString("ucs2", 2), ByteOrderMark.Utf16LittleEndian);
                            }
                            break;
                        case 0xEF:
                            if (buffer[1] === 0xBB) {
                                return new FileInformation(buffer.toString("utf8", 3), ByteOrderMark.Utf8);
                            }
                    }
                    return new FileInformation(buffer.toString("utf8", 0), ByteOrderMark.None);
                },
                writeFile: function (path, contents, writeByteOrderMark) {
                    function mkdirRecursiveSync(path) {
                        var stats = _fs.statSync(path);
                        if (stats.isFile()) {
                            throw "\"" + path + "\" exists but isn't a directory.";
                        }
                        else if (stats.isDirectory()) {
                            return;
                        }
                        else {
                            mkdirRecursiveSync(_path.dirname(path));
                            _fs.mkdirSync(path, 509);
                        }
                    }
                    var start = new Date().getTime();
                    mkdirRecursiveSync(_path.dirname(path));
                    TypeScript.nodeMakeDirectoryTime += new Date().getTime() - start;
                    if (writeByteOrderMark) {
                        contents = '\uFEFF' + contents;
                    }
                    var start = new Date().getTime();
                    var chunkLength = 4 * 1024;
                    var fileDescriptor = _fs.openSync(path, "w");
                    try {
                        for (var index = 0; index < contents.length; index += chunkLength) {
                            var bufferStart = new Date().getTime();
                            var buffer = new Buffer(contents.substr(index, chunkLength), "utf8");
                            TypeScript.nodeCreateBufferTime += new Date().getTime() - bufferStart;
                            _fs.writeSync(fileDescriptor, buffer, 0, buffer.length, null);
                        }
                    }
                    finally {
                        _fs.closeSync(fileDescriptor);
                    }
                    TypeScript.nodeWriteFileSyncTime += new Date().getTime() - start;
                },
                fileExists: function (path) {
                    return _fs.existsSync(path);
                },
                deleteFile: function (path) {
                    try {
                        _fs.unlinkSync(path);
                    }
                    catch (e) {
                    }
                },
                directoryExists: function (path) {
                    return _fs.existsSync(path) && _fs.statSync(path).isDirectory();
                },
                listFiles: function (path, spec, options) {
                    options = options || {};
                    function filesInFolder(folder) {
                        var paths = [];
                        var files = _fs.readdirSync(folder);
                        for (var i = 0; i < files.length; i++) {
                            var stat = _fs.statSync(folder + "\\" + files[i]);
                            if (options.recursive && stat.isDirectory()) {
                                paths = paths.concat(filesInFolder(folder + "\\" + files[i]));
                            }
                            else if (stat.isFile() && (!spec || files[i].match(spec))) {
                                paths.push(folder + "\\" + files[i]);
                            }
                        }
                        return paths;
                    }
                    return filesInFolder(path);
                },
                arguments: process.argv.slice(2),
                standardOut: {
                    Write: function (str) { process.stdout.write(str); },
                    WriteLine: function (str) { process.stdout.write(str + '\n'); },
                    Close: function () { }
                },
            };
        }
        ;
        if (typeof WScript !== "undefined" && typeof ActiveXObject === "function") {
            return getWindowsScriptHostEnvironment();
        }
        else if (typeof module !== 'undefined' && module.exports) {
            return getNodeEnvironment();
        }
        else {
            return null;
        }
    })();
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var IntegerUtilities;
    (function (IntegerUtilities) {
        function integerDivide(numerator, denominator) {
            return (numerator / denominator) >> 0;
        }
        IntegerUtilities.integerDivide = integerDivide;
        function integerMultiplyLow32Bits(n1, n2) {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;
            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;
            var resultLow32 = (((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) >>> 0;
            return resultLow32;
        }
        IntegerUtilities.integerMultiplyLow32Bits = integerMultiplyLow32Bits;
        function integerMultiplyHigh32Bits(n1, n2) {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;
            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;
            var resultHigh32 = n1High16 * n2High16 + ((((n1Low16 * n2Low16) >>> 17) + n1Low16 * n2High16) >>> 15);
            return resultHigh32;
        }
        IntegerUtilities.integerMultiplyHigh32Bits = integerMultiplyHigh32Bits;
        function isInteger(text) {
            return /^[0-9]+$/.test(text);
        }
        IntegerUtilities.isInteger = isInteger;
        function isHexInteger(text) {
            return /^0(x|X)[0-9a-fA-F]+$/.test(text);
        }
        IntegerUtilities.isHexInteger = isHexInteger;
    })(IntegerUtilities = TypeScript.IntegerUtilities || (TypeScript.IntegerUtilities = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var LineMap = (function () {
        function LineMap(_computeLineStarts, length) {
            this._computeLineStarts = _computeLineStarts;
            this.length = length;
            this._lineStarts = null;
        }
        LineMap.prototype.toJSON = function (key) {
            return { lineStarts: this.lineStarts(), length: this.length };
        };
        LineMap.prototype.equals = function (other) {
            return this.length === other.length &&
                TypeScript.ArrayUtilities.sequenceEquals(this.lineStarts(), other.lineStarts(), function (v1, v2) { return v1 === v2; });
        };
        LineMap.prototype.lineStarts = function () {
            if (this._lineStarts === null) {
                this._lineStarts = this._computeLineStarts();
            }
            return this._lineStarts;
        };
        LineMap.prototype.lineCount = function () {
            return this.lineStarts().length;
        };
        LineMap.prototype.getPosition = function (line, character) {
            return this.lineStarts()[line] + character;
        };
        LineMap.prototype.getLineNumberFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }
            if (position === this.length) {
                return this.lineCount() - 1;
            }
            var lineNumber = TypeScript.ArrayUtilities.binarySearch(this.lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }
            return lineNumber;
        };
        LineMap.prototype.getLineStartPosition = function (lineNumber) {
            return this.lineStarts()[lineNumber];
        };
        LineMap.prototype.fillLineAndCharacterFromPosition = function (position, lineAndCharacter) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position: " + position);
            }
            var lineNumber = this.getLineNumberFromPosition(position);
            lineAndCharacter.line = lineNumber;
            lineAndCharacter.character = position - this.lineStarts()[lineNumber];
        };
        LineMap.prototype.getLineAndCharacterFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }
            var lineNumber = this.getLineNumberFromPosition(position);
            return new TypeScript.LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
        };
        LineMap.empty = new LineMap(function () { return [0]; }, 0);
        return LineMap;
    }());
    TypeScript.LineMap = LineMap;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var LineAndCharacter = (function () {
        function LineAndCharacter(line, character) {
            this._line = 0;
            this._character = 0;
            if (line < 0) {
                throw TypeScript.Errors.argumentOutOfRange("line");
            }
            if (character < 0) {
                throw TypeScript.Errors.argumentOutOfRange("character");
            }
            this._line = line;
            this._character = character;
        }
        LineAndCharacter.prototype.line = function () {
            return this._line;
        };
        LineAndCharacter.prototype.character = function () {
            return this._character;
        };
        LineAndCharacter.prototype.toString = function () {
            return "(" + this._line + ", " + this._character + ")";
        };
        return LineAndCharacter;
    }());
    TypeScript.LineAndCharacter = LineAndCharacter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var MathPrototype = (function () {
        function MathPrototype() {
        }
        MathPrototype.max = function (a, b) {
            return a >= b ? a : b;
        };
        MathPrototype.min = function (a, b) {
            return a <= b ? a : b;
        };
        return MathPrototype;
    }());
    TypeScript.MathPrototype = MathPrototype;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Collections;
    (function (Collections) {
        Collections.DefaultStringTableCapacity = 256;
        var StringTableEntry = (function () {
            function StringTableEntry(Text, HashCode, Next) {
                this.Text = Text;
                this.HashCode = HashCode;
                this.Next = Next;
            }
            return StringTableEntry;
        }());
        var StringTable = (function () {
            function StringTable(capacity) {
                this.count = 0;
                var size = TypeScript.Hash.getPrime(capacity);
                this.entries = TypeScript.ArrayUtilities.createArray(size, null);
            }
            StringTable.prototype.addCharArray = function (key, start, len) {
                var hashCode = TypeScript.Hash.computeSimple31BitCharArrayHashCode(key, start, len) & 0x7FFFFFFF;
                var entry = this.findCharArrayEntry(key, start, len, hashCode);
                if (entry !== null) {
                    return entry.Text;
                }
                var slice = key.slice(start, start + len);
                return this.addEntry(TypeScript.StringUtilities.fromCharCodeArray(slice), hashCode);
            };
            StringTable.prototype.findCharArrayEntry = function (key, start, len, hashCode) {
                for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                    if (e.HashCode === hashCode && StringTable.textCharArrayEquals(e.Text, key, start, len)) {
                        return e;
                    }
                }
                return null;
            };
            StringTable.prototype.addEntry = function (text, hashCode) {
                var index = hashCode % this.entries.length;
                var e = new StringTableEntry(text, hashCode, this.entries[index]);
                this.entries[index] = e;
                if (this.count === this.entries.length) {
                    this.grow();
                }
                this.count++;
                return e.Text;
            };
            StringTable.prototype.grow = function () {
                var newSize = TypeScript.Hash.expandPrime(this.entries.length);
                var oldEntries = this.entries;
                var newEntries = TypeScript.ArrayUtilities.createArray(newSize, null);
                this.entries = newEntries;
                for (var i = 0; i < oldEntries.length; i++) {
                    var e = oldEntries[i];
                    while (e !== null) {
                        var newIndex = e.HashCode % newSize;
                        var tmp = e.Next;
                        e.Next = newEntries[newIndex];
                        newEntries[newIndex] = e;
                        e = tmp;
                    }
                }
            };
            StringTable.textCharArrayEquals = function (text, array, start, length) {
                if (text.length !== length) {
                    return false;
                }
                var s = start;
                for (var i = 0; i < length; i++) {
                    if (text.charCodeAt(i) !== array[s]) {
                        return false;
                    }
                    s++;
                }
                return true;
            };
            return StringTable;
        }());
        Collections.StringTable = StringTable;
        Collections.DefaultStringTable = new StringTable(Collections.DefaultStringTableCapacity);
    })(Collections = TypeScript.Collections || (TypeScript.Collections = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var StringUtilities = (function () {
        function StringUtilities() {
        }
        StringUtilities.isString = function (value) {
            return (typeof value === "string" || value instanceof String);
        };
        StringUtilities.fromCharCodeArray = function (array) {
            return RT.applyVariadic(String, "fromCharCode", array);
        };
        StringUtilities.endsWith = function (string, value) {
            return string.substring(string.length - value.length, string.length) === value;
        };
        StringUtilities.startsWith = function (string, value) {
            return string.substr(0, value.length) === value;
        };
        StringUtilities.copyTo = function (source, sourceIndex, destination, destinationIndex, count) {
            for (var i = 0; i < count; i++) {
                destination[destinationIndex + i] = source.charCodeAt(sourceIndex + i);
            }
        };
        StringUtilities.repeat = function (value, count) {
            return new Array(count + 1).join(value);
        };
        StringUtilities.stringEquals = function (val1, val2) {
            return val1 === val2;
        };
        return StringUtilities;
    }());
    TypeScript.StringUtilities = StringUtilities;
})(TypeScript || (TypeScript = {}));
var global = Function("return this").call(null);
var TypeScript;
(function (TypeScript) {
    var Clock;
    (function (Clock) {
        if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
            global['WScript'].InitializeProjection();
            Clock.now = function () {
                return TestUtilities.QueryPerformanceCounter();
            };
            Clock.resolution = TestUtilities.QueryPerformanceFrequency();
        }
        else {
            Clock.now = function () {
                return Date.now();
            };
            Clock.resolution = 1000;
        }
    })(Clock || (Clock = {}));
    var Timer = (function () {
        function Timer() {
            this.time = 0;
        }
        Timer.prototype.start = function () {
            this.time = 0;
            this.startTime = Clock.now();
        };
        Timer.prototype.end = function () {
            this.time = (Clock.now() - this.startTime);
        };
        return Timer;
    }());
    TypeScript.Timer = Timer;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DiagnosticCategory;
    (function (DiagnosticCategory) {
        DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
        DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
        DiagnosticCategory[DiagnosticCategory["Message"] = 2] = "Message";
        DiagnosticCategory[DiagnosticCategory["NoPrefix"] = 3] = "NoPrefix";
    })(DiagnosticCategory = TypeScript.DiagnosticCategory || (TypeScript.DiagnosticCategory = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    ;
    TypeScript.diagnosticInformationMap = {
        "error TS{0}: {1}": {
            "code": 0,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "warning TS{0}: {1}": {
            "code": 1,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Unrecognized escape sequence.": {
            "code": 1000,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Unexpected character {0}.": {
            "code": 1001,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Missing close quote character.": {
            "code": 1002,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Identifier expected.": {
            "code": 1003,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'{0}' keyword expected.": {
            "code": 1004,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'{0}' expected.": {
            "code": 1005,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Identifier expected; '{0}' is a keyword.": {
            "code": 1006,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Automatic semicolon insertion not allowed.": {
            "code": 1007,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Unexpected token; '{0}' expected.": {
            "code": 1008,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Trailing separator not allowed.": {
            "code": 1009,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'*/' expected.": {
            "code": 1010,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'public' or 'private' modifier must precede 'static'.": {
            "code": 1011,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Unexpected token.": {
            "code": 1012,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Catch clause parameter cannot have a type annotation.": {
            "code": 1013,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Rest parameter must be last in list.": {
            "code": 1014,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter cannot have question mark and initializer.": {
            "code": 1015,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Required parameter cannot follow optional parameter.": {
            "code": 1016,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Index signatures cannot have rest parameters.": {
            "code": 1017,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Index signature parameter cannot have accessibility modifiers.": {
            "code": 1018,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Index signature parameter cannot have a question mark.": {
            "code": 1019,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Index signature parameter cannot have an initializer.": {
            "code": 1020,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Index signature must have a type annotation.": {
            "code": 1021,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Index signature parameter must have a type annotation.": {
            "code": 1022,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Index signature parameter type must be 'string' or 'number'.": {
            "code": 1023,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'extends' clause already seen.": {
            "code": 1024,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'extends' clause must precede 'implements' clause.": {
            "code": 1025,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Classes can only extend a single class.": {
            "code": 1026,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'implements' clause already seen.": {
            "code": 1027,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Accessibility modifier already seen.": {
            "code": 1028,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'{0}' modifier must precede '{1}' modifier.": {
            "code": 1029,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'{0}' modifier already seen.": {
            "code": 1030,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'{0}' modifier cannot appear on a class element.": {
            "code": 1031,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Interface declaration cannot have 'implements' clause.": {
            "code": 1032,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'super' invocation cannot have type arguments.": {
            "code": 1034,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Only ambient modules can use quoted names.": {
            "code": 1035,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Statements are not allowed in ambient contexts.": {
            "code": 1036,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Implementations are not allowed in ambient contexts.": {
            "code": 1037,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'declare' modifier not allowed for code already in an ambient context.": {
            "code": 1038,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Initializers are not allowed in ambient contexts.": {
            "code": 1039,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter property declarations can only be used in constructors.": {
            "code": 1040,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Function implementation expected.": {
            "code": 1041,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Constructor implementation expected.": {
            "code": 1042,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Function overload name must be '{0}'.": {
            "code": 1043,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'{0}' modifier cannot appear on a module element.": {
            "code": 1044,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'declare' modifier cannot appear on an interface declaration.": {
            "code": 1045,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'declare' modifier required for top level element.": {
            "code": 1046,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Rest parameter cannot be optional.": {
            "code": 1047,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Rest parameter cannot have an initializer.": {
            "code": 1048,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'set' accessor must have one and only one parameter.": {
            "code": 1049,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'set' accessor parameter cannot be optional.": {
            "code": 1051,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'set' accessor parameter cannot have an initializer.": {
            "code": 1052,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'set' accessor cannot have rest parameter.": {
            "code": 1053,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'get' accessor cannot have parameters.": {
            "code": 1054,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Modifiers cannot appear here.": {
            "code": 1055,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Accessors are only available when targeting ECMAScript 5 and higher.": {
            "code": 1056,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Class name cannot be '{0}'.": {
            "code": 1057,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Interface name cannot be '{0}'.": {
            "code": 1058,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Enum name cannot be '{0}'.": {
            "code": 1059,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Module name cannot be '{0}'.": {
            "code": 1060,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Enum member must have initializer.": {
            "code": 1061,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Export assignment cannot be used in internal modules.": {
            "code": 1063,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Export assignment not allowed in module with exported element.": {
            "code": 1064,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Module cannot have multiple export assignments.": {
            "code": 1065,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Ambient enum elements can only have integer literal initializers.": {
            "code": 1066,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "module, class, interface, enum, import or statement": {
            "code": 1067,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "constructor, function, accessor or variable": {
            "code": 1068,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "statement": {
            "code": 1069,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "case or default clause": {
            "code": 1070,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "identifier": {
            "code": 1071,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "call, construct, index, property or function signature": {
            "code": 1072,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "expression": {
            "code": 1073,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "type name": {
            "code": 1074,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "property or accessor": {
            "code": 1075,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "parameter": {
            "code": 1076,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "type": {
            "code": 1077,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "type parameter": {
            "code": 1078,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "'declare' modifier not allowed on import declaration.": {
            "code": 1079,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Function overload must be static.": {
            "code": 1080,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Function overload must not be static.": {
            "code": 1081,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter property declarations cannot be used in an ambient context.": {
            "code": 1082,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter property declarations cannot be used in a constructor overload.": {
            "code": 1083,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Invalid 'reference' directive syntax.": {
            "code": 1084,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Octal literals are not available when targeting ECMAScript 5 and higher.": {
            "code": 1085,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Accessors are not allowed in ambient contexts.": {
            "code": 1086,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'{0}' modifier cannot appear on a constructor declaration.": {
            "code": 1089,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'{0}' modifier cannot appear on a parameter.": {
            "code": 1090,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Duplicate identifier '{0}'.": {
            "code": 2000,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "The name '{0}' does not exist in the current scope.": {
            "code": 2001,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "The name '{0}' does not refer to a value.": {
            "code": 2002,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'super' can only be used inside a class instance method.": {
            "code": 2003,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "The left-hand side of an assignment expression must be a variable, property or indexer.": {
            "code": 2004,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": {
            "code": 2161,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Value of type '{0}' is not callable.": {
            "code": 2006,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Value of type '{0}' is not newable.": {
            "code": 2007,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Value of type '{0}' is not indexable by type '{1}'.": {
            "code": 2008,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": {
            "code": 2009,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}": {
            "code": 2010,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Cannot convert '{0}' to '{1}'.": {
            "code": 2011,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Cannot convert '{0}' to '{1}':{NL}{2}": {
            "code": 2012,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Expected var, class, interface, or module.": {
            "code": 2013,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Operator '{0}' cannot be applied to type '{1}'.": {
            "code": 2014,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Getter '{0}' already declared.": {
            "code": 2015,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Setter '{0}' already declared.": {
            "code": 2016,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Exported class '{0}' extends private class '{1}'.": {
            "code": 2018,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Exported class '{0}' implements private interface '{1}'.": {
            "code": 2019,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Exported interface '{0}' extends private interface '{1}'.": {
            "code": 2020,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Exported class '{0}' extends class from inaccessible module {1}.": {
            "code": 2021,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Exported class '{0}' implements interface from inaccessible module {1}.": {
            "code": 2022,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Exported interface '{0}' extends interface from inaccessible module {1}.": {
            "code": 2023,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Public static property '{0}' of exported class has or is using private type '{1}'.": {
            "code": 2024,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Public property '{0}' of exported class has or is using private type '{1}'.": {
            "code": 2025,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Property '{0}' of exported interface has or is using private type '{1}'.": {
            "code": 2026,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Exported variable '{0}' has or is using private type '{1}'.": {
            "code": 2027,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Public static property '{0}' of exported class is using inaccessible module {1}.": {
            "code": 2028,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Public property '{0}' of exported class is using inaccessible module {1}.": {
            "code": 2029,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Property '{0}' of exported interface is using inaccessible module {1}.": {
            "code": 2030,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Exported variable '{0}' is using inaccessible module {1}.": {
            "code": 2031,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.": {
            "code": 2032,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.": {
            "code": 2033,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.": {
            "code": 2034,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": {
            "code": 2035,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.": {
            "code": 2036,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.": {
            "code": 2037,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of public method from exported class has or is using private type '{1}'.": {
            "code": 2038,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of method from exported interface has or is using private type '{1}'.": {
            "code": 2039,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of exported function has or is using private type '{1}'.": {
            "code": 2040,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.": {
            "code": 2041,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.": {
            "code": 2042,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.": {
            "code": 2043,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": {
            "code": 2044,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}": {
            "code": 2045,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.": {
            "code": 2046,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of public method from exported class is using inaccessible module {1}.": {
            "code": 2047,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of method from exported interface is using inaccessible module {1}.": {
            "code": 2048,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of exported function is using inaccessible module {1}.": {
            "code": 2049,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of public static property getter from exported class has or is using private type '{0}'.": {
            "code": 2050,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of public property getter from exported class has or is using private type '{0}'.": {
            "code": 2051,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of constructor signature from exported interface has or is using private type '{0}'.": {
            "code": 2052,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of call signature from exported interface has or is using private type '{0}'.": {
            "code": 2053,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of index signature from exported interface has or is using private type '{0}'.": {
            "code": 2054,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of public static method from exported class has or is using private type '{0}'.": {
            "code": 2055,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of public method from exported class has or is using private type '{0}'.": {
            "code": 2056,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of method from exported interface has or is using private type '{0}'.": {
            "code": 2057,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of exported function has or is using private type '{0}'.": {
            "code": 2058,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of public static property getter from exported class is using inaccessible module {0}.": {
            "code": 2059,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of public property getter from exported class is using inaccessible module {0}.": {
            "code": 2060,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of constructor signature from exported interface is using inaccessible module {0}.": {
            "code": 2061,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of call signature from exported interface is using inaccessible module {0}.": {
            "code": 2062,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of index signature from exported interface is using inaccessible module {0}.": {
            "code": 2063,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of public static method from exported class is using inaccessible module {0}.": {
            "code": 2064,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of public method from exported class is using inaccessible module {0}.": {
            "code": 2065,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of method from exported interface is using inaccessible module {0}.": {
            "code": 2066,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of exported function is using inaccessible module {0}.": {
            "code": 2067,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": {
            "code": 2068,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "A parameter list must follow a generic type argument list. '(' expected.": {
            "code": 2069,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Multiple constructor implementations are not allowed.": {
            "code": 2070,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Unable to resolve external module '{0}'.": {
            "code": 2071,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Module cannot be aliased to a non-module type.": {
            "code": 2072,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "A class may only extend another class.": {
            "code": 2073,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "A class may only implement another class or interface.": {
            "code": 2074,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "An interface may only extend another class or interface.": {
            "code": 2075,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Unable to resolve type.": {
            "code": 2077,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Unable to resolve type of '{0}'.": {
            "code": 2078,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Unable to resolve type parameter constraint.": {
            "code": 2079,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Type parameter constraint cannot be a primitive type.": {
            "code": 2080,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Supplied parameters do not match any signature of call target.": {
            "code": 2081,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Supplied parameters do not match any signature of call target:{NL}{0}": {
            "code": 2082,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Invalid 'new' expression.": {
            "code": 2083,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Call signatures used in a 'new' expression must have a 'void' return type.": {
            "code": 2084,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Could not select overload for 'new' expression.": {
            "code": 2085,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.": {
            "code": 2086,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Could not select overload for 'call' expression.": {
            "code": 2087,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Cannot invoke an expression whose type lacks a call signature.": {
            "code": 2088,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Calls to 'super' are only valid inside a class.": {
            "code": 2089,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Generic type '{0}' requires {1} type argument(s).": {
            "code": 2090,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Type of array literal cannot be determined. Best common type could not be found for array elements.": {
            "code": 2092,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Could not find enclosing symbol for dotted name '{0}'.": {
            "code": 2093,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "The property '{0}' does not exist on value of type '{1}'.": {
            "code": 2094,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Could not find symbol '{0}'.": {
            "code": 2095,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'get' and 'set' accessor must have the same type.": {
            "code": 2096,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'this' cannot be referenced in current location.": {
            "code": 2097,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Static methods cannot reference class type parameters.": {
            "code": 2099,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Class '{0}' is recursively referenced as a base type of itself.": {
            "code": 2100,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Interface '{0}' is recursively referenced as a base type of itself.": {
            "code": 2101,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": {
            "code": 2102,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'super' cannot be referenced in non-derived classes.": {
            "code": 2103,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": {
            "code": 2104,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Constructors for derived classes must contain a 'super' call.": {
            "code": 2105,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Super calls are not permitted outside constructors or in local functions inside constructors.": {
            "code": 2106,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'{0}.{1}' is inaccessible.": {
            "code": 2107,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'this' cannot be referenced within module bodies.": {
            "code": 2108,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Invalid '+' expression - types not known to support the addition operator.": {
            "code": 2111,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": {
            "code": 2112,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": {
            "code": 2113,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.": {
            "code": 2114,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Variable declarations of a 'for' statement cannot use a type annotation.": {
            "code": 2115,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Variable declarations of a 'for' statement must be of types 'string' or 'any'.": {
            "code": 2116,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": {
            "code": 2117,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.": {
            "code": 2118,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.": {
            "code": 2119,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": {
            "code": 2120,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "The right-hand side of an 'instanceof' expression must be of type 'any' or a subtype of the 'Function' interface type.": {
            "code": 2121,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Setters cannot return a value.": {
            "code": 2122,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Tried to query type of uninitialized module '{0}'.": {
            "code": 2123,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Tried to set variable type to uninitialized module type '{0}'.": {
            "code": 2124,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Function '{0}' declared a non-void return type, but has no return expression.": {
            "code": 2125,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Getters must return a value.": {
            "code": 2126,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Getter and setter accessors do not agree in visibility.": {
            "code": 2127,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Invalid left-hand side of assignment expression.": {
            "code": 2130,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Function declared a non-void return type, but has no return expression.": {
            "code": 2131,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Cannot resolve return type reference.": {
            "code": 2132,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Constructors cannot have a return type of 'void'.": {
            "code": 2133,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": {
            "code": 2134,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "All symbols within a with block will be resolved to 'any'.": {
            "code": 2135,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Import declarations in an internal module cannot reference an external module.": {
            "code": 2136,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Class {0} declares interface {1} but does not implement it:{NL}{2}": {
            "code": 2137,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}": {
            "code": 2138,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "The operand of an increment or decrement operator must be a variable, property or indexer.": {
            "code": 2139,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'this' cannot be referenced in static initializers in a class body.": {
            "code": 2140,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Class '{0}' cannot extend class '{1}':{NL}{2}": {
            "code": 2141,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Interface '{0}' cannot extend class '{1}':{NL}{2}": {
            "code": 2142,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Interface '{0}' cannot extend interface '{1}':{NL}{2}": {
            "code": 2143,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Duplicate overload signature for '{0}'.": {
            "code": 2144,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Duplicate constructor overload signature.": {
            "code": 2145,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Duplicate overload call signature.": {
            "code": 2146,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Duplicate overload construct signature.": {
            "code": 2147,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Overload signature is not compatible with function definition.": {
            "code": 2148,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Overload signature is not compatible with function definition:{NL}{0}": {
            "code": 2149,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Overload signatures must all be public or private.": {
            "code": 2150,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Overload signatures must all be exported or not exported.": {
            "code": 2151,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Overload signatures must all be ambient or non-ambient.": {
            "code": 2152,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Overload signatures must all be optional or required.": {
            "code": 2153,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Specialized overload signature is not subtype of any non-specialized signature.": {
            "code": 2154,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'this' cannot be referenced in constructor arguments.": {
            "code": 2155,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Instance member cannot be accessed off a class.": {
            "code": 2157,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Untyped function calls may not accept type arguments.": {
            "code": 2158,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Non-generic functions may not accept type arguments.": {
            "code": 2159,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "A generic type may not reference itself with a wrapped form of its own type parameters.": {
            "code": 2160,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Rest parameters must be array types.": {
            "code": 2162,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Overload signature implementation cannot use specialized type.": {
            "code": 2163,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Export assignments may only be used at the top-level of external modules.": {
            "code": 2164,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.": {
            "code": 2165,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Only public methods of the base class are accessible via the 'super' keyword.": {
            "code": 2166,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}'.": {
            "code": 2167,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}':{NL}{2}": {
            "code": 2168,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "All numerically named properties must be subtypes of numeric indexer type '{0}'.": {
            "code": 2169,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "All numerically named properties must be subtypes of numeric indexer type '{0}':{NL}{1}": {
            "code": 2170,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "All named properties must be subtypes of string indexer type '{0}'.": {
            "code": 2171,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "All named properties must be subtypes of string indexer type '{0}':{NL}{1}": {
            "code": 2172,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Generic type references must include all type arguments.": {
            "code": 2173,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Default arguments are not allowed in an overload parameter.": {
            "code": 2174,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Overloads cannot differ only by return type.": {
            "code": 2175,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Function expression declared a non-void return type, but has no return expression.": {
            "code": 2176,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.": {
            "code": 2177,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Could not find symbol '{0}' in module '{1}'.": {
            "code": 2178,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Unable to resolve module reference '{0}'.": {
            "code": 2179,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Could not find module '{0}' in module '{1}'.": {
            "code": 2180,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.": {
            "code": 2181,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.": {
            "code": 2182,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.": {
            "code": 2183,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.": {
            "code": 2184,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.": {
            "code": 2185,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Type reference '{0}' in extends clause does not reference constructor function for '{1}'.": {
            "code": 2186,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.": {
            "code": 2187,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.": {
            "code": 2188,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}": {
            "code": 2189,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": {
            "code": 2190,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Ambient external module declaration cannot be reopened.": {
            "code": 2191,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "All declarations of merged declaration '{0}' must be exported or not exported.": {
            "code": 2192,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'super' cannot be referenced in constructor arguments.": {
            "code": 2193,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Return type of constructor signature must be assignable to the instance type of the class.": {
            "code": 2194,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Ambient external module declaration must be defined in global context.": {
            "code": 2195,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Ambient external module declaration cannot specify relative module name.": {
            "code": 2196,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.": {
            "code": 2197,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Could not find the best common type of types of all return statement expressions.": {
            "code": 2198,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Import declaration cannot refer to external module reference when --noResolve option is set.": {
            "code": 2199,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": {
            "code": 2200,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'continue' statement can only be used within an enclosing iteration statement.": {
            "code": 2201,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'break' statement can only be used within an enclosing iteration or switch statement.": {
            "code": 2202,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Jump target not found.": {
            "code": 2203,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Jump target cannot cross function boundary.": {
            "code": 2204,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": {
            "code": 2205,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": {
            "code": 2206,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Expression resolves to '_super' that compiler uses to capture base class reference.": {
            "code": 2207,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": {
            "code": 2208,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.": {
            "code": 2209,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.": {
            "code": 2210,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.": {
            "code": 2211,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.": {
            "code": 2212,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of exported function has or is using private type '{1}'.": {
            "code": 2213,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": {
            "code": 2214,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}": {
            "code": 2215,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.": {
            "code": 2216,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.": {
            "code": 2217,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.": {
            "code": 2218,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of exported function is using inaccessible module {1}.": {
            "code": 2219,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of exported class has or is using private type '{1}'.": {
            "code": 2220,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of exported interface has or is using private type '{1}'.": {
            "code": 2221,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of exported class is using inaccessible module {1}.": {
            "code": 2222,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "TypeParameter '{0}' of exported interface is using inaccessible module {1}.": {
            "code": 2223,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.": {
            "code": 2224,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": {
            "code": 2225,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Type of conditional '{0}' must be identical to '{1}' or '{2}'.": {
            "code": 2226,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Type of conditional '{0}' must be identical to '{1}', '{2}' or '{3}'.": {
            "code": 2227,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.": {
            "code": 2228,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Type '{0}' is missing property '{1}' from type '{2}'.": {
            "code": 4000,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible.": {
            "code": 4001,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}": {
            "code": 4002,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": {
            "code": 4003,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": {
            "code": 4004,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Types '{0}' and '{1}' define property '{2}' as private.": {
            "code": 4005,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Call signatures of types '{0}' and '{1}' are incompatible.": {
            "code": 4006,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": {
            "code": 4007,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Type '{0}' requires a call signature, but type '{1}' lacks one.": {
            "code": 4008,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Construct signatures of types '{0}' and '{1}' are incompatible.": {
            "code": 4009,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": {
            "code": 4010,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Type '{0}' requires a construct signature, but type '{1}' lacks one.": {
            "code": 4011,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Index signatures of types '{0}' and '{1}' are incompatible.": {
            "code": 4012,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": {
            "code": 4013,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Call signature expects {0} or fewer parameters.": {
            "code": 4014,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Could not apply type '{0}' to argument {1} which is of type '{2}'.": {
            "code": 4015,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": {
            "code": 4016,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": {
            "code": 4017,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": {
            "code": 4018,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": {
            "code": 4019,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.": {
            "code": 4020,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}": {
            "code": 4021,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Type reference cannot refer to container '{0}'.": {
            "code": 4022,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Type reference must refer to type.": {
            "code": 4023,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Enums with multiple declarations must provide an initializer for the first enum element.": {
            "code": 4024,
            "category": TypeScript.DiagnosticCategory.Error
        },
        " (+ {0} overload(s))": {
            "code": 4025,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Variable declaration cannot have the same name as an import declaration.": {
            "code": 4026,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Signature expected {0} type arguments, got {1} instead.": {
            "code": 4027,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.": {
            "code": 4028,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Types '{0}' and '{1}' originating in inifinitely expanding type reference do not refer to same named type.": {
            "code": 4029,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Types '{0}' and '{1}' originating in inifinitely expanding type reference have incompatible type arguments.": {
            "code": 4030,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Types '{0}' and '{1}' originating in inifinitely expanding type reference have incompatible type arguments:{NL}{2}": {
            "code": 4031,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Types of property '{0}' of types '{1}' and '{2}' are not identical.": {
            "code": 4032,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Types of string indexer of types '{0}' and '{1}' are not identical.": {
            "code": 4033,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Types of number indexer of types '{0}' and '{1}' are not identical.": {
            "code": 4034,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Type of number indexer in type '{0}' is not a subtype of string indexer type in type '{1}'.{NL}{2}": {
            "code": 4035,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Type of property '{0}' in type '{1}' is not a subtype of string indexer type in type '{2}'.{NL}{3}": {
            "code": 4036,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Type of property '{0}' in type '{1}' is not a subtype of number indexer type in type '{2}'.{NL}{3}": {
            "code": 4037,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Current host does not support '{0}' option.": {
            "code": 5001,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'": {
            "code": 5002,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Module code generation '{0}' not supported.": {
            "code": 5003,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Could not find file: '{0}'.": {
            "code": 5004,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "A file cannot have a reference to itself.": {
            "code": 5006,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Cannot resolve referenced file: '{0}'.": {
            "code": 5007,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Cannot find the common subdirectory path for the input files.": {
            "code": 5009,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Emit Error: {0}.": {
            "code": 5011,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Cannot read file '{0}': {1}": {
            "code": 5012,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Unsupported file encoding.": {
            "code": 5013,
            "category": TypeScript.DiagnosticCategory.NoPrefix
        },
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": {
            "code": 5014,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Unsupported locale: '{0}'.": {
            "code": 5015,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Execution Failed.{NL}": {
            "code": 5016,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Invalid call to 'up'": {
            "code": 5019,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Invalid call to 'down'": {
            "code": 5020,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Base64 value '{0}' finished with a continuation bit.": {
            "code": 5021,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Unknown option '{0}'": {
            "code": 5023,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Expected {0} arguments to message, got {1} instead.": {
            "code": 5024,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Expected the message '{0}' to have {1} arguments, but it had {2}": {
            "code": 5025,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Could not delete file '{0}'": {
            "code": 5034,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Could not create directory '{0}'": {
            "code": 5035,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Error while executing file '{0}': ": {
            "code": 5036,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Cannot compile external modules unless the '--module' flag is provided.": {
            "code": 5037,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Option mapRoot cannot be specified without specifying sourcemap option.": {
            "code": 5038,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Option sourceRoot cannot be specified without specifying sourcemap option.": {
            "code": 5039,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.": {
            "code": 5040,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Option '{0}' specified without '{1}'": {
            "code": 5041,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'codepage' option not supported on current platform.": {
            "code": 5042,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Concatenate and emit output to single file.": {
            "code": 6001,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Generates corresponding {0} file.": {
            "code": 6002,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Specifies the location where debugger should locate map files instead of generated locations.": {
            "code": 6003,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": {
            "code": 6004,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Watch input files.": {
            "code": 6005,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Redirect output structure to the directory.": {
            "code": 6006,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Do not emit comments to output.": {
            "code": 6009,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Skip resolution and preprocessing.": {
            "code": 6010,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Specify ECMAScript target version: '{0}' (default), or '{1}'": {
            "code": 6015,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Specify module code generation: '{0}' or '{1}'": {
            "code": 6016,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Print this message.": {
            "code": 6017,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Print the compiler's version: {0}": {
            "code": 6019,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Allow use of deprecated '{0}' keyword when referencing an external module.": {
            "code": 6021,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Specify locale for errors and messages. For example '{0}' or '{1}'": {
            "code": 6022,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Syntax:   {0}": {
            "code": 6023,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "options": {
            "code": 6024,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "file1": {
            "code": 6025,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Examples:": {
            "code": 6026,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Options:": {
            "code": 6027,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Insert command line options and files from a file.": {
            "code": 6030,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Version {0}": {
            "code": 6029,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Use the '{0}' flag to see options.": {
            "code": 6031,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "{NL}Recompiling ({0}):": {
            "code": 6032,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "STRING": {
            "code": 6033,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "KIND": {
            "code": 6034,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "file2": {
            "code": 6035,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "VERSION": {
            "code": 6036,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "LOCATION": {
            "code": 6037,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "DIRECTORY": {
            "code": 6038,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "NUMBER": {
            "code": 6039,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Specify the codepage to use when opening source files.": {
            "code": 6040,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "This version of the Javascript runtime does not support the '{0}' function.": {
            "code": 7000,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Unknown rule.": {
            "code": 7002,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Invalid line number ({0})": {
            "code": 7003,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Warn on expressions and declarations with an implied 'any' type.": {
            "code": 7004,
            "category": TypeScript.DiagnosticCategory.Message
        },
        "Variable '{0}' implicitly has an 'any' type.": {
            "code": 7005,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of '{1}' implicitly has an 'any' type.": {
            "code": 7006,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of function type implicitly has an 'any' type.": {
            "code": 7007,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Member '{0}' of object type implicitly has an 'any' type.": {
            "code": 7008,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.": {
            "code": 7009,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": 7010,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": 7011,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Parameter '{0}' of lambda function implicitly has an 'any' type.": {
            "code": 7012,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": 7013,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": 7014,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Array Literal implicitly has an 'any' type from widening.": {
            "code": 7015,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.": {
            "code": 7016,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Expected return type {0}; but computed return type {1}": {
            "code": 7023,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Expected object of type {0}; but got object of type {1}": {
            "code": 7024,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Projecting field '{0}' from a value of type {1} is not safe": {
            "code": 7025,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Projecting a field from a value of non-record type is not safe; got type '{0}'": {
            "code": 7026,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Dynamic field access from a non-any-typed object or with a non-any-typed key is not allowed; type of object is {0}; type of key is {1}": {
            "code": 7027,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: All arguments in a dynamically-typed call must have type 'any'; some argument here includes a type 'un'": {
            "code": 7028,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Function expected {0} arguments but is provided {1}": {
            "code": 7029,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Function expected an argument of type {0} but given an argument of type {1}": {
            "code": 7030,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Cannot apply a non-function of type {0}": {
            "code": 7031,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: typeof is not safe on an un-typed value": {
            "code": 7031,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: '{0}' is not in the current scope": {
            "code": 7032,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Variable '{0}' of type '{1}' cannot be assigned a value of type '{2}'": {
            "code": 7034,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Unsafe assignment; field '{0}' does not exists in a value of type {1}": {
            "code": 7035,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Assigning to a field '{0}' of a non-record value of type '{1}'": {
            "code": 7036,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: All three objects in a dynamic assignment form (o[f]=v) must have type any;got {0}, {1} and {2}": {
            "code": 7037,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Multiple declarations of the same variable name within the same scope are not allowed; '{0}' is declared more than once, shadowing a declaration at {1}": {
            "code": 7038,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Expected array element of type {0}; got {1}": {
            "code": 7039,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Unary operator expects an un-free argument; got {0}": {
            "code": 7040,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Binary operator expects both arguments to have type any; got {0} and {1}": {
            "code": 7041,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Conditional guard expects type any; got {0}": {
            "code": 7042,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: This branch was expected to have type {0}; got {1}": {
            "code": 7043,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: For-in loops are only permitted on any-typed objects; got {0}": {
            "code": 7044,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Invalid iteration variable in for-in loop; {0}": {
            "code": 7045,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Exception value must have type any; got {0}": {
            "code": 7046,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Switching on non-primitive values is not supported; got a value of type {0}": {
            "code": 7047,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Type of the switch case does not match the type of the guard; expected {0} got {1}": {
            "code": 7048,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Increment/decrement operators are only available on the number type; got {0}": {
            "code": 7049,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Invalid LHS for increment/decrement operator": {
            "code": 7050,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Missing a 'return' statement on some code paths": {
            "code": 7051,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Variables of type {0} must be initialized": {
            "code": 7052,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Invalid extends clause; {0}": {
            "code": 7053,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: 'new' expression expects a class-typed value as the target; got {0}": {
            "code": 7054,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: 'arguments' is a reserved name in JavaScript; use another name": {
            "code": 7055,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: 'this' is not in scope": {
            "code": 7056,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: 'super' is not in scope": {
            "code": 7057,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: member '{0}' may not be initialized": {
            "code": 7058,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Field '{0}' of type '{1}' cannot be assigned a value of type '{2}'": {
            "code": 7059,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Field '{0}' is immutable": {
            "code": 7060,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Implicit conversion from 'any' to '{0}' was applied": {
            "code": 7061,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Type of LHS ({0}) is not compatible with type of RHS ({1})": {
            "code": 7062,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Assignment with an operator expects both operands to have undotted type; got {0} and {1}": {
            "code": 7063,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: {0} is a reserved name": {
            "code": 7064,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Assignment with addition requires number or string; got {0}": {
            "code": 7065,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Inferred type '{0}' is incompatible with the soundly computed type '{1}'": {
            "code": 7065,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Interface '{0}' may be declared more than once": {
            "code": 7066,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Generic types are as yet unsupported; {0} is generic": {
            "code": 7067,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Does not yet support this feature: {0}": {
            "code": 7068,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Required argument '{0}:{1}' is missing": {
            "code": 7069,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Module name {0} was previously used for a non-module": {
            "code": 7070,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Module {0} was previously declared to include a {1} field (at location {2})": {
            "code": 7071,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Interface {0} was previously declared to include a {1} field": {
            "code": 7072,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Delete operator expects an 'any'-typed argument; got {0}": {
            "code": 7073,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Delete operator expects a member- or element-access expression": {
            "code": 7074,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Unexpected property assignment in an object literal: {0}": {
            "code": 7075,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Index map expected a key of type '{0}'; got '{1}'": {
            "code": 7076,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Interface declaration '{0}' has type '{1}' which is inconsistent with '{2}'": {
            "code": 7077,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Unexpected type arguments to a mono-type: {0} (Selected overload #{1} but given type arguments {2})": {
            "code": 7078,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Unexpected class element: {0}": {
            "code": 7079,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Index map expected an element of type '{0}'; got '{1}'": {
            "code": 7080,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Initializer may rely on uninitialized top-level variables (function invocation may not be safe for top-level initializers)": {
            "code": 7081,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Unsafe circular dependence on variable '{0}' defined at '{1}'": {
            "code": 7082,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Could not infer type arguments; defaulting to 'any'": {
            "code": 7083,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "Safe TS: Assignment to a '{0}' is not allowed; must be either an identifier, member access or element access expression": {
            "code": 7084,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Assignment to index of an immutable array of type '{0}' is not allowed": {
            "code": 7085,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Array index not a number; got {0}": {
            "code": 7086,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Implicit conversion from '{0}' to '{1}' was applied": {
            "code": 7087,
            "category": TypeScript.DiagnosticCategory.Warning
        },
        "SafeTS: noGetters command line flag but code uses a get accessor": {
            "code": 7088,
            "category": TypeScript.DiagnosticCategory.Error
        },
        "Safe TS: Instantiated type '{0}' is not a subtype of constraint on '{1}'": {
            "code": 7089,
            "category": TypeScript.DiagnosticCategory.Error
        }
    };
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CharacterCodes;
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 8232] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 8233] = "paragraphSeparator";
        CharacterCodes[CharacterCodes["nextLine"] = 133] = "nextLine";
        CharacterCodes[CharacterCodes["space"] = 32] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 160] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 8192] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 8193] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 8194] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 8195] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 8196] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 8197] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 8198] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 8199] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 8200] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 8201] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 8202] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 8203] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 8239] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 12288] = "ideographicSpace";
        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";
        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";
        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";
        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 65279] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(CharacterCodes = TypeScript.CharacterCodes || (TypeScript.CharacterCodes = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ScriptSnapshot;
    (function (ScriptSnapshot) {
        var StringScriptSnapshot = (function () {
            function StringScriptSnapshot(text) {
                this.text = text;
                this._lineStartPositions = null;
            }
            StringScriptSnapshot.prototype.getText = function (start, end) {
                return this.text.substring(start, end);
            };
            StringScriptSnapshot.prototype.getLength = function () {
                return this.text.length;
            };
            StringScriptSnapshot.prototype.getLineStartPositions = function () {
                if (!this._lineStartPositions) {
                    this._lineStartPositions = TypeScript.TextUtilities.parseLineStarts(new String(this.text));
                }
                return this._lineStartPositions;
            };
            StringScriptSnapshot.prototype.getTextChangeRangeSinceVersion = function (scriptVersion) {
                throw TypeScript.Errors.notYetImplemented();
            };
            return StringScriptSnapshot;
        }());
        function fromString(text) {
            return new StringScriptSnapshot(text);
        }
        ScriptSnapshot.fromString = fromString;
    })(ScriptSnapshot = TypeScript.ScriptSnapshot || (TypeScript.ScriptSnapshot = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var LineMap1;
    (function (LineMap1) {
        function fromSimpleText(text) {
            return new TypeScript.LineMap(function () { return TypeScript.TextUtilities.parseLineStarts({ charCodeAt: function (index) { return text.charCodeAt(index); }, length: text.length() }); }, text.length());
        }
        LineMap1.fromSimpleText = fromSimpleText;
        function fromScriptSnapshot(scriptSnapshot) {
            return new TypeScript.LineMap(function () { return scriptSnapshot.getLineStartPositions(); }, scriptSnapshot.getLength());
        }
        LineMap1.fromScriptSnapshot = fromScriptSnapshot;
        function fromString(text) {
            return new TypeScript.LineMap(function () { return TypeScript.TextUtilities.parseLineStarts(new String(text)); }, text.length);
        }
        LineMap1.fromString = fromString;
    })(LineMap1 = TypeScript.LineMap1 || (TypeScript.LineMap1 = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextFactory;
    (function (TextFactory) {
        function getStartAndLengthOfLineBreakEndingAt(text, index, info) {
            var c = text.charCodeAt(index);
            if (c === TypeScript.CharacterCodes.lineFeed) {
                if (index > 0 && text.charCodeAt(index - 1) === TypeScript.CharacterCodes.carriageReturn) {
                    info.startPosition = index - 1;
                    info.length = 2;
                }
                else {
                    info.startPosition = index;
                    info.length = 1;
                }
            }
            else if (TypeScript.TextUtilities.isAnyLineBreakCharacter(c)) {
                info.startPosition = index;
                info.length = 1;
            }
            else {
                info.startPosition = index + 1;
                info.length = 0;
            }
        }
        var LinebreakInfo = (function () {
            function LinebreakInfo(startPosition, length) {
                this.startPosition = startPosition;
                this.length = length;
            }
            return LinebreakInfo;
        }());
        var TextLine = (function () {
            function TextLine(text, body, lineBreakLength, lineNumber) {
                this._text = null;
                this._textSpan = null;
                if (text === null) {
                    throw TypeScript.Errors.argumentNull('text');
                }
                TypeScript.Debug.assert(lineBreakLength >= 0);
                TypeScript.Debug.assert(lineNumber >= 0);
                this._text = text;
                this._textSpan = body;
                this._lineBreakLength = lineBreakLength;
                this._lineNumber = lineNumber;
            }
            TextLine.prototype.start = function () {
                return this._textSpan.start();
            };
            TextLine.prototype.end = function () {
                return this._textSpan.end();
            };
            TextLine.prototype.endIncludingLineBreak = function () {
                return this.end() + this._lineBreakLength;
            };
            TextLine.prototype.extent = function () {
                return this._textSpan;
            };
            TextLine.prototype.extentIncludingLineBreak = function () {
                return TypeScript.TextSpan.fromBounds(this.start(), this.endIncludingLineBreak());
            };
            TextLine.prototype.toString = function () {
                return this._text.toString(this._textSpan);
            };
            TextLine.prototype.lineNumber = function () {
                return this._lineNumber;
            };
            return TextLine;
        }());
        var TextBase = (function () {
            function TextBase() {
                this.linebreakInfo = new LinebreakInfo(0, 0);
                this.lastLineFoundForPosition = null;
            }
            TextBase.prototype.length = function () {
                throw TypeScript.Errors.abstract();
            };
            TextBase.prototype.charCodeAt = function (position) {
                throw TypeScript.Errors.abstract();
            };
            TextBase.prototype.checkSubSpan = function (span) {
                if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("span");
                }
            };
            TextBase.prototype.toString = function (span) {
                if (span === void 0) { span = null; }
                throw TypeScript.Errors.abstract();
            };
            TextBase.prototype.subText = function (span) {
                this.checkSubSpan(span);
                return new SubText(this, span);
            };
            TextBase.prototype.substr = function (start, length, intern) {
                throw TypeScript.Errors.abstract();
            };
            TextBase.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                throw TypeScript.Errors.abstract();
            };
            TextBase.prototype.lineCount = function () {
                return this._lineStarts().length;
            };
            TextBase.prototype.lines = function () {
                var lines = [];
                var length = this.lineCount();
                for (var i = 0; i < length; ++i) {
                    lines[i] = this.getLineFromLineNumber(i);
                }
                return lines;
            };
            TextBase.prototype.lineMap = function () {
                var _this = this;
                return new TypeScript.LineMap(function () { return _this._lineStarts(); }, this.length());
            };
            TextBase.prototype._lineStarts = function () {
                throw TypeScript.Errors.abstract();
            };
            TextBase.prototype.getLineFromLineNumber = function (lineNumber) {
                var lineStarts = this._lineStarts();
                if (lineNumber < 0 || lineNumber >= lineStarts.length) {
                    throw TypeScript.Errors.argumentOutOfRange("lineNumber");
                }
                var first = lineStarts[lineNumber];
                if (lineNumber === lineStarts.length - 1) {
                    return new TextLine(this, new TypeScript.TextSpan(first, this.length() - first), 0, lineNumber);
                }
                else {
                    getStartAndLengthOfLineBreakEndingAt(this, lineStarts[lineNumber + 1] - 1, this.linebreakInfo);
                    return new TextLine(this, new TypeScript.TextSpan(first, this.linebreakInfo.startPosition - first), this.linebreakInfo.length, lineNumber);
                }
            };
            TextBase.prototype.getLineFromPosition = function (position) {
                var lastFound = this.lastLineFoundForPosition;
                if (lastFound !== null &&
                    lastFound.start() <= position &&
                    lastFound.endIncludingLineBreak() > position) {
                    return lastFound;
                }
                var lineNumber = this.getLineNumberFromPosition(position);
                var result = this.getLineFromLineNumber(lineNumber);
                this.lastLineFoundForPosition = result;
                return result;
            };
            TextBase.prototype.getLineNumberFromPosition = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }
                if (position === this.length()) {
                    return this.lineCount() - 1;
                }
                var lineNumber = TypeScript.ArrayUtilities.binarySearch(this._lineStarts(), position);
                if (lineNumber < 0) {
                    lineNumber = (~lineNumber) - 1;
                }
                return lineNumber;
            };
            TextBase.prototype.getLinePosition = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }
                var lineNumber = this.getLineNumberFromPosition(position);
                return new TypeScript.LineAndCharacter(lineNumber, position - this._lineStarts()[lineNumber]);
            };
            return TextBase;
        }());
        var SubText = (function (_super) {
            __extends(SubText, _super);
            function SubText(text, span) {
                var _this = _super.call(this) || this;
                _this._lazyLineStarts = null;
                if (text === null) {
                    throw TypeScript.Errors.argumentNull("text");
                }
                if (span.start() < 0 ||
                    span.start() >= text.length() ||
                    span.end() < 0 ||
                    span.end() > text.length()) {
                    throw TypeScript.Errors.argument("span");
                }
                _this.text = text;
                _this.span = span;
                return _this;
            }
            SubText.prototype.length = function () {
                return this.span.length();
            };
            SubText.prototype.charCodeAt = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }
                return this.text.charCodeAt(this.span.start() + position);
            };
            SubText.prototype.subText = function (span) {
                this.checkSubSpan(span);
                return new SubText(this.text, this.getCompositeSpan(span.start(), span.length()));
            };
            SubText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var span = this.getCompositeSpan(sourceIndex, count);
                this.text.copyTo(span.start(), destination, destinationIndex, span.length());
            };
            SubText.prototype.substr = function (start, length, intern) {
                var startInOriginalText = this.span.start() + start;
                return this.text.substr(startInOriginalText, length, intern);
            };
            SubText.prototype.getCompositeSpan = function (start, length) {
                var compositeStart = TypeScript.MathPrototype.min(this.text.length(), this.span.start() + start);
                var compositeEnd = TypeScript.MathPrototype.min(this.text.length(), compositeStart + length);
                return new TypeScript.TextSpan(compositeStart, compositeEnd - compositeStart);
            };
            SubText.prototype._lineStarts = function () {
                if (!this._lazyLineStarts) {
                    this._lazyLineStarts = TypeScript.TextUtilities.parseLineStarts({ charCodeAt: function (index) { return this.charCodeAt(index); }, length: this.length() });
                }
                return this._lazyLineStarts;
            };
            return SubText;
        }(TextBase));
        var StringText = (function (_super) {
            __extends(StringText, _super);
            function StringText(data) {
                var _this = _super.call(this) || this;
                _this.source = null;
                _this._lazyLineStarts = null;
                if (data === null) {
                    throw TypeScript.Errors.argumentNull("data");
                }
                _this.source = data;
                return _this;
            }
            StringText.prototype.length = function () {
                return this.source.length;
            };
            StringText.prototype.charCodeAt = function (position) {
                if (position < 0 || position >= this.source.length) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }
                return this.source.charCodeAt(position);
            };
            StringText.prototype.substr = function (start, length, intern) {
                return this.source.substr(start, length);
            };
            StringText.prototype.toString = function (span) {
                if (span === void 0) { span = null; }
                if (span === null) {
                    span = new TypeScript.TextSpan(0, this.length());
                }
                this.checkSubSpan(span);
                if (span.start() === 0 && span.length() === this.length()) {
                    return this.source;
                }
                return this.source.substr(span.start(), span.length());
            };
            StringText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                TypeScript.StringUtilities.copyTo(this.source, sourceIndex, destination, destinationIndex, count);
            };
            StringText.prototype._lineStarts = function () {
                if (this._lazyLineStarts === null) {
                    this._lazyLineStarts = TypeScript.TextUtilities.parseLineStarts(new String(this.source));
                }
                return this._lazyLineStarts;
            };
            return StringText;
        }(TextBase));
        function createText(value) {
            return new StringText(value);
        }
        TextFactory.createText = createText;
    })(TextFactory = TypeScript.TextFactory || (TypeScript.TextFactory = {}));
})(TypeScript || (TypeScript = {}));
(function (TypeScript) {
    var SimpleText;
    (function (SimpleText) {
        var SimpleSubText = (function () {
            function SimpleSubText(text, span) {
                this.text = null;
                this.span = null;
                if (text === null) {
                    throw TypeScript.Errors.argumentNull("text");
                }
                if (span.start() < 0 ||
                    span.start() >= text.length() ||
                    span.end() < 0 ||
                    span.end() > text.length()) {
                    throw TypeScript.Errors.argument("span");
                }
                this.text = text;
                this.span = span;
            }
            SimpleSubText.prototype.checkSubSpan = function (span) {
                if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("span");
                }
            };
            SimpleSubText.prototype.checkSubPosition = function (position) {
                if (position < 0 || position >= this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }
            };
            SimpleSubText.prototype.length = function () {
                return this.span.length();
            };
            SimpleSubText.prototype.subText = function (span) {
                this.checkSubSpan(span);
                return new SimpleSubText(this.text, this.getCompositeSpan(span.start(), span.length()));
            };
            SimpleSubText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var span = this.getCompositeSpan(sourceIndex, count);
                this.text.copyTo(span.start(), destination, destinationIndex, span.length());
            };
            SimpleSubText.prototype.substr = function (start, length, intern) {
                var span = this.getCompositeSpan(start, length);
                return this.text.substr(span.start(), span.length(), intern);
            };
            SimpleSubText.prototype.getCompositeSpan = function (start, length) {
                var compositeStart = TypeScript.MathPrototype.min(this.text.length(), this.span.start() + start);
                var compositeEnd = TypeScript.MathPrototype.min(this.text.length(), compositeStart + length);
                return new TypeScript.TextSpan(compositeStart, compositeEnd - compositeStart);
            };
            SimpleSubText.prototype.charCodeAt = function (index) {
                this.checkSubPosition(index);
                return this.text.charCodeAt(this.span.start() + index);
            };
            SimpleSubText.prototype.lineMap = function () {
                return TypeScript.LineMap1.fromSimpleText(this);
            };
            return SimpleSubText;
        }());
        var SimpleStringText = (function () {
            function SimpleStringText(value) {
                this.value = value;
                this._lineMap = null;
            }
            SimpleStringText.prototype.length = function () {
                return this.value.length;
            };
            SimpleStringText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                TypeScript.StringUtilities.copyTo(this.value, sourceIndex, destination, destinationIndex, count);
            };
            SimpleStringText.prototype.substr = function (start, length, intern) {
                if (intern) {
                    var array = length <= SimpleStringText.charArray.length
                        ? SimpleStringText.charArray
                        : TypeScript.ArrayUtilities.createArray(length, 0);
                    this.copyTo(start, array, 0, length);
                    return TypeScript.Collections.DefaultStringTable.addCharArray(array, 0, length);
                }
                return this.value.substr(start, length);
            };
            SimpleStringText.prototype.subText = function (span) {
                return new SimpleSubText(this, span);
            };
            SimpleStringText.prototype.charCodeAt = function (index) {
                return this.value.charCodeAt(index);
            };
            SimpleStringText.prototype.lineMap = function () {
                if (!this._lineMap) {
                    this._lineMap = TypeScript.LineMap1.fromString(this.value);
                }
                return this._lineMap;
            };
            SimpleStringText.charArray = TypeScript.ArrayUtilities.createArray(1024, 0);
            return SimpleStringText;
        }());
        var SimpleScriptSnapshotText = (function () {
            function SimpleScriptSnapshotText(scriptSnapshot) {
                this.scriptSnapshot = scriptSnapshot;
            }
            SimpleScriptSnapshotText.prototype.charCodeAt = function (index) {
                return this.scriptSnapshot.getText(index, index + 1).charCodeAt(0);
            };
            SimpleScriptSnapshotText.prototype.length = function () {
                return this.scriptSnapshot.getLength();
            };
            SimpleScriptSnapshotText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var text = this.scriptSnapshot.getText(sourceIndex, sourceIndex + count);
                TypeScript.StringUtilities.copyTo(text, 0, destination, destinationIndex, count);
            };
            SimpleScriptSnapshotText.prototype.substr = function (start, length, intern) {
                return this.scriptSnapshot.getText(start, start + length);
            };
            SimpleScriptSnapshotText.prototype.subText = function (span) {
                return new SimpleSubText(this, span);
            };
            SimpleScriptSnapshotText.prototype.lineMap = function () {
                var _this = this;
                return new TypeScript.LineMap(function () { return _this.scriptSnapshot.getLineStartPositions(); }, this.length());
            };
            return SimpleScriptSnapshotText;
        }());
        function fromString(value) {
            return new SimpleStringText(value);
        }
        SimpleText.fromString = fromString;
        function fromScriptSnapshot(scriptSnapshot) {
            return new SimpleScriptSnapshotText(scriptSnapshot);
        }
        SimpleText.fromScriptSnapshot = fromScriptSnapshot;
    })(SimpleText = TypeScript.SimpleText || (TypeScript.SimpleText = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextUtilities;
    (function (TextUtilities) {
        function parseLineStarts(text) {
            var length = text.length;
            if (0 === length) {
                var result = new Array();
                result.push(0);
                return result;
            }
            var position = 0;
            var index = 0;
            var arrayBuilder = new Array();
            var lineNumber = 0;
            while (index < length) {
                var c = text.charCodeAt(index);
                var lineBreakLength;
                if (c > TypeScript.CharacterCodes.carriageReturn && c <= 127) {
                    index++;
                    continue;
                }
                else if (c === TypeScript.CharacterCodes.carriageReturn && index + 1 < length && text.charCodeAt(index + 1) === TypeScript.CharacterCodes.lineFeed) {
                    lineBreakLength = 2;
                }
                else if (c === TypeScript.CharacterCodes.lineFeed) {
                    lineBreakLength = 1;
                }
                else {
                    lineBreakLength = TextUtilities.getLengthOfLineBreak(text, index);
                }
                if (0 === lineBreakLength) {
                    index++;
                }
                else {
                    arrayBuilder.push(position);
                    index += lineBreakLength;
                    position = index;
                    lineNumber++;
                }
            }
            arrayBuilder.push(position);
            return arrayBuilder;
        }
        TextUtilities.parseLineStarts = parseLineStarts;
        function getLengthOfLineBreakSlow(text, index, c) {
            if (c === TypeScript.CharacterCodes.carriageReturn) {
                var next = index + 1;
                return (next < text.length) && TypeScript.CharacterCodes.lineFeed === text.charCodeAt(next) ? 2 : 1;
            }
            else if (isAnyLineBreakCharacter(c)) {
                return 1;
            }
            else {
                return 0;
            }
        }
        TextUtilities.getLengthOfLineBreakSlow = getLengthOfLineBreakSlow;
        function getLengthOfLineBreak(text, index) {
            var c = text.charCodeAt(index);
            if (c > TypeScript.CharacterCodes.carriageReturn && c <= 127) {
                return 0;
            }
            return getLengthOfLineBreakSlow(text, index, c);
        }
        TextUtilities.getLengthOfLineBreak = getLengthOfLineBreak;
        function isAnyLineBreakCharacter(c) {
            return c === TypeScript.CharacterCodes.lineFeed ||
                c === TypeScript.CharacterCodes.carriageReturn ||
                c === TypeScript.CharacterCodes.nextLine ||
                c === TypeScript.CharacterCodes.lineSeparator ||
                c === TypeScript.CharacterCodes.paragraphSeparator;
        }
        TextUtilities.isAnyLineBreakCharacter = isAnyLineBreakCharacter;
    })(TextUtilities = TypeScript.TextUtilities || (TypeScript.TextUtilities = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextSpan = (function () {
        function TextSpan(start, length) {
            if (start < 0) {
                TypeScript.Errors.argument("start");
            }
            if (length < 0) {
                TypeScript.Errors.argument("length");
            }
            this._start = start;
            this._length = length;
        }
        TextSpan.prototype.start = function () {
            return this._start;
        };
        TextSpan.prototype.length = function () {
            return this._length;
        };
        TextSpan.prototype.end = function () {
            return this._start + this._length;
        };
        TextSpan.prototype.isEmpty = function () {
            return this._length === 0;
        };
        TextSpan.prototype.containsPosition = function (position) {
            return position >= this._start && position < this.end();
        };
        TextSpan.prototype.containsTextSpan = function (span) {
            return span._start >= this._start && span.end() <= this.end();
        };
        TextSpan.prototype.overlapsWith = function (span) {
            var overlapStart = TypeScript.MathPrototype.max(this._start, span._start);
            var overlapEnd = TypeScript.MathPrototype.min(this.end(), span.end());
            return overlapStart < overlapEnd;
        };
        TextSpan.prototype.overlap = function (span) {
            var overlapStart = TypeScript.MathPrototype.max(this._start, span._start);
            var overlapEnd = TypeScript.MathPrototype.min(this.end(), span.end());
            if (overlapStart < overlapEnd) {
                return TextSpan.fromBounds(overlapStart, overlapEnd);
            }
            return null;
        };
        TextSpan.prototype.intersectsWithTextSpan = function (span) {
            return span._start <= this.end() && span.end() >= this._start;
        };
        TextSpan.prototype.intersectsWith = function (start, length) {
            var end = start + length;
            return start <= this.end() && end >= this._start;
        };
        TextSpan.prototype.intersectsWithPosition = function (position) {
            return position <= this.end() && position >= this._start;
        };
        TextSpan.prototype.intersection = function (span) {
            var intersectStart = TypeScript.MathPrototype.max(this._start, span._start);
            var intersectEnd = TypeScript.MathPrototype.min(this.end(), span.end());
            if (intersectStart <= intersectEnd) {
                return TextSpan.fromBounds(intersectStart, intersectEnd);
            }
            return null;
        };
        TextSpan.fromBounds = function (start, end) {
            TypeScript.Debug.assert(start >= 0);
            TypeScript.Debug.assert(end - start >= 0);
            return new TextSpan(start, end - start);
        };
        return TextSpan;
    }());
    TypeScript.TextSpan = TextSpan;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextChangeRange = (function () {
        function TextChangeRange(span, newLength) {
            if (newLength < 0) {
                throw TypeScript.Errors.argumentOutOfRange("newLength");
            }
            this._span = span;
            this._newLength = newLength;
        }
        TextChangeRange.prototype.span = function () {
            return this._span;
        };
        TextChangeRange.prototype.newLength = function () {
            return this._newLength;
        };
        TextChangeRange.prototype.newSpan = function () {
            return new TypeScript.TextSpan(this.span().start(), this.newLength());
        };
        TextChangeRange.prototype.isUnchanged = function () {
            return this.span().isEmpty() && this.newLength() === 0;
        };
        TextChangeRange.collapseChangesFromSingleVersion = function (changes) {
            var diff = 0;
            var start = TypeScript.Constants.Max31BitInteger;
            var end = 0;
            for (var i = 0; i < changes.length; i++) {
                var change = changes[i];
                diff += change.newLength() - change.span().length();
                if (change.span().start() < start) {
                    start = change.span().start();
                }
                if (change.span().end() > end) {
                    end = change.span().end();
                }
            }
            if (start > end) {
                return null;
            }
            var combined = TypeScript.TextSpan.fromBounds(start, end);
            var newLen = combined.length() + diff;
            return new TextChangeRange(combined, newLen);
        };
        TextChangeRange.collapseChangesAcrossMultipleVersions = function (changes) {
            if (changes.length === 0) {
                return TextChangeRange.unchanged;
            }
            if (changes.length === 1) {
                return changes[0];
            }
            var change0 = changes[0];
            var oldStartN = change0.span().start();
            var oldEndN = change0.span().end();
            var newEndN = oldStartN + change0.newLength();
            for (var i = 1; i < changes.length; i++) {
                var nextChange = changes[i];
                var oldStart1 = oldStartN;
                var oldEnd1 = oldEndN;
                var newEnd1 = newEndN;
                var oldStart2 = nextChange.span().start();
                var oldEnd2 = nextChange.span().end();
                var newEnd2 = oldStart2 + nextChange.newLength();
                oldStartN = TypeScript.MathPrototype.min(oldStart1, oldStart2);
                oldEndN = TypeScript.MathPrototype.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));
                newEndN = TypeScript.MathPrototype.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));
            }
            return new TextChangeRange(TypeScript.TextSpan.fromBounds(oldStartN, oldEndN), newEndN - oldStartN);
        };
        TextChangeRange.unchanged = new TextChangeRange(new TypeScript.TextSpan(0, 0), 0);
        return TextChangeRange;
    }());
    TypeScript.TextChangeRange = TextChangeRange;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CharacterInfo = (function () {
        function CharacterInfo() {
        }
        CharacterInfo.isDecimalDigit = function (c) {
            return c >= TypeScript.CharacterCodes._0 && c <= TypeScript.CharacterCodes._9;
        };
        CharacterInfo.isOctalDigit = function (c) {
            return c >= TypeScript.CharacterCodes._0 && c <= TypeScript.CharacterCodes._7;
        };
        CharacterInfo.isHexDigit = function (c) {
            return CharacterInfo.isDecimalDigit(c) ||
                (c >= TypeScript.CharacterCodes.A && c <= TypeScript.CharacterCodes.F) ||
                (c >= TypeScript.CharacterCodes.a && c <= TypeScript.CharacterCodes.f);
        };
        CharacterInfo.hexValue = function (c) {
            return CharacterInfo.isDecimalDigit(c)
                ? (c - TypeScript.CharacterCodes._0)
                : (c >= TypeScript.CharacterCodes.A && c <= TypeScript.CharacterCodes.F)
                    ? c - TypeScript.CharacterCodes.A + 10
                    : c - TypeScript.CharacterCodes.a + 10;
        };
        CharacterInfo.isWhitespace = function (ch) {
            switch (ch) {
                case TypeScript.CharacterCodes.space:
                case TypeScript.CharacterCodes.nonBreakingSpace:
                case TypeScript.CharacterCodes.enQuad:
                case TypeScript.CharacterCodes.emQuad:
                case TypeScript.CharacterCodes.enSpace:
                case TypeScript.CharacterCodes.emSpace:
                case TypeScript.CharacterCodes.threePerEmSpace:
                case TypeScript.CharacterCodes.fourPerEmSpace:
                case TypeScript.CharacterCodes.sixPerEmSpace:
                case TypeScript.CharacterCodes.figureSpace:
                case TypeScript.CharacterCodes.punctuationSpace:
                case TypeScript.CharacterCodes.thinSpace:
                case TypeScript.CharacterCodes.hairSpace:
                case TypeScript.CharacterCodes.zeroWidthSpace:
                case TypeScript.CharacterCodes.narrowNoBreakSpace:
                case TypeScript.CharacterCodes.ideographicSpace:
                case TypeScript.CharacterCodes.tab:
                case TypeScript.CharacterCodes.verticalTab:
                case TypeScript.CharacterCodes.formFeed:
                case TypeScript.CharacterCodes.byteOrderMark:
                    return true;
            }
            return false;
        };
        CharacterInfo.isLineTerminator = function (ch) {
            switch (ch) {
                case TypeScript.CharacterCodes.carriageReturn:
                case TypeScript.CharacterCodes.lineFeed:
                case TypeScript.CharacterCodes.paragraphSeparator:
                case TypeScript.CharacterCodes.lineSeparator:
                    return true;
            }
            return false;
        };
        return CharacterInfo;
    }());
    TypeScript.CharacterInfo = CharacterInfo;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxConstants;
    (function (SyntaxConstants) {
        SyntaxConstants[SyntaxConstants["TriviaNewLineMask"] = 1] = "TriviaNewLineMask";
        SyntaxConstants[SyntaxConstants["TriviaCommentMask"] = 2] = "TriviaCommentMask";
        SyntaxConstants[SyntaxConstants["TriviaFullWidthShift"] = 2] = "TriviaFullWidthShift";
        SyntaxConstants[SyntaxConstants["NodeDataComputed"] = 1] = "NodeDataComputed";
        SyntaxConstants[SyntaxConstants["NodeIncrementallyUnusableMask"] = 2] = "NodeIncrementallyUnusableMask";
        SyntaxConstants[SyntaxConstants["NodeParsedInStrictModeMask"] = 4] = "NodeParsedInStrictModeMask";
        SyntaxConstants[SyntaxConstants["NodeFullWidthShift"] = 3] = "NodeFullWidthShift";
        SyntaxConstants[SyntaxConstants["IsVariableWidthKeyword"] = -2147483648] = "IsVariableWidthKeyword";
    })(SyntaxConstants = TypeScript.SyntaxConstants || (TypeScript.SyntaxConstants = {}));
})(TypeScript || (TypeScript = {}));
var FormattingOptions = (function () {
    function FormattingOptions(useTabs, spacesPerTab, indentSpaces, newLineCharacter) {
        this.useTabs = useTabs;
        this.spacesPerTab = spacesPerTab;
        this.indentSpaces = indentSpaces;
        this.newLineCharacter = newLineCharacter;
    }
    FormattingOptions.defaultOptions = new FormattingOptions(false, 4, 4, "\r\n");
    return FormattingOptions;
}());
var TypeScript;
(function (TypeScript) {
    var Indentation;
    (function (Indentation) {
        function columnForEndOfToken(token, syntaxInformationMap, options) {
            return columnForStartOfToken(token, syntaxInformationMap, options) + token.width();
        }
        Indentation.columnForEndOfToken = columnForEndOfToken;
        function columnForStartOfToken(token, syntaxInformationMap, options) {
            var firstTokenInLine = syntaxInformationMap.firstTokenInLineContainingToken(token);
            var leadingTextInReverse = [];
            var current = token;
            while (current !== firstTokenInLine) {
                current = syntaxInformationMap.previousToken(current);
                if (current === firstTokenInLine) {
                    leadingTextInReverse.push(current.trailingTrivia().fullText());
                    leadingTextInReverse.push(current.text());
                }
                else {
                    leadingTextInReverse.push(current.fullText());
                }
            }
            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);
            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfToken = columnForStartOfToken;
        function columnForStartOfFirstTokenInLineContainingToken(token, syntaxInformationMap, options) {
            var firstTokenInLine = syntaxInformationMap.firstTokenInLineContainingToken(token);
            var leadingTextInReverse = [];
            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);
            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfFirstTokenInLineContainingToken = columnForStartOfFirstTokenInLineContainingToken;
        function collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse) {
            var leadingTrivia = firstTokenInLine.leadingTrivia();
            for (var i = leadingTrivia.count() - 1; i >= 0; i--) {
                var trivia = leadingTrivia.syntaxTriviaAt(i);
                if (trivia.kind() === TypeScript.SyntaxKind.NewLineTrivia) {
                    break;
                }
                if (trivia.kind() === TypeScript.SyntaxKind.MultiLineCommentTrivia) {
                    var lineSegments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
                    leadingTextInReverse.push(TypeScript.ArrayUtilities.last(lineSegments));
                    if (lineSegments.length > 0) {
                        break;
                    }
                }
                leadingTextInReverse.push(trivia.fullText());
            }
        }
        function columnForLeadingTextInReverse(leadingTextInReverse, options) {
            var column = 0;
            for (var i = leadingTextInReverse.length - 1; i >= 0; i--) {
                var text = leadingTextInReverse[i];
                column = columnForPositionInStringWorker(text, text.length, column, options);
            }
            return column;
        }
        function columnForPositionInString(input, position, options) {
            return columnForPositionInStringWorker(input, position, 0, options);
        }
        Indentation.columnForPositionInString = columnForPositionInString;
        function columnForPositionInStringWorker(input, position, startColumn, options) {
            var column = startColumn;
            var spacesPerTab = options.spacesPerTab;
            for (var j = 0; j < position; j++) {
                var ch = input.charCodeAt(j);
                if (ch === TypeScript.CharacterCodes.tab) {
                    column += spacesPerTab - column % spacesPerTab;
                }
                else {
                    column++;
                }
            }
            return column;
        }
        function indentationString(column, options) {
            var numberOfTabs = 0;
            var numberOfSpaces = TypeScript.MathPrototype.max(0, column);
            if (options.useTabs) {
                numberOfTabs = Math.floor(column / options.spacesPerTab);
                numberOfSpaces -= numberOfTabs * options.spacesPerTab;
            }
            return TypeScript.StringUtilities.repeat('\t', numberOfTabs) +
                TypeScript.StringUtilities.repeat(' ', numberOfSpaces);
        }
        Indentation.indentationString = indentationString;
        function indentationTrivia(column, options) {
            return TypeScript.Syntax.whitespace(indentationString(column, options));
        }
        Indentation.indentationTrivia = indentationTrivia;
        function firstNonWhitespacePosition(value) {
            for (var i = 0; i < value.length; i++) {
                var ch = value.charCodeAt(i);
                if (!TypeScript.CharacterInfo.isWhitespace(ch)) {
                    return i;
                }
            }
            return value.length;
        }
        Indentation.firstNonWhitespacePosition = firstNonWhitespacePosition;
    })(Indentation = TypeScript.Indentation || (TypeScript.Indentation = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var LanguageVersion;
    (function (LanguageVersion) {
        LanguageVersion[LanguageVersion["EcmaScript3"] = 0] = "EcmaScript3";
        LanguageVersion[LanguageVersion["EcmaScript5"] = 1] = "EcmaScript5";
    })(LanguageVersion = TypeScript.LanguageVersion || (TypeScript.LanguageVersion = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ParseOptions = (function () {
        function ParseOptions(languageVersion, allowAutomaticSemicolonInsertion) {
            this._languageVersion = languageVersion;
            this._allowAutomaticSemicolonInsertion = allowAutomaticSemicolonInsertion;
        }
        ParseOptions.prototype.toJSON = function (key) {
            return { allowAutomaticSemicolonInsertion: this._allowAutomaticSemicolonInsertion };
        };
        ParseOptions.prototype.languageVersion = function () {
            return this._languageVersion;
        };
        ParseOptions.prototype.allowAutomaticSemicolonInsertion = function () {
            return this._allowAutomaticSemicolonInsertion;
        };
        return ParseOptions;
    }());
    TypeScript.ParseOptions = ParseOptions;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PositionedElement = (function () {
        function PositionedElement(parent, element, fullStart) {
            this._parent = parent;
            this._element = element;
            this._fullStart = fullStart;
        }
        PositionedElement.create = function (parent, element, fullStart) {
            if (element === null) {
                return null;
            }
            if (element.isNode()) {
                return new PositionedNode(parent, element, fullStart);
            }
            else if (element.isToken()) {
                return new PositionedToken(parent, element, fullStart);
            }
            else if (element.isList()) {
                return new PositionedList(parent, element, fullStart);
            }
            else if (element.isSeparatedList()) {
                return new PositionedSeparatedList(parent, element, fullStart);
            }
            else {
                throw TypeScript.Errors.invalidOperation();
            }
        };
        PositionedElement.prototype.parent = function () {
            return this._parent;
        };
        PositionedElement.prototype.parentElement = function () {
            return this._parent && this._parent._element;
        };
        PositionedElement.prototype.element = function () {
            return this._element;
        };
        PositionedElement.prototype.kind = function () {
            return this.element().kind();
        };
        PositionedElement.prototype.childIndex = function (child) {
            return TypeScript.Syntax.childIndex(this.element(), child);
        };
        PositionedElement.prototype.childCount = function () {
            return this.element().childCount();
        };
        PositionedElement.prototype.childAt = function (index) {
            var offset = TypeScript.Syntax.childOffsetAt(this.element(), index);
            return PositionedElement.create(this, this.element().childAt(index), this.fullStart() + offset);
        };
        PositionedElement.prototype.childStart = function (child) {
            var offset = TypeScript.Syntax.childOffset(this.element(), child);
            return this.fullStart() + offset + child.leadingTriviaWidth();
        };
        PositionedElement.prototype.childEnd = function (child) {
            var offset = TypeScript.Syntax.childOffset(this.element(), child);
            return this.fullStart() + offset + child.leadingTriviaWidth() + child.width();
        };
        PositionedElement.prototype.childStartAt = function (index) {
            var offset = TypeScript.Syntax.childOffsetAt(this.element(), index);
            var child = this.element().childAt(index);
            return this.fullStart() + offset + child.leadingTriviaWidth();
        };
        PositionedElement.prototype.childEndAt = function (index) {
            var offset = TypeScript.Syntax.childOffsetAt(this.element(), index);
            var child = this.element().childAt(index);
            return this.fullStart() + offset + child.leadingTriviaWidth() + child.width();
        };
        PositionedElement.prototype.getPositionedChild = function (child) {
            var offset = TypeScript.Syntax.childOffset(this.element(), child);
            return PositionedElement.create(this, child, this.fullStart() + offset);
        };
        PositionedElement.prototype.fullStart = function () {
            return this._fullStart;
        };
        PositionedElement.prototype.fullEnd = function () {
            return this.fullStart() + this.element().fullWidth();
        };
        PositionedElement.prototype.fullWidth = function () {
            return this.element().fullWidth();
        };
        PositionedElement.prototype.start = function () {
            return this.fullStart() + this.element().leadingTriviaWidth();
        };
        PositionedElement.prototype.end = function () {
            return this.fullStart() + this.element().leadingTriviaWidth() + this.element().width();
        };
        PositionedElement.prototype.root = function () {
            var current = this;
            while (current.parent() !== null) {
                current = current.parent();
            }
            return current;
        };
        PositionedElement.prototype.containingNode = function () {
            var current = this.parent();
            while (current !== null && !current.element().isNode()) {
                current = current.parent();
            }
            return current;
        };
        return PositionedElement;
    }());
    TypeScript.PositionedElement = PositionedElement;
    var PositionedNodeOrToken = (function (_super) {
        __extends(PositionedNodeOrToken, _super);
        function PositionedNodeOrToken(parent, nodeOrToken, fullStart) {
            return _super.call(this, parent, nodeOrToken, fullStart) || this;
        }
        PositionedNodeOrToken.prototype.nodeOrToken = function () {
            return this.element();
        };
        return PositionedNodeOrToken;
    }(PositionedElement));
    TypeScript.PositionedNodeOrToken = PositionedNodeOrToken;
    var PositionedNode = (function (_super) {
        __extends(PositionedNode, _super);
        function PositionedNode(parent, node, fullStart) {
            return _super.call(this, parent, node, fullStart) || this;
        }
        PositionedNode.prototype.node = function () {
            return this.element();
        };
        return PositionedNode;
    }(PositionedNodeOrToken));
    TypeScript.PositionedNode = PositionedNode;
    var PositionedToken = (function (_super) {
        __extends(PositionedToken, _super);
        function PositionedToken(parent, token, fullStart) {
            return _super.call(this, parent, token, fullStart) || this;
        }
        PositionedToken.prototype.token = function () {
            return this.element();
        };
        PositionedToken.prototype.previousToken = function (includeSkippedTokens) {
            if (includeSkippedTokens === void 0) { includeSkippedTokens = false; }
            var triviaList = this.token().leadingTrivia();
            if (includeSkippedTokens && triviaList && triviaList.hasSkippedToken()) {
                var currentTriviaEndPosition = this.start();
                for (var i = triviaList.count() - 1; i >= 0; i--) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isSkippedToken()) {
                        return new PositionedSkippedToken(this, trivia.skippedToken(), currentTriviaEndPosition - trivia.fullWidth());
                    }
                    currentTriviaEndPosition -= trivia.fullWidth();
                }
            }
            var start = this.fullStart();
            if (start === 0) {
                return null;
            }
            return this.root().node().findToken(start - 1, includeSkippedTokens);
        };
        PositionedToken.prototype.nextToken = function (includeSkippedTokens) {
            if (includeSkippedTokens === void 0) { includeSkippedTokens = false; }
            if (this.token().tokenKind === TypeScript.SyntaxKind.EndOfFileToken) {
                return null;
            }
            var triviaList = this.token().trailingTrivia();
            if (includeSkippedTokens && triviaList && triviaList.hasSkippedToken()) {
                var fullStart = this.end();
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isSkippedToken()) {
                        return new PositionedSkippedToken(this, trivia.skippedToken(), fullStart);
                    }
                    fullStart += trivia.fullWidth();
                }
            }
            return this.root().node().findToken(this.fullEnd(), includeSkippedTokens);
        };
        return PositionedToken;
    }(PositionedNodeOrToken));
    TypeScript.PositionedToken = PositionedToken;
    var PositionedList = (function (_super) {
        __extends(PositionedList, _super);
        function PositionedList(parent, list, fullStart) {
            return _super.call(this, parent, list, fullStart) || this;
        }
        PositionedList.prototype.list = function () {
            return this.element();
        };
        return PositionedList;
    }(PositionedElement));
    TypeScript.PositionedList = PositionedList;
    var PositionedSeparatedList = (function (_super) {
        __extends(PositionedSeparatedList, _super);
        function PositionedSeparatedList(parent, list, fullStart) {
            return _super.call(this, parent, list, fullStart) || this;
        }
        PositionedSeparatedList.prototype.list = function () {
            return this.element();
        };
        return PositionedSeparatedList;
    }(PositionedElement));
    TypeScript.PositionedSeparatedList = PositionedSeparatedList;
    var PositionedSkippedToken = (function (_super) {
        __extends(PositionedSkippedToken, _super);
        function PositionedSkippedToken(parentToken, token, fullStart) {
            var _this = _super.call(this, parentToken.parent(), token, fullStart) || this;
            _this._parentToken = parentToken;
            return _this;
        }
        PositionedSkippedToken.prototype.parentToken = function () {
            return this._parentToken;
        };
        PositionedSkippedToken.prototype.previousToken = function (includeSkippedTokens) {
            if (includeSkippedTokens === void 0) { includeSkippedTokens = false; }
            var start = this.fullStart();
            if (includeSkippedTokens) {
                var previousToken;
                if (start >= this.parentToken().end()) {
                    previousToken = TypeScript.Syntax.findSkippedTokenInTrailingTriviaList(this.parentToken(), start - 1);
                    if (previousToken) {
                        return previousToken;
                    }
                    return this.parentToken();
                }
                else {
                    previousToken = TypeScript.Syntax.findSkippedTokenInLeadingTriviaList(this.parentToken(), start - 1);
                    if (previousToken) {
                        return previousToken;
                    }
                }
            }
            var start = this.parentToken().fullStart();
            if (start === 0) {
                return null;
            }
            return this.root().node().findToken(start - 1, includeSkippedTokens);
        };
        PositionedSkippedToken.prototype.nextToken = function (includeSkippedTokens) {
            if (includeSkippedTokens === void 0) { includeSkippedTokens = false; }
            if (this.token().tokenKind === TypeScript.SyntaxKind.EndOfFileToken) {
                return null;
            }
            if (includeSkippedTokens) {
                var end = this.end();
                var nextToken;
                if (end <= this.parentToken().start()) {
                    nextToken = TypeScript.Syntax.findSkippedTokenInLeadingTriviaList(this.parentToken(), end);
                    if (nextToken) {
                        return nextToken;
                    }
                    return this.parentToken();
                }
                else {
                    nextToken = TypeScript.Syntax.findSkippedTokenInTrailingTriviaList(this.parentToken(), end);
                    if (nextToken) {
                        return nextToken;
                    }
                }
            }
            return this.root().node().findToken(this.parentToken().fullEnd(), includeSkippedTokens);
        };
        return PositionedSkippedToken;
    }(PositionedToken));
    TypeScript.PositionedSkippedToken = PositionedSkippedToken;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxKind;
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["None"] = 0] = "None";
        SyntaxKind[SyntaxKind["List"] = 1] = "List";
        SyntaxKind[SyntaxKind["SeparatedList"] = 2] = "SeparatedList";
        SyntaxKind[SyntaxKind["TriviaList"] = 3] = "TriviaList";
        SyntaxKind[SyntaxKind["WhitespaceTrivia"] = 4] = "WhitespaceTrivia";
        SyntaxKind[SyntaxKind["NewLineTrivia"] = 5] = "NewLineTrivia";
        SyntaxKind[SyntaxKind["MultiLineCommentTrivia"] = 6] = "MultiLineCommentTrivia";
        SyntaxKind[SyntaxKind["SingleLineCommentTrivia"] = 7] = "SingleLineCommentTrivia";
        SyntaxKind[SyntaxKind["SkippedTokenTrivia"] = 8] = "SkippedTokenTrivia";
        SyntaxKind[SyntaxKind["ErrorToken"] = 9] = "ErrorToken";
        SyntaxKind[SyntaxKind["EndOfFileToken"] = 10] = "EndOfFileToken";
        SyntaxKind[SyntaxKind["IdentifierName"] = 11] = "IdentifierName";
        SyntaxKind[SyntaxKind["RegularExpressionLiteral"] = 12] = "RegularExpressionLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 13] = "NumericLiteral";
        SyntaxKind[SyntaxKind["StringLiteral"] = 14] = "StringLiteral";
        SyntaxKind[SyntaxKind["BreakKeyword"] = 15] = "BreakKeyword";
        SyntaxKind[SyntaxKind["CaseKeyword"] = 16] = "CaseKeyword";
        SyntaxKind[SyntaxKind["CatchKeyword"] = 17] = "CatchKeyword";
        SyntaxKind[SyntaxKind["ContinueKeyword"] = 18] = "ContinueKeyword";
        SyntaxKind[SyntaxKind["DebuggerKeyword"] = 19] = "DebuggerKeyword";
        SyntaxKind[SyntaxKind["DefaultKeyword"] = 20] = "DefaultKeyword";
        SyntaxKind[SyntaxKind["DeleteKeyword"] = 21] = "DeleteKeyword";
        SyntaxKind[SyntaxKind["DoKeyword"] = 22] = "DoKeyword";
        SyntaxKind[SyntaxKind["ElseKeyword"] = 23] = "ElseKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 24] = "FalseKeyword";
        SyntaxKind[SyntaxKind["FinallyKeyword"] = 25] = "FinallyKeyword";
        SyntaxKind[SyntaxKind["ForKeyword"] = 26] = "ForKeyword";
        SyntaxKind[SyntaxKind["FunctionKeyword"] = 27] = "FunctionKeyword";
        SyntaxKind[SyntaxKind["IfKeyword"] = 28] = "IfKeyword";
        SyntaxKind[SyntaxKind["InKeyword"] = 29] = "InKeyword";
        SyntaxKind[SyntaxKind["InstanceOfKeyword"] = 30] = "InstanceOfKeyword";
        SyntaxKind[SyntaxKind["NewKeyword"] = 31] = "NewKeyword";
        SyntaxKind[SyntaxKind["NullKeyword"] = 32] = "NullKeyword";
        SyntaxKind[SyntaxKind["ReturnKeyword"] = 33] = "ReturnKeyword";
        SyntaxKind[SyntaxKind["SwitchKeyword"] = 34] = "SwitchKeyword";
        SyntaxKind[SyntaxKind["ThisKeyword"] = 35] = "ThisKeyword";
        SyntaxKind[SyntaxKind["ThrowKeyword"] = 36] = "ThrowKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 37] = "TrueKeyword";
        SyntaxKind[SyntaxKind["TryKeyword"] = 38] = "TryKeyword";
        SyntaxKind[SyntaxKind["TypeOfKeyword"] = 39] = "TypeOfKeyword";
        SyntaxKind[SyntaxKind["VarKeyword"] = 40] = "VarKeyword";
        SyntaxKind[SyntaxKind["VoidKeyword"] = 41] = "VoidKeyword";
        SyntaxKind[SyntaxKind["WhileKeyword"] = 42] = "WhileKeyword";
        SyntaxKind[SyntaxKind["WithKeyword"] = 43] = "WithKeyword";
        SyntaxKind[SyntaxKind["ClassKeyword"] = 44] = "ClassKeyword";
        SyntaxKind[SyntaxKind["ConstKeyword"] = 45] = "ConstKeyword";
        SyntaxKind[SyntaxKind["EnumKeyword"] = 46] = "EnumKeyword";
        SyntaxKind[SyntaxKind["ExportKeyword"] = 47] = "ExportKeyword";
        SyntaxKind[SyntaxKind["ExtendsKeyword"] = 48] = "ExtendsKeyword";
        SyntaxKind[SyntaxKind["ImportKeyword"] = 49] = "ImportKeyword";
        SyntaxKind[SyntaxKind["SuperKeyword"] = 50] = "SuperKeyword";
        SyntaxKind[SyntaxKind["ImplementsKeyword"] = 51] = "ImplementsKeyword";
        SyntaxKind[SyntaxKind["InterfaceKeyword"] = 52] = "InterfaceKeyword";
        SyntaxKind[SyntaxKind["LetKeyword"] = 53] = "LetKeyword";
        SyntaxKind[SyntaxKind["PackageKeyword"] = 54] = "PackageKeyword";
        SyntaxKind[SyntaxKind["PrivateKeyword"] = 55] = "PrivateKeyword";
        SyntaxKind[SyntaxKind["ProtectedKeyword"] = 56] = "ProtectedKeyword";
        SyntaxKind[SyntaxKind["PublicKeyword"] = 57] = "PublicKeyword";
        SyntaxKind[SyntaxKind["StaticKeyword"] = 58] = "StaticKeyword";
        SyntaxKind[SyntaxKind["YieldKeyword"] = 59] = "YieldKeyword";
        SyntaxKind[SyntaxKind["AnyKeyword"] = 60] = "AnyKeyword";
        SyntaxKind[SyntaxKind["BooleanKeyword"] = 61] = "BooleanKeyword";
        SyntaxKind[SyntaxKind["ConstructorKeyword"] = 62] = "ConstructorKeyword";
        SyntaxKind[SyntaxKind["DeclareKeyword"] = 63] = "DeclareKeyword";
        SyntaxKind[SyntaxKind["GetKeyword"] = 64] = "GetKeyword";
        SyntaxKind[SyntaxKind["ModuleKeyword"] = 65] = "ModuleKeyword";
        SyntaxKind[SyntaxKind["RequireKeyword"] = 66] = "RequireKeyword";
        SyntaxKind[SyntaxKind["NumberKeyword"] = 67] = "NumberKeyword";
        SyntaxKind[SyntaxKind["SetKeyword"] = 68] = "SetKeyword";
        SyntaxKind[SyntaxKind["StringKeyword"] = 69] = "StringKeyword";
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 70] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 71] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenParenToken"] = 72] = "OpenParenToken";
        SyntaxKind[SyntaxKind["CloseParenToken"] = 73] = "CloseParenToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 74] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 75] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["DotToken"] = 76] = "DotToken";
        SyntaxKind[SyntaxKind["DotDotDotToken"] = 77] = "DotDotDotToken";
        SyntaxKind[SyntaxKind["SemicolonToken"] = 78] = "SemicolonToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 79] = "CommaToken";
        SyntaxKind[SyntaxKind["LessThanToken"] = 80] = "LessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanToken"] = 81] = "GreaterThanToken";
        SyntaxKind[SyntaxKind["LessThanEqualsToken"] = 82] = "LessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanEqualsToken"] = 83] = "GreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsToken"] = 84] = "EqualsEqualsToken";
        SyntaxKind[SyntaxKind["EqualsGreaterThanToken"] = 85] = "EqualsGreaterThanToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsToken"] = 86] = "ExclamationEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsEqualsToken"] = 87] = "EqualsEqualsEqualsToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsEqualsToken"] = 88] = "ExclamationEqualsEqualsToken";
        SyntaxKind[SyntaxKind["PlusToken"] = 89] = "PlusToken";
        SyntaxKind[SyntaxKind["MinusToken"] = 90] = "MinusToken";
        SyntaxKind[SyntaxKind["AsteriskToken"] = 91] = "AsteriskToken";
        SyntaxKind[SyntaxKind["PercentToken"] = 92] = "PercentToken";
        SyntaxKind[SyntaxKind["PlusPlusToken"] = 93] = "PlusPlusToken";
        SyntaxKind[SyntaxKind["MinusMinusToken"] = 94] = "MinusMinusToken";
        SyntaxKind[SyntaxKind["LessThanLessThanToken"] = 95] = "LessThanLessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanToken"] = 96] = "GreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanToken"] = 97] = "GreaterThanGreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["AmpersandToken"] = 98] = "AmpersandToken";
        SyntaxKind[SyntaxKind["BarToken"] = 99] = "BarToken";
        SyntaxKind[SyntaxKind["CaretToken"] = 100] = "CaretToken";
        SyntaxKind[SyntaxKind["ExclamationToken"] = 101] = "ExclamationToken";
        SyntaxKind[SyntaxKind["TildeToken"] = 102] = "TildeToken";
        SyntaxKind[SyntaxKind["AmpersandAmpersandToken"] = 103] = "AmpersandAmpersandToken";
        SyntaxKind[SyntaxKind["BarBarToken"] = 104] = "BarBarToken";
        SyntaxKind[SyntaxKind["QuestionToken"] = 105] = "QuestionToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 106] = "ColonToken";
        SyntaxKind[SyntaxKind["EqualsToken"] = 107] = "EqualsToken";
        SyntaxKind[SyntaxKind["PlusEqualsToken"] = 108] = "PlusEqualsToken";
        SyntaxKind[SyntaxKind["MinusEqualsToken"] = 109] = "MinusEqualsToken";
        SyntaxKind[SyntaxKind["AsteriskEqualsToken"] = 110] = "AsteriskEqualsToken";
        SyntaxKind[SyntaxKind["PercentEqualsToken"] = 111] = "PercentEqualsToken";
        SyntaxKind[SyntaxKind["LessThanLessThanEqualsToken"] = 112] = "LessThanLessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanEqualsToken"] = 113] = "GreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanEqualsToken"] = 114] = "GreaterThanGreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["AmpersandEqualsToken"] = 115] = "AmpersandEqualsToken";
        SyntaxKind[SyntaxKind["BarEqualsToken"] = 116] = "BarEqualsToken";
        SyntaxKind[SyntaxKind["CaretEqualsToken"] = 117] = "CaretEqualsToken";
        SyntaxKind[SyntaxKind["SlashToken"] = 118] = "SlashToken";
        SyntaxKind[SyntaxKind["SlashEqualsToken"] = 119] = "SlashEqualsToken";
        SyntaxKind[SyntaxKind["SourceUnit"] = 120] = "SourceUnit";
        SyntaxKind[SyntaxKind["QualifiedName"] = 121] = "QualifiedName";
        SyntaxKind[SyntaxKind["ObjectType"] = 122] = "ObjectType";
        SyntaxKind[SyntaxKind["FunctionType"] = 123] = "FunctionType";
        SyntaxKind[SyntaxKind["ArrayType"] = 124] = "ArrayType";
        SyntaxKind[SyntaxKind["TupleType"] = 125] = "TupleType";
        SyntaxKind[SyntaxKind["ConstructorType"] = 126] = "ConstructorType";
        SyntaxKind[SyntaxKind["GenericType"] = 127] = "GenericType";
        SyntaxKind[SyntaxKind["TypeQuery"] = 128] = "TypeQuery";
        SyntaxKind[SyntaxKind["InterfaceDeclaration"] = 129] = "InterfaceDeclaration";
        SyntaxKind[SyntaxKind["FunctionDeclaration"] = 130] = "FunctionDeclaration";
        SyntaxKind[SyntaxKind["ModuleDeclaration"] = 131] = "ModuleDeclaration";
        SyntaxKind[SyntaxKind["ClassDeclaration"] = 132] = "ClassDeclaration";
        SyntaxKind[SyntaxKind["EnumDeclaration"] = 133] = "EnumDeclaration";
        SyntaxKind[SyntaxKind["ImportDeclaration"] = 134] = "ImportDeclaration";
        SyntaxKind[SyntaxKind["ExportAssignment"] = 135] = "ExportAssignment";
        SyntaxKind[SyntaxKind["MemberFunctionDeclaration"] = 136] = "MemberFunctionDeclaration";
        SyntaxKind[SyntaxKind["MemberVariableDeclaration"] = 137] = "MemberVariableDeclaration";
        SyntaxKind[SyntaxKind["ConstructorDeclaration"] = 138] = "ConstructorDeclaration";
        SyntaxKind[SyntaxKind["IndexMemberDeclaration"] = 139] = "IndexMemberDeclaration";
        SyntaxKind[SyntaxKind["GetAccessor"] = 140] = "GetAccessor";
        SyntaxKind[SyntaxKind["SetAccessor"] = 141] = "SetAccessor";
        SyntaxKind[SyntaxKind["PropertySignature"] = 142] = "PropertySignature";
        SyntaxKind[SyntaxKind["CallSignature"] = 143] = "CallSignature";
        SyntaxKind[SyntaxKind["ConstructSignature"] = 144] = "ConstructSignature";
        SyntaxKind[SyntaxKind["IndexSignature"] = 145] = "IndexSignature";
        SyntaxKind[SyntaxKind["MethodSignature"] = 146] = "MethodSignature";
        SyntaxKind[SyntaxKind["Block"] = 147] = "Block";
        SyntaxKind[SyntaxKind["IfStatement"] = 148] = "IfStatement";
        SyntaxKind[SyntaxKind["VariableStatement"] = 149] = "VariableStatement";
        SyntaxKind[SyntaxKind["ExpressionStatement"] = 150] = "ExpressionStatement";
        SyntaxKind[SyntaxKind["ReturnStatement"] = 151] = "ReturnStatement";
        SyntaxKind[SyntaxKind["SwitchStatement"] = 152] = "SwitchStatement";
        SyntaxKind[SyntaxKind["BreakStatement"] = 153] = "BreakStatement";
        SyntaxKind[SyntaxKind["ContinueStatement"] = 154] = "ContinueStatement";
        SyntaxKind[SyntaxKind["ForStatement"] = 155] = "ForStatement";
        SyntaxKind[SyntaxKind["ForInStatement"] = 156] = "ForInStatement";
        SyntaxKind[SyntaxKind["EmptyStatement"] = 157] = "EmptyStatement";
        SyntaxKind[SyntaxKind["ThrowStatement"] = 158] = "ThrowStatement";
        SyntaxKind[SyntaxKind["WhileStatement"] = 159] = "WhileStatement";
        SyntaxKind[SyntaxKind["TryStatement"] = 160] = "TryStatement";
        SyntaxKind[SyntaxKind["LabeledStatement"] = 161] = "LabeledStatement";
        SyntaxKind[SyntaxKind["DoStatement"] = 162] = "DoStatement";
        SyntaxKind[SyntaxKind["DebuggerStatement"] = 163] = "DebuggerStatement";
        SyntaxKind[SyntaxKind["WithStatement"] = 164] = "WithStatement";
        SyntaxKind[SyntaxKind["PlusExpression"] = 165] = "PlusExpression";
        SyntaxKind[SyntaxKind["NegateExpression"] = 166] = "NegateExpression";
        SyntaxKind[SyntaxKind["BitwiseNotExpression"] = 167] = "BitwiseNotExpression";
        SyntaxKind[SyntaxKind["LogicalNotExpression"] = 168] = "LogicalNotExpression";
        SyntaxKind[SyntaxKind["PreIncrementExpression"] = 169] = "PreIncrementExpression";
        SyntaxKind[SyntaxKind["PreDecrementExpression"] = 170] = "PreDecrementExpression";
        SyntaxKind[SyntaxKind["DeleteExpression"] = 171] = "DeleteExpression";
        SyntaxKind[SyntaxKind["TypeOfExpression"] = 172] = "TypeOfExpression";
        SyntaxKind[SyntaxKind["VoidExpression"] = 173] = "VoidExpression";
        SyntaxKind[SyntaxKind["CommaExpression"] = 174] = "CommaExpression";
        SyntaxKind[SyntaxKind["AssignmentExpression"] = 175] = "AssignmentExpression";
        SyntaxKind[SyntaxKind["AddAssignmentExpression"] = 176] = "AddAssignmentExpression";
        SyntaxKind[SyntaxKind["SubtractAssignmentExpression"] = 177] = "SubtractAssignmentExpression";
        SyntaxKind[SyntaxKind["MultiplyAssignmentExpression"] = 178] = "MultiplyAssignmentExpression";
        SyntaxKind[SyntaxKind["DivideAssignmentExpression"] = 179] = "DivideAssignmentExpression";
        SyntaxKind[SyntaxKind["ModuloAssignmentExpression"] = 180] = "ModuloAssignmentExpression";
        SyntaxKind[SyntaxKind["AndAssignmentExpression"] = 181] = "AndAssignmentExpression";
        SyntaxKind[SyntaxKind["ExclusiveOrAssignmentExpression"] = 182] = "ExclusiveOrAssignmentExpression";
        SyntaxKind[SyntaxKind["OrAssignmentExpression"] = 183] = "OrAssignmentExpression";
        SyntaxKind[SyntaxKind["LeftShiftAssignmentExpression"] = 184] = "LeftShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["SignedRightShiftAssignmentExpression"] = 185] = "SignedRightShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["UnsignedRightShiftAssignmentExpression"] = 186] = "UnsignedRightShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["ConditionalExpression"] = 187] = "ConditionalExpression";
        SyntaxKind[SyntaxKind["LogicalOrExpression"] = 188] = "LogicalOrExpression";
        SyntaxKind[SyntaxKind["LogicalAndExpression"] = 189] = "LogicalAndExpression";
        SyntaxKind[SyntaxKind["BitwiseOrExpression"] = 190] = "BitwiseOrExpression";
        SyntaxKind[SyntaxKind["BitwiseExclusiveOrExpression"] = 191] = "BitwiseExclusiveOrExpression";
        SyntaxKind[SyntaxKind["BitwiseAndExpression"] = 192] = "BitwiseAndExpression";
        SyntaxKind[SyntaxKind["EqualsWithTypeConversionExpression"] = 193] = "EqualsWithTypeConversionExpression";
        SyntaxKind[SyntaxKind["NotEqualsWithTypeConversionExpression"] = 194] = "NotEqualsWithTypeConversionExpression";
        SyntaxKind[SyntaxKind["EqualsExpression"] = 195] = "EqualsExpression";
        SyntaxKind[SyntaxKind["NotEqualsExpression"] = 196] = "NotEqualsExpression";
        SyntaxKind[SyntaxKind["LessThanExpression"] = 197] = "LessThanExpression";
        SyntaxKind[SyntaxKind["GreaterThanExpression"] = 198] = "GreaterThanExpression";
        SyntaxKind[SyntaxKind["LessThanOrEqualExpression"] = 199] = "LessThanOrEqualExpression";
        SyntaxKind[SyntaxKind["GreaterThanOrEqualExpression"] = 200] = "GreaterThanOrEqualExpression";
        SyntaxKind[SyntaxKind["InstanceOfExpression"] = 201] = "InstanceOfExpression";
        SyntaxKind[SyntaxKind["InExpression"] = 202] = "InExpression";
        SyntaxKind[SyntaxKind["LeftShiftExpression"] = 203] = "LeftShiftExpression";
        SyntaxKind[SyntaxKind["SignedRightShiftExpression"] = 204] = "SignedRightShiftExpression";
        SyntaxKind[SyntaxKind["UnsignedRightShiftExpression"] = 205] = "UnsignedRightShiftExpression";
        SyntaxKind[SyntaxKind["MultiplyExpression"] = 206] = "MultiplyExpression";
        SyntaxKind[SyntaxKind["DivideExpression"] = 207] = "DivideExpression";
        SyntaxKind[SyntaxKind["ModuloExpression"] = 208] = "ModuloExpression";
        SyntaxKind[SyntaxKind["AddExpression"] = 209] = "AddExpression";
        SyntaxKind[SyntaxKind["SubtractExpression"] = 210] = "SubtractExpression";
        SyntaxKind[SyntaxKind["PostIncrementExpression"] = 211] = "PostIncrementExpression";
        SyntaxKind[SyntaxKind["PostDecrementExpression"] = 212] = "PostDecrementExpression";
        SyntaxKind[SyntaxKind["MemberAccessExpression"] = 213] = "MemberAccessExpression";
        SyntaxKind[SyntaxKind["InvocationExpression"] = 214] = "InvocationExpression";
        SyntaxKind[SyntaxKind["ArrayLiteralExpression"] = 215] = "ArrayLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectLiteralExpression"] = 216] = "ObjectLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectCreationExpression"] = 217] = "ObjectCreationExpression";
        SyntaxKind[SyntaxKind["ParenthesizedExpression"] = 218] = "ParenthesizedExpression";
        SyntaxKind[SyntaxKind["ParenthesizedArrowFunctionExpression"] = 219] = "ParenthesizedArrowFunctionExpression";
        SyntaxKind[SyntaxKind["SimpleArrowFunctionExpression"] = 220] = "SimpleArrowFunctionExpression";
        SyntaxKind[SyntaxKind["CastExpression"] = 221] = "CastExpression";
        SyntaxKind[SyntaxKind["ElementAccessExpression"] = 222] = "ElementAccessExpression";
        SyntaxKind[SyntaxKind["FunctionExpression"] = 223] = "FunctionExpression";
        SyntaxKind[SyntaxKind["OmittedExpression"] = 224] = "OmittedExpression";
        SyntaxKind[SyntaxKind["VariableDeclaration"] = 225] = "VariableDeclaration";
        SyntaxKind[SyntaxKind["VariableDeclarator"] = 226] = "VariableDeclarator";
        SyntaxKind[SyntaxKind["ArgumentList"] = 227] = "ArgumentList";
        SyntaxKind[SyntaxKind["ParameterList"] = 228] = "ParameterList";
        SyntaxKind[SyntaxKind["TypeArgumentList"] = 229] = "TypeArgumentList";
        SyntaxKind[SyntaxKind["TypeParameterList"] = 230] = "TypeParameterList";
        SyntaxKind[SyntaxKind["ExtendsHeritageClause"] = 231] = "ExtendsHeritageClause";
        SyntaxKind[SyntaxKind["ImplementsHeritageClause"] = 232] = "ImplementsHeritageClause";
        SyntaxKind[SyntaxKind["EqualsValueClause"] = 233] = "EqualsValueClause";
        SyntaxKind[SyntaxKind["CaseSwitchClause"] = 234] = "CaseSwitchClause";
        SyntaxKind[SyntaxKind["DefaultSwitchClause"] = 235] = "DefaultSwitchClause";
        SyntaxKind[SyntaxKind["ElseClause"] = 236] = "ElseClause";
        SyntaxKind[SyntaxKind["CatchClause"] = 237] = "CatchClause";
        SyntaxKind[SyntaxKind["FinallyClause"] = 238] = "FinallyClause";
        SyntaxKind[SyntaxKind["TypeParameter"] = 239] = "TypeParameter";
        SyntaxKind[SyntaxKind["Constraint"] = 240] = "Constraint";
        SyntaxKind[SyntaxKind["SimplePropertyAssignment"] = 241] = "SimplePropertyAssignment";
        SyntaxKind[SyntaxKind["FunctionPropertyAssignment"] = 242] = "FunctionPropertyAssignment";
        SyntaxKind[SyntaxKind["Parameter"] = 243] = "Parameter";
        SyntaxKind[SyntaxKind["EnumElement"] = 244] = "EnumElement";
        SyntaxKind[SyntaxKind["TypeAnnotation"] = 245] = "TypeAnnotation";
        SyntaxKind[SyntaxKind["ExternalModuleReference"] = 246] = "ExternalModuleReference";
        SyntaxKind[SyntaxKind["ModuleNameModuleReference"] = 247] = "ModuleNameModuleReference";
        SyntaxKind[SyntaxKind["Last"] = 247] = "Last";
        SyntaxKind[SyntaxKind["FirstStandardKeyword"] = 15] = "FirstStandardKeyword";
        SyntaxKind[SyntaxKind["LastStandardKeyword"] = 43] = "LastStandardKeyword";
        SyntaxKind[SyntaxKind["FirstFutureReservedKeyword"] = 44] = "FirstFutureReservedKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedKeyword"] = 50] = "LastFutureReservedKeyword";
        SyntaxKind[SyntaxKind["FirstFutureReservedStrictKeyword"] = 51] = "FirstFutureReservedStrictKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedStrictKeyword"] = 59] = "LastFutureReservedStrictKeyword";
        SyntaxKind[SyntaxKind["FirstTypeScriptKeyword"] = 60] = "FirstTypeScriptKeyword";
        SyntaxKind[SyntaxKind["LastTypeScriptKeyword"] = 69] = "LastTypeScriptKeyword";
        SyntaxKind[SyntaxKind["FirstKeyword"] = 15] = "FirstKeyword";
        SyntaxKind[SyntaxKind["LastKeyword"] = 69] = "LastKeyword";
        SyntaxKind[SyntaxKind["FirstToken"] = 9] = "FirstToken";
        SyntaxKind[SyntaxKind["LastToken"] = 119] = "LastToken";
        SyntaxKind[SyntaxKind["FirstPunctuation"] = 70] = "FirstPunctuation";
        SyntaxKind[SyntaxKind["LastPunctuation"] = 119] = "LastPunctuation";
        SyntaxKind[SyntaxKind["FirstFixedWidth"] = 15] = "FirstFixedWidth";
        SyntaxKind[SyntaxKind["LastFixedWidth"] = 119] = "LastFixedWidth";
        SyntaxKind[SyntaxKind["FirstTrivia"] = 4] = "FirstTrivia";
        SyntaxKind[SyntaxKind["LastTrivia"] = 8] = "LastTrivia";
    })(SyntaxKind = TypeScript.SyntaxKind || (TypeScript.SyntaxKind = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxFacts;
    (function (SyntaxFacts) {
        var textToKeywordKind = {
            "any": TypeScript.SyntaxKind.AnyKeyword,
            "boolean": TypeScript.SyntaxKind.BooleanKeyword,
            "break": TypeScript.SyntaxKind.BreakKeyword,
            "case": TypeScript.SyntaxKind.CaseKeyword,
            "catch": TypeScript.SyntaxKind.CatchKeyword,
            "class": TypeScript.SyntaxKind.ClassKeyword,
            "continue": TypeScript.SyntaxKind.ContinueKeyword,
            "const": TypeScript.SyntaxKind.ConstKeyword,
            "constructor": TypeScript.SyntaxKind.ConstructorKeyword,
            "debugger": TypeScript.SyntaxKind.DebuggerKeyword,
            "declare": TypeScript.SyntaxKind.DeclareKeyword,
            "default": TypeScript.SyntaxKind.DefaultKeyword,
            "delete": TypeScript.SyntaxKind.DeleteKeyword,
            "do": TypeScript.SyntaxKind.DoKeyword,
            "else": TypeScript.SyntaxKind.ElseKeyword,
            "enum": TypeScript.SyntaxKind.EnumKeyword,
            "export": TypeScript.SyntaxKind.ExportKeyword,
            "extends": TypeScript.SyntaxKind.ExtendsKeyword,
            "false": TypeScript.SyntaxKind.FalseKeyword,
            "finally": TypeScript.SyntaxKind.FinallyKeyword,
            "for": TypeScript.SyntaxKind.ForKeyword,
            "function": TypeScript.SyntaxKind.FunctionKeyword,
            "get": TypeScript.SyntaxKind.GetKeyword,
            "if": TypeScript.SyntaxKind.IfKeyword,
            "implements": TypeScript.SyntaxKind.ImplementsKeyword,
            "import": TypeScript.SyntaxKind.ImportKeyword,
            "in": TypeScript.SyntaxKind.InKeyword,
            "instanceof": TypeScript.SyntaxKind.InstanceOfKeyword,
            "interface": TypeScript.SyntaxKind.InterfaceKeyword,
            "let": TypeScript.SyntaxKind.LetKeyword,
            "module": TypeScript.SyntaxKind.ModuleKeyword,
            "new": TypeScript.SyntaxKind.NewKeyword,
            "null": TypeScript.SyntaxKind.NullKeyword,
            "number": TypeScript.SyntaxKind.NumberKeyword,
            "package": TypeScript.SyntaxKind.PackageKeyword,
            "private": TypeScript.SyntaxKind.PrivateKeyword,
            "protected": TypeScript.SyntaxKind.ProtectedKeyword,
            "public": TypeScript.SyntaxKind.PublicKeyword,
            "require": TypeScript.SyntaxKind.RequireKeyword,
            "return": TypeScript.SyntaxKind.ReturnKeyword,
            "set": TypeScript.SyntaxKind.SetKeyword,
            "static": TypeScript.SyntaxKind.StaticKeyword,
            "string": TypeScript.SyntaxKind.StringKeyword,
            "super": TypeScript.SyntaxKind.SuperKeyword,
            "switch": TypeScript.SyntaxKind.SwitchKeyword,
            "this": TypeScript.SyntaxKind.ThisKeyword,
            "throw": TypeScript.SyntaxKind.ThrowKeyword,
            "true": TypeScript.SyntaxKind.TrueKeyword,
            "try": TypeScript.SyntaxKind.TryKeyword,
            "typeof": TypeScript.SyntaxKind.TypeOfKeyword,
            "var": TypeScript.SyntaxKind.VarKeyword,
            "void": TypeScript.SyntaxKind.VoidKeyword,
            "while": TypeScript.SyntaxKind.WhileKeyword,
            "with": TypeScript.SyntaxKind.WithKeyword,
            "yield": TypeScript.SyntaxKind.YieldKeyword,
            "{": TypeScript.SyntaxKind.OpenBraceToken,
            "}": TypeScript.SyntaxKind.CloseBraceToken,
            "(": TypeScript.SyntaxKind.OpenParenToken,
            ")": TypeScript.SyntaxKind.CloseParenToken,
            "[": TypeScript.SyntaxKind.OpenBracketToken,
            "]": TypeScript.SyntaxKind.CloseBracketToken,
            ".": TypeScript.SyntaxKind.DotToken,
            "...": TypeScript.SyntaxKind.DotDotDotToken,
            ";": TypeScript.SyntaxKind.SemicolonToken,
            ",": TypeScript.SyntaxKind.CommaToken,
            "<": TypeScript.SyntaxKind.LessThanToken,
            ">": TypeScript.SyntaxKind.GreaterThanToken,
            "<=": TypeScript.SyntaxKind.LessThanEqualsToken,
            ">=": TypeScript.SyntaxKind.GreaterThanEqualsToken,
            "==": TypeScript.SyntaxKind.EqualsEqualsToken,
            "=>": TypeScript.SyntaxKind.EqualsGreaterThanToken,
            "!=": TypeScript.SyntaxKind.ExclamationEqualsToken,
            "===": TypeScript.SyntaxKind.EqualsEqualsEqualsToken,
            "!==": TypeScript.SyntaxKind.ExclamationEqualsEqualsToken,
            "+": TypeScript.SyntaxKind.PlusToken,
            "-": TypeScript.SyntaxKind.MinusToken,
            "*": TypeScript.SyntaxKind.AsteriskToken,
            "%": TypeScript.SyntaxKind.PercentToken,
            "++": TypeScript.SyntaxKind.PlusPlusToken,
            "--": TypeScript.SyntaxKind.MinusMinusToken,
            "<<": TypeScript.SyntaxKind.LessThanLessThanToken,
            ">>": TypeScript.SyntaxKind.GreaterThanGreaterThanToken,
            ">>>": TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanToken,
            "&": TypeScript.SyntaxKind.AmpersandToken,
            "|": TypeScript.SyntaxKind.BarToken,
            "^": TypeScript.SyntaxKind.CaretToken,
            "!": TypeScript.SyntaxKind.ExclamationToken,
            "~": TypeScript.SyntaxKind.TildeToken,
            "&&": TypeScript.SyntaxKind.AmpersandAmpersandToken,
            "||": TypeScript.SyntaxKind.BarBarToken,
            "?": TypeScript.SyntaxKind.QuestionToken,
            ":": TypeScript.SyntaxKind.ColonToken,
            "=": TypeScript.SyntaxKind.EqualsToken,
            "+=": TypeScript.SyntaxKind.PlusEqualsToken,
            "-=": TypeScript.SyntaxKind.MinusEqualsToken,
            "*=": TypeScript.SyntaxKind.AsteriskEqualsToken,
            "%=": TypeScript.SyntaxKind.PercentEqualsToken,
            "<<=": TypeScript.SyntaxKind.LessThanLessThanEqualsToken,
            ">>=": TypeScript.SyntaxKind.GreaterThanGreaterThanEqualsToken,
            ">>>=": TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,
            "&=": TypeScript.SyntaxKind.AmpersandEqualsToken,
            "|=": TypeScript.SyntaxKind.BarEqualsToken,
            "^=": TypeScript.SyntaxKind.CaretEqualsToken,
            "/": TypeScript.SyntaxKind.SlashToken,
            "/=": TypeScript.SyntaxKind.SlashEqualsToken,
        };
        var kindToText = new Array();
        for (var name in textToKeywordKind) {
            if (textToKeywordKind.hasOwnProperty(name)) {
                kindToText[textToKeywordKind[name]] = name;
            }
        }
        kindToText[TypeScript.SyntaxKind.ConstructorKeyword] = "constructor";
        function getTokenKind(text) {
            if (textToKeywordKind.hasOwnProperty(text)) {
                return textToKeywordKind[text];
            }
            return TypeScript.SyntaxKind.None;
        }
        SyntaxFacts.getTokenKind = getTokenKind;
        function getText(kind) {
            var result = kindToText[kind];
            return result !== undefined ? result : null;
        }
        SyntaxFacts.getText = getText;
        function isTokenKind(kind) {
            return kind >= TypeScript.SyntaxKind.FirstToken && kind <= TypeScript.SyntaxKind.LastToken;
        }
        SyntaxFacts.isTokenKind = isTokenKind;
        function isAnyKeyword(kind) {
            return kind >= TypeScript.SyntaxKind.FirstKeyword && kind <= TypeScript.SyntaxKind.LastKeyword;
        }
        SyntaxFacts.isAnyKeyword = isAnyKeyword;
        function isStandardKeyword(kind) {
            return kind >= TypeScript.SyntaxKind.FirstStandardKeyword && kind <= TypeScript.SyntaxKind.LastStandardKeyword;
        }
        SyntaxFacts.isStandardKeyword = isStandardKeyword;
        function isFutureReservedKeyword(kind) {
            return kind >= TypeScript.SyntaxKind.FirstFutureReservedKeyword && kind <= TypeScript.SyntaxKind.LastFutureReservedKeyword;
        }
        SyntaxFacts.isFutureReservedKeyword = isFutureReservedKeyword;
        function isFutureReservedStrictKeyword(kind) {
            return kind >= TypeScript.SyntaxKind.FirstFutureReservedStrictKeyword && kind <= TypeScript.SyntaxKind.LastFutureReservedStrictKeyword;
        }
        SyntaxFacts.isFutureReservedStrictKeyword = isFutureReservedStrictKeyword;
        function isAnyPunctuation(kind) {
            return kind >= TypeScript.SyntaxKind.FirstPunctuation && kind <= TypeScript.SyntaxKind.LastPunctuation;
        }
        SyntaxFacts.isAnyPunctuation = isAnyPunctuation;
        function isPrefixUnaryExpressionOperatorToken(tokenKind) {
            return getPrefixUnaryExpressionFromOperatorToken(tokenKind) !== TypeScript.SyntaxKind.None;
        }
        SyntaxFacts.isPrefixUnaryExpressionOperatorToken = isPrefixUnaryExpressionOperatorToken;
        function isBinaryExpressionOperatorToken(tokenKind) {
            return getBinaryExpressionFromOperatorToken(tokenKind) !== TypeScript.SyntaxKind.None;
        }
        SyntaxFacts.isBinaryExpressionOperatorToken = isBinaryExpressionOperatorToken;
        function getPrefixUnaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case TypeScript.SyntaxKind.PlusToken:
                    return TypeScript.SyntaxKind.PlusExpression;
                case TypeScript.SyntaxKind.MinusToken:
                    return TypeScript.SyntaxKind.NegateExpression;
                case TypeScript.SyntaxKind.TildeToken:
                    return TypeScript.SyntaxKind.BitwiseNotExpression;
                case TypeScript.SyntaxKind.ExclamationToken:
                    return TypeScript.SyntaxKind.LogicalNotExpression;
                case TypeScript.SyntaxKind.PlusPlusToken:
                    return TypeScript.SyntaxKind.PreIncrementExpression;
                case TypeScript.SyntaxKind.MinusMinusToken:
                    return TypeScript.SyntaxKind.PreDecrementExpression;
                default:
                    return TypeScript.SyntaxKind.None;
            }
        }
        SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken = getPrefixUnaryExpressionFromOperatorToken;
        function getPostfixUnaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case TypeScript.SyntaxKind.PlusPlusToken:
                    return TypeScript.SyntaxKind.PostIncrementExpression;
                case TypeScript.SyntaxKind.MinusMinusToken:
                    return TypeScript.SyntaxKind.PostDecrementExpression;
                default:
                    return TypeScript.SyntaxKind.None;
            }
        }
        SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken = getPostfixUnaryExpressionFromOperatorToken;
        function getBinaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case TypeScript.SyntaxKind.AsteriskToken:
                    return TypeScript.SyntaxKind.MultiplyExpression;
                case TypeScript.SyntaxKind.SlashToken:
                    return TypeScript.SyntaxKind.DivideExpression;
                case TypeScript.SyntaxKind.PercentToken:
                    return TypeScript.SyntaxKind.ModuloExpression;
                case TypeScript.SyntaxKind.PlusToken:
                    return TypeScript.SyntaxKind.AddExpression;
                case TypeScript.SyntaxKind.MinusToken:
                    return TypeScript.SyntaxKind.SubtractExpression;
                case TypeScript.SyntaxKind.LessThanLessThanToken:
                    return TypeScript.SyntaxKind.LeftShiftExpression;
                case TypeScript.SyntaxKind.GreaterThanGreaterThanToken:
                    return TypeScript.SyntaxKind.SignedRightShiftExpression;
                case TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                    return TypeScript.SyntaxKind.UnsignedRightShiftExpression;
                case TypeScript.SyntaxKind.LessThanToken:
                    return TypeScript.SyntaxKind.LessThanExpression;
                case TypeScript.SyntaxKind.GreaterThanToken:
                    return TypeScript.SyntaxKind.GreaterThanExpression;
                case TypeScript.SyntaxKind.LessThanEqualsToken:
                    return TypeScript.SyntaxKind.LessThanOrEqualExpression;
                case TypeScript.SyntaxKind.GreaterThanEqualsToken:
                    return TypeScript.SyntaxKind.GreaterThanOrEqualExpression;
                case TypeScript.SyntaxKind.InstanceOfKeyword:
                    return TypeScript.SyntaxKind.InstanceOfExpression;
                case TypeScript.SyntaxKind.InKeyword:
                    return TypeScript.SyntaxKind.InExpression;
                case TypeScript.SyntaxKind.EqualsEqualsToken:
                    return TypeScript.SyntaxKind.EqualsWithTypeConversionExpression;
                case TypeScript.SyntaxKind.ExclamationEqualsToken:
                    return TypeScript.SyntaxKind.NotEqualsWithTypeConversionExpression;
                case TypeScript.SyntaxKind.EqualsEqualsEqualsToken:
                    return TypeScript.SyntaxKind.EqualsExpression;
                case TypeScript.SyntaxKind.ExclamationEqualsEqualsToken:
                    return TypeScript.SyntaxKind.NotEqualsExpression;
                case TypeScript.SyntaxKind.AmpersandToken:
                    return TypeScript.SyntaxKind.BitwiseAndExpression;
                case TypeScript.SyntaxKind.CaretToken:
                    return TypeScript.SyntaxKind.BitwiseExclusiveOrExpression;
                case TypeScript.SyntaxKind.BarToken:
                    return TypeScript.SyntaxKind.BitwiseOrExpression;
                case TypeScript.SyntaxKind.AmpersandAmpersandToken:
                    return TypeScript.SyntaxKind.LogicalAndExpression;
                case TypeScript.SyntaxKind.BarBarToken:
                    return TypeScript.SyntaxKind.LogicalOrExpression;
                case TypeScript.SyntaxKind.BarEqualsToken:
                    return TypeScript.SyntaxKind.OrAssignmentExpression;
                case TypeScript.SyntaxKind.AmpersandEqualsToken:
                    return TypeScript.SyntaxKind.AndAssignmentExpression;
                case TypeScript.SyntaxKind.CaretEqualsToken:
                    return TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression;
                case TypeScript.SyntaxKind.LessThanLessThanEqualsToken:
                    return TypeScript.SyntaxKind.LeftShiftAssignmentExpression;
                case TypeScript.SyntaxKind.GreaterThanGreaterThanEqualsToken:
                    return TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression;
                case TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                    return TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression;
                case TypeScript.SyntaxKind.PlusEqualsToken:
                    return TypeScript.SyntaxKind.AddAssignmentExpression;
                case TypeScript.SyntaxKind.MinusEqualsToken:
                    return TypeScript.SyntaxKind.SubtractAssignmentExpression;
                case TypeScript.SyntaxKind.AsteriskEqualsToken:
                    return TypeScript.SyntaxKind.MultiplyAssignmentExpression;
                case TypeScript.SyntaxKind.SlashEqualsToken:
                    return TypeScript.SyntaxKind.DivideAssignmentExpression;
                case TypeScript.SyntaxKind.PercentEqualsToken:
                    return TypeScript.SyntaxKind.ModuloAssignmentExpression;
                case TypeScript.SyntaxKind.EqualsToken:
                    return TypeScript.SyntaxKind.AssignmentExpression;
                case TypeScript.SyntaxKind.CommaToken:
                    return TypeScript.SyntaxKind.CommaExpression;
                default:
                    return TypeScript.SyntaxKind.None;
            }
        }
        SyntaxFacts.getBinaryExpressionFromOperatorToken = getBinaryExpressionFromOperatorToken;
        function getOperatorTokenFromBinaryExpression(tokenKind) {
            switch (tokenKind) {
                case TypeScript.SyntaxKind.MultiplyExpression:
                    return TypeScript.SyntaxKind.AsteriskToken;
                case TypeScript.SyntaxKind.DivideExpression:
                    return TypeScript.SyntaxKind.SlashToken;
                case TypeScript.SyntaxKind.ModuloExpression:
                    return TypeScript.SyntaxKind.PercentToken;
                case TypeScript.SyntaxKind.AddExpression:
                    return TypeScript.SyntaxKind.PlusToken;
                case TypeScript.SyntaxKind.SubtractExpression:
                    return TypeScript.SyntaxKind.MinusToken;
                case TypeScript.SyntaxKind.LeftShiftExpression:
                    return TypeScript.SyntaxKind.LessThanLessThanToken;
                case TypeScript.SyntaxKind.SignedRightShiftExpression:
                    return TypeScript.SyntaxKind.GreaterThanGreaterThanToken;
                case TypeScript.SyntaxKind.UnsignedRightShiftExpression:
                    return TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanToken;
                case TypeScript.SyntaxKind.LessThanExpression:
                    return TypeScript.SyntaxKind.LessThanToken;
                case TypeScript.SyntaxKind.GreaterThanExpression:
                    return TypeScript.SyntaxKind.GreaterThanToken;
                case TypeScript.SyntaxKind.LessThanOrEqualExpression:
                    return TypeScript.SyntaxKind.LessThanEqualsToken;
                case TypeScript.SyntaxKind.GreaterThanOrEqualExpression:
                    return TypeScript.SyntaxKind.GreaterThanEqualsToken;
                case TypeScript.SyntaxKind.InstanceOfExpression:
                    return TypeScript.SyntaxKind.InstanceOfKeyword;
                case TypeScript.SyntaxKind.InExpression:
                    return TypeScript.SyntaxKind.InKeyword;
                case TypeScript.SyntaxKind.EqualsWithTypeConversionExpression:
                    return TypeScript.SyntaxKind.EqualsEqualsToken;
                case TypeScript.SyntaxKind.NotEqualsWithTypeConversionExpression:
                    return TypeScript.SyntaxKind.ExclamationEqualsToken;
                case TypeScript.SyntaxKind.EqualsExpression:
                    return TypeScript.SyntaxKind.EqualsEqualsEqualsToken;
                case TypeScript.SyntaxKind.NotEqualsExpression:
                    return TypeScript.SyntaxKind.ExclamationEqualsEqualsToken;
                case TypeScript.SyntaxKind.BitwiseAndExpression:
                    return TypeScript.SyntaxKind.AmpersandToken;
                case TypeScript.SyntaxKind.BitwiseExclusiveOrExpression:
                    return TypeScript.SyntaxKind.CaretToken;
                case TypeScript.SyntaxKind.BitwiseOrExpression:
                    return TypeScript.SyntaxKind.BarToken;
                case TypeScript.SyntaxKind.LogicalAndExpression:
                    return TypeScript.SyntaxKind.AmpersandAmpersandToken;
                case TypeScript.SyntaxKind.LogicalOrExpression:
                    return TypeScript.SyntaxKind.BarBarToken;
                case TypeScript.SyntaxKind.OrAssignmentExpression:
                    return TypeScript.SyntaxKind.BarEqualsToken;
                case TypeScript.SyntaxKind.AndAssignmentExpression:
                    return TypeScript.SyntaxKind.AmpersandEqualsToken;
                case TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression:
                    return TypeScript.SyntaxKind.CaretEqualsToken;
                case TypeScript.SyntaxKind.LeftShiftAssignmentExpression:
                    return TypeScript.SyntaxKind.LessThanLessThanEqualsToken;
                case TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression:
                    return TypeScript.SyntaxKind.GreaterThanGreaterThanEqualsToken;
                case TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression:
                    return TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken;
                case TypeScript.SyntaxKind.AddAssignmentExpression:
                    return TypeScript.SyntaxKind.PlusEqualsToken;
                case TypeScript.SyntaxKind.SubtractAssignmentExpression:
                    return TypeScript.SyntaxKind.MinusEqualsToken;
                case TypeScript.SyntaxKind.MultiplyAssignmentExpression:
                    return TypeScript.SyntaxKind.AsteriskEqualsToken;
                case TypeScript.SyntaxKind.DivideAssignmentExpression:
                    return TypeScript.SyntaxKind.SlashEqualsToken;
                case TypeScript.SyntaxKind.ModuloAssignmentExpression:
                    return TypeScript.SyntaxKind.PercentEqualsToken;
                case TypeScript.SyntaxKind.AssignmentExpression:
                    return TypeScript.SyntaxKind.EqualsToken;
                case TypeScript.SyntaxKind.CommaExpression:
                    return TypeScript.SyntaxKind.CommaToken;
                default:
                    return TypeScript.SyntaxKind.None;
            }
        }
        SyntaxFacts.getOperatorTokenFromBinaryExpression = getOperatorTokenFromBinaryExpression;
        function isAnyDivideToken(kind) {
            switch (kind) {
                case TypeScript.SyntaxKind.SlashToken:
                case TypeScript.SyntaxKind.SlashEqualsToken:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isAnyDivideToken = isAnyDivideToken;
        function isAnyDivideOrRegularExpressionToken(kind) {
            switch (kind) {
                case TypeScript.SyntaxKind.SlashToken:
                case TypeScript.SyntaxKind.SlashEqualsToken:
                case TypeScript.SyntaxKind.RegularExpressionLiteral:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isAnyDivideOrRegularExpressionToken = isAnyDivideOrRegularExpressionToken;
    })(SyntaxFacts = TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ScannerUtilities = (function () {
        function ScannerUtilities() {
        }
        ScannerUtilities.identifierKind = function (array, startIndex, length) {
            switch (length) {
                case 2:
                    switch (array[startIndex]) {
                        case TypeScript.CharacterCodes.d:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.o) ? TypeScript.SyntaxKind.DoKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.i:
                            switch (array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.f:
                                    return TypeScript.SyntaxKind.IfKeyword;
                                case TypeScript.CharacterCodes.n:
                                    return TypeScript.SyntaxKind.InKeyword;
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 3:
                    switch (array[startIndex]) {
                        case TypeScript.CharacterCodes.f:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.o && array[startIndex + 2] === TypeScript.CharacterCodes.r) ? TypeScript.SyntaxKind.ForKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.n:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.w) ? TypeScript.SyntaxKind.NewKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.t:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.r && array[startIndex + 2] === TypeScript.CharacterCodes.y) ? TypeScript.SyntaxKind.TryKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.v:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.a && array[startIndex + 2] === TypeScript.CharacterCodes.r) ? TypeScript.SyntaxKind.VarKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.l:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.LetKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.a:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.n && array[startIndex + 2] === TypeScript.CharacterCodes.y) ? TypeScript.SyntaxKind.AnyKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.g:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.GetKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.s:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.SetKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 4:
                    switch (array[startIndex]) {
                        case TypeScript.CharacterCodes.c:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.a && array[startIndex + 2] === TypeScript.CharacterCodes.s && array[startIndex + 3] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.CaseKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.e:
                            switch (array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.l:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.s && array[startIndex + 3] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.ElseKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.n:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.u && array[startIndex + 3] === TypeScript.CharacterCodes.m) ? TypeScript.SyntaxKind.EnumKeyword : TypeScript.SyntaxKind.IdentifierName;
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        case TypeScript.CharacterCodes.n:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.u && array[startIndex + 2] === TypeScript.CharacterCodes.l && array[startIndex + 3] === TypeScript.CharacterCodes.l) ? TypeScript.SyntaxKind.NullKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.t:
                            switch (array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.h:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.i && array[startIndex + 3] === TypeScript.CharacterCodes.s) ? TypeScript.SyntaxKind.ThisKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.r:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.u && array[startIndex + 3] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.TrueKeyword : TypeScript.SyntaxKind.IdentifierName;
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        case TypeScript.CharacterCodes.v:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.o && array[startIndex + 2] === TypeScript.CharacterCodes.i && array[startIndex + 3] === TypeScript.CharacterCodes.d) ? TypeScript.SyntaxKind.VoidKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.w:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.i && array[startIndex + 2] === TypeScript.CharacterCodes.t && array[startIndex + 3] === TypeScript.CharacterCodes.h) ? TypeScript.SyntaxKind.WithKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 5:
                    switch (array[startIndex]) {
                        case TypeScript.CharacterCodes.b:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.r && array[startIndex + 2] === TypeScript.CharacterCodes.e && array[startIndex + 3] === TypeScript.CharacterCodes.a && array[startIndex + 4] === TypeScript.CharacterCodes.k) ? TypeScript.SyntaxKind.BreakKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.c:
                            switch (array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.a:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.t && array[startIndex + 3] === TypeScript.CharacterCodes.c && array[startIndex + 4] === TypeScript.CharacterCodes.h) ? TypeScript.SyntaxKind.CatchKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.l:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.a && array[startIndex + 3] === TypeScript.CharacterCodes.s && array[startIndex + 4] === TypeScript.CharacterCodes.s) ? TypeScript.SyntaxKind.ClassKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.o:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.n && array[startIndex + 3] === TypeScript.CharacterCodes.s && array[startIndex + 4] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.ConstKeyword : TypeScript.SyntaxKind.IdentifierName;
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        case TypeScript.CharacterCodes.f:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.a && array[startIndex + 2] === TypeScript.CharacterCodes.l && array[startIndex + 3] === TypeScript.CharacterCodes.s && array[startIndex + 4] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.FalseKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.t:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.h && array[startIndex + 2] === TypeScript.CharacterCodes.r && array[startIndex + 3] === TypeScript.CharacterCodes.o && array[startIndex + 4] === TypeScript.CharacterCodes.w) ? TypeScript.SyntaxKind.ThrowKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.w:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.h && array[startIndex + 2] === TypeScript.CharacterCodes.i && array[startIndex + 3] === TypeScript.CharacterCodes.l && array[startIndex + 4] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.WhileKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.s:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.u && array[startIndex + 2] === TypeScript.CharacterCodes.p && array[startIndex + 3] === TypeScript.CharacterCodes.e && array[startIndex + 4] === TypeScript.CharacterCodes.r) ? TypeScript.SyntaxKind.SuperKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.y:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.i && array[startIndex + 2] === TypeScript.CharacterCodes.e && array[startIndex + 3] === TypeScript.CharacterCodes.l && array[startIndex + 4] === TypeScript.CharacterCodes.d) ? TypeScript.SyntaxKind.YieldKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 6:
                    switch (array[startIndex]) {
                        case TypeScript.CharacterCodes.d:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.l && array[startIndex + 3] === TypeScript.CharacterCodes.e && array[startIndex + 4] === TypeScript.CharacterCodes.t && array[startIndex + 5] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.DeleteKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.r:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.t && array[startIndex + 3] === TypeScript.CharacterCodes.u && array[startIndex + 4] === TypeScript.CharacterCodes.r && array[startIndex + 5] === TypeScript.CharacterCodes.n) ? TypeScript.SyntaxKind.ReturnKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.s:
                            switch (array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.w:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.i && array[startIndex + 3] === TypeScript.CharacterCodes.t && array[startIndex + 4] === TypeScript.CharacterCodes.c && array[startIndex + 5] === TypeScript.CharacterCodes.h) ? TypeScript.SyntaxKind.SwitchKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.t:
                                    switch (array[startIndex + 2]) {
                                        case TypeScript.CharacterCodes.a:
                                            return (array[startIndex + 3] === TypeScript.CharacterCodes.t && array[startIndex + 4] === TypeScript.CharacterCodes.i && array[startIndex + 5] === TypeScript.CharacterCodes.c) ? TypeScript.SyntaxKind.StaticKeyword : TypeScript.SyntaxKind.IdentifierName;
                                        case TypeScript.CharacterCodes.r:
                                            return (array[startIndex + 3] === TypeScript.CharacterCodes.i && array[startIndex + 4] === TypeScript.CharacterCodes.n && array[startIndex + 5] === TypeScript.CharacterCodes.g) ? TypeScript.SyntaxKind.StringKeyword : TypeScript.SyntaxKind.IdentifierName;
                                        default:
                                            return TypeScript.SyntaxKind.IdentifierName;
                                    }
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        case TypeScript.CharacterCodes.t:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.y && array[startIndex + 2] === TypeScript.CharacterCodes.p && array[startIndex + 3] === TypeScript.CharacterCodes.e && array[startIndex + 4] === TypeScript.CharacterCodes.o && array[startIndex + 5] === TypeScript.CharacterCodes.f) ? TypeScript.SyntaxKind.TypeOfKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.e:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.x && array[startIndex + 2] === TypeScript.CharacterCodes.p && array[startIndex + 3] === TypeScript.CharacterCodes.o && array[startIndex + 4] === TypeScript.CharacterCodes.r && array[startIndex + 5] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.ExportKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.i:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.m && array[startIndex + 2] === TypeScript.CharacterCodes.p && array[startIndex + 3] === TypeScript.CharacterCodes.o && array[startIndex + 4] === TypeScript.CharacterCodes.r && array[startIndex + 5] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.ImportKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.p:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.u && array[startIndex + 2] === TypeScript.CharacterCodes.b && array[startIndex + 3] === TypeScript.CharacterCodes.l && array[startIndex + 4] === TypeScript.CharacterCodes.i && array[startIndex + 5] === TypeScript.CharacterCodes.c) ? TypeScript.SyntaxKind.PublicKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.m:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.o && array[startIndex + 2] === TypeScript.CharacterCodes.d && array[startIndex + 3] === TypeScript.CharacterCodes.u && array[startIndex + 4] === TypeScript.CharacterCodes.l && array[startIndex + 5] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.ModuleKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.n:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.u && array[startIndex + 2] === TypeScript.CharacterCodes.m && array[startIndex + 3] === TypeScript.CharacterCodes.b && array[startIndex + 4] === TypeScript.CharacterCodes.e && array[startIndex + 5] === TypeScript.CharacterCodes.r) ? TypeScript.SyntaxKind.NumberKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 7:
                    switch (array[startIndex]) {
                        case TypeScript.CharacterCodes.d:
                            switch (array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.e:
                                    switch (array[startIndex + 2]) {
                                        case TypeScript.CharacterCodes.f:
                                            return (array[startIndex + 3] === TypeScript.CharacterCodes.a && array[startIndex + 4] === TypeScript.CharacterCodes.u && array[startIndex + 5] === TypeScript.CharacterCodes.l && array[startIndex + 6] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.DefaultKeyword : TypeScript.SyntaxKind.IdentifierName;
                                        case TypeScript.CharacterCodes.c:
                                            return (array[startIndex + 3] === TypeScript.CharacterCodes.l && array[startIndex + 4] === TypeScript.CharacterCodes.a && array[startIndex + 5] === TypeScript.CharacterCodes.r && array[startIndex + 6] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.DeclareKeyword : TypeScript.SyntaxKind.IdentifierName;
                                        default:
                                            return TypeScript.SyntaxKind.IdentifierName;
                                    }
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        case TypeScript.CharacterCodes.f:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.i && array[startIndex + 2] === TypeScript.CharacterCodes.n && array[startIndex + 3] === TypeScript.CharacterCodes.a && array[startIndex + 4] === TypeScript.CharacterCodes.l && array[startIndex + 5] === TypeScript.CharacterCodes.l && array[startIndex + 6] === TypeScript.CharacterCodes.y) ? TypeScript.SyntaxKind.FinallyKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.e:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.x && array[startIndex + 2] === TypeScript.CharacterCodes.t && array[startIndex + 3] === TypeScript.CharacterCodes.e && array[startIndex + 4] === TypeScript.CharacterCodes.n && array[startIndex + 5] === TypeScript.CharacterCodes.d && array[startIndex + 6] === TypeScript.CharacterCodes.s) ? TypeScript.SyntaxKind.ExtendsKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.p:
                            switch (array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.a:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.c && array[startIndex + 3] === TypeScript.CharacterCodes.k && array[startIndex + 4] === TypeScript.CharacterCodes.a && array[startIndex + 5] === TypeScript.CharacterCodes.g && array[startIndex + 6] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.PackageKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.r:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.i && array[startIndex + 3] === TypeScript.CharacterCodes.v && array[startIndex + 4] === TypeScript.CharacterCodes.a && array[startIndex + 5] === TypeScript.CharacterCodes.t && array[startIndex + 6] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.PrivateKeyword : TypeScript.SyntaxKind.IdentifierName;
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        case TypeScript.CharacterCodes.b:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.o && array[startIndex + 2] === TypeScript.CharacterCodes.o && array[startIndex + 3] === TypeScript.CharacterCodes.l && array[startIndex + 4] === TypeScript.CharacterCodes.e && array[startIndex + 5] === TypeScript.CharacterCodes.a && array[startIndex + 6] === TypeScript.CharacterCodes.n) ? TypeScript.SyntaxKind.BooleanKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.r:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.q && array[startIndex + 3] === TypeScript.CharacterCodes.u && array[startIndex + 4] === TypeScript.CharacterCodes.i && array[startIndex + 5] === TypeScript.CharacterCodes.r && array[startIndex + 6] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.RequireKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 8:
                    switch (array[startIndex]) {
                        case TypeScript.CharacterCodes.c:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.o && array[startIndex + 2] === TypeScript.CharacterCodes.n && array[startIndex + 3] === TypeScript.CharacterCodes.t && array[startIndex + 4] === TypeScript.CharacterCodes.i && array[startIndex + 5] === TypeScript.CharacterCodes.n && array[startIndex + 6] === TypeScript.CharacterCodes.u && array[startIndex + 7] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.ContinueKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.d:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.b && array[startIndex + 3] === TypeScript.CharacterCodes.u && array[startIndex + 4] === TypeScript.CharacterCodes.g && array[startIndex + 5] === TypeScript.CharacterCodes.g && array[startIndex + 6] === TypeScript.CharacterCodes.e && array[startIndex + 7] === TypeScript.CharacterCodes.r) ? TypeScript.SyntaxKind.DebuggerKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.f:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.u && array[startIndex + 2] === TypeScript.CharacterCodes.n && array[startIndex + 3] === TypeScript.CharacterCodes.c && array[startIndex + 4] === TypeScript.CharacterCodes.t && array[startIndex + 5] === TypeScript.CharacterCodes.i && array[startIndex + 6] === TypeScript.CharacterCodes.o && array[startIndex + 7] === TypeScript.CharacterCodes.n) ? TypeScript.SyntaxKind.FunctionKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 9:
                    switch (array[startIndex]) {
                        case TypeScript.CharacterCodes.i:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.n && array[startIndex + 2] === TypeScript.CharacterCodes.t && array[startIndex + 3] === TypeScript.CharacterCodes.e && array[startIndex + 4] === TypeScript.CharacterCodes.r && array[startIndex + 5] === TypeScript.CharacterCodes.f && array[startIndex + 6] === TypeScript.CharacterCodes.a && array[startIndex + 7] === TypeScript.CharacterCodes.c && array[startIndex + 8] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.InterfaceKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.p:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.r && array[startIndex + 2] === TypeScript.CharacterCodes.o && array[startIndex + 3] === TypeScript.CharacterCodes.t && array[startIndex + 4] === TypeScript.CharacterCodes.e && array[startIndex + 5] === TypeScript.CharacterCodes.c && array[startIndex + 6] === TypeScript.CharacterCodes.t && array[startIndex + 7] === TypeScript.CharacterCodes.e && array[startIndex + 8] === TypeScript.CharacterCodes.d) ? TypeScript.SyntaxKind.ProtectedKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 10:
                    switch (array[startIndex]) {
                        case TypeScript.CharacterCodes.i:
                            switch (array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.n:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.s && array[startIndex + 3] === TypeScript.CharacterCodes.t && array[startIndex + 4] === TypeScript.CharacterCodes.a && array[startIndex + 5] === TypeScript.CharacterCodes.n && array[startIndex + 6] === TypeScript.CharacterCodes.c && array[startIndex + 7] === TypeScript.CharacterCodes.e && array[startIndex + 8] === TypeScript.CharacterCodes.o && array[startIndex + 9] === TypeScript.CharacterCodes.f) ? TypeScript.SyntaxKind.InstanceOfKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.m:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.p && array[startIndex + 3] === TypeScript.CharacterCodes.l && array[startIndex + 4] === TypeScript.CharacterCodes.e && array[startIndex + 5] === TypeScript.CharacterCodes.m && array[startIndex + 6] === TypeScript.CharacterCodes.e && array[startIndex + 7] === TypeScript.CharacterCodes.n && array[startIndex + 8] === TypeScript.CharacterCodes.t && array[startIndex + 9] === TypeScript.CharacterCodes.s) ? TypeScript.SyntaxKind.ImplementsKeyword : TypeScript.SyntaxKind.IdentifierName;
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 11:
                    return (array[startIndex] === TypeScript.CharacterCodes.c && array[startIndex + 1] === TypeScript.CharacterCodes.o && array[startIndex + 2] === TypeScript.CharacterCodes.n && array[startIndex + 3] === TypeScript.CharacterCodes.s && array[startIndex + 4] === TypeScript.CharacterCodes.t && array[startIndex + 5] === TypeScript.CharacterCodes.r && array[startIndex + 6] === TypeScript.CharacterCodes.u && array[startIndex + 7] === TypeScript.CharacterCodes.c && array[startIndex + 8] === TypeScript.CharacterCodes.t && array[startIndex + 9] === TypeScript.CharacterCodes.o && array[startIndex + 10] === TypeScript.CharacterCodes.r) ? TypeScript.SyntaxKind.ConstructorKeyword : TypeScript.SyntaxKind.IdentifierName;
                default:
                    return TypeScript.SyntaxKind.IdentifierName;
            }
        };
        return ScannerUtilities;
    }());
    TypeScript.ScannerUtilities = ScannerUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        var EmptySeparatedSyntaxList = (function () {
            function EmptySeparatedSyntaxList() {
            }
            EmptySeparatedSyntaxList.prototype.kind = function () {
                return TypeScript.SyntaxKind.SeparatedList;
            };
            EmptySeparatedSyntaxList.prototype.isNode = function () {
                return false;
            };
            EmptySeparatedSyntaxList.prototype.isToken = function () {
                return false;
            };
            EmptySeparatedSyntaxList.prototype.isList = function () {
                return false;
            };
            EmptySeparatedSyntaxList.prototype.isSeparatedList = function () {
                return true;
            };
            EmptySeparatedSyntaxList.prototype.toJSON = function (key) {
                return [];
            };
            EmptySeparatedSyntaxList.prototype.childCount = function () {
                return 0;
            };
            EmptySeparatedSyntaxList.prototype.nonSeparatorCount = function () {
                return 0;
            };
            EmptySeparatedSyntaxList.prototype.separatorCount = function () {
                return 0;
            };
            EmptySeparatedSyntaxList.prototype.toArray = function () {
                return [];
            };
            EmptySeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                return [];
            };
            EmptySeparatedSyntaxList.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            EmptySeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            EmptySeparatedSyntaxList.prototype.separatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            EmptySeparatedSyntaxList.prototype.collectTextElements = function (elements) {
            };
            EmptySeparatedSyntaxList.prototype.firstToken = function () {
                return null;
            };
            EmptySeparatedSyntaxList.prototype.lastToken = function () {
                return null;
            };
            EmptySeparatedSyntaxList.prototype.fullWidth = function () {
                return 0;
            };
            EmptySeparatedSyntaxList.prototype.fullText = function () {
                return "";
            };
            EmptySeparatedSyntaxList.prototype.width = function () {
                return 0;
            };
            EmptySeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            EmptySeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return false;
            };
            EmptySeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                throw TypeScript.Errors.invalidOperation();
            };
            EmptySeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
            };
            EmptySeparatedSyntaxList.prototype.leadingTrivia = function () {
                return Syntax.emptyTriviaList;
            };
            EmptySeparatedSyntaxList.prototype.trailingTrivia = function () {
                return Syntax.emptyTriviaList;
            };
            EmptySeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            EmptySeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            return EmptySeparatedSyntaxList;
        }());
        Syntax.emptySeparatedList = new EmptySeparatedSyntaxList();
        var SingletonSeparatedSyntaxList = (function () {
            function SingletonSeparatedSyntaxList(item) {
                this.item = item;
            }
            SingletonSeparatedSyntaxList.prototype.toJSON = function (key) {
                return [this.item];
            };
            SingletonSeparatedSyntaxList.prototype.kind = function () { return TypeScript.SyntaxKind.SeparatedList; };
            SingletonSeparatedSyntaxList.prototype.isNode = function () { return false; };
            SingletonSeparatedSyntaxList.prototype.isToken = function () { return false; };
            SingletonSeparatedSyntaxList.prototype.isList = function () { return false; };
            SingletonSeparatedSyntaxList.prototype.isSeparatedList = function () { return true; };
            SingletonSeparatedSyntaxList.prototype.childCount = function () { return 1; };
            SingletonSeparatedSyntaxList.prototype.nonSeparatorCount = function () { return 1; };
            SingletonSeparatedSyntaxList.prototype.separatorCount = function () { return 0; };
            SingletonSeparatedSyntaxList.prototype.toArray = function () { return [this.item]; };
            SingletonSeparatedSyntaxList.prototype.toNonSeparatorArray = function () { return [this.item]; };
            SingletonSeparatedSyntaxList.prototype.childAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.item;
            };
            SingletonSeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.item;
            };
            SingletonSeparatedSyntaxList.prototype.separatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            SingletonSeparatedSyntaxList.prototype.collectTextElements = function (elements) {
                this.item.collectTextElements(elements);
            };
            SingletonSeparatedSyntaxList.prototype.firstToken = function () {
                return this.item.firstToken();
            };
            SingletonSeparatedSyntaxList.prototype.lastToken = function () {
                return this.item.lastToken();
            };
            SingletonSeparatedSyntaxList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };
            SingletonSeparatedSyntaxList.prototype.width = function () {
                return this.item.width();
            };
            SingletonSeparatedSyntaxList.prototype.fullText = function () {
                return this.item.fullText();
            };
            SingletonSeparatedSyntaxList.prototype.leadingTrivia = function () {
                return this.item.leadingTrivia();
            };
            SingletonSeparatedSyntaxList.prototype.trailingTrivia = function () {
                return this.item.trailingTrivia();
            };
            SingletonSeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.item.leadingTriviaWidth();
            };
            SingletonSeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.item.trailingTriviaWidth();
            };
            SingletonSeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                return this.item.isTypeScriptSpecific();
            };
            SingletonSeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return this.item.isIncrementallyUnusable();
            };
            SingletonSeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                return this.item.findTokenInternal(new TypeScript.PositionedSeparatedList(parent, this, fullStart), position, fullStart);
            };
            SingletonSeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
                array.splice(index, 0, this.item);
            };
            return SingletonSeparatedSyntaxList;
        }());
        var NormalSeparatedSyntaxList = (function () {
            function NormalSeparatedSyntaxList(elements) {
                this._data = 0;
                this.elements = elements;
            }
            NormalSeparatedSyntaxList.prototype.kind = function () { return TypeScript.SyntaxKind.SeparatedList; };
            NormalSeparatedSyntaxList.prototype.isToken = function () { return false; };
            NormalSeparatedSyntaxList.prototype.isNode = function () { return false; };
            NormalSeparatedSyntaxList.prototype.isList = function () { return false; };
            NormalSeparatedSyntaxList.prototype.isSeparatedList = function () { return true; };
            NormalSeparatedSyntaxList.prototype.toJSON = function (key) { return this.elements; };
            NormalSeparatedSyntaxList.prototype.childCount = function () { return this.elements.length; };
            NormalSeparatedSyntaxList.prototype.nonSeparatorCount = function () { return TypeScript.IntegerUtilities.integerDivide(this.elements.length + 1, 2); };
            NormalSeparatedSyntaxList.prototype.separatorCount = function () { return TypeScript.IntegerUtilities.integerDivide(this.elements.length, 2); };
            NormalSeparatedSyntaxList.prototype.toArray = function () { return this.elements.slice(0); };
            NormalSeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                var result = [];
                for (var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                    result.push(this.nonSeparatorAt(i));
                }
                return result;
            };
            NormalSeparatedSyntaxList.prototype.childAt = function (index) {
                if (index < 0 || index >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.elements[index];
            };
            NormalSeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                var value = index * 2;
                if (value < 0 || value >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.elements[value];
            };
            NormalSeparatedSyntaxList.prototype.separatorAt = function (index) {
                var value = index * 2 + 1;
                if (value < 0 || value >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.elements[value];
            };
            NormalSeparatedSyntaxList.prototype.firstToken = function () {
                var token;
                for (var i = 0, n = this.elements.length; i < n; i++) {
                    if (i % 2 === 0) {
                        var nodeOrToken = this.elements[i];
                        token = nodeOrToken.firstToken();
                        if (token !== null) {
                            return token;
                        }
                    }
                    else {
                        token = this.elements[i];
                        if (token.width() > 0) {
                            return token;
                        }
                    }
                }
                return null;
            };
            NormalSeparatedSyntaxList.prototype.lastToken = function () {
                var token;
                for (var i = this.elements.length - 1; i >= 0; i--) {
                    if (i % 2 === 0) {
                        var nodeOrToken = this.elements[i];
                        token = nodeOrToken.lastToken();
                        if (token !== null) {
                            return token;
                        }
                    }
                    else {
                        token = this.elements[i];
                        if (token.width() > 0) {
                            return token;
                        }
                    }
                }
                return null;
            };
            NormalSeparatedSyntaxList.prototype.fullText = function () {
                var elements = [];
                this.collectTextElements(elements);
                return elements.join("");
            };
            NormalSeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                for (var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                    if (this.nonSeparatorAt(i).isTypeScriptSpecific()) {
                        return true;
                    }
                }
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return (this.data() & TypeScript.SyntaxConstants.NodeIncrementallyUnusableMask) !== 0;
            };
            NormalSeparatedSyntaxList.prototype.fullWidth = function () {
                return this.data() >>> TypeScript.SyntaxConstants.NodeFullWidthShift;
            };
            NormalSeparatedSyntaxList.prototype.width = function () {
                var fullWidth = this.fullWidth();
                return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
            };
            NormalSeparatedSyntaxList.prototype.leadingTrivia = function () {
                return this.firstToken().leadingTrivia();
            };
            NormalSeparatedSyntaxList.prototype.trailingTrivia = function () {
                return this.lastToken().trailingTrivia();
            };
            NormalSeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.firstToken().leadingTriviaWidth();
            };
            NormalSeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.lastToken().trailingTriviaWidth();
            };
            NormalSeparatedSyntaxList.prototype.computeData = function () {
                var fullWidth = 0;
                var isIncrementallyUnusable = false;
                for (var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];
                    var childWidth = element.fullWidth();
                    fullWidth += childWidth;
                    isIncrementallyUnusable = isIncrementallyUnusable || element.isIncrementallyUnusable();
                }
                return (fullWidth << TypeScript.SyntaxConstants.NodeFullWidthShift)
                    | (isIncrementallyUnusable ? TypeScript.SyntaxConstants.NodeIncrementallyUnusableMask : 0)
                    | TypeScript.SyntaxConstants.NodeDataComputed;
            };
            NormalSeparatedSyntaxList.prototype.data = function () {
                if ((this._data & TypeScript.SyntaxConstants.NodeDataComputed) === 0) {
                    this._data = this.computeData();
                }
                return this._data;
            };
            NormalSeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                parent = new TypeScript.PositionedSeparatedList(parent, this, fullStart);
                for (var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];
                    var childWidth = element.fullWidth();
                    if (position < childWidth) {
                        return element.findTokenInternal(parent, position, fullStart);
                    }
                    position -= childWidth;
                    fullStart += childWidth;
                }
                throw TypeScript.Errors.invalidOperation();
            };
            NormalSeparatedSyntaxList.prototype.collectTextElements = function (elements) {
                for (var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];
                    element.collectTextElements(elements);
                }
            };
            NormalSeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
                if (index === 0) {
                    RT.applyVariadic(array, "unshift", this.elements);
                }
                else {
                    RT.applyVariadic(array, "splice", [index, 0].concat(this.elements));
                }
            };
            return NormalSeparatedSyntaxList;
        }());
        function separatedList(nodes) {
            return separatedListAndValidate(nodes, false);
        }
        Syntax.separatedList = separatedList;
        function separatedListAndValidate(nodes, validate) {
            if (nodes === undefined || nodes === null || nodes.length === 0) {
                return Syntax.emptySeparatedList;
            }
            if (validate) {
                for (var i = 0; i < nodes.length; i++) {
                    var item = nodes[i];
                    if (i % 2 === 1) {
                    }
                }
            }
            if (nodes.length === 1) {
                return new SingletonSeparatedSyntaxList(nodes[0]);
            }
            return new NormalSeparatedSyntaxList(nodes);
        }
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        function emptySourceUnit() {
            return Syntax.normalModeFactory.sourceUnit(Syntax.emptyList, Syntax.token(TypeScript.SyntaxKind.EndOfFileToken, { text: "" }));
        }
        Syntax.emptySourceUnit = emptySourceUnit;
        function getStandaloneExpression(positionedToken) {
            var token = positionedToken.token();
            if (positionedToken !== null && positionedToken.kind() === TypeScript.SyntaxKind.IdentifierName) {
                var parentPositionedNode = positionedToken.containingNode();
                var parentNode = parentPositionedNode.node();
                if (parentNode.kind() === TypeScript.SyntaxKind.QualifiedName && parentNode.right === token) {
                    return parentPositionedNode;
                }
                else if (parentNode.kind() === TypeScript.SyntaxKind.MemberAccessExpression && parentNode.name === token) {
                    return parentPositionedNode;
                }
            }
            return positionedToken;
        }
        Syntax.getStandaloneExpression = getStandaloneExpression;
        function isInModuleOrTypeContext(positionedToken) {
            if (positionedToken !== null) {
                var positionedNodeOrToken = Syntax.getStandaloneExpression(positionedToken);
                var parent = positionedNodeOrToken.containingNode();
                if (parent !== null) {
                    switch (parent.kind()) {
                        case TypeScript.SyntaxKind.ModuleNameModuleReference:
                            return true;
                        case TypeScript.SyntaxKind.QualifiedName:
                            return true;
                        default:
                            return isInTypeOnlyContext(positionedToken);
                    }
                }
            }
            return false;
        }
        Syntax.isInModuleOrTypeContext = isInModuleOrTypeContext;
        function isInTypeOnlyContext(positionedToken) {
            var positionedNodeOrToken = Syntax.getStandaloneExpression(positionedToken);
            var positionedParent = positionedNodeOrToken.containingNode();
            var parent = positionedParent.node();
            var nodeOrToken = positionedNodeOrToken.nodeOrToken();
            if (parent !== null) {
                switch (parent.kind()) {
                    case TypeScript.SyntaxKind.ArrayType:
                        return parent.type === nodeOrToken;
                    case TypeScript.SyntaxKind.TupleType:
                        return parent.type === nodeOrToken;
                    case TypeScript.SyntaxKind.CastExpression:
                        return parent.type === nodeOrToken;
                    case TypeScript.SyntaxKind.TypeAnnotation:
                    case TypeScript.SyntaxKind.ExtendsHeritageClause:
                    case TypeScript.SyntaxKind.ImplementsHeritageClause:
                    case TypeScript.SyntaxKind.TypeArgumentList:
                        return true;
                }
            }
            return false;
        }
        Syntax.isInTypeOnlyContext = isInTypeOnlyContext;
        function childOffset(parent, child) {
            var offset = 0;
            for (var i = 0, n = parent.childCount(); i < n; i++) {
                var current = parent.childAt(i);
                if (current === child) {
                    return offset;
                }
                if (current !== null) {
                    offset += current.fullWidth();
                }
            }
            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.childOffset = childOffset;
        function childOffsetAt(parent, index) {
            var offset = 0;
            for (var i = 0; i < index; i++) {
                var current = parent.childAt(i);
                if (current !== null) {
                    offset += current.fullWidth();
                }
            }
            return offset;
        }
        Syntax.childOffsetAt = childOffsetAt;
        function childIndex(parent, child) {
            for (var i = 0, n = parent.childCount(); i < n; i++) {
                var current = parent.childAt(i);
                if (current === child) {
                    return i;
                }
            }
            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.childIndex = childIndex;
        function nodeStructuralEquals(node1, node2) {
            if (node1 === null) {
                return node2 === null;
            }
            return node1.structuralEquals(node2);
        }
        Syntax.nodeStructuralEquals = nodeStructuralEquals;
        function nodeOrTokenStructuralEquals(node1, node2) {
            if (node1 === node2) {
                return true;
            }
            if (node1 === null || node2 === null) {
                return false;
            }
            if (node1.isToken()) {
                return node2.isToken() ? tokenStructuralEquals(node1, node2) : false;
            }
            return node2.isNode() ? nodeStructuralEquals(node1, node2) : false;
        }
        Syntax.nodeOrTokenStructuralEquals = nodeOrTokenStructuralEquals;
        function tokenStructuralEquals(token1, token2) {
            if (token1 === token2) {
                return true;
            }
            if (token1 === null || token2 === null) {
                return false;
            }
            return token1.kind() === token2.kind() &&
                token1.width() === token2.width() &&
                token1.fullWidth() === token2.fullWidth() &&
                token1.text() === token2.text() &&
                Syntax.triviaListStructuralEquals(token1.leadingTrivia(), token2.leadingTrivia()) &&
                Syntax.triviaListStructuralEquals(token1.trailingTrivia(), token2.trailingTrivia());
        }
        Syntax.tokenStructuralEquals = tokenStructuralEquals;
        function triviaListStructuralEquals(triviaList1, triviaList2) {
            if (triviaList1.count() !== triviaList2.count()) {
                return false;
            }
            for (var i = 0, n = triviaList1.count(); i < n; i++) {
                if (!Syntax.triviaStructuralEquals(triviaList1.syntaxTriviaAt(i), triviaList2.syntaxTriviaAt(i))) {
                    return false;
                }
            }
            return true;
        }
        Syntax.triviaListStructuralEquals = triviaListStructuralEquals;
        function triviaStructuralEquals(trivia1, trivia2) {
            return trivia1.kind() === trivia2.kind() &&
                trivia1.fullWidth() === trivia2.fullWidth() &&
                trivia1.fullText() === trivia2.fullText();
        }
        Syntax.triviaStructuralEquals = triviaStructuralEquals;
        function listStructuralEquals(list1, list2) {
            if (list1.childCount() !== list2.childCount()) {
                return false;
            }
            for (var i = 0, n = list1.childCount(); i < n; i++) {
                var child1 = list1.childAt(i);
                var child2 = list2.childAt(i);
                if (!Syntax.nodeOrTokenStructuralEquals(child1, child2)) {
                    return false;
                }
            }
            return true;
        }
        Syntax.listStructuralEquals = listStructuralEquals;
        function separatedListStructuralEquals(list1, list2) {
            if (list1.childCount() !== list2.childCount()) {
                return false;
            }
            for (var i = 0, n = list1.childCount(); i < n; i++) {
                var element1 = list1.childAt(i);
                var element2 = list2.childAt(i);
                if (!Syntax.nodeOrTokenStructuralEquals(element1, element2)) {
                    return false;
                }
            }
            return true;
        }
        Syntax.separatedListStructuralEquals = separatedListStructuralEquals;
        function elementStructuralEquals(element1, element2) {
            if (element1 === element2) {
                return true;
            }
            if (element1 === null || element2 === null) {
                return false;
            }
            if (element2.kind() !== element2.kind()) {
                return false;
            }
            if (element1.isToken()) {
                return tokenStructuralEquals(element1, element2);
            }
            else if (element1.isNode()) {
                return nodeStructuralEquals(element1, element2);
            }
            else if (element1.isList()) {
                return listStructuralEquals(element1, element2);
            }
            else if (element1.isSeparatedList()) {
                return separatedListStructuralEquals(element1, element2);
            }
            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.elementStructuralEquals = elementStructuralEquals;
        function identifierName(text, info) {
            if (info === void 0) { info = null; }
            return Syntax.identifier(text);
        }
        Syntax.identifierName = identifierName;
        function trueExpression() {
            return Syntax.token(TypeScript.SyntaxKind.TrueKeyword);
        }
        Syntax.trueExpression = trueExpression;
        function falseExpression() {
            return Syntax.token(TypeScript.SyntaxKind.FalseKeyword);
        }
        Syntax.falseExpression = falseExpression;
        function numericLiteralExpression(text) {
            return Syntax.token(TypeScript.SyntaxKind.NumericLiteral, { text: text });
        }
        Syntax.numericLiteralExpression = numericLiteralExpression;
        function stringLiteralExpression(text) {
            return Syntax.token(TypeScript.SyntaxKind.StringLiteral, { text: text });
        }
        Syntax.stringLiteralExpression = stringLiteralExpression;
        function isSuperInvocationExpression(node) {
            return node.kind() === TypeScript.SyntaxKind.InvocationExpression &&
                node.expression.kind() === TypeScript.SyntaxKind.SuperKeyword;
        }
        Syntax.isSuperInvocationExpression = isSuperInvocationExpression;
        function isSuperInvocationExpressionStatement(node) {
            return node.kind() === TypeScript.SyntaxKind.ExpressionStatement &&
                isSuperInvocationExpression(node.expression);
        }
        Syntax.isSuperInvocationExpressionStatement = isSuperInvocationExpressionStatement;
        function isSuperMemberAccessExpression(node) {
            return node.kind() === TypeScript.SyntaxKind.MemberAccessExpression &&
                node.expression.kind() === TypeScript.SyntaxKind.SuperKeyword;
        }
        Syntax.isSuperMemberAccessExpression = isSuperMemberAccessExpression;
        function isSuperMemberAccessInvocationExpression(node) {
            return node.kind() === TypeScript.SyntaxKind.InvocationExpression &&
                isSuperMemberAccessExpression(node.expression);
        }
        Syntax.isSuperMemberAccessInvocationExpression = isSuperMemberAccessInvocationExpression;
        function assignmentExpression(left, token, right) {
            return Syntax.normalModeFactory.binaryExpression(TypeScript.SyntaxKind.AssignmentExpression, left, token, right);
        }
        Syntax.assignmentExpression = assignmentExpression;
        function nodeHasSkippedOrMissingTokens(node) {
            for (var i = 0; i < node.childCount(); i++) {
                var child = node.childAt(i);
                if (child !== null && child.isToken()) {
                    var token = child;
                    if (token.hasSkippedToken() || (token.width() === 0 && token.kind() !== TypeScript.SyntaxKind.EndOfFileToken)) {
                        return true;
                    }
                }
            }
            return false;
        }
        Syntax.nodeHasSkippedOrMissingTokens = nodeHasSkippedOrMissingTokens;
        function isUnterminatedStringLiteral(token) {
            if (token && token.kind() === TypeScript.SyntaxKind.StringLiteral) {
                var text = token.text();
                return text.length < 2 || text.charCodeAt(text.length - 1) !== text.charCodeAt(0);
            }
            return false;
        }
        Syntax.isUnterminatedStringLiteral = isUnterminatedStringLiteral;
        function isUnterminatedMultilineCommentTrivia(trivia) {
            if (trivia && trivia.kind() === TypeScript.SyntaxKind.MultiLineCommentTrivia) {
                var text = trivia.fullText();
                return text.length < 4 || text.substring(text.length - 2) !== "*/";
            }
            return false;
        }
        Syntax.isUnterminatedMultilineCommentTrivia = isUnterminatedMultilineCommentTrivia;
        function isEntirelyInsideCommentTrivia(trivia, fullStart, position) {
            if (trivia && trivia.isComment() && position > fullStart) {
                var end = fullStart + trivia.fullWidth();
                if (position < end) {
                    return true;
                }
                else if (position === end) {
                    return trivia.kind() === TypeScript.SyntaxKind.SingleLineCommentTrivia || isUnterminatedMultilineCommentTrivia(trivia);
                }
            }
            return false;
        }
        Syntax.isEntirelyInsideCommentTrivia = isEntirelyInsideCommentTrivia;
        function isEntirelyInsideComment(sourceUnit, position) {
            var positionedToken = sourceUnit.findToken(position);
            var fullStart = positionedToken.fullStart();
            var triviaList = null;
            var lastTriviaBeforeToken = null;
            if (positionedToken.kind() === TypeScript.SyntaxKind.EndOfFileToken) {
                if (positionedToken.token().hasLeadingTrivia()) {
                    triviaList = positionedToken.token().leadingTrivia();
                }
                else {
                    positionedToken = positionedToken.previousToken();
                    if (positionedToken) {
                        if (positionedToken && positionedToken.token().hasTrailingTrivia()) {
                            triviaList = positionedToken.token().trailingTrivia();
                            fullStart = positionedToken.end();
                        }
                    }
                }
            }
            else {
                if (position <= (fullStart + positionedToken.token().leadingTriviaWidth())) {
                    triviaList = positionedToken.token().leadingTrivia();
                }
                else if (position >= (fullStart + positionedToken.token().width())) {
                    triviaList = positionedToken.token().trailingTrivia();
                    fullStart = positionedToken.end();
                }
            }
            if (triviaList) {
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (position <= fullStart) {
                        break;
                    }
                    else if (position <= fullStart + trivia.fullWidth() && trivia.isComment()) {
                        lastTriviaBeforeToken = trivia;
                        break;
                    }
                    fullStart += trivia.fullWidth();
                }
            }
            return lastTriviaBeforeToken && isEntirelyInsideCommentTrivia(lastTriviaBeforeToken, fullStart, position);
        }
        Syntax.isEntirelyInsideComment = isEntirelyInsideComment;
        function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit, position) {
            var positionedToken = sourceUnit.findToken(position);
            if (positionedToken) {
                if (positionedToken.kind() === TypeScript.SyntaxKind.EndOfFileToken) {
                    positionedToken = positionedToken.previousToken();
                    return positionedToken && positionedToken.token().trailingTriviaWidth() === 0 && isUnterminatedStringLiteral(positionedToken.token());
                }
                else if (position > positionedToken.start()) {
                    return (position < positionedToken.end() && (positionedToken.kind() === TypeScript.SyntaxKind.StringLiteral || positionedToken.kind() === TypeScript.SyntaxKind.RegularExpressionLiteral)) ||
                        (position <= positionedToken.end() && isUnterminatedStringLiteral(positionedToken.token()));
                }
            }
            return false;
        }
        Syntax.isEntirelyInStringOrRegularExpressionLiteral = isEntirelyInStringOrRegularExpressionLiteral;
        function findSkippedTokenInTriviaList(positionedToken, position, lookInLeadingTriviaList) {
            var triviaList = null;
            var fullStart;
            if (lookInLeadingTriviaList) {
                triviaList = positionedToken.token().leadingTrivia();
                fullStart = positionedToken.fullStart();
            }
            else {
                triviaList = positionedToken.token().trailingTrivia();
                fullStart = positionedToken.end();
            }
            if (triviaList && triviaList.hasSkippedToken()) {
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    var triviaWidth = trivia.fullWidth();
                    if (trivia.isSkippedToken() && position >= fullStart && position <= fullStart + triviaWidth) {
                        return new TypeScript.PositionedSkippedToken(positionedToken, trivia.skippedToken(), fullStart);
                    }
                    fullStart += triviaWidth;
                }
            }
            return null;
        }
        function findSkippedTokenOnLeftInTriviaList(positionedToken, position, lookInLeadingTriviaList) {
            var triviaList = null;
            var fullEnd;
            if (lookInLeadingTriviaList) {
                triviaList = positionedToken.token().leadingTrivia();
                fullEnd = positionedToken.fullStart() + triviaList.fullWidth();
            }
            else {
                triviaList = positionedToken.token().trailingTrivia();
                fullEnd = positionedToken.fullEnd();
            }
            if (triviaList && triviaList.hasSkippedToken()) {
                for (var i = triviaList.count() - 1; i >= 0; i--) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    var triviaWidth = trivia.fullWidth();
                    if (trivia.isSkippedToken() && position >= fullEnd) {
                        return new TypeScript.PositionedSkippedToken(positionedToken, trivia.skippedToken(), fullEnd - triviaWidth);
                    }
                    fullEnd -= triviaWidth;
                }
            }
            return null;
        }
        function findSkippedTokenInLeadingTriviaList(positionedToken, position) {
            return findSkippedTokenInTriviaList(positionedToken, position, true);
        }
        Syntax.findSkippedTokenInLeadingTriviaList = findSkippedTokenInLeadingTriviaList;
        function findSkippedTokenInTrailingTriviaList(positionedToken, position) {
            return findSkippedTokenInTriviaList(positionedToken, position, false);
        }
        Syntax.findSkippedTokenInTrailingTriviaList = findSkippedTokenInTrailingTriviaList;
        function findSkippedTokenInPositionedToken(positionedToken, position) {
            var positionInLeadingTriviaList = (position < positionedToken.start());
            return findSkippedTokenInTriviaList(positionedToken, position, positionInLeadingTriviaList);
        }
        Syntax.findSkippedTokenInPositionedToken = findSkippedTokenInPositionedToken;
        function findSkippedTokenOnLeft(positionedToken, position) {
            var positionInLeadingTriviaList = (position < positionedToken.start());
            return findSkippedTokenOnLeftInTriviaList(positionedToken, position, positionInLeadingTriviaList);
        }
        Syntax.findSkippedTokenOnLeft = findSkippedTokenOnLeft;
        function getAncestorOfKind(positionedToken, kind) {
            while (positionedToken && positionedToken.parent()) {
                if (positionedToken.parent().kind() === kind) {
                    return positionedToken.parent();
                }
                positionedToken = positionedToken.parent();
            }
            return null;
        }
        Syntax.getAncestorOfKind = getAncestorOfKind;
        function hasAncestorOfKind(positionedToken, kind) {
            return Syntax.getAncestorOfKind(positionedToken, kind) !== null;
        }
        Syntax.hasAncestorOfKind = hasAncestorOfKind;
        function isIntegerLiteral(expression) {
            if (expression) {
                switch (expression.kind()) {
                    case TypeScript.SyntaxKind.PlusExpression:
                    case TypeScript.SyntaxKind.NegateExpression:
                        expression = expression.operand;
                        return expression.isToken() && TypeScript.IntegerUtilities.isInteger(expression.text());
                    case TypeScript.SyntaxKind.NumericLiteral:
                        var text = expression.text();
                        return TypeScript.IntegerUtilities.isInteger(text) || TypeScript.IntegerUtilities.isHexInteger(text);
                }
            }
            return false;
        }
        Syntax.isIntegerLiteral = isIntegerLiteral;
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        var NormalModeFactory = (function () {
            function NormalModeFactory() {
            }
            NormalModeFactory.prototype.sourceUnit = function (moduleElements, endOfFileToken) {
                return new TypeScript.SourceUnitSyntax(moduleElements, endOfFileToken, false);
            };
            NormalModeFactory.prototype.externalModuleReference = function (requireKeyword, openParenToken, stringLiteral, closeParenToken) {
                return new TypeScript.ExternalModuleReferenceSyntax(requireKeyword, openParenToken, stringLiteral, closeParenToken, false);
            };
            NormalModeFactory.prototype.moduleNameModuleReference = function (moduleName) {
                return new TypeScript.ModuleNameModuleReferenceSyntax(moduleName, false);
            };
            NormalModeFactory.prototype.importDeclaration = function (modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
                return new TypeScript.ImportDeclarationSyntax(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, false);
            };
            NormalModeFactory.prototype.exportAssignment = function (exportKeyword, equalsToken, identifier, semicolonToken) {
                return new TypeScript.ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.classDeclaration = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
                return new TypeScript.ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.interfaceDeclaration = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
                return new TypeScript.InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, false);
            };
            NormalModeFactory.prototype.heritageClause = function (kind, extendsOrImplementsKeyword, typeNames) {
                return new TypeScript.HeritageClauseSyntax(kind, extendsOrImplementsKeyword, typeNames, false);
            };
            NormalModeFactory.prototype.moduleDeclaration = function (modifiers, moduleKeyword, name, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
                return new TypeScript.ModuleDeclarationSyntax(modifiers, moduleKeyword, name, stringLiteral, openBraceToken, moduleElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.functionDeclaration = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
                return new TypeScript.FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.variableStatement = function (modifiers, variableDeclaration, semicolonToken) {
                return new TypeScript.VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, false);
            };
            NormalModeFactory.prototype.variableDeclaration = function (varKeyword, variableDeclarators) {
                return new TypeScript.VariableDeclarationSyntax(varKeyword, variableDeclarators, false);
            };
            NormalModeFactory.prototype.variableDeclarator = function (propertyName, typeAnnotation, equalsValueClause) {
                return new TypeScript.VariableDeclaratorSyntax(propertyName, typeAnnotation, equalsValueClause, false);
            };
            NormalModeFactory.prototype.equalsValueClause = function (equalsToken, value) {
                return new TypeScript.EqualsValueClauseSyntax(equalsToken, value, false);
            };
            NormalModeFactory.prototype.prefixUnaryExpression = function (kind, operatorToken, operand) {
                return new TypeScript.PrefixUnaryExpressionSyntax(kind, operatorToken, operand, false);
            };
            NormalModeFactory.prototype.arrayLiteralExpression = function (openBracketToken, expressions, closeBracketToken) {
                return new TypeScript.ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, false);
            };
            NormalModeFactory.prototype.omittedExpression = function () {
                return new TypeScript.OmittedExpressionSyntax(false);
            };
            NormalModeFactory.prototype.parenthesizedExpression = function (openParenToken, expression, closeParenToken) {
                return new TypeScript.ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, false);
            };
            NormalModeFactory.prototype.simpleArrowFunctionExpression = function (identifier, equalsGreaterThanToken, block, expression) {
                return new TypeScript.SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, block, expression, false);
            };
            NormalModeFactory.prototype.parenthesizedArrowFunctionExpression = function (callSignature, equalsGreaterThanToken, block, expression) {
                return new TypeScript.ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, block, expression, false);
            };
            NormalModeFactory.prototype.qualifiedName = function (left, dotToken, right) {
                return new TypeScript.QualifiedNameSyntax(left, dotToken, right, false);
            };
            NormalModeFactory.prototype.typeArgumentList = function (lessThanToken, typeArguments, greaterThanToken) {
                return new TypeScript.TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, false);
            };
            NormalModeFactory.prototype.constructorType = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, false);
            };
            NormalModeFactory.prototype.functionType = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, false);
            };
            NormalModeFactory.prototype.objectType = function (openBraceToken, typeMembers, closeBraceToken) {
                return new TypeScript.ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, false);
            };
            NormalModeFactory.prototype.arrayType = function (type, openBracketToken, closeBracketToken) {
                return new TypeScript.ArrayTypeSyntax(type, openBracketToken, closeBracketToken, false);
            };
            NormalModeFactory.prototype.genericType = function (name, typeArgumentList) {
                return new TypeScript.GenericTypeSyntax(name, typeArgumentList, false);
            };
            NormalModeFactory.prototype.typeQuery = function (typeOfKeyword, name) {
                return new TypeScript.TypeQuerySyntax(typeOfKeyword, name, false);
            };
            NormalModeFactory.prototype.typeAnnotation = function (colonToken, type) {
                return new TypeScript.TypeAnnotationSyntax(colonToken, type, false);
            };
            NormalModeFactory.prototype.block = function (openBraceToken, statements, closeBraceToken) {
                return new TypeScript.BlockSyntax(openBraceToken, statements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.parameter = function (dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause) {
                return new TypeScript.ParameterSyntax(dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause, false);
            };
            NormalModeFactory.prototype.memberAccessExpression = function (expression, dotToken, name) {
                return new TypeScript.MemberAccessExpressionSyntax(expression, dotToken, name, false);
            };
            NormalModeFactory.prototype.postfixUnaryExpression = function (kind, operand, operatorToken) {
                return new TypeScript.PostfixUnaryExpressionSyntax(kind, operand, operatorToken, false);
            };
            NormalModeFactory.prototype.elementAccessExpression = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
                return new TypeScript.ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, false);
            };
            NormalModeFactory.prototype.invocationExpression = function (expression, argumentList) {
                return new TypeScript.InvocationExpressionSyntax(expression, argumentList, false);
            };
            NormalModeFactory.prototype.argumentList = function (typeArgumentList, openParenToken, args, closeParenToken) {
                return new TypeScript.ArgumentListSyntax(typeArgumentList, openParenToken, args, closeParenToken, false);
            };
            NormalModeFactory.prototype.binaryExpression = function (kind, left, operatorToken, right) {
                return new TypeScript.BinaryExpressionSyntax(kind, left, operatorToken, right, false);
            };
            NormalModeFactory.prototype.conditionalExpression = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
                return new TypeScript.ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, false);
            };
            NormalModeFactory.prototype.constructSignature = function (newKeyword, callSignature) {
                return new TypeScript.ConstructSignatureSyntax(newKeyword, callSignature, false);
            };
            NormalModeFactory.prototype.methodSignature = function (propertyName, questionToken, callSignature) {
                return new TypeScript.MethodSignatureSyntax(propertyName, questionToken, callSignature, false);
            };
            NormalModeFactory.prototype.indexSignature = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
                return new TypeScript.IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, false);
            };
            NormalModeFactory.prototype.propertySignature = function (propertyName, questionToken, typeAnnotation) {
                return new TypeScript.PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, false);
            };
            NormalModeFactory.prototype.callSignature = function (typeParameterList, parameterList, typeAnnotation) {
                return new TypeScript.CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, false);
            };
            NormalModeFactory.prototype.parameterList = function (openParenToken, parameters, closeParenToken) {
                return new TypeScript.ParameterListSyntax(openParenToken, parameters, closeParenToken, false);
            };
            NormalModeFactory.prototype.typeParameterList = function (lessThanToken, typeParameters, greaterThanToken) {
                return new TypeScript.TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, false);
            };
            NormalModeFactory.prototype.typeParameter = function (identifier, constraint) {
                return new TypeScript.TypeParameterSyntax(identifier, constraint, false);
            };
            NormalModeFactory.prototype.constraint = function (extendsKeyword, type) {
                return new TypeScript.ConstraintSyntax(extendsKeyword, type, false);
            };
            NormalModeFactory.prototype.elseClause = function (elseKeyword, statement) {
                return new TypeScript.ElseClauseSyntax(elseKeyword, statement, false);
            };
            NormalModeFactory.prototype.ifStatement = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
                return new TypeScript.IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, false);
            };
            NormalModeFactory.prototype.expressionStatement = function (expression, semicolonToken) {
                return new TypeScript.ExpressionStatementSyntax(expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.constructorDeclaration = function (modifiers, constructorKeyword, parameterList, block, semicolonToken) {
                return new TypeScript.ConstructorDeclarationSyntax(modifiers, constructorKeyword, parameterList, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.memberFunctionDeclaration = function (modifiers, propertyName, callSignature, block, semicolonToken) {
                return new TypeScript.MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.getAccessor = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
                return new TypeScript.GetAccessorSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, false);
            };
            NormalModeFactory.prototype.setAccessor = function (modifiers, setKeyword, propertyName, parameterList, block) {
                return new TypeScript.SetAccessorSyntax(modifiers, setKeyword, propertyName, parameterList, block, false);
            };
            NormalModeFactory.prototype.memberVariableDeclaration = function (modifiers, variableDeclarator, semicolonToken) {
                return new TypeScript.MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, false);
            };
            NormalModeFactory.prototype.indexMemberDeclaration = function (modifiers, indexSignature, semicolonToken) {
                return new TypeScript.IndexMemberDeclarationSyntax(modifiers, indexSignature, semicolonToken, false);
            };
            NormalModeFactory.prototype.throwStatement = function (throwKeyword, expression, semicolonToken) {
                return new TypeScript.ThrowStatementSyntax(throwKeyword, expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.returnStatement = function (returnKeyword, expression, semicolonToken) {
                return new TypeScript.ReturnStatementSyntax(returnKeyword, expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.objectCreationExpression = function (newKeyword, expression, argumentList) {
                return new TypeScript.ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, false);
            };
            NormalModeFactory.prototype.switchStatement = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
                return new TypeScript.SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, false);
            };
            NormalModeFactory.prototype.caseSwitchClause = function (caseKeyword, expression, colonToken, statements) {
                return new TypeScript.CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, false);
            };
            NormalModeFactory.prototype.defaultSwitchClause = function (defaultKeyword, colonToken, statements) {
                return new TypeScript.DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, false);
            };
            NormalModeFactory.prototype.breakStatement = function (breakKeyword, identifier, semicolonToken) {
                return new TypeScript.BreakStatementSyntax(breakKeyword, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.continueStatement = function (continueKeyword, identifier, semicolonToken) {
                return new TypeScript.ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.forStatement = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
                return new TypeScript.ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.forInStatement = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
                return new TypeScript.ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.whileStatement = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.withStatement = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.enumDeclaration = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
                return new TypeScript.EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.enumElement = function (propertyName, equalsValueClause) {
                return new TypeScript.EnumElementSyntax(propertyName, equalsValueClause, false);
            };
            NormalModeFactory.prototype.castExpression = function (lessThanToken, type, greaterThanToken, expression) {
                return new TypeScript.CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, false);
            };
            NormalModeFactory.prototype.objectLiteralExpression = function (openBraceToken, propertyAssignments, closeBraceToken) {
                return new TypeScript.ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, false);
            };
            NormalModeFactory.prototype.simplePropertyAssignment = function (propertyName, colonToken, expression) {
                return new TypeScript.SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, false);
            };
            NormalModeFactory.prototype.functionPropertyAssignment = function (propertyName, callSignature, block) {
                return new TypeScript.FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, false);
            };
            NormalModeFactory.prototype.functionExpression = function (functionKeyword, identifier, callSignature, block) {
                return new TypeScript.FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, false);
            };
            NormalModeFactory.prototype.emptyStatement = function (semicolonToken) {
                return new TypeScript.EmptyStatementSyntax(semicolonToken, false);
            };
            NormalModeFactory.prototype.tryStatement = function (tryKeyword, block, catchClause, finallyClause) {
                return new TypeScript.TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, false);
            };
            NormalModeFactory.prototype.catchClause = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
                return new TypeScript.CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, false);
            };
            NormalModeFactory.prototype.finallyClause = function (finallyKeyword, block) {
                return new TypeScript.FinallyClauseSyntax(finallyKeyword, block, false);
            };
            NormalModeFactory.prototype.labeledStatement = function (identifier, colonToken, statement) {
                return new TypeScript.LabeledStatementSyntax(identifier, colonToken, statement, false);
            };
            NormalModeFactory.prototype.doStatement = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
                return new TypeScript.DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, false);
            };
            NormalModeFactory.prototype.typeOfExpression = function (typeOfKeyword, expression) {
                return new TypeScript.TypeOfExpressionSyntax(typeOfKeyword, expression, false);
            };
            NormalModeFactory.prototype.deleteExpression = function (deleteKeyword, expression) {
                return new TypeScript.DeleteExpressionSyntax(deleteKeyword, expression, false);
            };
            NormalModeFactory.prototype.voidExpression = function (voidKeyword, expression) {
                return new TypeScript.VoidExpressionSyntax(voidKeyword, expression, false);
            };
            NormalModeFactory.prototype.debuggerStatement = function (debuggerKeyword, semicolonToken) {
                return new TypeScript.DebuggerStatementSyntax(debuggerKeyword, semicolonToken, false);
            };
            return NormalModeFactory;
        }());
        Syntax.NormalModeFactory = NormalModeFactory;
        var StrictModeFactory = (function () {
            function StrictModeFactory() {
            }
            StrictModeFactory.prototype.sourceUnit = function (moduleElements, endOfFileToken) {
                return new TypeScript.SourceUnitSyntax(moduleElements, endOfFileToken, true);
            };
            StrictModeFactory.prototype.externalModuleReference = function (requireKeyword, openParenToken, stringLiteral, closeParenToken) {
                return new TypeScript.ExternalModuleReferenceSyntax(requireKeyword, openParenToken, stringLiteral, closeParenToken, true);
            };
            StrictModeFactory.prototype.moduleNameModuleReference = function (moduleName) {
                return new TypeScript.ModuleNameModuleReferenceSyntax(moduleName, true);
            };
            StrictModeFactory.prototype.importDeclaration = function (modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
                return new TypeScript.ImportDeclarationSyntax(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, true);
            };
            StrictModeFactory.prototype.exportAssignment = function (exportKeyword, equalsToken, identifier, semicolonToken) {
                return new TypeScript.ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.classDeclaration = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
                return new TypeScript.ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.interfaceDeclaration = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
                return new TypeScript.InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, true);
            };
            StrictModeFactory.prototype.heritageClause = function (kind, extendsOrImplementsKeyword, typeNames) {
                return new TypeScript.HeritageClauseSyntax(kind, extendsOrImplementsKeyword, typeNames, true);
            };
            StrictModeFactory.prototype.moduleDeclaration = function (modifiers, moduleKeyword, name, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
                return new TypeScript.ModuleDeclarationSyntax(modifiers, moduleKeyword, name, stringLiteral, openBraceToken, moduleElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.functionDeclaration = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
                return new TypeScript.FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.variableStatement = function (modifiers, variableDeclaration, semicolonToken) {
                return new TypeScript.VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, true);
            };
            StrictModeFactory.prototype.variableDeclaration = function (varKeyword, variableDeclarators) {
                return new TypeScript.VariableDeclarationSyntax(varKeyword, variableDeclarators, true);
            };
            StrictModeFactory.prototype.variableDeclarator = function (propertyName, typeAnnotation, equalsValueClause) {
                return new TypeScript.VariableDeclaratorSyntax(propertyName, typeAnnotation, equalsValueClause, true);
            };
            StrictModeFactory.prototype.equalsValueClause = function (equalsToken, value) {
                return new TypeScript.EqualsValueClauseSyntax(equalsToken, value, true);
            };
            StrictModeFactory.prototype.prefixUnaryExpression = function (kind, operatorToken, operand) {
                return new TypeScript.PrefixUnaryExpressionSyntax(kind, operatorToken, operand, true);
            };
            StrictModeFactory.prototype.arrayLiteralExpression = function (openBracketToken, expressions, closeBracketToken) {
                return new TypeScript.ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, true);
            };
            StrictModeFactory.prototype.omittedExpression = function () {
                return new TypeScript.OmittedExpressionSyntax(true);
            };
            StrictModeFactory.prototype.parenthesizedExpression = function (openParenToken, expression, closeParenToken) {
                return new TypeScript.ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, true);
            };
            StrictModeFactory.prototype.simpleArrowFunctionExpression = function (identifier, equalsGreaterThanToken, block, expression) {
                return new TypeScript.SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, block, expression, true);
            };
            StrictModeFactory.prototype.parenthesizedArrowFunctionExpression = function (callSignature, equalsGreaterThanToken, block, expression) {
                return new TypeScript.ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, block, expression, true);
            };
            StrictModeFactory.prototype.qualifiedName = function (left, dotToken, right) {
                return new TypeScript.QualifiedNameSyntax(left, dotToken, right, true);
            };
            StrictModeFactory.prototype.typeArgumentList = function (lessThanToken, typeArguments, greaterThanToken) {
                return new TypeScript.TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, true);
            };
            StrictModeFactory.prototype.constructorType = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, true);
            };
            StrictModeFactory.prototype.functionType = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, true);
            };
            StrictModeFactory.prototype.objectType = function (openBraceToken, typeMembers, closeBraceToken) {
                return new TypeScript.ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, true);
            };
            StrictModeFactory.prototype.arrayType = function (type, openBracketToken, closeBracketToken) {
                return new TypeScript.ArrayTypeSyntax(type, openBracketToken, closeBracketToken, true);
            };
            StrictModeFactory.prototype.genericType = function (name, typeArgumentList) {
                return new TypeScript.GenericTypeSyntax(name, typeArgumentList, true);
            };
            StrictModeFactory.prototype.typeQuery = function (typeOfKeyword, name) {
                return new TypeScript.TypeQuerySyntax(typeOfKeyword, name, true);
            };
            StrictModeFactory.prototype.typeAnnotation = function (colonToken, type) {
                return new TypeScript.TypeAnnotationSyntax(colonToken, type, true);
            };
            StrictModeFactory.prototype.block = function (openBraceToken, statements, closeBraceToken) {
                return new TypeScript.BlockSyntax(openBraceToken, statements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.parameter = function (dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause) {
                return new TypeScript.ParameterSyntax(dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause, true);
            };
            StrictModeFactory.prototype.memberAccessExpression = function (expression, dotToken, name) {
                return new TypeScript.MemberAccessExpressionSyntax(expression, dotToken, name, true);
            };
            StrictModeFactory.prototype.postfixUnaryExpression = function (kind, operand, operatorToken) {
                return new TypeScript.PostfixUnaryExpressionSyntax(kind, operand, operatorToken, true);
            };
            StrictModeFactory.prototype.elementAccessExpression = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
                return new TypeScript.ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, true);
            };
            StrictModeFactory.prototype.invocationExpression = function (expression, argumentList) {
                return new TypeScript.InvocationExpressionSyntax(expression, argumentList, true);
            };
            StrictModeFactory.prototype.argumentList = function (typeArgumentList, openParenToken, args, closeParenToken) {
                return new TypeScript.ArgumentListSyntax(typeArgumentList, openParenToken, args, closeParenToken, true);
            };
            StrictModeFactory.prototype.binaryExpression = function (kind, left, operatorToken, right) {
                return new TypeScript.BinaryExpressionSyntax(kind, left, operatorToken, right, true);
            };
            StrictModeFactory.prototype.conditionalExpression = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
                return new TypeScript.ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, true);
            };
            StrictModeFactory.prototype.constructSignature = function (newKeyword, callSignature) {
                return new TypeScript.ConstructSignatureSyntax(newKeyword, callSignature, true);
            };
            StrictModeFactory.prototype.methodSignature = function (propertyName, questionToken, callSignature) {
                return new TypeScript.MethodSignatureSyntax(propertyName, questionToken, callSignature, true);
            };
            StrictModeFactory.prototype.indexSignature = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
                return new TypeScript.IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, true);
            };
            StrictModeFactory.prototype.propertySignature = function (propertyName, questionToken, typeAnnotation) {
                return new TypeScript.PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, true);
            };
            StrictModeFactory.prototype.callSignature = function (typeParameterList, parameterList, typeAnnotation) {
                return new TypeScript.CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, true);
            };
            StrictModeFactory.prototype.parameterList = function (openParenToken, parameters, closeParenToken) {
                return new TypeScript.ParameterListSyntax(openParenToken, parameters, closeParenToken, true);
            };
            StrictModeFactory.prototype.typeParameterList = function (lessThanToken, typeParameters, greaterThanToken) {
                return new TypeScript.TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, true);
            };
            StrictModeFactory.prototype.typeParameter = function (identifier, constraint) {
                return new TypeScript.TypeParameterSyntax(identifier, constraint, true);
            };
            StrictModeFactory.prototype.constraint = function (extendsKeyword, type) {
                return new TypeScript.ConstraintSyntax(extendsKeyword, type, true);
            };
            StrictModeFactory.prototype.elseClause = function (elseKeyword, statement) {
                return new TypeScript.ElseClauseSyntax(elseKeyword, statement, true);
            };
            StrictModeFactory.prototype.ifStatement = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
                return new TypeScript.IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, true);
            };
            StrictModeFactory.prototype.expressionStatement = function (expression, semicolonToken) {
                return new TypeScript.ExpressionStatementSyntax(expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.constructorDeclaration = function (modifiers, constructorKeyword, parameterList, block, semicolonToken) {
                return new TypeScript.ConstructorDeclarationSyntax(modifiers, constructorKeyword, parameterList, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.memberFunctionDeclaration = function (modifiers, propertyName, callSignature, block, semicolonToken) {
                return new TypeScript.MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.getAccessor = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
                return new TypeScript.GetAccessorSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, true);
            };
            StrictModeFactory.prototype.setAccessor = function (modifiers, setKeyword, propertyName, parameterList, block) {
                return new TypeScript.SetAccessorSyntax(modifiers, setKeyword, propertyName, parameterList, block, true);
            };
            StrictModeFactory.prototype.memberVariableDeclaration = function (modifiers, variableDeclarator, semicolonToken) {
                return new TypeScript.MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, true);
            };
            StrictModeFactory.prototype.indexMemberDeclaration = function (modifiers, indexSignature, semicolonToken) {
                return new TypeScript.IndexMemberDeclarationSyntax(modifiers, indexSignature, semicolonToken, true);
            };
            StrictModeFactory.prototype.throwStatement = function (throwKeyword, expression, semicolonToken) {
                return new TypeScript.ThrowStatementSyntax(throwKeyword, expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.returnStatement = function (returnKeyword, expression, semicolonToken) {
                return new TypeScript.ReturnStatementSyntax(returnKeyword, expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.objectCreationExpression = function (newKeyword, expression, argumentList) {
                return new TypeScript.ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, true);
            };
            StrictModeFactory.prototype.switchStatement = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
                return new TypeScript.SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, true);
            };
            StrictModeFactory.prototype.caseSwitchClause = function (caseKeyword, expression, colonToken, statements) {
                return new TypeScript.CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, true);
            };
            StrictModeFactory.prototype.defaultSwitchClause = function (defaultKeyword, colonToken, statements) {
                return new TypeScript.DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, true);
            };
            StrictModeFactory.prototype.breakStatement = function (breakKeyword, identifier, semicolonToken) {
                return new TypeScript.BreakStatementSyntax(breakKeyword, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.continueStatement = function (continueKeyword, identifier, semicolonToken) {
                return new TypeScript.ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.forStatement = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
                return new TypeScript.ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.forInStatement = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
                return new TypeScript.ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.whileStatement = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.withStatement = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.enumDeclaration = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
                return new TypeScript.EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.enumElement = function (propertyName, equalsValueClause) {
                return new TypeScript.EnumElementSyntax(propertyName, equalsValueClause, true);
            };
            StrictModeFactory.prototype.castExpression = function (lessThanToken, type, greaterThanToken, expression) {
                return new TypeScript.CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, true);
            };
            StrictModeFactory.prototype.objectLiteralExpression = function (openBraceToken, propertyAssignments, closeBraceToken) {
                return new TypeScript.ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, true);
            };
            StrictModeFactory.prototype.simplePropertyAssignment = function (propertyName, colonToken, expression) {
                return new TypeScript.SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, true);
            };
            StrictModeFactory.prototype.functionPropertyAssignment = function (propertyName, callSignature, block) {
                return new TypeScript.FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, true);
            };
            StrictModeFactory.prototype.functionExpression = function (functionKeyword, identifier, callSignature, block) {
                return new TypeScript.FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, true);
            };
            StrictModeFactory.prototype.emptyStatement = function (semicolonToken) {
                return new TypeScript.EmptyStatementSyntax(semicolonToken, true);
            };
            StrictModeFactory.prototype.tryStatement = function (tryKeyword, block, catchClause, finallyClause) {
                return new TypeScript.TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, true);
            };
            StrictModeFactory.prototype.catchClause = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
                return new TypeScript.CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, true);
            };
            StrictModeFactory.prototype.finallyClause = function (finallyKeyword, block) {
                return new TypeScript.FinallyClauseSyntax(finallyKeyword, block, true);
            };
            StrictModeFactory.prototype.labeledStatement = function (identifier, colonToken, statement) {
                return new TypeScript.LabeledStatementSyntax(identifier, colonToken, statement, true);
            };
            StrictModeFactory.prototype.doStatement = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
                return new TypeScript.DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, true);
            };
            StrictModeFactory.prototype.typeOfExpression = function (typeOfKeyword, expression) {
                return new TypeScript.TypeOfExpressionSyntax(typeOfKeyword, expression, true);
            };
            StrictModeFactory.prototype.deleteExpression = function (deleteKeyword, expression) {
                return new TypeScript.DeleteExpressionSyntax(deleteKeyword, expression, true);
            };
            StrictModeFactory.prototype.voidExpression = function (voidKeyword, expression) {
                return new TypeScript.VoidExpressionSyntax(voidKeyword, expression, true);
            };
            StrictModeFactory.prototype.debuggerStatement = function (debuggerKeyword, semicolonToken) {
                return new TypeScript.DebuggerStatementSyntax(debuggerKeyword, semicolonToken, true);
            };
            return StrictModeFactory;
        }());
        Syntax.StrictModeFactory = StrictModeFactory;
        Syntax.normalModeFactory = new NormalModeFactory();
        Syntax.strictModeFactory = new StrictModeFactory();
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxFacts;
    (function (SyntaxFacts) {
        function isDirectivePrologueElement(node) {
            if (node.kind() === TypeScript.SyntaxKind.ExpressionStatement) {
                var expressionStatement = node;
                var expression = expressionStatement.expression;
                if (expression.kind() === TypeScript.SyntaxKind.StringLiteral) {
                    return true;
                }
            }
            return false;
        }
        SyntaxFacts.isDirectivePrologueElement = isDirectivePrologueElement;
        function isUseStrictDirective(node) {
            var expressionStatement = node;
            var stringLiteral = expressionStatement.expression;
            var text = stringLiteral.text();
            return text === '"use strict"' || text === "'use strict'";
        }
        SyntaxFacts.isUseStrictDirective = isUseStrictDirective;
        function isIdentifierNameOrAnyKeyword(token) {
            var tokenKind = token.tokenKind;
            return tokenKind === TypeScript.SyntaxKind.IdentifierName || SyntaxFacts.isAnyKeyword(tokenKind);
        }
        SyntaxFacts.isIdentifierNameOrAnyKeyword = isIdentifierNameOrAnyKeyword;
    })(SyntaxFacts = TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxNode = (function () {
        function SyntaxNode(parsedInStrictMode) {
            this._data = parsedInStrictMode ? TypeScript.SyntaxConstants.NodeParsedInStrictModeMask : 0;
        }
        SyntaxNode.prototype.isNode = function () { return true; };
        SyntaxNode.prototype.isToken = function () { return false; };
        SyntaxNode.prototype.isList = function () { return false; };
        SyntaxNode.prototype.isSeparatedList = function () { return false; };
        SyntaxNode.prototype.kind = function () {
            throw TypeScript.Errors.abstract();
        };
        SyntaxNode.prototype.childCount = function () {
            throw TypeScript.Errors.abstract();
        };
        SyntaxNode.prototype.childAt = function (slot) {
            throw TypeScript.Errors.abstract();
        };
        SyntaxNode.prototype.firstToken = function () {
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);
                if (element !== null) {
                    if (element.fullWidth() > 0 || element.kind() === TypeScript.SyntaxKind.EndOfFileToken) {
                        return element.firstToken();
                    }
                }
            }
            return null;
        };
        SyntaxNode.prototype.lastToken = function () {
            for (var i = this.childCount() - 1; i >= 0; i--) {
                var element = this.childAt(i);
                if (element !== null) {
                    if (element.fullWidth() > 0 || element.kind() === TypeScript.SyntaxKind.EndOfFileToken) {
                        return element.lastToken();
                    }
                }
            }
            return null;
        };
        SyntaxNode.prototype.insertChildrenInto = function (array, index) {
            for (var i = this.childCount() - 1; i >= 0; i--) {
                var element = this.childAt(i);
                if (element !== null) {
                    if (element.isNode() || element.isToken()) {
                        array.splice(index, 0, element);
                    }
                    else if (element.isList()) {
                        element.insertChildrenInto(array, index);
                    }
                    else if (element.isSeparatedList()) {
                        element.insertChildrenInto(array, index);
                    }
                    else {
                        throw TypeScript.Errors.invalidOperation();
                    }
                }
            }
        };
        SyntaxNode.prototype.leadingTrivia = function () {
            var firstToken = this.firstToken();
            return firstToken ? firstToken.leadingTrivia() : TypeScript.Syntax.emptyTriviaList;
        };
        SyntaxNode.prototype.trailingTrivia = function () {
            var lastToken = this.lastToken();
            return lastToken ? lastToken.trailingTrivia() : TypeScript.Syntax.emptyTriviaList;
        };
        SyntaxNode.prototype.toJSON = function (key) {
            var result = {
                kind: TypeScript.SyntaxKind[this.kind()],
                fullWidth: this.fullWidth()
            };
            if (this.isIncrementallyUnusable()) {
                result.isIncrementallyUnusable = true;
            }
            if (this.parsedInStrictMode()) {
                result.parsedInStrictMode = true;
            }
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var value = this.childAt(i);
                if (value) {
                    for (var name in this) {
                        if (value === this[name]) {
                            result[name] = value;
                            break;
                        }
                    }
                }
            }
            return result;
        };
        SyntaxNode.prototype.accept = function (visitor) {
            throw TypeScript.Errors.abstract();
        };
        SyntaxNode.prototype.fullText = function () {
            var elements = [];
            this.collectTextElements(elements);
            return elements.join("");
        };
        SyntaxNode.prototype.collectTextElements = function (elements) {
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);
                if (element !== null) {
                    element.collectTextElements(elements);
                }
            }
        };
        SyntaxNode.prototype.replaceToken = function (token1, token2) {
            if (token1 === token2) {
                return this;
            }
            return this.accept(new TypeScript.SyntaxTokenReplacer(token1, token2));
        };
        SyntaxNode.prototype.withLeadingTrivia = function (trivia) {
            return this.replaceToken(this.firstToken(), this.firstToken().withLeadingTrivia(trivia));
        };
        SyntaxNode.prototype.withTrailingTrivia = function (trivia) {
            return this.replaceToken(this.lastToken(), this.lastToken().withTrailingTrivia(trivia));
        };
        SyntaxNode.prototype.hasLeadingTrivia = function () {
            return this.lastToken().hasLeadingTrivia();
        };
        SyntaxNode.prototype.hasTrailingTrivia = function () {
            return this.lastToken().hasTrailingTrivia();
        };
        SyntaxNode.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        SyntaxNode.prototype.isIncrementallyUnusable = function () {
            return (this.data() & TypeScript.SyntaxConstants.NodeIncrementallyUnusableMask) !== 0;
        };
        SyntaxNode.prototype.parsedInStrictMode = function () {
            return (this.data() & TypeScript.SyntaxConstants.NodeParsedInStrictModeMask) !== 0;
        };
        SyntaxNode.prototype.fullWidth = function () {
            return this.data() >>> TypeScript.SyntaxConstants.NodeFullWidthShift;
        };
        SyntaxNode.prototype.computeData = function () {
            var slotCount = this.childCount();
            var fullWidth = 0;
            var childWidth = 0;
            var isIncrementallyUnusable = ((this._data & TypeScript.SyntaxConstants.NodeIncrementallyUnusableMask) !== 0) || slotCount === 0;
            for (var i = 0, n = slotCount; i < n; i++) {
                var element = this.childAt(i);
                if (element !== null) {
                    childWidth = element.fullWidth();
                    fullWidth += childWidth;
                    if (!isIncrementallyUnusable) {
                        isIncrementallyUnusable = element.isIncrementallyUnusable();
                    }
                }
            }
            return (fullWidth << TypeScript.SyntaxConstants.NodeFullWidthShift)
                | (isIncrementallyUnusable ? TypeScript.SyntaxConstants.NodeIncrementallyUnusableMask : 0)
                | TypeScript.SyntaxConstants.NodeDataComputed;
        };
        SyntaxNode.prototype.data = function () {
            if ((this._data & TypeScript.SyntaxConstants.NodeDataComputed) === 0) {
                this._data |= this.computeData();
            }
            return this._data;
        };
        SyntaxNode.prototype.findToken = function (position, includeSkippedTokens) {
            if (includeSkippedTokens === void 0) { includeSkippedTokens = false; }
            var endOfFileToken = this.tryGetEndOfFileAt(position);
            if (endOfFileToken !== null) {
                return endOfFileToken;
            }
            if (position < 0 || position >= this.fullWidth()) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }
            var positionedToken = this.findTokenInternal(null, position, 0);
            if (includeSkippedTokens) {
                return TypeScript.Syntax.findSkippedTokenInPositionedToken(positionedToken, position) || positionedToken;
            }
            return positionedToken;
        };
        SyntaxNode.prototype.tryGetEndOfFileAt = function (position) {
            if (this.kind() === TypeScript.SyntaxKind.SourceUnit && position === this.fullWidth()) {
                var sourceUnit = this;
                return new TypeScript.PositionedToken(new TypeScript.PositionedNode(null, sourceUnit, 0), sourceUnit.endOfFileToken, sourceUnit.moduleElements.fullWidth());
            }
            return null;
        };
        SyntaxNode.prototype.findTokenInternal = function (parent, position, fullStart) {
            parent = new TypeScript.PositionedNode(parent, this, fullStart);
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);
                if (element !== null) {
                    var childWidth = element.fullWidth();
                    if (position < childWidth) {
                        return element.findTokenInternal(parent, position, fullStart);
                    }
                    position -= childWidth;
                    fullStart += childWidth;
                }
            }
            throw TypeScript.Errors.invalidOperation();
        };
        SyntaxNode.prototype.findTokenOnLeft = function (position, includeSkippedTokens) {
            if (includeSkippedTokens === void 0) { includeSkippedTokens = false; }
            var positionedToken = this.findToken(position, false);
            var start = positionedToken.start();
            if (includeSkippedTokens) {
                positionedToken = TypeScript.Syntax.findSkippedTokenOnLeft(positionedToken, position) || positionedToken;
            }
            if (position > start) {
                return positionedToken;
            }
            if (positionedToken.fullStart() === 0) {
                return null;
            }
            return positionedToken.previousToken(includeSkippedTokens);
        };
        SyntaxNode.prototype.findCompleteTokenOnLeft = function (position, includeSkippedTokens) {
            if (includeSkippedTokens === void 0) { includeSkippedTokens = false; }
            var positionedToken = this.findToken(position, false);
            if (includeSkippedTokens) {
                positionedToken = TypeScript.Syntax.findSkippedTokenOnLeft(positionedToken, position) || positionedToken;
            }
            if (positionedToken.token().width() > 0 && position >= positionedToken.end()) {
                return positionedToken;
            }
            return positionedToken.previousToken(includeSkippedTokens);
        };
        SyntaxNode.prototype.isModuleElement = function () {
            return false;
        };
        SyntaxNode.prototype.isClassElement = function () {
            return false;
        };
        SyntaxNode.prototype.isTypeMember = function () {
            return false;
        };
        SyntaxNode.prototype.isStatement = function () {
            return false;
        };
        SyntaxNode.prototype.isExpression = function () {
            return false;
        };
        SyntaxNode.prototype.isSwitchClause = function () {
            return false;
        };
        SyntaxNode.prototype.structuralEquals = function (node) {
            if (this === node) {
                return true;
            }
            if (node === null) {
                return false;
            }
            if (this.kind() !== node.kind()) {
                return false;
            }
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element1 = this.childAt(i);
                var element2 = node.childAt(i);
                if (!TypeScript.Syntax.elementStructuralEquals(element1, element2)) {
                    return false;
                }
            }
            return true;
        };
        SyntaxNode.prototype.width = function () {
            return this.fullWidth() - this.leadingTriviaWidth() - this.trailingTriviaWidth();
        };
        SyntaxNode.prototype.leadingTriviaWidth = function () {
            var firstToken = this.firstToken();
            return firstToken === null ? 0 : firstToken.leadingTriviaWidth();
        };
        SyntaxNode.prototype.trailingTriviaWidth = function () {
            var lastToken = this.lastToken();
            return lastToken === null ? 0 : lastToken.trailingTriviaWidth();
        };
        return SyntaxNode;
    }());
    TypeScript.SyntaxNode = SyntaxNode;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SourceUnitSyntax = (function (_super) {
        __extends(SourceUnitSyntax, _super);
        function SourceUnitSyntax(moduleElements, endOfFileToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.moduleElements = moduleElements;
            _this.endOfFileToken = endOfFileToken;
            return _this;
        }
        SourceUnitSyntax.prototype.accept = function (visitor) {
            return visitor.visitSourceUnit(this);
        };
        SourceUnitSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.SourceUnit;
        };
        SourceUnitSyntax.prototype.childCount = function () {
            return 2;
        };
        SourceUnitSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.moduleElements;
                case 1: return this.endOfFileToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        SourceUnitSyntax.prototype.update = function (moduleElements, endOfFileToken) {
            if (this.moduleElements === moduleElements && this.endOfFileToken === endOfFileToken) {
                return this;
            }
            return new SourceUnitSyntax(moduleElements, endOfFileToken, this.parsedInStrictMode());
        };
        SourceUnitSyntax.create = function (endOfFileToken) {
            return new SourceUnitSyntax(TypeScript.Syntax.emptyList, endOfFileToken, false);
        };
        SourceUnitSyntax.create1 = function (endOfFileToken) {
            return new SourceUnitSyntax(TypeScript.Syntax.emptyList, endOfFileToken, false);
        };
        SourceUnitSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        SourceUnitSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        SourceUnitSyntax.prototype.withModuleElements = function (moduleElements) {
            return this.update(moduleElements, this.endOfFileToken);
        };
        SourceUnitSyntax.prototype.withModuleElement = function (moduleElement) {
            return this.withModuleElements(TypeScript.Syntax.list([moduleElement]));
        };
        SourceUnitSyntax.prototype.withEndOfFileToken = function (endOfFileToken) {
            return this.update(this.moduleElements, endOfFileToken);
        };
        SourceUnitSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.moduleElements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SourceUnitSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.SourceUnitSyntax = SourceUnitSyntax;
    var ExternalModuleReferenceSyntax = (function (_super) {
        __extends(ExternalModuleReferenceSyntax, _super);
        function ExternalModuleReferenceSyntax(requireKeyword, openParenToken, stringLiteral, closeParenToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.requireKeyword = requireKeyword;
            _this.openParenToken = openParenToken;
            _this.stringLiteral = stringLiteral;
            _this.closeParenToken = closeParenToken;
            return _this;
        }
        ExternalModuleReferenceSyntax.prototype.accept = function (visitor) {
            return visitor.visitExternalModuleReference(this);
        };
        ExternalModuleReferenceSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ExternalModuleReference;
        };
        ExternalModuleReferenceSyntax.prototype.childCount = function () {
            return 4;
        };
        ExternalModuleReferenceSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.requireKeyword;
                case 1: return this.openParenToken;
                case 2: return this.stringLiteral;
                case 3: return this.closeParenToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ExternalModuleReferenceSyntax.prototype.isModuleReference = function () {
            return true;
        };
        ExternalModuleReferenceSyntax.prototype.update = function (requireKeyword, openParenToken, stringLiteral, closeParenToken) {
            if (this.requireKeyword === requireKeyword && this.openParenToken === openParenToken && this.stringLiteral === stringLiteral && this.closeParenToken === closeParenToken) {
                return this;
            }
            return new ExternalModuleReferenceSyntax(requireKeyword, openParenToken, stringLiteral, closeParenToken, this.parsedInStrictMode());
        };
        ExternalModuleReferenceSyntax.create1 = function (stringLiteral) {
            return new ExternalModuleReferenceSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.RequireKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), stringLiteral, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), false);
        };
        ExternalModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ExternalModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ExternalModuleReferenceSyntax.prototype.withRequireKeyword = function (requireKeyword) {
            return this.update(requireKeyword, this.openParenToken, this.stringLiteral, this.closeParenToken);
        };
        ExternalModuleReferenceSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.requireKeyword, openParenToken, this.stringLiteral, this.closeParenToken);
        };
        ExternalModuleReferenceSyntax.prototype.withStringLiteral = function (stringLiteral) {
            return this.update(this.requireKeyword, this.openParenToken, stringLiteral, this.closeParenToken);
        };
        ExternalModuleReferenceSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.requireKeyword, this.openParenToken, this.stringLiteral, closeParenToken);
        };
        ExternalModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ExternalModuleReferenceSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ExternalModuleReferenceSyntax = ExternalModuleReferenceSyntax;
    var ModuleNameModuleReferenceSyntax = (function (_super) {
        __extends(ModuleNameModuleReferenceSyntax, _super);
        function ModuleNameModuleReferenceSyntax(moduleName, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.moduleName = moduleName;
            return _this;
        }
        ModuleNameModuleReferenceSyntax.prototype.accept = function (visitor) {
            return visitor.visitModuleNameModuleReference(this);
        };
        ModuleNameModuleReferenceSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ModuleNameModuleReference;
        };
        ModuleNameModuleReferenceSyntax.prototype.childCount = function () {
            return 1;
        };
        ModuleNameModuleReferenceSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.moduleName;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ModuleNameModuleReferenceSyntax.prototype.isModuleReference = function () {
            return true;
        };
        ModuleNameModuleReferenceSyntax.prototype.update = function (moduleName) {
            if (this.moduleName === moduleName) {
                return this;
            }
            return new ModuleNameModuleReferenceSyntax(moduleName, this.parsedInStrictMode());
        };
        ModuleNameModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ModuleNameModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ModuleNameModuleReferenceSyntax.prototype.withModuleName = function (moduleName) {
            return this.update(moduleName);
        };
        ModuleNameModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleNameModuleReferenceSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ModuleNameModuleReferenceSyntax = ModuleNameModuleReferenceSyntax;
    var ImportDeclarationSyntax = (function (_super) {
        __extends(ImportDeclarationSyntax, _super);
        function ImportDeclarationSyntax(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.modifiers = modifiers;
            _this.importKeyword = importKeyword;
            _this.identifier = identifier;
            _this.equalsToken = equalsToken;
            _this.moduleReference = moduleReference;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        ImportDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitImportDeclaration(this);
        };
        ImportDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ImportDeclaration;
        };
        ImportDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };
        ImportDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.modifiers;
                case 1: return this.importKeyword;
                case 2: return this.identifier;
                case 3: return this.equalsToken;
                case 4: return this.moduleReference;
                case 5: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ImportDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ImportDeclarationSyntax.prototype.update = function (modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
            if (this.modifiers === modifiers && this.importKeyword === importKeyword && this.identifier === identifier && this.equalsToken === equalsToken && this.moduleReference === moduleReference && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ImportDeclarationSyntax(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, this.parsedInStrictMode());
        };
        ImportDeclarationSyntax.create = function (importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
            return new ImportDeclarationSyntax(TypeScript.Syntax.emptyList, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, false);
        };
        ImportDeclarationSyntax.create1 = function (identifier, moduleReference) {
            return new ImportDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.ImportKeyword), identifier, TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsToken), moduleReference, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        ImportDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ImportDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ImportDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.importKeyword, this.identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
        };
        ImportDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        ImportDeclarationSyntax.prototype.withImportKeyword = function (importKeyword) {
            return this.update(this.modifiers, importKeyword, this.identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
        };
        ImportDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.importKeyword, identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
        };
        ImportDeclarationSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(this.modifiers, this.importKeyword, this.identifier, equalsToken, this.moduleReference, this.semicolonToken);
        };
        ImportDeclarationSyntax.prototype.withModuleReference = function (moduleReference) {
            return this.update(this.modifiers, this.importKeyword, this.identifier, this.equalsToken, moduleReference, this.semicolonToken);
        };
        ImportDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.importKeyword, this.identifier, this.equalsToken, this.moduleReference, semicolonToken);
        };
        ImportDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ImportDeclarationSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ImportDeclarationSyntax = ImportDeclarationSyntax;
    var ExportAssignmentSyntax = (function (_super) {
        __extends(ExportAssignmentSyntax, _super);
        function ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.exportKeyword = exportKeyword;
            _this.equalsToken = equalsToken;
            _this.identifier = identifier;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        ExportAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitExportAssignment(this);
        };
        ExportAssignmentSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ExportAssignment;
        };
        ExportAssignmentSyntax.prototype.childCount = function () {
            return 4;
        };
        ExportAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.exportKeyword;
                case 1: return this.equalsToken;
                case 2: return this.identifier;
                case 3: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ExportAssignmentSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ExportAssignmentSyntax.prototype.update = function (exportKeyword, equalsToken, identifier, semicolonToken) {
            if (this.exportKeyword === exportKeyword && this.equalsToken === equalsToken && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, this.parsedInStrictMode());
        };
        ExportAssignmentSyntax.create1 = function (identifier) {
            return new ExportAssignmentSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ExportKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsToken), identifier, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        ExportAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ExportAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ExportAssignmentSyntax.prototype.withExportKeyword = function (exportKeyword) {
            return this.update(exportKeyword, this.equalsToken, this.identifier, this.semicolonToken);
        };
        ExportAssignmentSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(this.exportKeyword, equalsToken, this.identifier, this.semicolonToken);
        };
        ExportAssignmentSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.exportKeyword, this.equalsToken, identifier, this.semicolonToken);
        };
        ExportAssignmentSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.exportKeyword, this.equalsToken, this.identifier, semicolonToken);
        };
        ExportAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ExportAssignmentSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ExportAssignmentSyntax = ExportAssignmentSyntax;
    var ClassDeclarationSyntax = (function (_super) {
        __extends(ClassDeclarationSyntax, _super);
        function ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.modifiers = modifiers;
            _this.classKeyword = classKeyword;
            _this.identifier = identifier;
            _this.typeParameterList = typeParameterList;
            _this.heritageClauses = heritageClauses;
            _this.openBraceToken = openBraceToken;
            _this.classElements = classElements;
            _this.closeBraceToken = closeBraceToken;
            return _this;
        }
        ClassDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitClassDeclaration(this);
        };
        ClassDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ClassDeclaration;
        };
        ClassDeclarationSyntax.prototype.childCount = function () {
            return 8;
        };
        ClassDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.modifiers;
                case 1: return this.classKeyword;
                case 2: return this.identifier;
                case 3: return this.typeParameterList;
                case 4: return this.heritageClauses;
                case 5: return this.openBraceToken;
                case 6: return this.classElements;
                case 7: return this.closeBraceToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ClassDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ClassDeclarationSyntax.prototype.update = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.classKeyword === classKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.heritageClauses === heritageClauses && this.openBraceToken === openBraceToken && this.classElements === classElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, this.parsedInStrictMode());
        };
        ClassDeclarationSyntax.create = function (classKeyword, identifier, openBraceToken, closeBraceToken) {
            return new ClassDeclarationSyntax(TypeScript.Syntax.emptyList, classKeyword, identifier, null, TypeScript.Syntax.emptyList, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };
        ClassDeclarationSyntax.create1 = function (identifier) {
            return new ClassDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.ClassKeyword), identifier, null, TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        ClassDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ClassDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ClassDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        ClassDeclarationSyntax.prototype.withClassKeyword = function (classKeyword) {
            return this.update(this.modifiers, classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.classKeyword, identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withHeritageClauses = function (heritageClauses) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withHeritageClause = function (heritageClause) {
            return this.withHeritageClauses(TypeScript.Syntax.list([heritageClause]));
        };
        ClassDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, openBraceToken, this.classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withClassElements = function (classElements) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withClassElement = function (classElement) {
            return this.withClassElements(TypeScript.Syntax.list([classElement]));
        };
        ClassDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ClassDeclarationSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ClassDeclarationSyntax = ClassDeclarationSyntax;
    var InterfaceDeclarationSyntax = (function (_super) {
        __extends(InterfaceDeclarationSyntax, _super);
        function InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.modifiers = modifiers;
            _this.interfaceKeyword = interfaceKeyword;
            _this.identifier = identifier;
            _this.typeParameterList = typeParameterList;
            _this.heritageClauses = heritageClauses;
            _this.body = body;
            return _this;
        }
        InterfaceDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitInterfaceDeclaration(this);
        };
        InterfaceDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.InterfaceDeclaration;
        };
        InterfaceDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };
        InterfaceDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.modifiers;
                case 1: return this.interfaceKeyword;
                case 2: return this.identifier;
                case 3: return this.typeParameterList;
                case 4: return this.heritageClauses;
                case 5: return this.body;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        InterfaceDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };
        InterfaceDeclarationSyntax.prototype.update = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
            if (this.modifiers === modifiers && this.interfaceKeyword === interfaceKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.heritageClauses === heritageClauses && this.body === body) {
                return this;
            }
            return new InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, this.parsedInStrictMode());
        };
        InterfaceDeclarationSyntax.create = function (interfaceKeyword, identifier, body) {
            return new InterfaceDeclarationSyntax(TypeScript.Syntax.emptyList, interfaceKeyword, identifier, null, TypeScript.Syntax.emptyList, body, false);
        };
        InterfaceDeclarationSyntax.create1 = function (identifier) {
            return new InterfaceDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.InterfaceKeyword), identifier, null, TypeScript.Syntax.emptyList, ObjectTypeSyntax.create1(), false);
        };
        InterfaceDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        InterfaceDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        InterfaceDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.body);
        };
        InterfaceDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        InterfaceDeclarationSyntax.prototype.withInterfaceKeyword = function (interfaceKeyword) {
            return this.update(this.modifiers, interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.body);
        };
        InterfaceDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.interfaceKeyword, identifier, this.typeParameterList, this.heritageClauses, this.body);
        };
        InterfaceDeclarationSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, typeParameterList, this.heritageClauses, this.body);
        };
        InterfaceDeclarationSyntax.prototype.withHeritageClauses = function (heritageClauses) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, heritageClauses, this.body);
        };
        InterfaceDeclarationSyntax.prototype.withHeritageClause = function (heritageClause) {
            return this.withHeritageClauses(TypeScript.Syntax.list([heritageClause]));
        };
        InterfaceDeclarationSyntax.prototype.withBody = function (body) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, body);
        };
        InterfaceDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return InterfaceDeclarationSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.InterfaceDeclarationSyntax = InterfaceDeclarationSyntax;
    var HeritageClauseSyntax = (function (_super) {
        __extends(HeritageClauseSyntax, _super);
        function HeritageClauseSyntax(kind, extendsOrImplementsKeyword, typeNames, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.extendsOrImplementsKeyword = extendsOrImplementsKeyword;
            _this.typeNames = typeNames;
            _this._kind = kind;
            return _this;
        }
        HeritageClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitHeritageClause(this);
        };
        HeritageClauseSyntax.prototype.childCount = function () {
            return 2;
        };
        HeritageClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.extendsOrImplementsKeyword;
                case 1: return this.typeNames;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        HeritageClauseSyntax.prototype.kind = function () {
            return this._kind;
        };
        HeritageClauseSyntax.prototype.update = function (kind, extendsOrImplementsKeyword, typeNames) {
            if (this._kind === kind && this.extendsOrImplementsKeyword === extendsOrImplementsKeyword && this.typeNames === typeNames) {
                return this;
            }
            return new HeritageClauseSyntax(kind, extendsOrImplementsKeyword, typeNames, this.parsedInStrictMode());
        };
        HeritageClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        HeritageClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        HeritageClauseSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.extendsOrImplementsKeyword, this.typeNames);
        };
        HeritageClauseSyntax.prototype.withExtendsOrImplementsKeyword = function (extendsOrImplementsKeyword) {
            return this.update(this._kind, extendsOrImplementsKeyword, this.typeNames);
        };
        HeritageClauseSyntax.prototype.withTypeNames = function (typeNames) {
            return this.update(this._kind, this.extendsOrImplementsKeyword, typeNames);
        };
        HeritageClauseSyntax.prototype.withTypeName = function (typeName) {
            return this.withTypeNames(TypeScript.Syntax.separatedList([typeName]));
        };
        HeritageClauseSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return HeritageClauseSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.HeritageClauseSyntax = HeritageClauseSyntax;
    var ModuleDeclarationSyntax = (function (_super) {
        __extends(ModuleDeclarationSyntax, _super);
        function ModuleDeclarationSyntax(modifiers, moduleKeyword, name, stringLiteral, openBraceToken, moduleElements, closeBraceToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.modifiers = modifiers;
            _this.moduleKeyword = moduleKeyword;
            _this.name = name;
            _this.stringLiteral = stringLiteral;
            _this.openBraceToken = openBraceToken;
            _this.moduleElements = moduleElements;
            _this.closeBraceToken = closeBraceToken;
            return _this;
        }
        ModuleDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitModuleDeclaration(this);
        };
        ModuleDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ModuleDeclaration;
        };
        ModuleDeclarationSyntax.prototype.childCount = function () {
            return 7;
        };
        ModuleDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.modifiers;
                case 1: return this.moduleKeyword;
                case 2: return this.name;
                case 3: return this.stringLiteral;
                case 4: return this.openBraceToken;
                case 5: return this.moduleElements;
                case 6: return this.closeBraceToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ModuleDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ModuleDeclarationSyntax.prototype.update = function (modifiers, moduleKeyword, name, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.moduleKeyword === moduleKeyword && this.name === name && this.stringLiteral === stringLiteral && this.openBraceToken === openBraceToken && this.moduleElements === moduleElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new ModuleDeclarationSyntax(modifiers, moduleKeyword, name, stringLiteral, openBraceToken, moduleElements, closeBraceToken, this.parsedInStrictMode());
        };
        ModuleDeclarationSyntax.create = function (moduleKeyword, openBraceToken, closeBraceToken) {
            return new ModuleDeclarationSyntax(TypeScript.Syntax.emptyList, moduleKeyword, null, null, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };
        ModuleDeclarationSyntax.create1 = function () {
            return new ModuleDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.ModuleKeyword), null, null, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        ModuleDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ModuleDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ModuleDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.moduleKeyword, this.name, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        ModuleDeclarationSyntax.prototype.withModuleKeyword = function (moduleKeyword) {
            return this.update(this.modifiers, moduleKeyword, this.name, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.withName = function (name) {
            return this.update(this.modifiers, this.moduleKeyword, name, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.withStringLiteral = function (stringLiteral) {
            return this.update(this.modifiers, this.moduleKeyword, this.name, stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.moduleKeyword, this.name, this.stringLiteral, openBraceToken, this.moduleElements, this.closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.withModuleElements = function (moduleElements) {
            return this.update(this.modifiers, this.moduleKeyword, this.name, this.stringLiteral, this.openBraceToken, moduleElements, this.closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.withModuleElement = function (moduleElement) {
            return this.withModuleElements(TypeScript.Syntax.list([moduleElement]));
        };
        ModuleDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.moduleKeyword, this.name, this.stringLiteral, this.openBraceToken, this.moduleElements, closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleDeclarationSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ModuleDeclarationSyntax = ModuleDeclarationSyntax;
    var FunctionDeclarationSyntax = (function (_super) {
        __extends(FunctionDeclarationSyntax, _super);
        function FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.modifiers = modifiers;
            _this.functionKeyword = functionKeyword;
            _this.identifier = identifier;
            _this.callSignature = callSignature;
            _this.block = block;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        FunctionDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionDeclaration(this);
        };
        FunctionDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.FunctionDeclaration;
        };
        FunctionDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };
        FunctionDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.modifiers;
                case 1: return this.functionKeyword;
                case 2: return this.identifier;
                case 3: return this.callSignature;
                case 4: return this.block;
                case 5: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        FunctionDeclarationSyntax.prototype.isStatement = function () {
            return true;
        };
        FunctionDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };
        FunctionDeclarationSyntax.prototype.update = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
            if (this.modifiers === modifiers && this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, this.parsedInStrictMode());
        };
        FunctionDeclarationSyntax.create = function (functionKeyword, identifier, callSignature) {
            return new FunctionDeclarationSyntax(TypeScript.Syntax.emptyList, functionKeyword, identifier, callSignature, null, null, false);
        };
        FunctionDeclarationSyntax.create1 = function (identifier) {
            return new FunctionDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.FunctionKeyword), identifier, CallSignatureSyntax.create1(), null, null, false);
        };
        FunctionDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        FunctionDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        FunctionDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.functionKeyword, this.identifier, this.callSignature, this.block, this.semicolonToken);
        };
        FunctionDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        FunctionDeclarationSyntax.prototype.withFunctionKeyword = function (functionKeyword) {
            return this.update(this.modifiers, functionKeyword, this.identifier, this.callSignature, this.block, this.semicolonToken);
        };
        FunctionDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.functionKeyword, identifier, this.callSignature, this.block, this.semicolonToken);
        };
        FunctionDeclarationSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, callSignature, this.block, this.semicolonToken);
        };
        FunctionDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, this.callSignature, block, this.semicolonToken);
        };
        FunctionDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, this.callSignature, this.block, semicolonToken);
        };
        FunctionDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.modifiers.childCount() > 0) {
                return true;
            }
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block !== null && this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionDeclarationSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.FunctionDeclarationSyntax = FunctionDeclarationSyntax;
    var VariableStatementSyntax = (function (_super) {
        __extends(VariableStatementSyntax, _super);
        function VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.modifiers = modifiers;
            _this.variableDeclaration = variableDeclaration;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        VariableStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableStatement(this);
        };
        VariableStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.VariableStatement;
        };
        VariableStatementSyntax.prototype.childCount = function () {
            return 3;
        };
        VariableStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.modifiers;
                case 1: return this.variableDeclaration;
                case 2: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        VariableStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        VariableStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        VariableStatementSyntax.prototype.update = function (modifiers, variableDeclaration, semicolonToken) {
            if (this.modifiers === modifiers && this.variableDeclaration === variableDeclaration && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, this.parsedInStrictMode());
        };
        VariableStatementSyntax.create = function (variableDeclaration, semicolonToken) {
            return new VariableStatementSyntax(TypeScript.Syntax.emptyList, variableDeclaration, semicolonToken, false);
        };
        VariableStatementSyntax.create1 = function (variableDeclaration) {
            return new VariableStatementSyntax(TypeScript.Syntax.emptyList, variableDeclaration, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        VariableStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        VariableStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        VariableStatementSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.variableDeclaration, this.semicolonToken);
        };
        VariableStatementSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        VariableStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.modifiers, variableDeclaration, this.semicolonToken);
        };
        VariableStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.variableDeclaration, semicolonToken);
        };
        VariableStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.modifiers.childCount() > 0) {
                return true;
            }
            if (this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.VariableStatementSyntax = VariableStatementSyntax;
    var VariableDeclarationSyntax = (function (_super) {
        __extends(VariableDeclarationSyntax, _super);
        function VariableDeclarationSyntax(varKeyword, variableDeclarators, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.varKeyword = varKeyword;
            _this.variableDeclarators = variableDeclarators;
            return _this;
        }
        VariableDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableDeclaration(this);
        };
        VariableDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.VariableDeclaration;
        };
        VariableDeclarationSyntax.prototype.childCount = function () {
            return 2;
        };
        VariableDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.varKeyword;
                case 1: return this.variableDeclarators;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        VariableDeclarationSyntax.prototype.update = function (varKeyword, variableDeclarators) {
            if (this.varKeyword === varKeyword && this.variableDeclarators === variableDeclarators) {
                return this;
            }
            return new VariableDeclarationSyntax(varKeyword, variableDeclarators, this.parsedInStrictMode());
        };
        VariableDeclarationSyntax.create1 = function (variableDeclarators) {
            return new VariableDeclarationSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.VarKeyword), variableDeclarators, false);
        };
        VariableDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        VariableDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        VariableDeclarationSyntax.prototype.withVarKeyword = function (varKeyword) {
            return this.update(varKeyword, this.variableDeclarators);
        };
        VariableDeclarationSyntax.prototype.withVariableDeclarators = function (variableDeclarators) {
            return this.update(this.varKeyword, variableDeclarators);
        };
        VariableDeclarationSyntax.prototype.withVariableDeclarator = function (variableDeclarator) {
            return this.withVariableDeclarators(TypeScript.Syntax.separatedList([variableDeclarator]));
        };
        VariableDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclarators.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableDeclarationSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.VariableDeclarationSyntax = VariableDeclarationSyntax;
    var VariableDeclaratorSyntax = (function (_super) {
        __extends(VariableDeclaratorSyntax, _super);
        function VariableDeclaratorSyntax(propertyName, typeAnnotation, equalsValueClause, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.propertyName = propertyName;
            _this.typeAnnotation = typeAnnotation;
            _this.equalsValueClause = equalsValueClause;
            return _this;
        }
        VariableDeclaratorSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableDeclarator(this);
        };
        VariableDeclaratorSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.VariableDeclarator;
        };
        VariableDeclaratorSyntax.prototype.childCount = function () {
            return 3;
        };
        VariableDeclaratorSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.propertyName;
                case 1: return this.typeAnnotation;
                case 2: return this.equalsValueClause;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        VariableDeclaratorSyntax.prototype.update = function (propertyName, typeAnnotation, equalsValueClause) {
            if (this.propertyName === propertyName && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
                return this;
            }
            return new VariableDeclaratorSyntax(propertyName, typeAnnotation, equalsValueClause, this.parsedInStrictMode());
        };
        VariableDeclaratorSyntax.create = function (propertyName) {
            return new VariableDeclaratorSyntax(propertyName, null, null, false);
        };
        VariableDeclaratorSyntax.create1 = function (propertyName) {
            return new VariableDeclaratorSyntax(propertyName, null, null, false);
        };
        VariableDeclaratorSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        VariableDeclaratorSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        VariableDeclaratorSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.typeAnnotation, this.equalsValueClause);
        };
        VariableDeclaratorSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.propertyName, typeAnnotation, this.equalsValueClause);
        };
        VariableDeclaratorSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.propertyName, this.typeAnnotation, equalsValueClause);
        };
        VariableDeclaratorSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null) {
                return true;
            }
            if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableDeclaratorSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.VariableDeclaratorSyntax = VariableDeclaratorSyntax;
    var EqualsValueClauseSyntax = (function (_super) {
        __extends(EqualsValueClauseSyntax, _super);
        function EqualsValueClauseSyntax(equalsToken, value, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.equalsToken = equalsToken;
            _this.value = value;
            return _this;
        }
        EqualsValueClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitEqualsValueClause(this);
        };
        EqualsValueClauseSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.EqualsValueClause;
        };
        EqualsValueClauseSyntax.prototype.childCount = function () {
            return 2;
        };
        EqualsValueClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.equalsToken;
                case 1: return this.value;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        EqualsValueClauseSyntax.prototype.update = function (equalsToken, value) {
            if (this.equalsToken === equalsToken && this.value === value) {
                return this;
            }
            return new EqualsValueClauseSyntax(equalsToken, value, this.parsedInStrictMode());
        };
        EqualsValueClauseSyntax.create1 = function (value) {
            return new EqualsValueClauseSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsToken), value, false);
        };
        EqualsValueClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        EqualsValueClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        EqualsValueClauseSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(equalsToken, this.value);
        };
        EqualsValueClauseSyntax.prototype.withValue = function (value) {
            return this.update(this.equalsToken, value);
        };
        EqualsValueClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.value.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return EqualsValueClauseSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.EqualsValueClauseSyntax = EqualsValueClauseSyntax;
    var PrefixUnaryExpressionSyntax = (function (_super) {
        __extends(PrefixUnaryExpressionSyntax, _super);
        function PrefixUnaryExpressionSyntax(kind, operatorToken, operand, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.operatorToken = operatorToken;
            _this.operand = operand;
            _this._kind = kind;
            return _this;
        }
        PrefixUnaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitPrefixUnaryExpression(this);
        };
        PrefixUnaryExpressionSyntax.prototype.childCount = function () {
            return 2;
        };
        PrefixUnaryExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.operatorToken;
                case 1: return this.operand;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        PrefixUnaryExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        PrefixUnaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        PrefixUnaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };
        PrefixUnaryExpressionSyntax.prototype.update = function (kind, operatorToken, operand) {
            if (this._kind === kind && this.operatorToken === operatorToken && this.operand === operand) {
                return this;
            }
            return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, this.parsedInStrictMode());
        };
        PrefixUnaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        PrefixUnaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        PrefixUnaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.operatorToken, this.operand);
        };
        PrefixUnaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, operatorToken, this.operand);
        };
        PrefixUnaryExpressionSyntax.prototype.withOperand = function (operand) {
            return this.update(this._kind, this.operatorToken, operand);
        };
        PrefixUnaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.operand.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return PrefixUnaryExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.PrefixUnaryExpressionSyntax = PrefixUnaryExpressionSyntax;
    var ArrayLiteralExpressionSyntax = (function (_super) {
        __extends(ArrayLiteralExpressionSyntax, _super);
        function ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.openBracketToken = openBracketToken;
            _this.expressions = expressions;
            _this.closeBracketToken = closeBracketToken;
            return _this;
        }
        ArrayLiteralExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitArrayLiteralExpression(this);
        };
        ArrayLiteralExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ArrayLiteralExpression;
        };
        ArrayLiteralExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        ArrayLiteralExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.openBracketToken;
                case 1: return this.expressions;
                case 2: return this.closeBracketToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ArrayLiteralExpressionSyntax.prototype.isPrimaryExpression = function () {
            return true;
        };
        ArrayLiteralExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };
        ArrayLiteralExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };
        ArrayLiteralExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ArrayLiteralExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ArrayLiteralExpressionSyntax.prototype.update = function (openBracketToken, expressions, closeBracketToken) {
            if (this.openBracketToken === openBracketToken && this.expressions === expressions && this.closeBracketToken === closeBracketToken) {
                return this;
            }
            return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, this.parsedInStrictMode());
        };
        ArrayLiteralExpressionSyntax.create = function (openBracketToken, closeBracketToken) {
            return new ArrayLiteralExpressionSyntax(openBracketToken, TypeScript.Syntax.emptySeparatedList, closeBracketToken, false);
        };
        ArrayLiteralExpressionSyntax.create1 = function () {
            return new ArrayLiteralExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBracketToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBracketToken), false);
        };
        ArrayLiteralExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ArrayLiteralExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ArrayLiteralExpressionSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(openBracketToken, this.expressions, this.closeBracketToken);
        };
        ArrayLiteralExpressionSyntax.prototype.withExpressions = function (expressions) {
            return this.update(this.openBracketToken, expressions, this.closeBracketToken);
        };
        ArrayLiteralExpressionSyntax.prototype.withExpression = function (expression) {
            return this.withExpressions(TypeScript.Syntax.separatedList([expression]));
        };
        ArrayLiteralExpressionSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.openBracketToken, this.expressions, closeBracketToken);
        };
        ArrayLiteralExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expressions.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ArrayLiteralExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ArrayLiteralExpressionSyntax = ArrayLiteralExpressionSyntax;
    var OmittedExpressionSyntax = (function (_super) {
        __extends(OmittedExpressionSyntax, _super);
        function OmittedExpressionSyntax(parsedInStrictMode) {
            return _super.call(this, parsedInStrictMode) || this;
        }
        OmittedExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitOmittedExpression(this);
        };
        OmittedExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.OmittedExpression;
        };
        OmittedExpressionSyntax.prototype.childCount = function () {
            return 0;
        };
        OmittedExpressionSyntax.prototype.childAt = function (slot) {
            throw TypeScript.Errors.invalidOperation();
        };
        OmittedExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        OmittedExpressionSyntax.prototype.update = function () {
            return this;
        };
        OmittedExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        OmittedExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        OmittedExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return OmittedExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.OmittedExpressionSyntax = OmittedExpressionSyntax;
    var ParenthesizedExpressionSyntax = (function (_super) {
        __extends(ParenthesizedExpressionSyntax, _super);
        function ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.openParenToken = openParenToken;
            _this.expression = expression;
            _this.closeParenToken = closeParenToken;
            return _this;
        }
        ParenthesizedExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitParenthesizedExpression(this);
        };
        ParenthesizedExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ParenthesizedExpression;
        };
        ParenthesizedExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        ParenthesizedExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.openParenToken;
                case 1: return this.expression;
                case 2: return this.closeParenToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ParenthesizedExpressionSyntax.prototype.isPrimaryExpression = function () {
            return true;
        };
        ParenthesizedExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };
        ParenthesizedExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };
        ParenthesizedExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ParenthesizedExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ParenthesizedExpressionSyntax.prototype.update = function (openParenToken, expression, closeParenToken) {
            if (this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken) {
                return this;
            }
            return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, this.parsedInStrictMode());
        };
        ParenthesizedExpressionSyntax.create1 = function (expression) {
            return new ParenthesizedExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), false);
        };
        ParenthesizedExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ParenthesizedExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ParenthesizedExpressionSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(openParenToken, this.expression, this.closeParenToken);
        };
        ParenthesizedExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.openParenToken, expression, this.closeParenToken);
        };
        ParenthesizedExpressionSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.openParenToken, this.expression, closeParenToken);
        };
        ParenthesizedExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ParenthesizedExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ParenthesizedExpressionSyntax = ParenthesizedExpressionSyntax;
    var SimpleArrowFunctionExpressionSyntax = (function (_super) {
        __extends(SimpleArrowFunctionExpressionSyntax, _super);
        function SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, block, expression, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.identifier = identifier;
            _this.equalsGreaterThanToken = equalsGreaterThanToken;
            _this.block = block;
            _this.expression = expression;
            return _this;
        }
        SimpleArrowFunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitSimpleArrowFunctionExpression(this);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.SimpleArrowFunctionExpression;
        };
        SimpleArrowFunctionExpressionSyntax.prototype.childCount = function () {
            return 4;
        };
        SimpleArrowFunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.identifier;
                case 1: return this.equalsGreaterThanToken;
                case 2: return this.block;
                case 3: return this.expression;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        SimpleArrowFunctionExpressionSyntax.prototype.isArrowFunctionExpression = function () {
            return true;
        };
        SimpleArrowFunctionExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        SimpleArrowFunctionExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        SimpleArrowFunctionExpressionSyntax.prototype.update = function (identifier, equalsGreaterThanToken, block, expression) {
            if (this.identifier === identifier && this.equalsGreaterThanToken === equalsGreaterThanToken && this.block === block && this.expression === expression) {
                return this;
            }
            return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, block, expression, this.parsedInStrictMode());
        };
        SimpleArrowFunctionExpressionSyntax.create = function (identifier, equalsGreaterThanToken) {
            return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, null, null, false);
        };
        SimpleArrowFunctionExpressionSyntax.create1 = function (identifier) {
            return new SimpleArrowFunctionExpressionSyntax(identifier, TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsGreaterThanToken), null, null, false);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.equalsGreaterThanToken, this.block, this.expression);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.identifier, equalsGreaterThanToken, this.block, this.expression);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.withBlock = function (block) {
            return this.update(this.identifier, this.equalsGreaterThanToken, block, this.expression);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.identifier, this.equalsGreaterThanToken, this.block, expression);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return SimpleArrowFunctionExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.SimpleArrowFunctionExpressionSyntax = SimpleArrowFunctionExpressionSyntax;
    var ParenthesizedArrowFunctionExpressionSyntax = (function (_super) {
        __extends(ParenthesizedArrowFunctionExpressionSyntax, _super);
        function ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, block, expression, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.callSignature = callSignature;
            _this.equalsGreaterThanToken = equalsGreaterThanToken;
            _this.block = block;
            _this.expression = expression;
            return _this;
        }
        ParenthesizedArrowFunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitParenthesizedArrowFunctionExpression(this);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression;
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.childCount = function () {
            return 4;
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.callSignature;
                case 1: return this.equalsGreaterThanToken;
                case 2: return this.block;
                case 3: return this.expression;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.isArrowFunctionExpression = function () {
            return true;
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.update = function (callSignature, equalsGreaterThanToken, block, expression) {
            if (this.callSignature === callSignature && this.equalsGreaterThanToken === equalsGreaterThanToken && this.block === block && this.expression === expression) {
                return this;
            }
            return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, block, expression, this.parsedInStrictMode());
        };
        ParenthesizedArrowFunctionExpressionSyntax.create = function (callSignature, equalsGreaterThanToken) {
            return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, null, null, false);
        };
        ParenthesizedArrowFunctionExpressionSyntax.create1 = function () {
            return new ParenthesizedArrowFunctionExpressionSyntax(CallSignatureSyntax.create1(), TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsGreaterThanToken), null, null, false);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(callSignature, this.equalsGreaterThanToken, this.block, this.expression);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.callSignature, equalsGreaterThanToken, this.block, this.expression);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.withBlock = function (block) {
            return this.update(this.callSignature, this.equalsGreaterThanToken, block, this.expression);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.callSignature, this.equalsGreaterThanToken, this.block, expression);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ParenthesizedArrowFunctionExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ParenthesizedArrowFunctionExpressionSyntax = ParenthesizedArrowFunctionExpressionSyntax;
    var QualifiedNameSyntax = (function (_super) {
        __extends(QualifiedNameSyntax, _super);
        function QualifiedNameSyntax(left, dotToken, right, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.left = left;
            _this.dotToken = dotToken;
            _this.right = right;
            return _this;
        }
        QualifiedNameSyntax.prototype.accept = function (visitor) {
            return visitor.visitQualifiedName(this);
        };
        QualifiedNameSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.QualifiedName;
        };
        QualifiedNameSyntax.prototype.childCount = function () {
            return 3;
        };
        QualifiedNameSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.left;
                case 1: return this.dotToken;
                case 2: return this.right;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        QualifiedNameSyntax.prototype.isName = function () {
            return true;
        };
        QualifiedNameSyntax.prototype.isType = function () {
            return true;
        };
        QualifiedNameSyntax.prototype.update = function (left, dotToken, right) {
            if (this.left === left && this.dotToken === dotToken && this.right === right) {
                return this;
            }
            return new QualifiedNameSyntax(left, dotToken, right, this.parsedInStrictMode());
        };
        QualifiedNameSyntax.create1 = function (left, right) {
            return new QualifiedNameSyntax(left, TypeScript.Syntax.token(TypeScript.SyntaxKind.DotToken), right, false);
        };
        QualifiedNameSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        QualifiedNameSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        QualifiedNameSyntax.prototype.withLeft = function (left) {
            return this.update(left, this.dotToken, this.right);
        };
        QualifiedNameSyntax.prototype.withDotToken = function (dotToken) {
            return this.update(this.left, dotToken, this.right);
        };
        QualifiedNameSyntax.prototype.withRight = function (right) {
            return this.update(this.left, this.dotToken, right);
        };
        QualifiedNameSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return QualifiedNameSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.QualifiedNameSyntax = QualifiedNameSyntax;
    var TypeArgumentListSyntax = (function (_super) {
        __extends(TypeArgumentListSyntax, _super);
        function TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.lessThanToken = lessThanToken;
            _this.typeArguments = typeArguments;
            _this.greaterThanToken = greaterThanToken;
            return _this;
        }
        TypeArgumentListSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeArgumentList(this);
        };
        TypeArgumentListSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeArgumentList;
        };
        TypeArgumentListSyntax.prototype.childCount = function () {
            return 3;
        };
        TypeArgumentListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.lessThanToken;
                case 1: return this.typeArguments;
                case 2: return this.greaterThanToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        TypeArgumentListSyntax.prototype.update = function (lessThanToken, typeArguments, greaterThanToken) {
            if (this.lessThanToken === lessThanToken && this.typeArguments === typeArguments && this.greaterThanToken === greaterThanToken) {
                return this;
            }
            return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, this.parsedInStrictMode());
        };
        TypeArgumentListSyntax.create = function (lessThanToken, greaterThanToken) {
            return new TypeArgumentListSyntax(lessThanToken, TypeScript.Syntax.emptySeparatedList, greaterThanToken, false);
        };
        TypeArgumentListSyntax.create1 = function () {
            return new TypeArgumentListSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.LessThanToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.GreaterThanToken), false);
        };
        TypeArgumentListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        TypeArgumentListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        TypeArgumentListSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.typeArguments, this.greaterThanToken);
        };
        TypeArgumentListSyntax.prototype.withTypeArguments = function (typeArguments) {
            return this.update(this.lessThanToken, typeArguments, this.greaterThanToken);
        };
        TypeArgumentListSyntax.prototype.withTypeArgument = function (typeArgument) {
            return this.withTypeArguments(TypeScript.Syntax.separatedList([typeArgument]));
        };
        TypeArgumentListSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.typeArguments, greaterThanToken);
        };
        TypeArgumentListSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeArgumentListSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.TypeArgumentListSyntax = TypeArgumentListSyntax;
    var ConstructorTypeSyntax = (function (_super) {
        __extends(ConstructorTypeSyntax, _super);
        function ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.newKeyword = newKeyword;
            _this.typeParameterList = typeParameterList;
            _this.parameterList = parameterList;
            _this.equalsGreaterThanToken = equalsGreaterThanToken;
            _this.type = type;
            return _this;
        }
        ConstructorTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructorType(this);
        };
        ConstructorTypeSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ConstructorType;
        };
        ConstructorTypeSyntax.prototype.childCount = function () {
            return 5;
        };
        ConstructorTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.newKeyword;
                case 1: return this.typeParameterList;
                case 2: return this.parameterList;
                case 3: return this.equalsGreaterThanToken;
                case 4: return this.type;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ConstructorTypeSyntax.prototype.isType = function () {
            return true;
        };
        ConstructorTypeSyntax.prototype.update = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
            if (this.newKeyword === newKeyword && this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
                return this;
            }
            return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, this.parsedInStrictMode());
        };
        ConstructorTypeSyntax.create = function (newKeyword, parameterList, equalsGreaterThanToken, type) {
            return new ConstructorTypeSyntax(newKeyword, null, parameterList, equalsGreaterThanToken, type, false);
        };
        ConstructorTypeSyntax.create1 = function (type) {
            return new ConstructorTypeSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.NewKeyword), null, ParameterListSyntax.create1(), TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsGreaterThanToken), type, false);
        };
        ConstructorTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ConstructorTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ConstructorTypeSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };
        ConstructorTypeSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.newKeyword, typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };
        ConstructorTypeSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.newKeyword, this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
        };
        ConstructorTypeSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.newKeyword, this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
        };
        ConstructorTypeSyntax.prototype.withType = function (type) {
            return this.update(this.newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
        };
        ConstructorTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructorTypeSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ConstructorTypeSyntax = ConstructorTypeSyntax;
    var FunctionTypeSyntax = (function (_super) {
        __extends(FunctionTypeSyntax, _super);
        function FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.typeParameterList = typeParameterList;
            _this.parameterList = parameterList;
            _this.equalsGreaterThanToken = equalsGreaterThanToken;
            _this.type = type;
            return _this;
        }
        FunctionTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionType(this);
        };
        FunctionTypeSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.FunctionType;
        };
        FunctionTypeSyntax.prototype.childCount = function () {
            return 4;
        };
        FunctionTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.typeParameterList;
                case 1: return this.parameterList;
                case 2: return this.equalsGreaterThanToken;
                case 3: return this.type;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        FunctionTypeSyntax.prototype.isType = function () {
            return true;
        };
        FunctionTypeSyntax.prototype.update = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
            if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
                return this;
            }
            return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, this.parsedInStrictMode());
        };
        FunctionTypeSyntax.create = function (parameterList, equalsGreaterThanToken, type) {
            return new FunctionTypeSyntax(null, parameterList, equalsGreaterThanToken, type, false);
        };
        FunctionTypeSyntax.create1 = function (type) {
            return new FunctionTypeSyntax(null, ParameterListSyntax.create1(), TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsGreaterThanToken), type, false);
        };
        FunctionTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        FunctionTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        FunctionTypeSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };
        FunctionTypeSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
        };
        FunctionTypeSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
        };
        FunctionTypeSyntax.prototype.withType = function (type) {
            return this.update(this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
        };
        FunctionTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return FunctionTypeSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.FunctionTypeSyntax = FunctionTypeSyntax;
    var ObjectTypeSyntax = (function (_super) {
        __extends(ObjectTypeSyntax, _super);
        function ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.openBraceToken = openBraceToken;
            _this.typeMembers = typeMembers;
            _this.closeBraceToken = closeBraceToken;
            return _this;
        }
        ObjectTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectType(this);
        };
        ObjectTypeSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ObjectType;
        };
        ObjectTypeSyntax.prototype.childCount = function () {
            return 3;
        };
        ObjectTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.openBraceToken;
                case 1: return this.typeMembers;
                case 2: return this.closeBraceToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ObjectTypeSyntax.prototype.isType = function () {
            return true;
        };
        ObjectTypeSyntax.prototype.update = function (openBraceToken, typeMembers, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.typeMembers === typeMembers && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, this.parsedInStrictMode());
        };
        ObjectTypeSyntax.create = function (openBraceToken, closeBraceToken) {
            return new ObjectTypeSyntax(openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };
        ObjectTypeSyntax.create1 = function () {
            return new ObjectTypeSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        ObjectTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ObjectTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ObjectTypeSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.typeMembers, this.closeBraceToken);
        };
        ObjectTypeSyntax.prototype.withTypeMembers = function (typeMembers) {
            return this.update(this.openBraceToken, typeMembers, this.closeBraceToken);
        };
        ObjectTypeSyntax.prototype.withTypeMember = function (typeMember) {
            return this.withTypeMembers(TypeScript.Syntax.separatedList([typeMember]));
        };
        ObjectTypeSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.typeMembers, closeBraceToken);
        };
        ObjectTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ObjectTypeSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ObjectTypeSyntax = ObjectTypeSyntax;
    var ArrayTypeSyntax = (function (_super) {
        __extends(ArrayTypeSyntax, _super);
        function ArrayTypeSyntax(type, openBracketToken, closeBracketToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.type = type;
            _this.openBracketToken = openBracketToken;
            _this.closeBracketToken = closeBracketToken;
            return _this;
        }
        ArrayTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitArrayType(this);
        };
        ArrayTypeSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ArrayType;
        };
        ArrayTypeSyntax.prototype.childCount = function () {
            return 3;
        };
        ArrayTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.type;
                case 1: return this.openBracketToken;
                case 2: return this.closeBracketToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ArrayTypeSyntax.prototype.isType = function () {
            return true;
        };
        ArrayTypeSyntax.prototype.update = function (type, openBracketToken, closeBracketToken) {
            if (this.type === type && this.openBracketToken === openBracketToken && this.closeBracketToken === closeBracketToken) {
                return this;
            }
            return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, this.parsedInStrictMode());
        };
        ArrayTypeSyntax.create1 = function (type) {
            return new ArrayTypeSyntax(type, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBracketToken), TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBracketToken), false);
        };
        ArrayTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ArrayTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ArrayTypeSyntax.prototype.withType = function (type) {
            return this.update(type, this.openBracketToken, this.closeBracketToken);
        };
        ArrayTypeSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(this.type, openBracketToken, this.closeBracketToken);
        };
        ArrayTypeSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.type, this.openBracketToken, closeBracketToken);
        };
        ArrayTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ArrayTypeSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ArrayTypeSyntax = ArrayTypeSyntax;
    var GenericTypeSyntax = (function (_super) {
        __extends(GenericTypeSyntax, _super);
        function GenericTypeSyntax(name, typeArgumentList, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.name = name;
            _this.typeArgumentList = typeArgumentList;
            return _this;
        }
        GenericTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitGenericType(this);
        };
        GenericTypeSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.GenericType;
        };
        GenericTypeSyntax.prototype.childCount = function () {
            return 2;
        };
        GenericTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.name;
                case 1: return this.typeArgumentList;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        GenericTypeSyntax.prototype.isType = function () {
            return true;
        };
        GenericTypeSyntax.prototype.update = function (name, typeArgumentList) {
            if (this.name === name && this.typeArgumentList === typeArgumentList) {
                return this;
            }
            return new GenericTypeSyntax(name, typeArgumentList, this.parsedInStrictMode());
        };
        GenericTypeSyntax.create1 = function (name) {
            return new GenericTypeSyntax(name, TypeArgumentListSyntax.create1(), false);
        };
        GenericTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        GenericTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        GenericTypeSyntax.prototype.withName = function (name) {
            return this.update(name, this.typeArgumentList);
        };
        GenericTypeSyntax.prototype.withTypeArgumentList = function (typeArgumentList) {
            return this.update(this.name, typeArgumentList);
        };
        GenericTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return GenericTypeSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.GenericTypeSyntax = GenericTypeSyntax;
    var TypeQuerySyntax = (function (_super) {
        __extends(TypeQuerySyntax, _super);
        function TypeQuerySyntax(typeOfKeyword, name, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.typeOfKeyword = typeOfKeyword;
            _this.name = name;
            return _this;
        }
        TypeQuerySyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeQuery(this);
        };
        TypeQuerySyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeQuery;
        };
        TypeQuerySyntax.prototype.childCount = function () {
            return 2;
        };
        TypeQuerySyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.typeOfKeyword;
                case 1: return this.name;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        TypeQuerySyntax.prototype.isType = function () {
            return true;
        };
        TypeQuerySyntax.prototype.update = function (typeOfKeyword, name) {
            if (this.typeOfKeyword === typeOfKeyword && this.name === name) {
                return this;
            }
            return new TypeQuerySyntax(typeOfKeyword, name, this.parsedInStrictMode());
        };
        TypeQuerySyntax.create1 = function (name) {
            return new TypeQuerySyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.TypeOfKeyword), name, false);
        };
        TypeQuerySyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        TypeQuerySyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        TypeQuerySyntax.prototype.withTypeOfKeyword = function (typeOfKeyword) {
            return this.update(typeOfKeyword, this.name);
        };
        TypeQuerySyntax.prototype.withName = function (name) {
            return this.update(this.typeOfKeyword, name);
        };
        TypeQuerySyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeQuerySyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.TypeQuerySyntax = TypeQuerySyntax;
    var TypeAnnotationSyntax = (function (_super) {
        __extends(TypeAnnotationSyntax, _super);
        function TypeAnnotationSyntax(colonToken, type, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.colonToken = colonToken;
            _this.type = type;
            return _this;
        }
        TypeAnnotationSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeAnnotation(this);
        };
        TypeAnnotationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeAnnotation;
        };
        TypeAnnotationSyntax.prototype.childCount = function () {
            return 2;
        };
        TypeAnnotationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.colonToken;
                case 1: return this.type;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        TypeAnnotationSyntax.prototype.update = function (colonToken, type) {
            if (this.colonToken === colonToken && this.type === type) {
                return this;
            }
            return new TypeAnnotationSyntax(colonToken, type, this.parsedInStrictMode());
        };
        TypeAnnotationSyntax.create1 = function (type) {
            return new TypeAnnotationSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ColonToken), type, false);
        };
        TypeAnnotationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        TypeAnnotationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        TypeAnnotationSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(colonToken, this.type);
        };
        TypeAnnotationSyntax.prototype.withType = function (type) {
            return this.update(this.colonToken, type);
        };
        TypeAnnotationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeAnnotationSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.TypeAnnotationSyntax = TypeAnnotationSyntax;
    var BlockSyntax = (function (_super) {
        __extends(BlockSyntax, _super);
        function BlockSyntax(openBraceToken, statements, closeBraceToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.openBraceToken = openBraceToken;
            _this.statements = statements;
            _this.closeBraceToken = closeBraceToken;
            return _this;
        }
        BlockSyntax.prototype.accept = function (visitor) {
            return visitor.visitBlock(this);
        };
        BlockSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.Block;
        };
        BlockSyntax.prototype.childCount = function () {
            return 3;
        };
        BlockSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.openBraceToken;
                case 1: return this.statements;
                case 2: return this.closeBraceToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        BlockSyntax.prototype.isStatement = function () {
            return true;
        };
        BlockSyntax.prototype.isModuleElement = function () {
            return true;
        };
        BlockSyntax.prototype.update = function (openBraceToken, statements, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.statements === statements && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new BlockSyntax(openBraceToken, statements, closeBraceToken, this.parsedInStrictMode());
        };
        BlockSyntax.create = function (openBraceToken, closeBraceToken) {
            return new BlockSyntax(openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };
        BlockSyntax.create1 = function () {
            return new BlockSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        BlockSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        BlockSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        BlockSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.statements, this.closeBraceToken);
        };
        BlockSyntax.prototype.withStatements = function (statements) {
            return this.update(this.openBraceToken, statements, this.closeBraceToken);
        };
        BlockSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([statement]));
        };
        BlockSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.statements, closeBraceToken);
        };
        BlockSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return BlockSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.BlockSyntax = BlockSyntax;
    var ParameterSyntax = (function (_super) {
        __extends(ParameterSyntax, _super);
        function ParameterSyntax(dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.dotDotDotToken = dotDotDotToken;
            _this.modifiers = modifiers;
            _this.identifier = identifier;
            _this.questionToken = questionToken;
            _this.typeAnnotation = typeAnnotation;
            _this.equalsValueClause = equalsValueClause;
            return _this;
        }
        ParameterSyntax.prototype.accept = function (visitor) {
            return visitor.visitParameter(this);
        };
        ParameterSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.Parameter;
        };
        ParameterSyntax.prototype.childCount = function () {
            return 6;
        };
        ParameterSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.dotDotDotToken;
                case 1: return this.modifiers;
                case 2: return this.identifier;
                case 3: return this.questionToken;
                case 4: return this.typeAnnotation;
                case 5: return this.equalsValueClause;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ParameterSyntax.prototype.update = function (dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause) {
            if (this.dotDotDotToken === dotDotDotToken && this.modifiers === modifiers && this.identifier === identifier && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
                return this;
            }
            return new ParameterSyntax(dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause, this.parsedInStrictMode());
        };
        ParameterSyntax.create = function (identifier) {
            return new ParameterSyntax(null, TypeScript.Syntax.emptyList, identifier, null, null, null, false);
        };
        ParameterSyntax.create1 = function (identifier) {
            return new ParameterSyntax(null, TypeScript.Syntax.emptyList, identifier, null, null, null, false);
        };
        ParameterSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ParameterSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ParameterSyntax.prototype.withDotDotDotToken = function (dotDotDotToken) {
            return this.update(dotDotDotToken, this.modifiers, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };
        ParameterSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(this.dotDotDotToken, modifiers, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };
        ParameterSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        ParameterSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.dotDotDotToken, this.modifiers, identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };
        ParameterSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.dotDotDotToken, this.modifiers, this.identifier, questionToken, this.typeAnnotation, this.equalsValueClause);
        };
        ParameterSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.dotDotDotToken, this.modifiers, this.identifier, this.questionToken, typeAnnotation, this.equalsValueClause);
        };
        ParameterSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.dotDotDotToken, this.modifiers, this.identifier, this.questionToken, this.typeAnnotation, equalsValueClause);
        };
        ParameterSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.dotDotDotToken !== null) {
                return true;
            }
            if (this.modifiers.isTypeScriptSpecific()) {
                return true;
            }
            if (this.questionToken !== null) {
                return true;
            }
            if (this.typeAnnotation !== null) {
                return true;
            }
            if (this.equalsValueClause !== null) {
                return true;
            }
            return false;
        };
        return ParameterSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ParameterSyntax = ParameterSyntax;
    var MemberAccessExpressionSyntax = (function (_super) {
        __extends(MemberAccessExpressionSyntax, _super);
        function MemberAccessExpressionSyntax(expression, dotToken, name, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.expression = expression;
            _this.dotToken = dotToken;
            _this.name = name;
            return _this;
        }
        MemberAccessExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberAccessExpression(this);
        };
        MemberAccessExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.MemberAccessExpression;
        };
        MemberAccessExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        MemberAccessExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.expression;
                case 1: return this.dotToken;
                case 2: return this.name;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        MemberAccessExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };
        MemberAccessExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };
        MemberAccessExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        MemberAccessExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        MemberAccessExpressionSyntax.prototype.update = function (expression, dotToken, name) {
            if (this.expression === expression && this.dotToken === dotToken && this.name === name) {
                return this;
            }
            return new MemberAccessExpressionSyntax(expression, dotToken, name, this.parsedInStrictMode());
        };
        MemberAccessExpressionSyntax.create1 = function (expression, name) {
            return new MemberAccessExpressionSyntax(expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.DotToken), name, false);
        };
        MemberAccessExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        MemberAccessExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        MemberAccessExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.dotToken, this.name);
        };
        MemberAccessExpressionSyntax.prototype.withDotToken = function (dotToken) {
            return this.update(this.expression, dotToken, this.name);
        };
        MemberAccessExpressionSyntax.prototype.withName = function (name) {
            return this.update(this.expression, this.dotToken, name);
        };
        MemberAccessExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return MemberAccessExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.MemberAccessExpressionSyntax = MemberAccessExpressionSyntax;
    var PostfixUnaryExpressionSyntax = (function (_super) {
        __extends(PostfixUnaryExpressionSyntax, _super);
        function PostfixUnaryExpressionSyntax(kind, operand, operatorToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.operand = operand;
            _this.operatorToken = operatorToken;
            _this._kind = kind;
            return _this;
        }
        PostfixUnaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitPostfixUnaryExpression(this);
        };
        PostfixUnaryExpressionSyntax.prototype.childCount = function () {
            return 2;
        };
        PostfixUnaryExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.operand;
                case 1: return this.operatorToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        PostfixUnaryExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };
        PostfixUnaryExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        PostfixUnaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        PostfixUnaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };
        PostfixUnaryExpressionSyntax.prototype.update = function (kind, operand, operatorToken) {
            if (this._kind === kind && this.operand === operand && this.operatorToken === operatorToken) {
                return this;
            }
            return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, this.parsedInStrictMode());
        };
        PostfixUnaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        PostfixUnaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        PostfixUnaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.operand, this.operatorToken);
        };
        PostfixUnaryExpressionSyntax.prototype.withOperand = function (operand) {
            return this.update(this._kind, operand, this.operatorToken);
        };
        PostfixUnaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, this.operand, operatorToken);
        };
        PostfixUnaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.operand.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return PostfixUnaryExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.PostfixUnaryExpressionSyntax = PostfixUnaryExpressionSyntax;
    var ElementAccessExpressionSyntax = (function (_super) {
        __extends(ElementAccessExpressionSyntax, _super);
        function ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.expression = expression;
            _this.openBracketToken = openBracketToken;
            _this.argumentExpression = argumentExpression;
            _this.closeBracketToken = closeBracketToken;
            return _this;
        }
        ElementAccessExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitElementAccessExpression(this);
        };
        ElementAccessExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ElementAccessExpression;
        };
        ElementAccessExpressionSyntax.prototype.childCount = function () {
            return 4;
        };
        ElementAccessExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.expression;
                case 1: return this.openBracketToken;
                case 2: return this.argumentExpression;
                case 3: return this.closeBracketToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ElementAccessExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };
        ElementAccessExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };
        ElementAccessExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ElementAccessExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ElementAccessExpressionSyntax.prototype.update = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
            if (this.expression === expression && this.openBracketToken === openBracketToken && this.argumentExpression === argumentExpression && this.closeBracketToken === closeBracketToken) {
                return this;
            }
            return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, this.parsedInStrictMode());
        };
        ElementAccessExpressionSyntax.create1 = function (expression, argumentExpression) {
            return new ElementAccessExpressionSyntax(expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBracketToken), argumentExpression, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBracketToken), false);
        };
        ElementAccessExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ElementAccessExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ElementAccessExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.openBracketToken, this.argumentExpression, this.closeBracketToken);
        };
        ElementAccessExpressionSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(this.expression, openBracketToken, this.argumentExpression, this.closeBracketToken);
        };
        ElementAccessExpressionSyntax.prototype.withArgumentExpression = function (argumentExpression) {
            return this.update(this.expression, this.openBracketToken, argumentExpression, this.closeBracketToken);
        };
        ElementAccessExpressionSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.expression, this.openBracketToken, this.argumentExpression, closeBracketToken);
        };
        ElementAccessExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentExpression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ElementAccessExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ElementAccessExpressionSyntax = ElementAccessExpressionSyntax;
    var InvocationExpressionSyntax = (function (_super) {
        __extends(InvocationExpressionSyntax, _super);
        function InvocationExpressionSyntax(expression, argumentList, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.expression = expression;
            _this.argumentList = argumentList;
            return _this;
        }
        InvocationExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitInvocationExpression(this);
        };
        InvocationExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.InvocationExpression;
        };
        InvocationExpressionSyntax.prototype.childCount = function () {
            return 2;
        };
        InvocationExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.expression;
                case 1: return this.argumentList;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        InvocationExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };
        InvocationExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };
        InvocationExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        InvocationExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        InvocationExpressionSyntax.prototype.update = function (expression, argumentList) {
            if (this.expression === expression && this.argumentList === argumentList) {
                return this;
            }
            return new InvocationExpressionSyntax(expression, argumentList, this.parsedInStrictMode());
        };
        InvocationExpressionSyntax.create1 = function (expression) {
            return new InvocationExpressionSyntax(expression, ArgumentListSyntax.create1(), false);
        };
        InvocationExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        InvocationExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        InvocationExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.argumentList);
        };
        InvocationExpressionSyntax.prototype.withArgumentList = function (argumentList) {
            return this.update(this.expression, argumentList);
        };
        InvocationExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentList.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return InvocationExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.InvocationExpressionSyntax = InvocationExpressionSyntax;
    var ArgumentListSyntax = (function (_super) {
        __extends(ArgumentListSyntax, _super);
        function ArgumentListSyntax(typeArgumentList, openParenToken, args, closeParenToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.typeArgumentList = typeArgumentList;
            _this.openParenToken = openParenToken;
            _this.args = args;
            _this.closeParenToken = closeParenToken;
            return _this;
        }
        ArgumentListSyntax.prototype.accept = function (visitor) {
            return visitor.visitArgumentList(this);
        };
        ArgumentListSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ArgumentList;
        };
        ArgumentListSyntax.prototype.childCount = function () {
            return 4;
        };
        ArgumentListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.typeArgumentList;
                case 1: return this.openParenToken;
                case 2: return this.args;
                case 3: return this.closeParenToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ArgumentListSyntax.prototype.update = function (typeArgumentList, openParenToken, args, closeParenToken) {
            if (this.typeArgumentList === typeArgumentList && this.openParenToken === openParenToken && this.args === args && this.closeParenToken === closeParenToken) {
                return this;
            }
            return new ArgumentListSyntax(typeArgumentList, openParenToken, args, closeParenToken, this.parsedInStrictMode());
        };
        ArgumentListSyntax.create = function (openParenToken, closeParenToken) {
            return new ArgumentListSyntax(null, openParenToken, TypeScript.Syntax.emptySeparatedList, closeParenToken, false);
        };
        ArgumentListSyntax.create1 = function () {
            return new ArgumentListSyntax(null, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), false);
        };
        ArgumentListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ArgumentListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ArgumentListSyntax.prototype.withTypeArgumentList = function (typeArgumentList) {
            return this.update(typeArgumentList, this.openParenToken, this.args, this.closeParenToken);
        };
        ArgumentListSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.typeArgumentList, openParenToken, this.args, this.closeParenToken);
        };
        ArgumentListSyntax.prototype.withArgs = function (args) {
            return this.update(this.typeArgumentList, this.openParenToken, args, this.closeParenToken);
        };
        ArgumentListSyntax.prototype.withArg = function (arg) {
            return this.withArgs(TypeScript.Syntax.separatedList([arg]));
        };
        ArgumentListSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.typeArgumentList, this.openParenToken, this.args, closeParenToken);
        };
        ArgumentListSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeArgumentList !== null && this.typeArgumentList.isTypeScriptSpecific()) {
                return true;
            }
            if (this.args.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ArgumentListSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ArgumentListSyntax = ArgumentListSyntax;
    var BinaryExpressionSyntax = (function (_super) {
        __extends(BinaryExpressionSyntax, _super);
        function BinaryExpressionSyntax(kind, left, operatorToken, right, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.left = left;
            _this.operatorToken = operatorToken;
            _this.right = right;
            _this._kind = kind;
            return _this;
        }
        BinaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitBinaryExpression(this);
        };
        BinaryExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        BinaryExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.left;
                case 1: return this.operatorToken;
                case 2: return this.right;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        BinaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        BinaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };
        BinaryExpressionSyntax.prototype.update = function (kind, left, operatorToken, right) {
            if (this._kind === kind && this.left === left && this.operatorToken === operatorToken && this.right === right) {
                return this;
            }
            return new BinaryExpressionSyntax(kind, left, operatorToken, right, this.parsedInStrictMode());
        };
        BinaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        BinaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        BinaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.left, this.operatorToken, this.right);
        };
        BinaryExpressionSyntax.prototype.withLeft = function (left) {
            return this.update(this._kind, left, this.operatorToken, this.right);
        };
        BinaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, this.left, operatorToken, this.right);
        };
        BinaryExpressionSyntax.prototype.withRight = function (right) {
            return this.update(this._kind, this.left, this.operatorToken, right);
        };
        BinaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.left.isTypeScriptSpecific()) {
                return true;
            }
            if (this.right.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return BinaryExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.BinaryExpressionSyntax = BinaryExpressionSyntax;
    var ConditionalExpressionSyntax = (function (_super) {
        __extends(ConditionalExpressionSyntax, _super);
        function ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.condition = condition;
            _this.questionToken = questionToken;
            _this.whenTrue = whenTrue;
            _this.colonToken = colonToken;
            _this.whenFalse = whenFalse;
            return _this;
        }
        ConditionalExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitConditionalExpression(this);
        };
        ConditionalExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ConditionalExpression;
        };
        ConditionalExpressionSyntax.prototype.childCount = function () {
            return 5;
        };
        ConditionalExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.condition;
                case 1: return this.questionToken;
                case 2: return this.whenTrue;
                case 3: return this.colonToken;
                case 4: return this.whenFalse;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ConditionalExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ConditionalExpressionSyntax.prototype.update = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
            if (this.condition === condition && this.questionToken === questionToken && this.whenTrue === whenTrue && this.colonToken === colonToken && this.whenFalse === whenFalse) {
                return this;
            }
            return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, this.parsedInStrictMode());
        };
        ConditionalExpressionSyntax.create1 = function (condition, whenTrue, whenFalse) {
            return new ConditionalExpressionSyntax(condition, TypeScript.Syntax.token(TypeScript.SyntaxKind.QuestionToken), whenTrue, TypeScript.Syntax.token(TypeScript.SyntaxKind.ColonToken), whenFalse, false);
        };
        ConditionalExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ConditionalExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ConditionalExpressionSyntax.prototype.withCondition = function (condition) {
            return this.update(condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse);
        };
        ConditionalExpressionSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.condition, questionToken, this.whenTrue, this.colonToken, this.whenFalse);
        };
        ConditionalExpressionSyntax.prototype.withWhenTrue = function (whenTrue) {
            return this.update(this.condition, this.questionToken, whenTrue, this.colonToken, this.whenFalse);
        };
        ConditionalExpressionSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.condition, this.questionToken, this.whenTrue, colonToken, this.whenFalse);
        };
        ConditionalExpressionSyntax.prototype.withWhenFalse = function (whenFalse) {
            return this.update(this.condition, this.questionToken, this.whenTrue, this.colonToken, whenFalse);
        };
        ConditionalExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.whenTrue.isTypeScriptSpecific()) {
                return true;
            }
            if (this.whenFalse.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ConditionalExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ConditionalExpressionSyntax = ConditionalExpressionSyntax;
    var ConstructSignatureSyntax = (function (_super) {
        __extends(ConstructSignatureSyntax, _super);
        function ConstructSignatureSyntax(newKeyword, callSignature, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.newKeyword = newKeyword;
            _this.callSignature = callSignature;
            return _this;
        }
        ConstructSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructSignature(this);
        };
        ConstructSignatureSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ConstructSignature;
        };
        ConstructSignatureSyntax.prototype.childCount = function () {
            return 2;
        };
        ConstructSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.newKeyword;
                case 1: return this.callSignature;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ConstructSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };
        ConstructSignatureSyntax.prototype.update = function (newKeyword, callSignature) {
            if (this.newKeyword === newKeyword && this.callSignature === callSignature) {
                return this;
            }
            return new ConstructSignatureSyntax(newKeyword, callSignature, this.parsedInStrictMode());
        };
        ConstructSignatureSyntax.create1 = function () {
            return new ConstructSignatureSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.NewKeyword), CallSignatureSyntax.create1(), false);
        };
        ConstructSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ConstructSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ConstructSignatureSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.callSignature);
        };
        ConstructSignatureSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.newKeyword, callSignature);
        };
        ConstructSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructSignatureSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ConstructSignatureSyntax = ConstructSignatureSyntax;
    var MethodSignatureSyntax = (function (_super) {
        __extends(MethodSignatureSyntax, _super);
        function MethodSignatureSyntax(propertyName, questionToken, callSignature, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.propertyName = propertyName;
            _this.questionToken = questionToken;
            _this.callSignature = callSignature;
            return _this;
        }
        MethodSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitMethodSignature(this);
        };
        MethodSignatureSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.MethodSignature;
        };
        MethodSignatureSyntax.prototype.childCount = function () {
            return 3;
        };
        MethodSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.propertyName;
                case 1: return this.questionToken;
                case 2: return this.callSignature;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        MethodSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };
        MethodSignatureSyntax.prototype.update = function (propertyName, questionToken, callSignature) {
            if (this.propertyName === propertyName && this.questionToken === questionToken && this.callSignature === callSignature) {
                return this;
            }
            return new MethodSignatureSyntax(propertyName, questionToken, callSignature, this.parsedInStrictMode());
        };
        MethodSignatureSyntax.create = function (propertyName, callSignature) {
            return new MethodSignatureSyntax(propertyName, null, callSignature, false);
        };
        MethodSignatureSyntax.create1 = function (propertyName) {
            return new MethodSignatureSyntax(propertyName, null, CallSignatureSyntax.create1(), false);
        };
        MethodSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        MethodSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        MethodSignatureSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.questionToken, this.callSignature);
        };
        MethodSignatureSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.propertyName, questionToken, this.callSignature);
        };
        MethodSignatureSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.propertyName, this.questionToken, callSignature);
        };
        MethodSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return MethodSignatureSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.MethodSignatureSyntax = MethodSignatureSyntax;
    var IndexSignatureSyntax = (function (_super) {
        __extends(IndexSignatureSyntax, _super);
        function IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.openBracketToken = openBracketToken;
            _this.parameter = parameter;
            _this.closeBracketToken = closeBracketToken;
            _this.typeAnnotation = typeAnnotation;
            return _this;
        }
        IndexSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitIndexSignature(this);
        };
        IndexSignatureSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.IndexSignature;
        };
        IndexSignatureSyntax.prototype.childCount = function () {
            return 4;
        };
        IndexSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.openBracketToken;
                case 1: return this.parameter;
                case 2: return this.closeBracketToken;
                case 3: return this.typeAnnotation;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        IndexSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };
        IndexSignatureSyntax.prototype.update = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
            if (this.openBracketToken === openBracketToken && this.parameter === parameter && this.closeBracketToken === closeBracketToken && this.typeAnnotation === typeAnnotation) {
                return this;
            }
            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, this.parsedInStrictMode());
        };
        IndexSignatureSyntax.create = function (openBracketToken, parameter, closeBracketToken) {
            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, null, false);
        };
        IndexSignatureSyntax.create1 = function (parameter) {
            return new IndexSignatureSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBracketToken), parameter, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBracketToken), null, false);
        };
        IndexSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        IndexSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        IndexSignatureSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(openBracketToken, this.parameter, this.closeBracketToken, this.typeAnnotation);
        };
        IndexSignatureSyntax.prototype.withParameter = function (parameter) {
            return this.update(this.openBracketToken, parameter, this.closeBracketToken, this.typeAnnotation);
        };
        IndexSignatureSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.openBracketToken, this.parameter, closeBracketToken, this.typeAnnotation);
        };
        IndexSignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.openBracketToken, this.parameter, this.closeBracketToken, typeAnnotation);
        };
        IndexSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return IndexSignatureSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.IndexSignatureSyntax = IndexSignatureSyntax;
    var PropertySignatureSyntax = (function (_super) {
        __extends(PropertySignatureSyntax, _super);
        function PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.propertyName = propertyName;
            _this.questionToken = questionToken;
            _this.typeAnnotation = typeAnnotation;
            return _this;
        }
        PropertySignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitPropertySignature(this);
        };
        PropertySignatureSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.PropertySignature;
        };
        PropertySignatureSyntax.prototype.childCount = function () {
            return 3;
        };
        PropertySignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.propertyName;
                case 1: return this.questionToken;
                case 2: return this.typeAnnotation;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        PropertySignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };
        PropertySignatureSyntax.prototype.update = function (propertyName, questionToken, typeAnnotation) {
            if (this.propertyName === propertyName && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation) {
                return this;
            }
            return new PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, this.parsedInStrictMode());
        };
        PropertySignatureSyntax.create = function (propertyName) {
            return new PropertySignatureSyntax(propertyName, null, null, false);
        };
        PropertySignatureSyntax.create1 = function (propertyName) {
            return new PropertySignatureSyntax(propertyName, null, null, false);
        };
        PropertySignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        PropertySignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        PropertySignatureSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.questionToken, this.typeAnnotation);
        };
        PropertySignatureSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.propertyName, questionToken, this.typeAnnotation);
        };
        PropertySignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.propertyName, this.questionToken, typeAnnotation);
        };
        PropertySignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return PropertySignatureSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.PropertySignatureSyntax = PropertySignatureSyntax;
    var CallSignatureSyntax = (function (_super) {
        __extends(CallSignatureSyntax, _super);
        function CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.typeParameterList = typeParameterList;
            _this.parameterList = parameterList;
            _this.typeAnnotation = typeAnnotation;
            return _this;
        }
        CallSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitCallSignature(this);
        };
        CallSignatureSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.CallSignature;
        };
        CallSignatureSyntax.prototype.childCount = function () {
            return 3;
        };
        CallSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.typeParameterList;
                case 1: return this.parameterList;
                case 2: return this.typeAnnotation;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        CallSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };
        CallSignatureSyntax.prototype.update = function (typeParameterList, parameterList, typeAnnotation) {
            if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation) {
                return this;
            }
            return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, this.parsedInStrictMode());
        };
        CallSignatureSyntax.create = function (parameterList) {
            return new CallSignatureSyntax(null, parameterList, null, false);
        };
        CallSignatureSyntax.create1 = function () {
            return new CallSignatureSyntax(null, ParameterListSyntax.create1(), null, false);
        };
        CallSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        CallSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        CallSignatureSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(typeParameterList, this.parameterList, this.typeAnnotation);
        };
        CallSignatureSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.typeParameterList, parameterList, this.typeAnnotation);
        };
        CallSignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.typeParameterList, this.parameterList, typeAnnotation);
        };
        CallSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeParameterList !== null) {
                return true;
            }
            if (this.parameterList.isTypeScriptSpecific()) {
                return true;
            }
            if (this.typeAnnotation !== null) {
                return true;
            }
            return false;
        };
        return CallSignatureSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.CallSignatureSyntax = CallSignatureSyntax;
    var ParameterListSyntax = (function (_super) {
        __extends(ParameterListSyntax, _super);
        function ParameterListSyntax(openParenToken, parameters, closeParenToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.openParenToken = openParenToken;
            _this.parameters = parameters;
            _this.closeParenToken = closeParenToken;
            return _this;
        }
        ParameterListSyntax.prototype.accept = function (visitor) {
            return visitor.visitParameterList(this);
        };
        ParameterListSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ParameterList;
        };
        ParameterListSyntax.prototype.childCount = function () {
            return 3;
        };
        ParameterListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.openParenToken;
                case 1: return this.parameters;
                case 2: return this.closeParenToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ParameterListSyntax.prototype.update = function (openParenToken, parameters, closeParenToken) {
            if (this.openParenToken === openParenToken && this.parameters === parameters && this.closeParenToken === closeParenToken) {
                return this;
            }
            return new ParameterListSyntax(openParenToken, parameters, closeParenToken, this.parsedInStrictMode());
        };
        ParameterListSyntax.create = function (openParenToken, closeParenToken) {
            return new ParameterListSyntax(openParenToken, TypeScript.Syntax.emptySeparatedList, closeParenToken, false);
        };
        ParameterListSyntax.create1 = function () {
            return new ParameterListSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), false);
        };
        ParameterListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ParameterListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ParameterListSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(openParenToken, this.parameters, this.closeParenToken);
        };
        ParameterListSyntax.prototype.withParameters = function (parameters) {
            return this.update(this.openParenToken, parameters, this.closeParenToken);
        };
        ParameterListSyntax.prototype.withParameter = function (parameter) {
            return this.withParameters(TypeScript.Syntax.separatedList([parameter]));
        };
        ParameterListSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.openParenToken, this.parameters, closeParenToken);
        };
        ParameterListSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.parameters.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ParameterListSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ParameterListSyntax = ParameterListSyntax;
    var TypeParameterListSyntax = (function (_super) {
        __extends(TypeParameterListSyntax, _super);
        function TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.lessThanToken = lessThanToken;
            _this.typeParameters = typeParameters;
            _this.greaterThanToken = greaterThanToken;
            return _this;
        }
        TypeParameterListSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeParameterList(this);
        };
        TypeParameterListSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeParameterList;
        };
        TypeParameterListSyntax.prototype.childCount = function () {
            return 3;
        };
        TypeParameterListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.lessThanToken;
                case 1: return this.typeParameters;
                case 2: return this.greaterThanToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        TypeParameterListSyntax.prototype.update = function (lessThanToken, typeParameters, greaterThanToken) {
            if (this.lessThanToken === lessThanToken && this.typeParameters === typeParameters && this.greaterThanToken === greaterThanToken) {
                return this;
            }
            return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, this.parsedInStrictMode());
        };
        TypeParameterListSyntax.create = function (lessThanToken, greaterThanToken) {
            return new TypeParameterListSyntax(lessThanToken, TypeScript.Syntax.emptySeparatedList, greaterThanToken, false);
        };
        TypeParameterListSyntax.create1 = function () {
            return new TypeParameterListSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.LessThanToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.GreaterThanToken), false);
        };
        TypeParameterListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        TypeParameterListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        TypeParameterListSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.typeParameters, this.greaterThanToken);
        };
        TypeParameterListSyntax.prototype.withTypeParameters = function (typeParameters) {
            return this.update(this.lessThanToken, typeParameters, this.greaterThanToken);
        };
        TypeParameterListSyntax.prototype.withTypeParameter = function (typeParameter) {
            return this.withTypeParameters(TypeScript.Syntax.separatedList([typeParameter]));
        };
        TypeParameterListSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.typeParameters, greaterThanToken);
        };
        TypeParameterListSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeParameterListSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.TypeParameterListSyntax = TypeParameterListSyntax;
    var TypeParameterSyntax = (function (_super) {
        __extends(TypeParameterSyntax, _super);
        function TypeParameterSyntax(identifier, constraint, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.identifier = identifier;
            _this.constraint = constraint;
            return _this;
        }
        TypeParameterSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeParameter(this);
        };
        TypeParameterSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeParameter;
        };
        TypeParameterSyntax.prototype.childCount = function () {
            return 2;
        };
        TypeParameterSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.identifier;
                case 1: return this.constraint;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        TypeParameterSyntax.prototype.update = function (identifier, constraint) {
            if (this.identifier === identifier && this.constraint === constraint) {
                return this;
            }
            return new TypeParameterSyntax(identifier, constraint, this.parsedInStrictMode());
        };
        TypeParameterSyntax.create = function (identifier) {
            return new TypeParameterSyntax(identifier, null, false);
        };
        TypeParameterSyntax.create1 = function (identifier) {
            return new TypeParameterSyntax(identifier, null, false);
        };
        TypeParameterSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        TypeParameterSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        TypeParameterSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.constraint);
        };
        TypeParameterSyntax.prototype.withConstraint = function (constraint) {
            return this.update(this.identifier, constraint);
        };
        TypeParameterSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeParameterSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.TypeParameterSyntax = TypeParameterSyntax;
    var ConstraintSyntax = (function (_super) {
        __extends(ConstraintSyntax, _super);
        function ConstraintSyntax(extendsKeyword, type, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.extendsKeyword = extendsKeyword;
            _this.type = type;
            return _this;
        }
        ConstraintSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstraint(this);
        };
        ConstraintSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.Constraint;
        };
        ConstraintSyntax.prototype.childCount = function () {
            return 2;
        };
        ConstraintSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.extendsKeyword;
                case 1: return this.type;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ConstraintSyntax.prototype.update = function (extendsKeyword, type) {
            if (this.extendsKeyword === extendsKeyword && this.type === type) {
                return this;
            }
            return new ConstraintSyntax(extendsKeyword, type, this.parsedInStrictMode());
        };
        ConstraintSyntax.create1 = function (type) {
            return new ConstraintSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ExtendsKeyword), type, false);
        };
        ConstraintSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ConstraintSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ConstraintSyntax.prototype.withExtendsKeyword = function (extendsKeyword) {
            return this.update(extendsKeyword, this.type);
        };
        ConstraintSyntax.prototype.withType = function (type) {
            return this.update(this.extendsKeyword, type);
        };
        ConstraintSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstraintSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ConstraintSyntax = ConstraintSyntax;
    var ElseClauseSyntax = (function (_super) {
        __extends(ElseClauseSyntax, _super);
        function ElseClauseSyntax(elseKeyword, statement, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.elseKeyword = elseKeyword;
            _this.statement = statement;
            return _this;
        }
        ElseClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitElseClause(this);
        };
        ElseClauseSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ElseClause;
        };
        ElseClauseSyntax.prototype.childCount = function () {
            return 2;
        };
        ElseClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.elseKeyword;
                case 1: return this.statement;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ElseClauseSyntax.prototype.update = function (elseKeyword, statement) {
            if (this.elseKeyword === elseKeyword && this.statement === statement) {
                return this;
            }
            return new ElseClauseSyntax(elseKeyword, statement, this.parsedInStrictMode());
        };
        ElseClauseSyntax.create1 = function (statement) {
            return new ElseClauseSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ElseKeyword), statement, false);
        };
        ElseClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ElseClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ElseClauseSyntax.prototype.withElseKeyword = function (elseKeyword) {
            return this.update(elseKeyword, this.statement);
        };
        ElseClauseSyntax.prototype.withStatement = function (statement) {
            return this.update(this.elseKeyword, statement);
        };
        ElseClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ElseClauseSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ElseClauseSyntax = ElseClauseSyntax;
    var IfStatementSyntax = (function (_super) {
        __extends(IfStatementSyntax, _super);
        function IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.ifKeyword = ifKeyword;
            _this.openParenToken = openParenToken;
            _this.condition = condition;
            _this.closeParenToken = closeParenToken;
            _this.statement = statement;
            _this.elseClause = elseClause;
            return _this;
        }
        IfStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitIfStatement(this);
        };
        IfStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.IfStatement;
        };
        IfStatementSyntax.prototype.childCount = function () {
            return 6;
        };
        IfStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.ifKeyword;
                case 1: return this.openParenToken;
                case 2: return this.condition;
                case 3: return this.closeParenToken;
                case 4: return this.statement;
                case 5: return this.elseClause;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        IfStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        IfStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        IfStatementSyntax.prototype.update = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
            if (this.ifKeyword === ifKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement && this.elseClause === elseClause) {
                return this;
            }
            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, this.parsedInStrictMode());
        };
        IfStatementSyntax.create = function (ifKeyword, openParenToken, condition, closeParenToken, statement) {
            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, null, false);
        };
        IfStatementSyntax.create1 = function (condition, statement) {
            return new IfStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.IfKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), condition, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), statement, null, false);
        };
        IfStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        IfStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        IfStatementSyntax.prototype.withIfKeyword = function (ifKeyword) {
            return this.update(ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
        };
        IfStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.ifKeyword, openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
        };
        IfStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.ifKeyword, this.openParenToken, condition, this.closeParenToken, this.statement, this.elseClause);
        };
        IfStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, closeParenToken, this.statement, this.elseClause);
        };
        IfStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, statement, this.elseClause);
        };
        IfStatementSyntax.prototype.withElseClause = function (elseClause) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, elseClause);
        };
        IfStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            if (this.elseClause !== null && this.elseClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return IfStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.IfStatementSyntax = IfStatementSyntax;
    var ExpressionStatementSyntax = (function (_super) {
        __extends(ExpressionStatementSyntax, _super);
        function ExpressionStatementSyntax(expression, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.expression = expression;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        ExpressionStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitExpressionStatement(this);
        };
        ExpressionStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ExpressionStatement;
        };
        ExpressionStatementSyntax.prototype.childCount = function () {
            return 2;
        };
        ExpressionStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.expression;
                case 1: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ExpressionStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        ExpressionStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ExpressionStatementSyntax.prototype.update = function (expression, semicolonToken) {
            if (this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ExpressionStatementSyntax(expression, semicolonToken, this.parsedInStrictMode());
        };
        ExpressionStatementSyntax.create1 = function (expression) {
            return new ExpressionStatementSyntax(expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        ExpressionStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ExpressionStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ExpressionStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.semicolonToken);
        };
        ExpressionStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.expression, semicolonToken);
        };
        ExpressionStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ExpressionStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ExpressionStatementSyntax = ExpressionStatementSyntax;
    var ConstructorDeclarationSyntax = (function (_super) {
        __extends(ConstructorDeclarationSyntax, _super);
        function ConstructorDeclarationSyntax(modifiers, constructorKeyword, parameterList, block, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.modifiers = modifiers;
            _this.constructorKeyword = constructorKeyword;
            _this.parameterList = parameterList;
            _this.block = block;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        ConstructorDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructorDeclaration(this);
        };
        ConstructorDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ConstructorDeclaration;
        };
        ConstructorDeclarationSyntax.prototype.childCount = function () {
            return 5;
        };
        ConstructorDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.modifiers;
                case 1: return this.constructorKeyword;
                case 2: return this.parameterList;
                case 3: return this.block;
                case 4: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ConstructorDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };
        ConstructorDeclarationSyntax.prototype.update = function (modifiers, constructorKeyword, parameterList, block, semicolonToken) {
            if (this.modifiers === modifiers && this.constructorKeyword === constructorKeyword && this.parameterList === parameterList && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ConstructorDeclarationSyntax(modifiers, constructorKeyword, parameterList, block, semicolonToken, this.parsedInStrictMode());
        };
        ConstructorDeclarationSyntax.create = function (constructorKeyword, parameterList) {
            return new ConstructorDeclarationSyntax(TypeScript.Syntax.emptyList, constructorKeyword, parameterList, null, null, false);
        };
        ConstructorDeclarationSyntax.create1 = function () {
            return new ConstructorDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.ConstructorKeyword), ParameterListSyntax.create1(), null, null, false);
        };
        ConstructorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ConstructorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ConstructorDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.constructorKeyword, this.parameterList, this.block, this.semicolonToken);
        };
        ConstructorDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        ConstructorDeclarationSyntax.prototype.withConstructorKeyword = function (constructorKeyword) {
            return this.update(this.modifiers, constructorKeyword, this.parameterList, this.block, this.semicolonToken);
        };
        ConstructorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.modifiers, this.constructorKeyword, parameterList, this.block, this.semicolonToken);
        };
        ConstructorDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.constructorKeyword, this.parameterList, block, this.semicolonToken);
        };
        ConstructorDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.constructorKeyword, this.parameterList, this.block, semicolonToken);
        };
        ConstructorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructorDeclarationSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ConstructorDeclarationSyntax = ConstructorDeclarationSyntax;
    var MemberFunctionDeclarationSyntax = (function (_super) {
        __extends(MemberFunctionDeclarationSyntax, _super);
        function MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.modifiers = modifiers;
            _this.propertyName = propertyName;
            _this.callSignature = callSignature;
            _this.block = block;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        MemberFunctionDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberFunctionDeclaration(this);
        };
        MemberFunctionDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.MemberFunctionDeclaration;
        };
        MemberFunctionDeclarationSyntax.prototype.childCount = function () {
            return 5;
        };
        MemberFunctionDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.modifiers;
                case 1: return this.propertyName;
                case 2: return this.callSignature;
                case 3: return this.block;
                case 4: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        MemberFunctionDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };
        MemberFunctionDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };
        MemberFunctionDeclarationSyntax.prototype.update = function (modifiers, propertyName, callSignature, block, semicolonToken) {
            if (this.modifiers === modifiers && this.propertyName === propertyName && this.callSignature === callSignature && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, this.parsedInStrictMode());
        };
        MemberFunctionDeclarationSyntax.create = function (propertyName, callSignature) {
            return new MemberFunctionDeclarationSyntax(TypeScript.Syntax.emptyList, propertyName, callSignature, null, null, false);
        };
        MemberFunctionDeclarationSyntax.create1 = function (propertyName) {
            return new MemberFunctionDeclarationSyntax(TypeScript.Syntax.emptyList, propertyName, CallSignatureSyntax.create1(), null, null, false);
        };
        MemberFunctionDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        MemberFunctionDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        MemberFunctionDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.propertyName, this.callSignature, this.block, this.semicolonToken);
        };
        MemberFunctionDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        MemberFunctionDeclarationSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, propertyName, this.callSignature, this.block, this.semicolonToken);
        };
        MemberFunctionDeclarationSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.modifiers, this.propertyName, callSignature, this.block, this.semicolonToken);
        };
        MemberFunctionDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.propertyName, this.callSignature, block, this.semicolonToken);
        };
        MemberFunctionDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.propertyName, this.callSignature, this.block, semicolonToken);
        };
        MemberFunctionDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberFunctionDeclarationSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.MemberFunctionDeclarationSyntax = MemberFunctionDeclarationSyntax;
    var GetAccessorSyntax = (function (_super) {
        __extends(GetAccessorSyntax, _super);
        function GetAccessorSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.modifiers = modifiers;
            _this.getKeyword = getKeyword;
            _this.propertyName = propertyName;
            _this.parameterList = parameterList;
            _this.typeAnnotation = typeAnnotation;
            _this.block = block;
            return _this;
        }
        GetAccessorSyntax.prototype.accept = function (visitor) {
            return visitor.visitGetAccessor(this);
        };
        GetAccessorSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.GetAccessor;
        };
        GetAccessorSyntax.prototype.childCount = function () {
            return 6;
        };
        GetAccessorSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.modifiers;
                case 1: return this.getKeyword;
                case 2: return this.propertyName;
                case 3: return this.parameterList;
                case 4: return this.typeAnnotation;
                case 5: return this.block;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        GetAccessorSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };
        GetAccessorSyntax.prototype.isPropertyAssignment = function () {
            return true;
        };
        GetAccessorSyntax.prototype.isClassElement = function () {
            return true;
        };
        GetAccessorSyntax.prototype.update = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
            if (this.modifiers === modifiers && this.getKeyword === getKeyword && this.propertyName === propertyName && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation && this.block === block) {
                return this;
            }
            return new GetAccessorSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, this.parsedInStrictMode());
        };
        GetAccessorSyntax.create = function (getKeyword, propertyName, parameterList, block) {
            return new GetAccessorSyntax(TypeScript.Syntax.emptyList, getKeyword, propertyName, parameterList, null, block, false);
        };
        GetAccessorSyntax.create1 = function (propertyName) {
            return new GetAccessorSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.GetKeyword), propertyName, ParameterListSyntax.create1(), null, BlockSyntax.create1(), false);
        };
        GetAccessorSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        GetAccessorSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        GetAccessorSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, this.block);
        };
        GetAccessorSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        GetAccessorSyntax.prototype.withGetKeyword = function (getKeyword) {
            return this.update(this.modifiers, getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, this.block);
        };
        GetAccessorSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, this.getKeyword, propertyName, this.parameterList, this.typeAnnotation, this.block);
        };
        GetAccessorSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, parameterList, this.typeAnnotation, this.block);
        };
        GetAccessorSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, this.parameterList, typeAnnotation, this.block);
        };
        GetAccessorSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, block);
        };
        GetAccessorSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.modifiers.childCount() > 0) {
                return true;
            }
            if (this.parameterList.isTypeScriptSpecific()) {
                return true;
            }
            if (this.typeAnnotation !== null) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return GetAccessorSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.GetAccessorSyntax = GetAccessorSyntax;
    var SetAccessorSyntax = (function (_super) {
        __extends(SetAccessorSyntax, _super);
        function SetAccessorSyntax(modifiers, setKeyword, propertyName, parameterList, block, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.modifiers = modifiers;
            _this.setKeyword = setKeyword;
            _this.propertyName = propertyName;
            _this.parameterList = parameterList;
            _this.block = block;
            return _this;
        }
        SetAccessorSyntax.prototype.accept = function (visitor) {
            return visitor.visitSetAccessor(this);
        };
        SetAccessorSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.SetAccessor;
        };
        SetAccessorSyntax.prototype.childCount = function () {
            return 5;
        };
        SetAccessorSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.modifiers;
                case 1: return this.setKeyword;
                case 2: return this.propertyName;
                case 3: return this.parameterList;
                case 4: return this.block;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        SetAccessorSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };
        SetAccessorSyntax.prototype.isPropertyAssignment = function () {
            return true;
        };
        SetAccessorSyntax.prototype.isClassElement = function () {
            return true;
        };
        SetAccessorSyntax.prototype.update = function (modifiers, setKeyword, propertyName, parameterList, block) {
            if (this.modifiers === modifiers && this.setKeyword === setKeyword && this.propertyName === propertyName && this.parameterList === parameterList && this.block === block) {
                return this;
            }
            return new SetAccessorSyntax(modifiers, setKeyword, propertyName, parameterList, block, this.parsedInStrictMode());
        };
        SetAccessorSyntax.create = function (setKeyword, propertyName, parameterList, block) {
            return new SetAccessorSyntax(TypeScript.Syntax.emptyList, setKeyword, propertyName, parameterList, block, false);
        };
        SetAccessorSyntax.create1 = function (propertyName) {
            return new SetAccessorSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.SetKeyword), propertyName, ParameterListSyntax.create1(), BlockSyntax.create1(), false);
        };
        SetAccessorSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        SetAccessorSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        SetAccessorSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.setKeyword, this.propertyName, this.parameterList, this.block);
        };
        SetAccessorSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        SetAccessorSyntax.prototype.withSetKeyword = function (setKeyword) {
            return this.update(this.modifiers, setKeyword, this.propertyName, this.parameterList, this.block);
        };
        SetAccessorSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, this.setKeyword, propertyName, this.parameterList, this.block);
        };
        SetAccessorSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.modifiers, this.setKeyword, this.propertyName, parameterList, this.block);
        };
        SetAccessorSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.setKeyword, this.propertyName, this.parameterList, block);
        };
        SetAccessorSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return SetAccessorSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.SetAccessorSyntax = SetAccessorSyntax;
    var MemberVariableDeclarationSyntax = (function (_super) {
        __extends(MemberVariableDeclarationSyntax, _super);
        function MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.modifiers = modifiers;
            _this.variableDeclarator = variableDeclarator;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        MemberVariableDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberVariableDeclaration(this);
        };
        MemberVariableDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.MemberVariableDeclaration;
        };
        MemberVariableDeclarationSyntax.prototype.childCount = function () {
            return 3;
        };
        MemberVariableDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.modifiers;
                case 1: return this.variableDeclarator;
                case 2: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        MemberVariableDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };
        MemberVariableDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };
        MemberVariableDeclarationSyntax.prototype.update = function (modifiers, variableDeclarator, semicolonToken) {
            if (this.modifiers === modifiers && this.variableDeclarator === variableDeclarator && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, this.parsedInStrictMode());
        };
        MemberVariableDeclarationSyntax.create = function (variableDeclarator, semicolonToken) {
            return new MemberVariableDeclarationSyntax(TypeScript.Syntax.emptyList, variableDeclarator, semicolonToken, false);
        };
        MemberVariableDeclarationSyntax.create1 = function (variableDeclarator) {
            return new MemberVariableDeclarationSyntax(TypeScript.Syntax.emptyList, variableDeclarator, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        MemberVariableDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        MemberVariableDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        MemberVariableDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.variableDeclarator, this.semicolonToken);
        };
        MemberVariableDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        MemberVariableDeclarationSyntax.prototype.withVariableDeclarator = function (variableDeclarator) {
            return this.update(this.modifiers, variableDeclarator, this.semicolonToken);
        };
        MemberVariableDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.variableDeclarator, semicolonToken);
        };
        MemberVariableDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberVariableDeclarationSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.MemberVariableDeclarationSyntax = MemberVariableDeclarationSyntax;
    var IndexMemberDeclarationSyntax = (function (_super) {
        __extends(IndexMemberDeclarationSyntax, _super);
        function IndexMemberDeclarationSyntax(modifiers, indexSignature, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.modifiers = modifiers;
            _this.indexSignature = indexSignature;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        IndexMemberDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitIndexMemberDeclaration(this);
        };
        IndexMemberDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.IndexMemberDeclaration;
        };
        IndexMemberDeclarationSyntax.prototype.childCount = function () {
            return 3;
        };
        IndexMemberDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.modifiers;
                case 1: return this.indexSignature;
                case 2: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        IndexMemberDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };
        IndexMemberDeclarationSyntax.prototype.update = function (modifiers, indexSignature, semicolonToken) {
            if (this.modifiers === modifiers && this.indexSignature === indexSignature && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new IndexMemberDeclarationSyntax(modifiers, indexSignature, semicolonToken, this.parsedInStrictMode());
        };
        IndexMemberDeclarationSyntax.create = function (indexSignature, semicolonToken) {
            return new IndexMemberDeclarationSyntax(TypeScript.Syntax.emptyList, indexSignature, semicolonToken, false);
        };
        IndexMemberDeclarationSyntax.create1 = function (indexSignature) {
            return new IndexMemberDeclarationSyntax(TypeScript.Syntax.emptyList, indexSignature, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        IndexMemberDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        IndexMemberDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        IndexMemberDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.indexSignature, this.semicolonToken);
        };
        IndexMemberDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        IndexMemberDeclarationSyntax.prototype.withIndexSignature = function (indexSignature) {
            return this.update(this.modifiers, indexSignature, this.semicolonToken);
        };
        IndexMemberDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.indexSignature, semicolonToken);
        };
        IndexMemberDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return IndexMemberDeclarationSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.IndexMemberDeclarationSyntax = IndexMemberDeclarationSyntax;
    var ThrowStatementSyntax = (function (_super) {
        __extends(ThrowStatementSyntax, _super);
        function ThrowStatementSyntax(throwKeyword, expression, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.throwKeyword = throwKeyword;
            _this.expression = expression;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        ThrowStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitThrowStatement(this);
        };
        ThrowStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ThrowStatement;
        };
        ThrowStatementSyntax.prototype.childCount = function () {
            return 3;
        };
        ThrowStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.throwKeyword;
                case 1: return this.expression;
                case 2: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ThrowStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        ThrowStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ThrowStatementSyntax.prototype.update = function (throwKeyword, expression, semicolonToken) {
            if (this.throwKeyword === throwKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, this.parsedInStrictMode());
        };
        ThrowStatementSyntax.create1 = function (expression) {
            return new ThrowStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ThrowKeyword), expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        ThrowStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ThrowStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ThrowStatementSyntax.prototype.withThrowKeyword = function (throwKeyword) {
            return this.update(throwKeyword, this.expression, this.semicolonToken);
        };
        ThrowStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.throwKeyword, expression, this.semicolonToken);
        };
        ThrowStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.throwKeyword, this.expression, semicolonToken);
        };
        ThrowStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ThrowStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ThrowStatementSyntax = ThrowStatementSyntax;
    var ReturnStatementSyntax = (function (_super) {
        __extends(ReturnStatementSyntax, _super);
        function ReturnStatementSyntax(returnKeyword, expression, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.returnKeyword = returnKeyword;
            _this.expression = expression;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        ReturnStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitReturnStatement(this);
        };
        ReturnStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ReturnStatement;
        };
        ReturnStatementSyntax.prototype.childCount = function () {
            return 3;
        };
        ReturnStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.returnKeyword;
                case 1: return this.expression;
                case 2: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ReturnStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        ReturnStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ReturnStatementSyntax.prototype.update = function (returnKeyword, expression, semicolonToken) {
            if (this.returnKeyword === returnKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, this.parsedInStrictMode());
        };
        ReturnStatementSyntax.create = function (returnKeyword, semicolonToken) {
            return new ReturnStatementSyntax(returnKeyword, null, semicolonToken, false);
        };
        ReturnStatementSyntax.create1 = function () {
            return new ReturnStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ReturnKeyword), null, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        ReturnStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ReturnStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ReturnStatementSyntax.prototype.withReturnKeyword = function (returnKeyword) {
            return this.update(returnKeyword, this.expression, this.semicolonToken);
        };
        ReturnStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.returnKeyword, expression, this.semicolonToken);
        };
        ReturnStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.returnKeyword, this.expression, semicolonToken);
        };
        ReturnStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression !== null && this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ReturnStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ReturnStatementSyntax = ReturnStatementSyntax;
    var ObjectCreationExpressionSyntax = (function (_super) {
        __extends(ObjectCreationExpressionSyntax, _super);
        function ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.newKeyword = newKeyword;
            _this.expression = expression;
            _this.argumentList = argumentList;
            return _this;
        }
        ObjectCreationExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectCreationExpression(this);
        };
        ObjectCreationExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ObjectCreationExpression;
        };
        ObjectCreationExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        ObjectCreationExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.newKeyword;
                case 1: return this.expression;
                case 2: return this.argumentList;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ObjectCreationExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };
        ObjectCreationExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };
        ObjectCreationExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ObjectCreationExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ObjectCreationExpressionSyntax.prototype.update = function (newKeyword, expression, argumentList) {
            if (this.newKeyword === newKeyword && this.expression === expression && this.argumentList === argumentList) {
                return this;
            }
            return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, this.parsedInStrictMode());
        };
        ObjectCreationExpressionSyntax.create = function (newKeyword, expression) {
            return new ObjectCreationExpressionSyntax(newKeyword, expression, null, false);
        };
        ObjectCreationExpressionSyntax.create1 = function (expression) {
            return new ObjectCreationExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.NewKeyword), expression, null, false);
        };
        ObjectCreationExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ObjectCreationExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ObjectCreationExpressionSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.expression, this.argumentList);
        };
        ObjectCreationExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.newKeyword, expression, this.argumentList);
        };
        ObjectCreationExpressionSyntax.prototype.withArgumentList = function (argumentList) {
            return this.update(this.newKeyword, this.expression, argumentList);
        };
        ObjectCreationExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentList !== null && this.argumentList.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ObjectCreationExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ObjectCreationExpressionSyntax = ObjectCreationExpressionSyntax;
    var SwitchStatementSyntax = (function (_super) {
        __extends(SwitchStatementSyntax, _super);
        function SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.switchKeyword = switchKeyword;
            _this.openParenToken = openParenToken;
            _this.expression = expression;
            _this.closeParenToken = closeParenToken;
            _this.openBraceToken = openBraceToken;
            _this.switchClauses = switchClauses;
            _this.closeBraceToken = closeBraceToken;
            return _this;
        }
        SwitchStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitSwitchStatement(this);
        };
        SwitchStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.SwitchStatement;
        };
        SwitchStatementSyntax.prototype.childCount = function () {
            return 7;
        };
        SwitchStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.switchKeyword;
                case 1: return this.openParenToken;
                case 2: return this.expression;
                case 3: return this.closeParenToken;
                case 4: return this.openBraceToken;
                case 5: return this.switchClauses;
                case 6: return this.closeBraceToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        SwitchStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        SwitchStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        SwitchStatementSyntax.prototype.update = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
            if (this.switchKeyword === switchKeyword && this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken && this.openBraceToken === openBraceToken && this.switchClauses === switchClauses && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, this.parsedInStrictMode());
        };
        SwitchStatementSyntax.create = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, closeBraceToken) {
            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };
        SwitchStatementSyntax.create1 = function (expression) {
            return new SwitchStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.SwitchKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        SwitchStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        SwitchStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        SwitchStatementSyntax.prototype.withSwitchKeyword = function (switchKeyword) {
            return this.update(switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };
        SwitchStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.switchKeyword, openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };
        SwitchStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.switchKeyword, this.openParenToken, expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };
        SwitchStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };
        SwitchStatementSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, openBraceToken, this.switchClauses, this.closeBraceToken);
        };
        SwitchStatementSyntax.prototype.withSwitchClauses = function (switchClauses) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, switchClauses, this.closeBraceToken);
        };
        SwitchStatementSyntax.prototype.withSwitchClause = function (switchClause) {
            return this.withSwitchClauses(TypeScript.Syntax.list([switchClause]));
        };
        SwitchStatementSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, closeBraceToken);
        };
        SwitchStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.switchClauses.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SwitchStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.SwitchStatementSyntax = SwitchStatementSyntax;
    var CaseSwitchClauseSyntax = (function (_super) {
        __extends(CaseSwitchClauseSyntax, _super);
        function CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.caseKeyword = caseKeyword;
            _this.expression = expression;
            _this.colonToken = colonToken;
            _this.statements = statements;
            return _this;
        }
        CaseSwitchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitCaseSwitchClause(this);
        };
        CaseSwitchClauseSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.CaseSwitchClause;
        };
        CaseSwitchClauseSyntax.prototype.childCount = function () {
            return 4;
        };
        CaseSwitchClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.caseKeyword;
                case 1: return this.expression;
                case 2: return this.colonToken;
                case 3: return this.statements;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        CaseSwitchClauseSyntax.prototype.isSwitchClause = function () {
            return true;
        };
        CaseSwitchClauseSyntax.prototype.update = function (caseKeyword, expression, colonToken, statements) {
            if (this.caseKeyword === caseKeyword && this.expression === expression && this.colonToken === colonToken && this.statements === statements) {
                return this;
            }
            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, this.parsedInStrictMode());
        };
        CaseSwitchClauseSyntax.create = function (caseKeyword, expression, colonToken) {
            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, TypeScript.Syntax.emptyList, false);
        };
        CaseSwitchClauseSyntax.create1 = function (expression) {
            return new CaseSwitchClauseSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.CaseKeyword), expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.ColonToken), TypeScript.Syntax.emptyList, false);
        };
        CaseSwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        CaseSwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        CaseSwitchClauseSyntax.prototype.withCaseKeyword = function (caseKeyword) {
            return this.update(caseKeyword, this.expression, this.colonToken, this.statements);
        };
        CaseSwitchClauseSyntax.prototype.withExpression = function (expression) {
            return this.update(this.caseKeyword, expression, this.colonToken, this.statements);
        };
        CaseSwitchClauseSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.caseKeyword, this.expression, colonToken, this.statements);
        };
        CaseSwitchClauseSyntax.prototype.withStatements = function (statements) {
            return this.update(this.caseKeyword, this.expression, this.colonToken, statements);
        };
        CaseSwitchClauseSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([statement]));
        };
        CaseSwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return CaseSwitchClauseSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.CaseSwitchClauseSyntax = CaseSwitchClauseSyntax;
    var DefaultSwitchClauseSyntax = (function (_super) {
        __extends(DefaultSwitchClauseSyntax, _super);
        function DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.defaultKeyword = defaultKeyword;
            _this.colonToken = colonToken;
            _this.statements = statements;
            return _this;
        }
        DefaultSwitchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitDefaultSwitchClause(this);
        };
        DefaultSwitchClauseSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.DefaultSwitchClause;
        };
        DefaultSwitchClauseSyntax.prototype.childCount = function () {
            return 3;
        };
        DefaultSwitchClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.defaultKeyword;
                case 1: return this.colonToken;
                case 2: return this.statements;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        DefaultSwitchClauseSyntax.prototype.isSwitchClause = function () {
            return true;
        };
        DefaultSwitchClauseSyntax.prototype.update = function (defaultKeyword, colonToken, statements) {
            if (this.defaultKeyword === defaultKeyword && this.colonToken === colonToken && this.statements === statements) {
                return this;
            }
            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, this.parsedInStrictMode());
        };
        DefaultSwitchClauseSyntax.create = function (defaultKeyword, colonToken) {
            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, TypeScript.Syntax.emptyList, false);
        };
        DefaultSwitchClauseSyntax.create1 = function () {
            return new DefaultSwitchClauseSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.DefaultKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.ColonToken), TypeScript.Syntax.emptyList, false);
        };
        DefaultSwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        DefaultSwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        DefaultSwitchClauseSyntax.prototype.withDefaultKeyword = function (defaultKeyword) {
            return this.update(defaultKeyword, this.colonToken, this.statements);
        };
        DefaultSwitchClauseSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.defaultKeyword, colonToken, this.statements);
        };
        DefaultSwitchClauseSyntax.prototype.withStatements = function (statements) {
            return this.update(this.defaultKeyword, this.colonToken, statements);
        };
        DefaultSwitchClauseSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([statement]));
        };
        DefaultSwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DefaultSwitchClauseSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.DefaultSwitchClauseSyntax = DefaultSwitchClauseSyntax;
    var BreakStatementSyntax = (function (_super) {
        __extends(BreakStatementSyntax, _super);
        function BreakStatementSyntax(breakKeyword, identifier, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.breakKeyword = breakKeyword;
            _this.identifier = identifier;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        BreakStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitBreakStatement(this);
        };
        BreakStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.BreakStatement;
        };
        BreakStatementSyntax.prototype.childCount = function () {
            return 3;
        };
        BreakStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.breakKeyword;
                case 1: return this.identifier;
                case 2: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        BreakStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        BreakStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        BreakStatementSyntax.prototype.update = function (breakKeyword, identifier, semicolonToken) {
            if (this.breakKeyword === breakKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, this.parsedInStrictMode());
        };
        BreakStatementSyntax.create = function (breakKeyword, semicolonToken) {
            return new BreakStatementSyntax(breakKeyword, null, semicolonToken, false);
        };
        BreakStatementSyntax.create1 = function () {
            return new BreakStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.BreakKeyword), null, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        BreakStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        BreakStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        BreakStatementSyntax.prototype.withBreakKeyword = function (breakKeyword) {
            return this.update(breakKeyword, this.identifier, this.semicolonToken);
        };
        BreakStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.breakKeyword, identifier, this.semicolonToken);
        };
        BreakStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.breakKeyword, this.identifier, semicolonToken);
        };
        BreakStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return BreakStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.BreakStatementSyntax = BreakStatementSyntax;
    var ContinueStatementSyntax = (function (_super) {
        __extends(ContinueStatementSyntax, _super);
        function ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.continueKeyword = continueKeyword;
            _this.identifier = identifier;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        ContinueStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitContinueStatement(this);
        };
        ContinueStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ContinueStatement;
        };
        ContinueStatementSyntax.prototype.childCount = function () {
            return 3;
        };
        ContinueStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.continueKeyword;
                case 1: return this.identifier;
                case 2: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ContinueStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        ContinueStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ContinueStatementSyntax.prototype.update = function (continueKeyword, identifier, semicolonToken) {
            if (this.continueKeyword === continueKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, this.parsedInStrictMode());
        };
        ContinueStatementSyntax.create = function (continueKeyword, semicolonToken) {
            return new ContinueStatementSyntax(continueKeyword, null, semicolonToken, false);
        };
        ContinueStatementSyntax.create1 = function () {
            return new ContinueStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ContinueKeyword), null, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        ContinueStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ContinueStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ContinueStatementSyntax.prototype.withContinueKeyword = function (continueKeyword) {
            return this.update(continueKeyword, this.identifier, this.semicolonToken);
        };
        ContinueStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.continueKeyword, identifier, this.semicolonToken);
        };
        ContinueStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.continueKeyword, this.identifier, semicolonToken);
        };
        ContinueStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return ContinueStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ContinueStatementSyntax = ContinueStatementSyntax;
    var ForStatementSyntax = (function (_super) {
        __extends(ForStatementSyntax, _super);
        function ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.forKeyword = forKeyword;
            _this.openParenToken = openParenToken;
            _this.variableDeclaration = variableDeclaration;
            _this.initializer = initializer;
            _this.firstSemicolonToken = firstSemicolonToken;
            _this.condition = condition;
            _this.secondSemicolonToken = secondSemicolonToken;
            _this.incrementor = incrementor;
            _this.closeParenToken = closeParenToken;
            _this.statement = statement;
            return _this;
        }
        ForStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitForStatement(this);
        };
        ForStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ForStatement;
        };
        ForStatementSyntax.prototype.childCount = function () {
            return 10;
        };
        ForStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.forKeyword;
                case 1: return this.openParenToken;
                case 2: return this.variableDeclaration;
                case 3: return this.initializer;
                case 4: return this.firstSemicolonToken;
                case 5: return this.condition;
                case 6: return this.secondSemicolonToken;
                case 7: return this.incrementor;
                case 8: return this.closeParenToken;
                case 9: return this.statement;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ForStatementSyntax.prototype.isIterationStatement = function () {
            return true;
        };
        ForStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        ForStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ForStatementSyntax.prototype.update = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
            if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.initializer === initializer && this.firstSemicolonToken === firstSemicolonToken && this.condition === condition && this.secondSemicolonToken === secondSemicolonToken && this.incrementor === incrementor && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }
            return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, this.parsedInStrictMode());
        };
        ForStatementSyntax.create = function (forKeyword, openParenToken, firstSemicolonToken, secondSemicolonToken, closeParenToken, statement) {
            return new ForStatementSyntax(forKeyword, openParenToken, null, null, firstSemicolonToken, null, secondSemicolonToken, null, closeParenToken, statement, false);
        };
        ForStatementSyntax.create1 = function (statement) {
            return new ForStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ForKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), null, null, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), null, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), null, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), statement, false);
        };
        ForStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ForStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ForStatementSyntax.prototype.withForKeyword = function (forKeyword) {
            return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withInitializer = function (initializer) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withFirstSemicolonToken = function (firstSemicolonToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withSecondSemicolonToken = function (secondSemicolonToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withIncrementor = function (incrementor) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, statement);
        };
        ForStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            if (this.initializer !== null && this.initializer.isTypeScriptSpecific()) {
                return true;
            }
            if (this.condition !== null && this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.incrementor !== null && this.incrementor.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ForStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ForStatementSyntax = ForStatementSyntax;
    var ForInStatementSyntax = (function (_super) {
        __extends(ForInStatementSyntax, _super);
        function ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.forKeyword = forKeyword;
            _this.openParenToken = openParenToken;
            _this.variableDeclaration = variableDeclaration;
            _this.left = left;
            _this.inKeyword = inKeyword;
            _this.expression = expression;
            _this.closeParenToken = closeParenToken;
            _this.statement = statement;
            return _this;
        }
        ForInStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitForInStatement(this);
        };
        ForInStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ForInStatement;
        };
        ForInStatementSyntax.prototype.childCount = function () {
            return 8;
        };
        ForInStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.forKeyword;
                case 1: return this.openParenToken;
                case 2: return this.variableDeclaration;
                case 3: return this.left;
                case 4: return this.inKeyword;
                case 5: return this.expression;
                case 6: return this.closeParenToken;
                case 7: return this.statement;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ForInStatementSyntax.prototype.isIterationStatement = function () {
            return true;
        };
        ForInStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        ForInStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ForInStatementSyntax.prototype.update = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
            if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.left === left && this.inKeyword === inKeyword && this.expression === expression && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }
            return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, this.parsedInStrictMode());
        };
        ForInStatementSyntax.create = function (forKeyword, openParenToken, inKeyword, expression, closeParenToken, statement) {
            return new ForInStatementSyntax(forKeyword, openParenToken, null, null, inKeyword, expression, closeParenToken, statement, false);
        };
        ForInStatementSyntax.create1 = function (expression, statement) {
            return new ForInStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ForKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), null, null, TypeScript.Syntax.token(TypeScript.SyntaxKind.InKeyword), expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), statement, false);
        };
        ForInStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ForInStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ForInStatementSyntax.prototype.withForKeyword = function (forKeyword) {
            return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withLeft = function (left) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withInKeyword = function (inKeyword) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, inKeyword, this.expression, this.closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, expression, this.closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, statement);
        };
        ForInStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            if (this.left !== null && this.left.isTypeScriptSpecific()) {
                return true;
            }
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ForInStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ForInStatementSyntax = ForInStatementSyntax;
    var WhileStatementSyntax = (function (_super) {
        __extends(WhileStatementSyntax, _super);
        function WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.whileKeyword = whileKeyword;
            _this.openParenToken = openParenToken;
            _this.condition = condition;
            _this.closeParenToken = closeParenToken;
            _this.statement = statement;
            return _this;
        }
        WhileStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitWhileStatement(this);
        };
        WhileStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.WhileStatement;
        };
        WhileStatementSyntax.prototype.childCount = function () {
            return 5;
        };
        WhileStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.whileKeyword;
                case 1: return this.openParenToken;
                case 2: return this.condition;
                case 3: return this.closeParenToken;
                case 4: return this.statement;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        WhileStatementSyntax.prototype.isIterationStatement = function () {
            return true;
        };
        WhileStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        WhileStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        WhileStatementSyntax.prototype.update = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
            if (this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }
            return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, this.parsedInStrictMode());
        };
        WhileStatementSyntax.create1 = function (condition, statement) {
            return new WhileStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.WhileKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), condition, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), statement, false);
        };
        WhileStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        WhileStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        WhileStatementSyntax.prototype.withWhileKeyword = function (whileKeyword) {
            return this.update(whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
        };
        WhileStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
        };
        WhileStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
        };
        WhileStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
        };
        WhileStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
        };
        WhileStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return WhileStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.WhileStatementSyntax = WhileStatementSyntax;
    var WithStatementSyntax = (function (_super) {
        __extends(WithStatementSyntax, _super);
        function WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.withKeyword = withKeyword;
            _this.openParenToken = openParenToken;
            _this.condition = condition;
            _this.closeParenToken = closeParenToken;
            _this.statement = statement;
            return _this;
        }
        WithStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitWithStatement(this);
        };
        WithStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.WithStatement;
        };
        WithStatementSyntax.prototype.childCount = function () {
            return 5;
        };
        WithStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.withKeyword;
                case 1: return this.openParenToken;
                case 2: return this.condition;
                case 3: return this.closeParenToken;
                case 4: return this.statement;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        WithStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        WithStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        WithStatementSyntax.prototype.update = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
            if (this.withKeyword === withKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }
            return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, this.parsedInStrictMode());
        };
        WithStatementSyntax.create1 = function (condition, statement) {
            return new WithStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.WithKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), condition, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), statement, false);
        };
        WithStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        WithStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        WithStatementSyntax.prototype.withWithKeyword = function (withKeyword) {
            return this.update(withKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
        };
        WithStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.withKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
        };
        WithStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.withKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
        };
        WithStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.withKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
        };
        WithStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.withKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
        };
        WithStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return WithStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.WithStatementSyntax = WithStatementSyntax;
    var EnumDeclarationSyntax = (function (_super) {
        __extends(EnumDeclarationSyntax, _super);
        function EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.modifiers = modifiers;
            _this.enumKeyword = enumKeyword;
            _this.identifier = identifier;
            _this.openBraceToken = openBraceToken;
            _this.enumElements = enumElements;
            _this.closeBraceToken = closeBraceToken;
            return _this;
        }
        EnumDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitEnumDeclaration(this);
        };
        EnumDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.EnumDeclaration;
        };
        EnumDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };
        EnumDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.modifiers;
                case 1: return this.enumKeyword;
                case 2: return this.identifier;
                case 3: return this.openBraceToken;
                case 4: return this.enumElements;
                case 5: return this.closeBraceToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        EnumDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };
        EnumDeclarationSyntax.prototype.update = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.enumKeyword === enumKeyword && this.identifier === identifier && this.openBraceToken === openBraceToken && this.enumElements === enumElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, this.parsedInStrictMode());
        };
        EnumDeclarationSyntax.create = function (enumKeyword, identifier, openBraceToken, closeBraceToken) {
            return new EnumDeclarationSyntax(TypeScript.Syntax.emptyList, enumKeyword, identifier, openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };
        EnumDeclarationSyntax.create1 = function (identifier) {
            return new EnumDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.EnumKeyword), identifier, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        EnumDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        EnumDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        EnumDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.enumKeyword, this.identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };
        EnumDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };
        EnumDeclarationSyntax.prototype.withEnumKeyword = function (enumKeyword) {
            return this.update(this.modifiers, enumKeyword, this.identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };
        EnumDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.enumKeyword, identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };
        EnumDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, openBraceToken, this.enumElements, this.closeBraceToken);
        };
        EnumDeclarationSyntax.prototype.withEnumElements = function (enumElements) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, this.openBraceToken, enumElements, this.closeBraceToken);
        };
        EnumDeclarationSyntax.prototype.withEnumElement = function (enumElement) {
            return this.withEnumElements(TypeScript.Syntax.separatedList([enumElement]));
        };
        EnumDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, this.openBraceToken, this.enumElements, closeBraceToken);
        };
        EnumDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return EnumDeclarationSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.EnumDeclarationSyntax = EnumDeclarationSyntax;
    var EnumElementSyntax = (function (_super) {
        __extends(EnumElementSyntax, _super);
        function EnumElementSyntax(propertyName, equalsValueClause, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.propertyName = propertyName;
            _this.equalsValueClause = equalsValueClause;
            return _this;
        }
        EnumElementSyntax.prototype.accept = function (visitor) {
            return visitor.visitEnumElement(this);
        };
        EnumElementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.EnumElement;
        };
        EnumElementSyntax.prototype.childCount = function () {
            return 2;
        };
        EnumElementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.propertyName;
                case 1: return this.equalsValueClause;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        EnumElementSyntax.prototype.update = function (propertyName, equalsValueClause) {
            if (this.propertyName === propertyName && this.equalsValueClause === equalsValueClause) {
                return this;
            }
            return new EnumElementSyntax(propertyName, equalsValueClause, this.parsedInStrictMode());
        };
        EnumElementSyntax.create = function (propertyName) {
            return new EnumElementSyntax(propertyName, null, false);
        };
        EnumElementSyntax.create1 = function (propertyName) {
            return new EnumElementSyntax(propertyName, null, false);
        };
        EnumElementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        EnumElementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        EnumElementSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.equalsValueClause);
        };
        EnumElementSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.propertyName, equalsValueClause);
        };
        EnumElementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return EnumElementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.EnumElementSyntax = EnumElementSyntax;
    var CastExpressionSyntax = (function (_super) {
        __extends(CastExpressionSyntax, _super);
        function CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.lessThanToken = lessThanToken;
            _this.type = type;
            _this.greaterThanToken = greaterThanToken;
            _this.expression = expression;
            return _this;
        }
        CastExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitCastExpression(this);
        };
        CastExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.CastExpression;
        };
        CastExpressionSyntax.prototype.childCount = function () {
            return 4;
        };
        CastExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.lessThanToken;
                case 1: return this.type;
                case 2: return this.greaterThanToken;
                case 3: return this.expression;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        CastExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        CastExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        CastExpressionSyntax.prototype.update = function (lessThanToken, type, greaterThanToken, expression) {
            if (this.lessThanToken === lessThanToken && this.type === type && this.greaterThanToken === greaterThanToken && this.expression === expression) {
                return this;
            }
            return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, this.parsedInStrictMode());
        };
        CastExpressionSyntax.create1 = function (type, expression) {
            return new CastExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.LessThanToken), type, TypeScript.Syntax.token(TypeScript.SyntaxKind.GreaterThanToken), expression, false);
        };
        CastExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        CastExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        CastExpressionSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.type, this.greaterThanToken, this.expression);
        };
        CastExpressionSyntax.prototype.withType = function (type) {
            return this.update(this.lessThanToken, type, this.greaterThanToken, this.expression);
        };
        CastExpressionSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.type, greaterThanToken, this.expression);
        };
        CastExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.lessThanToken, this.type, this.greaterThanToken, expression);
        };
        CastExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return CastExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.CastExpressionSyntax = CastExpressionSyntax;
    var ObjectLiteralExpressionSyntax = (function (_super) {
        __extends(ObjectLiteralExpressionSyntax, _super);
        function ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.openBraceToken = openBraceToken;
            _this.propertyAssignments = propertyAssignments;
            _this.closeBraceToken = closeBraceToken;
            return _this;
        }
        ObjectLiteralExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectLiteralExpression(this);
        };
        ObjectLiteralExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ObjectLiteralExpression;
        };
        ObjectLiteralExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        ObjectLiteralExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.openBraceToken;
                case 1: return this.propertyAssignments;
                case 2: return this.closeBraceToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        ObjectLiteralExpressionSyntax.prototype.isPrimaryExpression = function () {
            return true;
        };
        ObjectLiteralExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };
        ObjectLiteralExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };
        ObjectLiteralExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ObjectLiteralExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ObjectLiteralExpressionSyntax.prototype.update = function (openBraceToken, propertyAssignments, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.propertyAssignments === propertyAssignments && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, this.parsedInStrictMode());
        };
        ObjectLiteralExpressionSyntax.create = function (openBraceToken, closeBraceToken) {
            return new ObjectLiteralExpressionSyntax(openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };
        ObjectLiteralExpressionSyntax.create1 = function () {
            return new ObjectLiteralExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        ObjectLiteralExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ObjectLiteralExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ObjectLiteralExpressionSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.propertyAssignments, this.closeBraceToken);
        };
        ObjectLiteralExpressionSyntax.prototype.withPropertyAssignments = function (propertyAssignments) {
            return this.update(this.openBraceToken, propertyAssignments, this.closeBraceToken);
        };
        ObjectLiteralExpressionSyntax.prototype.withPropertyAssignment = function (propertyAssignment) {
            return this.withPropertyAssignments(TypeScript.Syntax.separatedList([propertyAssignment]));
        };
        ObjectLiteralExpressionSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.propertyAssignments, closeBraceToken);
        };
        ObjectLiteralExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.propertyAssignments.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ObjectLiteralExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.ObjectLiteralExpressionSyntax = ObjectLiteralExpressionSyntax;
    var SimplePropertyAssignmentSyntax = (function (_super) {
        __extends(SimplePropertyAssignmentSyntax, _super);
        function SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.propertyName = propertyName;
            _this.colonToken = colonToken;
            _this.expression = expression;
            return _this;
        }
        SimplePropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitSimplePropertyAssignment(this);
        };
        SimplePropertyAssignmentSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.SimplePropertyAssignment;
        };
        SimplePropertyAssignmentSyntax.prototype.childCount = function () {
            return 3;
        };
        SimplePropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.propertyName;
                case 1: return this.colonToken;
                case 2: return this.expression;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        SimplePropertyAssignmentSyntax.prototype.isPropertyAssignment = function () {
            return true;
        };
        SimplePropertyAssignmentSyntax.prototype.update = function (propertyName, colonToken, expression) {
            if (this.propertyName === propertyName && this.colonToken === colonToken && this.expression === expression) {
                return this;
            }
            return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, this.parsedInStrictMode());
        };
        SimplePropertyAssignmentSyntax.create1 = function (propertyName, expression) {
            return new SimplePropertyAssignmentSyntax(propertyName, TypeScript.Syntax.token(TypeScript.SyntaxKind.ColonToken), expression, false);
        };
        SimplePropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        SimplePropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        SimplePropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.colonToken, this.expression);
        };
        SimplePropertyAssignmentSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.propertyName, colonToken, this.expression);
        };
        SimplePropertyAssignmentSyntax.prototype.withExpression = function (expression) {
            return this.update(this.propertyName, this.colonToken, expression);
        };
        SimplePropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SimplePropertyAssignmentSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.SimplePropertyAssignmentSyntax = SimplePropertyAssignmentSyntax;
    var FunctionPropertyAssignmentSyntax = (function (_super) {
        __extends(FunctionPropertyAssignmentSyntax, _super);
        function FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.propertyName = propertyName;
            _this.callSignature = callSignature;
            _this.block = block;
            return _this;
        }
        FunctionPropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionPropertyAssignment(this);
        };
        FunctionPropertyAssignmentSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.FunctionPropertyAssignment;
        };
        FunctionPropertyAssignmentSyntax.prototype.childCount = function () {
            return 3;
        };
        FunctionPropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.propertyName;
                case 1: return this.callSignature;
                case 2: return this.block;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        FunctionPropertyAssignmentSyntax.prototype.isPropertyAssignment = function () {
            return true;
        };
        FunctionPropertyAssignmentSyntax.prototype.update = function (propertyName, callSignature, block) {
            if (this.propertyName === propertyName && this.callSignature === callSignature && this.block === block) {
                return this;
            }
            return new FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, this.parsedInStrictMode());
        };
        FunctionPropertyAssignmentSyntax.create1 = function (propertyName) {
            return new FunctionPropertyAssignmentSyntax(propertyName, CallSignatureSyntax.create1(), BlockSyntax.create1(), false);
        };
        FunctionPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        FunctionPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        FunctionPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.callSignature, this.block);
        };
        FunctionPropertyAssignmentSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.propertyName, callSignature, this.block);
        };
        FunctionPropertyAssignmentSyntax.prototype.withBlock = function (block) {
            return this.update(this.propertyName, this.callSignature, block);
        };
        FunctionPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionPropertyAssignmentSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.FunctionPropertyAssignmentSyntax = FunctionPropertyAssignmentSyntax;
    var FunctionExpressionSyntax = (function (_super) {
        __extends(FunctionExpressionSyntax, _super);
        function FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.functionKeyword = functionKeyword;
            _this.identifier = identifier;
            _this.callSignature = callSignature;
            _this.block = block;
            return _this;
        }
        FunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionExpression(this);
        };
        FunctionExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.FunctionExpression;
        };
        FunctionExpressionSyntax.prototype.childCount = function () {
            return 4;
        };
        FunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.functionKeyword;
                case 1: return this.identifier;
                case 2: return this.callSignature;
                case 3: return this.block;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        FunctionExpressionSyntax.prototype.isPrimaryExpression = function () {
            return true;
        };
        FunctionExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };
        FunctionExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };
        FunctionExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        FunctionExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        FunctionExpressionSyntax.prototype.update = function (functionKeyword, identifier, callSignature, block) {
            if (this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block) {
                return this;
            }
            return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, this.parsedInStrictMode());
        };
        FunctionExpressionSyntax.create = function (functionKeyword, callSignature, block) {
            return new FunctionExpressionSyntax(functionKeyword, null, callSignature, block, false);
        };
        FunctionExpressionSyntax.create1 = function () {
            return new FunctionExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.FunctionKeyword), null, CallSignatureSyntax.create1(), BlockSyntax.create1(), false);
        };
        FunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        FunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        FunctionExpressionSyntax.prototype.withFunctionKeyword = function (functionKeyword) {
            return this.update(functionKeyword, this.identifier, this.callSignature, this.block);
        };
        FunctionExpressionSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.functionKeyword, identifier, this.callSignature, this.block);
        };
        FunctionExpressionSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.functionKeyword, this.identifier, callSignature, this.block);
        };
        FunctionExpressionSyntax.prototype.withBlock = function (block) {
            return this.update(this.functionKeyword, this.identifier, this.callSignature, block);
        };
        FunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.FunctionExpressionSyntax = FunctionExpressionSyntax;
    var EmptyStatementSyntax = (function (_super) {
        __extends(EmptyStatementSyntax, _super);
        function EmptyStatementSyntax(semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        EmptyStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitEmptyStatement(this);
        };
        EmptyStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.EmptyStatement;
        };
        EmptyStatementSyntax.prototype.childCount = function () {
            return 1;
        };
        EmptyStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        EmptyStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        EmptyStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        EmptyStatementSyntax.prototype.update = function (semicolonToken) {
            if (this.semicolonToken === semicolonToken) {
                return this;
            }
            return new EmptyStatementSyntax(semicolonToken, this.parsedInStrictMode());
        };
        EmptyStatementSyntax.create1 = function () {
            return new EmptyStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        EmptyStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        EmptyStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        EmptyStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(semicolonToken);
        };
        EmptyStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return EmptyStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.EmptyStatementSyntax = EmptyStatementSyntax;
    var TryStatementSyntax = (function (_super) {
        __extends(TryStatementSyntax, _super);
        function TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.tryKeyword = tryKeyword;
            _this.block = block;
            _this.catchClause = catchClause;
            _this.finallyClause = finallyClause;
            return _this;
        }
        TryStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitTryStatement(this);
        };
        TryStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.TryStatement;
        };
        TryStatementSyntax.prototype.childCount = function () {
            return 4;
        };
        TryStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.tryKeyword;
                case 1: return this.block;
                case 2: return this.catchClause;
                case 3: return this.finallyClause;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        TryStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        TryStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        TryStatementSyntax.prototype.update = function (tryKeyword, block, catchClause, finallyClause) {
            if (this.tryKeyword === tryKeyword && this.block === block && this.catchClause === catchClause && this.finallyClause === finallyClause) {
                return this;
            }
            return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, this.parsedInStrictMode());
        };
        TryStatementSyntax.create = function (tryKeyword, block) {
            return new TryStatementSyntax(tryKeyword, block, null, null, false);
        };
        TryStatementSyntax.create1 = function () {
            return new TryStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.TryKeyword), BlockSyntax.create1(), null, null, false);
        };
        TryStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        TryStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        TryStatementSyntax.prototype.withTryKeyword = function (tryKeyword) {
            return this.update(tryKeyword, this.block, this.catchClause, this.finallyClause);
        };
        TryStatementSyntax.prototype.withBlock = function (block) {
            return this.update(this.tryKeyword, block, this.catchClause, this.finallyClause);
        };
        TryStatementSyntax.prototype.withCatchClause = function (catchClause) {
            return this.update(this.tryKeyword, this.block, catchClause, this.finallyClause);
        };
        TryStatementSyntax.prototype.withFinallyClause = function (finallyClause) {
            return this.update(this.tryKeyword, this.block, this.catchClause, finallyClause);
        };
        TryStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            if (this.catchClause !== null && this.catchClause.isTypeScriptSpecific()) {
                return true;
            }
            if (this.finallyClause !== null && this.finallyClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return TryStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.TryStatementSyntax = TryStatementSyntax;
    var CatchClauseSyntax = (function (_super) {
        __extends(CatchClauseSyntax, _super);
        function CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.catchKeyword = catchKeyword;
            _this.openParenToken = openParenToken;
            _this.identifier = identifier;
            _this.typeAnnotation = typeAnnotation;
            _this.closeParenToken = closeParenToken;
            _this.block = block;
            return _this;
        }
        CatchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitCatchClause(this);
        };
        CatchClauseSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.CatchClause;
        };
        CatchClauseSyntax.prototype.childCount = function () {
            return 6;
        };
        CatchClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.catchKeyword;
                case 1: return this.openParenToken;
                case 2: return this.identifier;
                case 3: return this.typeAnnotation;
                case 4: return this.closeParenToken;
                case 5: return this.block;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        CatchClauseSyntax.prototype.update = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
            if (this.catchKeyword === catchKeyword && this.openParenToken === openParenToken && this.identifier === identifier && this.typeAnnotation === typeAnnotation && this.closeParenToken === closeParenToken && this.block === block) {
                return this;
            }
            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, this.parsedInStrictMode());
        };
        CatchClauseSyntax.create = function (catchKeyword, openParenToken, identifier, closeParenToken, block) {
            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, null, closeParenToken, block, false);
        };
        CatchClauseSyntax.create1 = function (identifier) {
            return new CatchClauseSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.CatchKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), identifier, null, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), BlockSyntax.create1(), false);
        };
        CatchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        CatchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        CatchClauseSyntax.prototype.withCatchKeyword = function (catchKeyword) {
            return this.update(catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };
        CatchClauseSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.catchKeyword, openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };
        CatchClauseSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.catchKeyword, this.openParenToken, identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };
        CatchClauseSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, typeAnnotation, this.closeParenToken, this.block);
        };
        CatchClauseSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, closeParenToken, this.block);
        };
        CatchClauseSyntax.prototype.withBlock = function (block) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, block);
        };
        CatchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null && this.typeAnnotation.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return CatchClauseSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.CatchClauseSyntax = CatchClauseSyntax;
    var FinallyClauseSyntax = (function (_super) {
        __extends(FinallyClauseSyntax, _super);
        function FinallyClauseSyntax(finallyKeyword, block, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.finallyKeyword = finallyKeyword;
            _this.block = block;
            return _this;
        }
        FinallyClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitFinallyClause(this);
        };
        FinallyClauseSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.FinallyClause;
        };
        FinallyClauseSyntax.prototype.childCount = function () {
            return 2;
        };
        FinallyClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.finallyKeyword;
                case 1: return this.block;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        FinallyClauseSyntax.prototype.update = function (finallyKeyword, block) {
            if (this.finallyKeyword === finallyKeyword && this.block === block) {
                return this;
            }
            return new FinallyClauseSyntax(finallyKeyword, block, this.parsedInStrictMode());
        };
        FinallyClauseSyntax.create1 = function () {
            return new FinallyClauseSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.FinallyKeyword), BlockSyntax.create1(), false);
        };
        FinallyClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        FinallyClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        FinallyClauseSyntax.prototype.withFinallyKeyword = function (finallyKeyword) {
            return this.update(finallyKeyword, this.block);
        };
        FinallyClauseSyntax.prototype.withBlock = function (block) {
            return this.update(this.finallyKeyword, block);
        };
        FinallyClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FinallyClauseSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.FinallyClauseSyntax = FinallyClauseSyntax;
    var LabeledStatementSyntax = (function (_super) {
        __extends(LabeledStatementSyntax, _super);
        function LabeledStatementSyntax(identifier, colonToken, statement, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.identifier = identifier;
            _this.colonToken = colonToken;
            _this.statement = statement;
            return _this;
        }
        LabeledStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitLabeledStatement(this);
        };
        LabeledStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.LabeledStatement;
        };
        LabeledStatementSyntax.prototype.childCount = function () {
            return 3;
        };
        LabeledStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.identifier;
                case 1: return this.colonToken;
                case 2: return this.statement;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        LabeledStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        LabeledStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        LabeledStatementSyntax.prototype.update = function (identifier, colonToken, statement) {
            if (this.identifier === identifier && this.colonToken === colonToken && this.statement === statement) {
                return this;
            }
            return new LabeledStatementSyntax(identifier, colonToken, statement, this.parsedInStrictMode());
        };
        LabeledStatementSyntax.create1 = function (identifier, statement) {
            return new LabeledStatementSyntax(identifier, TypeScript.Syntax.token(TypeScript.SyntaxKind.ColonToken), statement, false);
        };
        LabeledStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        LabeledStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        LabeledStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.colonToken, this.statement);
        };
        LabeledStatementSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.identifier, colonToken, this.statement);
        };
        LabeledStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.identifier, this.colonToken, statement);
        };
        LabeledStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return LabeledStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.LabeledStatementSyntax = LabeledStatementSyntax;
    var DoStatementSyntax = (function (_super) {
        __extends(DoStatementSyntax, _super);
        function DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.doKeyword = doKeyword;
            _this.statement = statement;
            _this.whileKeyword = whileKeyword;
            _this.openParenToken = openParenToken;
            _this.condition = condition;
            _this.closeParenToken = closeParenToken;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        DoStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitDoStatement(this);
        };
        DoStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.DoStatement;
        };
        DoStatementSyntax.prototype.childCount = function () {
            return 7;
        };
        DoStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.doKeyword;
                case 1: return this.statement;
                case 2: return this.whileKeyword;
                case 3: return this.openParenToken;
                case 4: return this.condition;
                case 5: return this.closeParenToken;
                case 6: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        DoStatementSyntax.prototype.isIterationStatement = function () {
            return true;
        };
        DoStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        DoStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        DoStatementSyntax.prototype.update = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
            if (this.doKeyword === doKeyword && this.statement === statement && this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, this.parsedInStrictMode());
        };
        DoStatementSyntax.create1 = function (statement, condition) {
            return new DoStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.DoKeyword), statement, TypeScript.Syntax.token(TypeScript.SyntaxKind.WhileKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), condition, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        DoStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        DoStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        DoStatementSyntax.prototype.withDoKeyword = function (doKeyword) {
            return this.update(doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };
        DoStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.doKeyword, statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };
        DoStatementSyntax.prototype.withWhileKeyword = function (whileKeyword) {
            return this.update(this.doKeyword, this.statement, whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };
        DoStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };
        DoStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.semicolonToken);
        };
        DoStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.semicolonToken);
        };
        DoStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, semicolonToken);
        };
        DoStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DoStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.DoStatementSyntax = DoStatementSyntax;
    var TypeOfExpressionSyntax = (function (_super) {
        __extends(TypeOfExpressionSyntax, _super);
        function TypeOfExpressionSyntax(typeOfKeyword, expression, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.typeOfKeyword = typeOfKeyword;
            _this.expression = expression;
            return _this;
        }
        TypeOfExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeOfExpression(this);
        };
        TypeOfExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeOfExpression;
        };
        TypeOfExpressionSyntax.prototype.childCount = function () {
            return 2;
        };
        TypeOfExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.typeOfKeyword;
                case 1: return this.expression;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        TypeOfExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        TypeOfExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        TypeOfExpressionSyntax.prototype.update = function (typeOfKeyword, expression) {
            if (this.typeOfKeyword === typeOfKeyword && this.expression === expression) {
                return this;
            }
            return new TypeOfExpressionSyntax(typeOfKeyword, expression, this.parsedInStrictMode());
        };
        TypeOfExpressionSyntax.create1 = function (expression) {
            return new TypeOfExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.TypeOfKeyword), expression, false);
        };
        TypeOfExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        TypeOfExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        TypeOfExpressionSyntax.prototype.withTypeOfKeyword = function (typeOfKeyword) {
            return this.update(typeOfKeyword, this.expression);
        };
        TypeOfExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.typeOfKeyword, expression);
        };
        TypeOfExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return TypeOfExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.TypeOfExpressionSyntax = TypeOfExpressionSyntax;
    var DeleteExpressionSyntax = (function (_super) {
        __extends(DeleteExpressionSyntax, _super);
        function DeleteExpressionSyntax(deleteKeyword, expression, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.deleteKeyword = deleteKeyword;
            _this.expression = expression;
            return _this;
        }
        DeleteExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitDeleteExpression(this);
        };
        DeleteExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.DeleteExpression;
        };
        DeleteExpressionSyntax.prototype.childCount = function () {
            return 2;
        };
        DeleteExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.deleteKeyword;
                case 1: return this.expression;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        DeleteExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        DeleteExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        DeleteExpressionSyntax.prototype.update = function (deleteKeyword, expression) {
            if (this.deleteKeyword === deleteKeyword && this.expression === expression) {
                return this;
            }
            return new DeleteExpressionSyntax(deleteKeyword, expression, this.parsedInStrictMode());
        };
        DeleteExpressionSyntax.create1 = function (expression) {
            return new DeleteExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.DeleteKeyword), expression, false);
        };
        DeleteExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        DeleteExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        DeleteExpressionSyntax.prototype.withDeleteKeyword = function (deleteKeyword) {
            return this.update(deleteKeyword, this.expression);
        };
        DeleteExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.deleteKeyword, expression);
        };
        DeleteExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DeleteExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.DeleteExpressionSyntax = DeleteExpressionSyntax;
    var VoidExpressionSyntax = (function (_super) {
        __extends(VoidExpressionSyntax, _super);
        function VoidExpressionSyntax(voidKeyword, expression, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.voidKeyword = voidKeyword;
            _this.expression = expression;
            return _this;
        }
        VoidExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitVoidExpression(this);
        };
        VoidExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.VoidExpression;
        };
        VoidExpressionSyntax.prototype.childCount = function () {
            return 2;
        };
        VoidExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.voidKeyword;
                case 1: return this.expression;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        VoidExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        VoidExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        VoidExpressionSyntax.prototype.update = function (voidKeyword, expression) {
            if (this.voidKeyword === voidKeyword && this.expression === expression) {
                return this;
            }
            return new VoidExpressionSyntax(voidKeyword, expression, this.parsedInStrictMode());
        };
        VoidExpressionSyntax.create1 = function (expression) {
            return new VoidExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.VoidKeyword), expression, false);
        };
        VoidExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        VoidExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        VoidExpressionSyntax.prototype.withVoidKeyword = function (voidKeyword) {
            return this.update(voidKeyword, this.expression);
        };
        VoidExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.voidKeyword, expression);
        };
        VoidExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VoidExpressionSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.VoidExpressionSyntax = VoidExpressionSyntax;
    var DebuggerStatementSyntax = (function (_super) {
        __extends(DebuggerStatementSyntax, _super);
        function DebuggerStatementSyntax(debuggerKeyword, semicolonToken, parsedInStrictMode) {
            var _this = _super.call(this, parsedInStrictMode) || this;
            _this.debuggerKeyword = debuggerKeyword;
            _this.semicolonToken = semicolonToken;
            return _this;
        }
        DebuggerStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitDebuggerStatement(this);
        };
        DebuggerStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.DebuggerStatement;
        };
        DebuggerStatementSyntax.prototype.childCount = function () {
            return 2;
        };
        DebuggerStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0: return this.debuggerKeyword;
                case 1: return this.semicolonToken;
                default: throw TypeScript.Errors.invalidOperation();
            }
        };
        DebuggerStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        DebuggerStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        DebuggerStatementSyntax.prototype.update = function (debuggerKeyword, semicolonToken) {
            if (this.debuggerKeyword === debuggerKeyword && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, this.parsedInStrictMode());
        };
        DebuggerStatementSyntax.create1 = function () {
            return new DebuggerStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.DebuggerKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        DebuggerStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        DebuggerStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        DebuggerStatementSyntax.prototype.withDebuggerKeyword = function (debuggerKeyword) {
            return this.update(debuggerKeyword, this.semicolonToken);
        };
        DebuggerStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.debuggerKeyword, semicolonToken);
        };
        DebuggerStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return DebuggerStatementSyntax;
    }(TypeScript.SyntaxNode));
    TypeScript.DebuggerStatementSyntax = DebuggerStatementSyntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxRewriter = (function () {
        function SyntaxRewriter() {
        }
        SyntaxRewriter.prototype.visitToken = function (token) {
            return token;
        };
        SyntaxRewriter.prototype.visitNode = function (node) {
            return node.accept(this);
        };
        SyntaxRewriter.prototype.visitNodeOrToken = function (node) {
            return node.isToken() ? this.visitToken(node) : this.visitNode(node);
        };
        SyntaxRewriter.prototype.visitList = function (list) {
            var newItems = null;
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                var newItem = this.visitNodeOrToken(item);
                if (item !== newItem && newItems === null) {
                    newItems = [];
                    for (var j = 0; j < i; j++) {
                        newItems.push(list.childAt(j));
                    }
                }
                if (newItems) {
                    newItems.push(newItem);
                }
            }
            return newItems === null ? list : TypeScript.Syntax.list(newItems);
        };
        SyntaxRewriter.prototype.visitSeparatedList = function (list) {
            var newItems = null;
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                var newItem = item.isToken() ? this.visitToken(item) : this.visitNode(item);
                if (item !== newItem && newItems === null) {
                    newItems = [];
                    for (var j = 0; j < i; j++) {
                        newItems.push(list.childAt(j));
                    }
                }
                if (newItems) {
                    newItems.push(newItem);
                }
            }
            return newItems === null ? list : TypeScript.Syntax.separatedList(newItems);
        };
        SyntaxRewriter.prototype.visitSourceUnit = function (node) {
            return node.update(this.visitList(node.moduleElements), this.visitToken(node.endOfFileToken));
        };
        SyntaxRewriter.prototype.visitExternalModuleReference = function (node) {
            return node.update(this.visitToken(node.requireKeyword), this.visitToken(node.openParenToken), this.visitToken(node.stringLiteral), this.visitToken(node.closeParenToken));
        };
        SyntaxRewriter.prototype.visitModuleNameModuleReference = function (node) {
            return node.update(this.visitNodeOrToken(node.moduleName));
        };
        SyntaxRewriter.prototype.visitImportDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.importKeyword), this.visitToken(node.identifier), this.visitToken(node.equalsToken), this.visitNodeOrToken(node.moduleReference), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitExportAssignment = function (node) {
            return node.update(this.visitToken(node.exportKeyword), this.visitToken(node.equalsToken), this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitClassDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.classKeyword), this.visitToken(node.identifier), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitList(node.heritageClauses), this.visitToken(node.openBraceToken), this.visitList(node.classElements), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitInterfaceDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.interfaceKeyword), this.visitToken(node.identifier), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitList(node.heritageClauses), this.visitNode(node.body));
        };
        SyntaxRewriter.prototype.visitHeritageClause = function (node) {
            return node.update(node.kind(), this.visitToken(node.extendsOrImplementsKeyword), this.visitSeparatedList(node.typeNames));
        };
        SyntaxRewriter.prototype.visitModuleDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.moduleKeyword), node.name === null ? null : this.visitNodeOrToken(node.name), node.stringLiteral === null ? null : this.visitToken(node.stringLiteral), this.visitToken(node.openBraceToken), this.visitList(node.moduleElements), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitFunctionDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.functionKeyword), this.visitToken(node.identifier), this.visitNode(node.callSignature), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitVariableStatement = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitNode(node.variableDeclaration), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitVariableDeclaration = function (node) {
            return node.update(this.visitToken(node.varKeyword), this.visitSeparatedList(node.variableDeclarators));
        };
        SyntaxRewriter.prototype.visitVariableDeclarator = function (node) {
            return node.update(this.visitToken(node.propertyName), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };
        SyntaxRewriter.prototype.visitEqualsValueClause = function (node) {
            return node.update(this.visitToken(node.equalsToken), this.visitNodeOrToken(node.value));
        };
        SyntaxRewriter.prototype.visitPrefixUnaryExpression = function (node) {
            return node.update(node.kind(), this.visitToken(node.operatorToken), this.visitNodeOrToken(node.operand));
        };
        SyntaxRewriter.prototype.visitArrayLiteralExpression = function (node) {
            return node.update(this.visitToken(node.openBracketToken), this.visitSeparatedList(node.expressions), this.visitToken(node.closeBracketToken));
        };
        SyntaxRewriter.prototype.visitOmittedExpression = function (node) {
            return node;
        };
        SyntaxRewriter.prototype.visitParenthesizedExpression = function (node) {
            return node.update(this.visitToken(node.openParenToken), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken));
        };
        SyntaxRewriter.prototype.visitSimpleArrowFunctionExpression = function (node) {
            return node.update(this.visitToken(node.identifier), this.visitToken(node.equalsGreaterThanToken), node.block === null ? null : this.visitNode(node.block), node.expression === null ? null : this.visitNodeOrToken(node.expression));
        };
        SyntaxRewriter.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            return node.update(this.visitNode(node.callSignature), this.visitToken(node.equalsGreaterThanToken), node.block === null ? null : this.visitNode(node.block), node.expression === null ? null : this.visitNodeOrToken(node.expression));
        };
        SyntaxRewriter.prototype.visitQualifiedName = function (node) {
            return node.update(this.visitNodeOrToken(node.left), this.visitToken(node.dotToken), this.visitToken(node.right));
        };
        SyntaxRewriter.prototype.visitTypeArgumentList = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitSeparatedList(node.typeArguments), this.visitToken(node.greaterThanToken));
        };
        SyntaxRewriter.prototype.visitConstructorType = function (node) {
            return node.update(this.visitToken(node.newKeyword), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.type));
        };
        SyntaxRewriter.prototype.visitFunctionType = function (node) {
            return node.update(node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.type));
        };
        SyntaxRewriter.prototype.visitObjectType = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitSeparatedList(node.typeMembers), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitArrayType = function (node) {
            return node.update(this.visitNodeOrToken(node.type), this.visitToken(node.openBracketToken), this.visitToken(node.closeBracketToken));
        };
        SyntaxRewriter.prototype.visitGenericType = function (node) {
            return node.update(this.visitNodeOrToken(node.name), this.visitNode(node.typeArgumentList));
        };
        SyntaxRewriter.prototype.visitTypeQuery = function (node) {
            return node.update(this.visitToken(node.typeOfKeyword), this.visitNodeOrToken(node.name));
        };
        SyntaxRewriter.prototype.visitTypeAnnotation = function (node) {
            return node.update(this.visitToken(node.colonToken), this.visitNodeOrToken(node.type));
        };
        SyntaxRewriter.prototype.visitBlock = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitList(node.statements), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitParameter = function (node) {
            return node.update(node.dotDotDotToken === null ? null : this.visitToken(node.dotDotDotToken), this.visitList(node.modifiers), this.visitToken(node.identifier), node.questionToken === null ? null : this.visitToken(node.questionToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };
        SyntaxRewriter.prototype.visitMemberAccessExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.dotToken), this.visitToken(node.name));
        };
        SyntaxRewriter.prototype.visitPostfixUnaryExpression = function (node) {
            return node.update(node.kind(), this.visitNodeOrToken(node.operand), this.visitToken(node.operatorToken));
        };
        SyntaxRewriter.prototype.visitElementAccessExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.openBracketToken), this.visitNodeOrToken(node.argumentExpression), this.visitToken(node.closeBracketToken));
        };
        SyntaxRewriter.prototype.visitInvocationExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitNode(node.argumentList));
        };
        SyntaxRewriter.prototype.visitArgumentList = function (node) {
            return node.update(node.typeArgumentList === null ? null : this.visitNode(node.typeArgumentList), this.visitToken(node.openParenToken), this.visitSeparatedList(node.args), this.visitToken(node.closeParenToken));
        };
        SyntaxRewriter.prototype.visitBinaryExpression = function (node) {
            return node.update(node.kind(), this.visitNodeOrToken(node.left), this.visitToken(node.operatorToken), this.visitNodeOrToken(node.right));
        };
        SyntaxRewriter.prototype.visitConditionalExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.condition), this.visitToken(node.questionToken), this.visitNodeOrToken(node.whenTrue), this.visitToken(node.colonToken), this.visitNodeOrToken(node.whenFalse));
        };
        SyntaxRewriter.prototype.visitConstructSignature = function (node) {
            return node.update(this.visitToken(node.newKeyword), this.visitNode(node.callSignature));
        };
        SyntaxRewriter.prototype.visitMethodSignature = function (node) {
            return node.update(this.visitToken(node.propertyName), node.questionToken === null ? null : this.visitToken(node.questionToken), this.visitNode(node.callSignature));
        };
        SyntaxRewriter.prototype.visitIndexSignature = function (node) {
            return node.update(this.visitToken(node.openBracketToken), this.visitNode(node.parameter), this.visitToken(node.closeBracketToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };
        SyntaxRewriter.prototype.visitPropertySignature = function (node) {
            return node.update(this.visitToken(node.propertyName), node.questionToken === null ? null : this.visitToken(node.questionToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };
        SyntaxRewriter.prototype.visitCallSignature = function (node) {
            return node.update(node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };
        SyntaxRewriter.prototype.visitParameterList = function (node) {
            return node.update(this.visitToken(node.openParenToken), this.visitSeparatedList(node.parameters), this.visitToken(node.closeParenToken));
        };
        SyntaxRewriter.prototype.visitTypeParameterList = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitSeparatedList(node.typeParameters), this.visitToken(node.greaterThanToken));
        };
        SyntaxRewriter.prototype.visitTypeParameter = function (node) {
            return node.update(this.visitToken(node.identifier), node.constraint === null ? null : this.visitNode(node.constraint));
        };
        SyntaxRewriter.prototype.visitConstraint = function (node) {
            return node.update(this.visitToken(node.extendsKeyword), this.visitNodeOrToken(node.type));
        };
        SyntaxRewriter.prototype.visitElseClause = function (node) {
            return node.update(this.visitToken(node.elseKeyword), this.visitNodeOrToken(node.statement));
        };
        SyntaxRewriter.prototype.visitIfStatement = function (node) {
            return node.update(this.visitToken(node.ifKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement), node.elseClause === null ? null : this.visitNode(node.elseClause));
        };
        SyntaxRewriter.prototype.visitExpressionStatement = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitConstructorDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.constructorKeyword), this.visitNode(node.parameterList), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitMemberFunctionDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.propertyName), this.visitNode(node.callSignature), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitGetAccessor = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.getKeyword), this.visitToken(node.propertyName), this.visitNode(node.parameterList), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitNode(node.block));
        };
        SyntaxRewriter.prototype.visitSetAccessor = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.setKeyword), this.visitToken(node.propertyName), this.visitNode(node.parameterList), this.visitNode(node.block));
        };
        SyntaxRewriter.prototype.visitMemberVariableDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitNode(node.variableDeclarator), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitIndexMemberDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitNode(node.indexSignature), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitThrowStatement = function (node) {
            return node.update(this.visitToken(node.throwKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitReturnStatement = function (node) {
            return node.update(this.visitToken(node.returnKeyword), node.expression === null ? null : this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitObjectCreationExpression = function (node) {
            return node.update(this.visitToken(node.newKeyword), this.visitNodeOrToken(node.expression), node.argumentList === null ? null : this.visitNode(node.argumentList));
        };
        SyntaxRewriter.prototype.visitSwitchStatement = function (node) {
            return node.update(this.visitToken(node.switchKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken), this.visitToken(node.openBraceToken), this.visitList(node.switchClauses), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitCaseSwitchClause = function (node) {
            return node.update(this.visitToken(node.caseKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.colonToken), this.visitList(node.statements));
        };
        SyntaxRewriter.prototype.visitDefaultSwitchClause = function (node) {
            return node.update(this.visitToken(node.defaultKeyword), this.visitToken(node.colonToken), this.visitList(node.statements));
        };
        SyntaxRewriter.prototype.visitBreakStatement = function (node) {
            return node.update(this.visitToken(node.breakKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitContinueStatement = function (node) {
            return node.update(this.visitToken(node.continueKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitForStatement = function (node) {
            return node.update(this.visitToken(node.forKeyword), this.visitToken(node.openParenToken), node.variableDeclaration === null ? null : this.visitNode(node.variableDeclaration), node.initializer === null ? null : this.visitNodeOrToken(node.initializer), this.visitToken(node.firstSemicolonToken), node.condition === null ? null : this.visitNodeOrToken(node.condition), this.visitToken(node.secondSemicolonToken), node.incrementor === null ? null : this.visitNodeOrToken(node.incrementor), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };
        SyntaxRewriter.prototype.visitForInStatement = function (node) {
            return node.update(this.visitToken(node.forKeyword), this.visitToken(node.openParenToken), node.variableDeclaration === null ? null : this.visitNode(node.variableDeclaration), node.left === null ? null : this.visitNodeOrToken(node.left), this.visitToken(node.inKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };
        SyntaxRewriter.prototype.visitWhileStatement = function (node) {
            return node.update(this.visitToken(node.whileKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };
        SyntaxRewriter.prototype.visitWithStatement = function (node) {
            return node.update(this.visitToken(node.withKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };
        SyntaxRewriter.prototype.visitEnumDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.enumKeyword), this.visitToken(node.identifier), this.visitToken(node.openBraceToken), this.visitSeparatedList(node.enumElements), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitEnumElement = function (node) {
            return node.update(this.visitToken(node.propertyName), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };
        SyntaxRewriter.prototype.visitCastExpression = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitNodeOrToken(node.type), this.visitToken(node.greaterThanToken), this.visitNodeOrToken(node.expression));
        };
        SyntaxRewriter.prototype.visitObjectLiteralExpression = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitSeparatedList(node.propertyAssignments), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitSimplePropertyAssignment = function (node) {
            return node.update(this.visitToken(node.propertyName), this.visitToken(node.colonToken), this.visitNodeOrToken(node.expression));
        };
        SyntaxRewriter.prototype.visitFunctionPropertyAssignment = function (node) {
            return node.update(this.visitToken(node.propertyName), this.visitNode(node.callSignature), this.visitNode(node.block));
        };
        SyntaxRewriter.prototype.visitFunctionExpression = function (node) {
            return node.update(this.visitToken(node.functionKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitNode(node.callSignature), this.visitNode(node.block));
        };
        SyntaxRewriter.prototype.visitEmptyStatement = function (node) {
            return node.update(this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitTryStatement = function (node) {
            return node.update(this.visitToken(node.tryKeyword), this.visitNode(node.block), node.catchClause === null ? null : this.visitNode(node.catchClause), node.finallyClause === null ? null : this.visitNode(node.finallyClause));
        };
        SyntaxRewriter.prototype.visitCatchClause = function (node) {
            return node.update(this.visitToken(node.catchKeyword), this.visitToken(node.openParenToken), this.visitToken(node.identifier), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitToken(node.closeParenToken), this.visitNode(node.block));
        };
        SyntaxRewriter.prototype.visitFinallyClause = function (node) {
            return node.update(this.visitToken(node.finallyKeyword), this.visitNode(node.block));
        };
        SyntaxRewriter.prototype.visitLabeledStatement = function (node) {
            return node.update(this.visitToken(node.identifier), this.visitToken(node.colonToken), this.visitNodeOrToken(node.statement));
        };
        SyntaxRewriter.prototype.visitDoStatement = function (node) {
            return node.update(this.visitToken(node.doKeyword), this.visitNodeOrToken(node.statement), this.visitToken(node.whileKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitTypeOfExpression = function (node) {
            return node.update(this.visitToken(node.typeOfKeyword), this.visitNodeOrToken(node.expression));
        };
        SyntaxRewriter.prototype.visitDeleteExpression = function (node) {
            return node.update(this.visitToken(node.deleteKeyword), this.visitNodeOrToken(node.expression));
        };
        SyntaxRewriter.prototype.visitVoidExpression = function (node) {
            return node.update(this.visitToken(node.voidKeyword), this.visitNodeOrToken(node.expression));
        };
        SyntaxRewriter.prototype.visitDebuggerStatement = function (node) {
            return node.update(this.visitToken(node.debuggerKeyword), this.visitToken(node.semicolonToken));
        };
        return SyntaxRewriter;
    }());
    TypeScript.SyntaxRewriter = SyntaxRewriter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxDedenter = (function (_super) {
        __extends(SyntaxDedenter, _super);
        function SyntaxDedenter(dedentFirstToken, dedentationAmount, minimumIndent, options) {
            var _this = _super.call(this) || this;
            _this.dedentationAmount = dedentationAmount;
            _this.minimumIndent = minimumIndent;
            _this.options = options;
            _this.lastTriviaWasNewLine = dedentFirstToken;
            return _this;
        }
        SyntaxDedenter.prototype.abort = function () {
            this.lastTriviaWasNewLine = false;
            this.dedentationAmount = 0;
        };
        SyntaxDedenter.prototype.isAborted = function () {
            return this.dedentationAmount === 0;
        };
        SyntaxDedenter.prototype.visitToken = function (token) {
            if (token.width() === 0) {
                return token;
            }
            var result = token;
            if (this.lastTriviaWasNewLine) {
                result = token.withLeadingTrivia(this.dedentTriviaList(token.leadingTrivia()));
            }
            if (this.isAborted()) {
                return token;
            }
            this.lastTriviaWasNewLine = token.hasTrailingNewLine();
            return result;
        };
        SyntaxDedenter.prototype.dedentTriviaList = function (triviaList) {
            var result = [];
            var dedentNextWhitespace = true;
            for (var i = 0, n = triviaList.count(); i < n && !this.isAborted(); i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                var dedentThisTrivia = dedentNextWhitespace;
                dedentNextWhitespace = false;
                if (dedentThisTrivia) {
                    if (trivia.kind() === TypeScript.SyntaxKind.WhitespaceTrivia) {
                        var hasFollowingNewLine = (i < triviaList.count() - 1) &&
                            triviaList.syntaxTriviaAt(i + 1).kind() === TypeScript.SyntaxKind.NewLineTrivia;
                        result.push(this.dedentWhitespace(trivia, hasFollowingNewLine));
                        continue;
                    }
                    else if (trivia.kind() !== TypeScript.SyntaxKind.NewLineTrivia) {
                        this.abort();
                        break;
                    }
                }
                if (trivia.kind() === TypeScript.SyntaxKind.MultiLineCommentTrivia) {
                    result.push(this.dedentMultiLineComment(trivia));
                    continue;
                }
                result.push(trivia);
                if (trivia.kind() === TypeScript.SyntaxKind.NewLineTrivia) {
                    dedentNextWhitespace = true;
                }
            }
            if (dedentNextWhitespace) {
                this.abort();
            }
            if (this.isAborted()) {
                return triviaList;
            }
            return TypeScript.Syntax.triviaList(result);
        };
        SyntaxDedenter.prototype.dedentSegment = function (segment, hasFollowingNewLineTrivia) {
            var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);
            if (firstNonWhitespacePosition === segment.length) {
                if (hasFollowingNewLineTrivia) {
                    return "";
                }
            }
            else if (TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                return segment.substring(firstNonWhitespacePosition);
            }
            var firstNonWhitespaceColumn = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);
            var newFirstNonWhitespaceColumn = TypeScript.MathPrototype.min(firstNonWhitespaceColumn, TypeScript.MathPrototype.max(firstNonWhitespaceColumn - this.dedentationAmount, this.minimumIndent));
            if (newFirstNonWhitespaceColumn === firstNonWhitespaceColumn) {
                this.abort();
                return segment;
            }
            this.dedentationAmount = firstNonWhitespaceColumn - newFirstNonWhitespaceColumn;
            TypeScript.Debug.assert(this.dedentationAmount >= 0);
            var indentationString = TypeScript.Indentation.indentationString(newFirstNonWhitespaceColumn, this.options);
            return indentationString + segment.substring(firstNonWhitespacePosition);
        };
        SyntaxDedenter.prototype.dedentWhitespace = function (trivia, hasFollowingNewLineTrivia) {
            var newIndentation = this.dedentSegment(trivia.fullText(), hasFollowingNewLineTrivia);
            return TypeScript.Syntax.whitespace(newIndentation);
        };
        SyntaxDedenter.prototype.dedentMultiLineComment = function (trivia) {
            var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
            if (segments.length === 1) {
                return trivia;
            }
            for (var i = 1; i < segments.length; i++) {
                var segment = segments[i];
                segments[i] = this.dedentSegment(segment, false);
            }
            var result = segments.join("");
            return TypeScript.Syntax.multiLineComment(result);
        };
        SyntaxDedenter.dedentNode = function (node, dedentFirstToken, dedentAmount, minimumIndent, options) {
            var dedenter = new SyntaxDedenter(dedentFirstToken, dedentAmount, minimumIndent, options);
            var result = node.accept(dedenter);
            if (dedenter.isAborted()) {
                return node;
            }
            return result;
        };
        return SyntaxDedenter;
    }(TypeScript.SyntaxRewriter));
    TypeScript.SyntaxDedenter = SyntaxDedenter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxIndenter = (function (_super) {
        __extends(SyntaxIndenter, _super);
        function SyntaxIndenter(indentFirstToken, indentationAmount, options) {
            var _this = _super.call(this) || this;
            _this.indentationAmount = indentationAmount;
            _this.options = options;
            _this.lastTriviaWasNewLine = indentFirstToken;
            _this.indentationTrivia = TypeScript.Indentation.indentationTrivia(_this.indentationAmount, _this.options);
            return _this;
        }
        SyntaxIndenter.prototype.visitToken = function (token) {
            if (token.width() === 0) {
                return token;
            }
            var result = token;
            if (this.lastTriviaWasNewLine) {
                result = token.withLeadingTrivia(this.indentTriviaList(token.leadingTrivia()));
            }
            this.lastTriviaWasNewLine = token.hasTrailingNewLine();
            return result;
        };
        SyntaxIndenter.prototype.indentTriviaList = function (triviaList) {
            var result = [];
            var indentNextTrivia = true;
            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                var indentThisTrivia = indentNextTrivia;
                indentNextTrivia = false;
                switch (trivia.kind()) {
                    case TypeScript.SyntaxKind.MultiLineCommentTrivia:
                        this.indentMultiLineComment(trivia, indentThisTrivia, result);
                        continue;
                    case TypeScript.SyntaxKind.SingleLineCommentTrivia:
                    case TypeScript.SyntaxKind.SkippedTokenTrivia:
                        this.indentSingleLineOrSkippedText(trivia, indentThisTrivia, result);
                        continue;
                    case TypeScript.SyntaxKind.WhitespaceTrivia:
                        this.indentWhitespace(trivia, indentThisTrivia, result);
                        continue;
                    case TypeScript.SyntaxKind.NewLineTrivia:
                        result.push(trivia);
                        indentNextTrivia = true;
                        continue;
                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            }
            if (indentNextTrivia) {
                result.push(this.indentationTrivia);
            }
            return TypeScript.Syntax.triviaList(result);
        };
        SyntaxIndenter.prototype.indentSegment = function (segment) {
            var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);
            if (firstNonWhitespacePosition < segment.length &&
                TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                return segment;
            }
            var firstNonWhitespaceColumn = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);
            var newFirstNonWhitespaceColumn = firstNonWhitespaceColumn + this.indentationAmount;
            var indentationString = TypeScript.Indentation.indentationString(newFirstNonWhitespaceColumn, this.options);
            return indentationString + segment.substring(firstNonWhitespacePosition);
        };
        SyntaxIndenter.prototype.indentWhitespace = function (trivia, indentThisTrivia, result) {
            if (!indentThisTrivia) {
                result.push(trivia);
                return;
            }
            var newIndentation = this.indentSegment(trivia.fullText());
            result.push(TypeScript.Syntax.whitespace(newIndentation));
        };
        SyntaxIndenter.prototype.indentSingleLineOrSkippedText = function (trivia, indentThisTrivia, result) {
            if (indentThisTrivia) {
                result.push(this.indentationTrivia);
            }
            result.push(trivia);
        };
        SyntaxIndenter.prototype.indentMultiLineComment = function (trivia, indentThisTrivia, result) {
            if (indentThisTrivia) {
                result.push(this.indentationTrivia);
            }
            var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
            for (var i = 1; i < segments.length; i++) {
                segments[i] = this.indentSegment(segments[i]);
            }
            var newText = segments.join("");
            result.push(TypeScript.Syntax.multiLineComment(newText));
        };
        SyntaxIndenter.indentNode = function (node, indentFirstToken, indentAmount, options) {
            var indenter = new SyntaxIndenter(indentFirstToken, indentAmount, options);
            return node.accept(indenter);
        };
        SyntaxIndenter.indentNodes = function (nodes, indentFirstToken, indentAmount, options) {
            var indenter = new SyntaxIndenter(indentFirstToken, indentAmount, options);
            var result = TypeScript.ArrayUtilities.select(nodes, function (n) { return n.accept(indenter); });
            return result;
        };
        return SyntaxIndenter;
    }(TypeScript.SyntaxRewriter));
    TypeScript.SyntaxIndenter = SyntaxIndenter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        var VariableWidthTokenWithNoTrivia = (function () {
            function VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, textOrWidth) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._textOrWidth = textOrWidth;
            }
            VariableWidthTokenWithNoTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithNoTrivia(this._sourceText, this._fullStart, this.tokenKind, this._textOrWidth);
            };
            VariableWidthTokenWithNoTrivia.prototype.isNode = function () { return false; };
            VariableWidthTokenWithNoTrivia.prototype.isToken = function () { return true; };
            VariableWidthTokenWithNoTrivia.prototype.isList = function () { return false; };
            VariableWidthTokenWithNoTrivia.prototype.isSeparatedList = function () { return false; };
            VariableWidthTokenWithNoTrivia.prototype.kind = function () { return this.tokenKind; };
            VariableWidthTokenWithNoTrivia.prototype.childCount = function () { return 0; };
            VariableWidthTokenWithNoTrivia.prototype.childAt = function (index) { throw TypeScript.Errors.argumentOutOfRange('index'); };
            VariableWidthTokenWithNoTrivia.prototype.fullWidth = function () { return this.width(); };
            VariableWidthTokenWithNoTrivia.prototype.start = function () { return this._fullStart; };
            VariableWidthTokenWithNoTrivia.prototype.end = function () { return this.start() + this.width(); };
            VariableWidthTokenWithNoTrivia.prototype.width = function () { return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length; };
            VariableWidthTokenWithNoTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === TypeScript.SyntaxKind.IdentifierName);
                }
                return this._textOrWidth;
            };
            VariableWidthTokenWithNoTrivia.prototype.fullText = function () { return this._sourceText.substr(this._fullStart, this.fullWidth(), false); };
            VariableWidthTokenWithNoTrivia.prototype.value = function () {
                if (this._value === undefined) {
                    this._value = Syntax.value(this);
                }
                return this._value;
            };
            VariableWidthTokenWithNoTrivia.prototype.valueText = function () {
                if (this._valueText === undefined) {
                    this._valueText = Syntax.valueText(this);
                }
                return this._valueText;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () { return false; };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () { return false; };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingNewLine = function () { return false; };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingSkippedText = function () { return false; };
            VariableWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () { return 0; };
            VariableWidthTokenWithNoTrivia.prototype.leadingTrivia = function () { return Syntax.emptyTriviaList; };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () { return false; };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () { return false; };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingNewLine = function () { return false; };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingSkippedText = function () { return false; };
            VariableWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () { return 0; };
            VariableWidthTokenWithNoTrivia.prototype.trailingTrivia = function () { return Syntax.emptyTriviaList; };
            VariableWidthTokenWithNoTrivia.prototype.hasSkippedToken = function () { return false; };
            VariableWidthTokenWithNoTrivia.prototype.toJSON = function (key) { return Syntax.tokenToJSON(this); };
            VariableWidthTokenWithNoTrivia.prototype.firstToken = function () { return this; };
            VariableWidthTokenWithNoTrivia.prototype.lastToken = function () { return this; };
            VariableWidthTokenWithNoTrivia.prototype.isTypeScriptSpecific = function () { return false; };
            VariableWidthTokenWithNoTrivia.prototype.isIncrementallyUnusable = function () { return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); };
            VariableWidthTokenWithNoTrivia.prototype.accept = function (visitor) { return visitor.visitToken(this); };
            VariableWidthTokenWithNoTrivia.prototype.realize = function () { return Syntax.realizeToken(this); };
            VariableWidthTokenWithNoTrivia.prototype.collectTextElements = function (elements) { collectTokenTextElements(this, elements); };
            VariableWidthTokenWithNoTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            VariableWidthTokenWithNoTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            VariableWidthTokenWithNoTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            VariableWidthTokenWithNoTrivia.prototype.isExpression = function () {
                return Syntax.isExpression(this);
            };
            VariableWidthTokenWithNoTrivia.prototype.isPrimaryExpression = function () {
                return this.isExpression();
            };
            VariableWidthTokenWithNoTrivia.prototype.isMemberExpression = function () {
                return this.isExpression();
            };
            VariableWidthTokenWithNoTrivia.prototype.isPostfixExpression = function () {
                return this.isExpression();
            };
            VariableWidthTokenWithNoTrivia.prototype.isUnaryExpression = function () {
                return this.isExpression();
            };
            return VariableWidthTokenWithNoTrivia;
        }());
        Syntax.VariableWidthTokenWithNoTrivia = VariableWidthTokenWithNoTrivia;
        var VariableWidthTokenWithLeadingTrivia = (function () {
            function VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, textOrWidth) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._textOrWidth = textOrWidth;
            }
            VariableWidthTokenWithLeadingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithLeadingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._textOrWidth);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isNode = function () { return false; };
            VariableWidthTokenWithLeadingTrivia.prototype.isToken = function () { return true; };
            VariableWidthTokenWithLeadingTrivia.prototype.isList = function () { return false; };
            VariableWidthTokenWithLeadingTrivia.prototype.isSeparatedList = function () { return false; };
            VariableWidthTokenWithLeadingTrivia.prototype.kind = function () { return this.tokenKind; };
            VariableWidthTokenWithLeadingTrivia.prototype.childCount = function () { return 0; };
            VariableWidthTokenWithLeadingTrivia.prototype.childAt = function (index) { throw TypeScript.Errors.argumentOutOfRange('index'); };
            VariableWidthTokenWithLeadingTrivia.prototype.fullWidth = function () { return getTriviaWidth(this._leadingTriviaInfo) + this.width(); };
            VariableWidthTokenWithLeadingTrivia.prototype.start = function () { return this._fullStart + getTriviaWidth(this._leadingTriviaInfo); };
            VariableWidthTokenWithLeadingTrivia.prototype.end = function () { return this.start() + this.width(); };
            VariableWidthTokenWithLeadingTrivia.prototype.width = function () { return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length; };
            VariableWidthTokenWithLeadingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === TypeScript.SyntaxKind.IdentifierName);
                }
                return this._textOrWidth;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.fullText = function () { return this._sourceText.substr(this._fullStart, this.fullWidth(), false); };
            VariableWidthTokenWithLeadingTrivia.prototype.value = function () {
                if (this._value === undefined) {
                    this._value = Syntax.value(this);
                }
                return this._value;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.valueText = function () {
                if (this._valueText === undefined) {
                    this._valueText = Syntax.valueText(this);
                }
                return this._valueText;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingTrivia = function () { return true; };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingComment = function () { return hasTriviaComment(this._leadingTriviaInfo); };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingNewLine = function () { return hasTriviaNewLine(this._leadingTriviaInfo); };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingSkippedText = function () { return false; };
            VariableWidthTokenWithLeadingTrivia.prototype.leadingTriviaWidth = function () { return getTriviaWidth(this._leadingTriviaInfo); };
            VariableWidthTokenWithLeadingTrivia.prototype.leadingTrivia = function () { return Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false); };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingTrivia = function () { return false; };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingComment = function () { return false; };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingNewLine = function () { return false; };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingSkippedText = function () { return false; };
            VariableWidthTokenWithLeadingTrivia.prototype.trailingTriviaWidth = function () { return 0; };
            VariableWidthTokenWithLeadingTrivia.prototype.trailingTrivia = function () { return Syntax.emptyTriviaList; };
            VariableWidthTokenWithLeadingTrivia.prototype.hasSkippedToken = function () { return false; };
            VariableWidthTokenWithLeadingTrivia.prototype.toJSON = function (key) { return Syntax.tokenToJSON(this); };
            VariableWidthTokenWithLeadingTrivia.prototype.firstToken = function () { return this; };
            VariableWidthTokenWithLeadingTrivia.prototype.lastToken = function () { return this; };
            VariableWidthTokenWithLeadingTrivia.prototype.isTypeScriptSpecific = function () { return false; };
            VariableWidthTokenWithLeadingTrivia.prototype.isIncrementallyUnusable = function () { return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); };
            VariableWidthTokenWithLeadingTrivia.prototype.accept = function (visitor) { return visitor.visitToken(this); };
            VariableWidthTokenWithLeadingTrivia.prototype.realize = function () { return Syntax.realizeToken(this); };
            VariableWidthTokenWithLeadingTrivia.prototype.collectTextElements = function (elements) { collectTokenTextElements(this, elements); };
            VariableWidthTokenWithLeadingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isExpression = function () {
                return Syntax.isExpression(this);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isPrimaryExpression = function () {
                return this.isExpression();
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isMemberExpression = function () {
                return this.isExpression();
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isPostfixExpression = function () {
                return this.isExpression();
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isUnaryExpression = function () {
                return this.isExpression();
            };
            return VariableWidthTokenWithLeadingTrivia;
        }());
        Syntax.VariableWidthTokenWithLeadingTrivia = VariableWidthTokenWithLeadingTrivia;
        var VariableWidthTokenWithTrailingTrivia = (function () {
            function VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, textOrWidth, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._textOrWidth = textOrWidth;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            VariableWidthTokenWithTrailingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._textOrWidth, this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isNode = function () { return false; };
            VariableWidthTokenWithTrailingTrivia.prototype.isToken = function () { return true; };
            VariableWidthTokenWithTrailingTrivia.prototype.isList = function () { return false; };
            VariableWidthTokenWithTrailingTrivia.prototype.isSeparatedList = function () { return false; };
            VariableWidthTokenWithTrailingTrivia.prototype.kind = function () { return this.tokenKind; };
            VariableWidthTokenWithTrailingTrivia.prototype.childCount = function () { return 0; };
            VariableWidthTokenWithTrailingTrivia.prototype.childAt = function (index) { throw TypeScript.Errors.argumentOutOfRange('index'); };
            VariableWidthTokenWithTrailingTrivia.prototype.fullWidth = function () { return this.width() + getTriviaWidth(this._trailingTriviaInfo); };
            VariableWidthTokenWithTrailingTrivia.prototype.start = function () { return this._fullStart; };
            VariableWidthTokenWithTrailingTrivia.prototype.end = function () { return this.start() + this.width(); };
            VariableWidthTokenWithTrailingTrivia.prototype.width = function () { return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length; };
            VariableWidthTokenWithTrailingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === TypeScript.SyntaxKind.IdentifierName);
                }
                return this._textOrWidth;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.fullText = function () { return this._sourceText.substr(this._fullStart, this.fullWidth(), false); };
            VariableWidthTokenWithTrailingTrivia.prototype.value = function () {
                if (this._value === undefined) {
                    this._value = Syntax.value(this);
                }
                return this._value;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.valueText = function () {
                if (this._valueText === undefined) {
                    this._valueText = Syntax.valueText(this);
                }
                return this._valueText;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingTrivia = function () { return false; };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingComment = function () { return false; };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingNewLine = function () { return false; };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingSkippedText = function () { return false; };
            VariableWidthTokenWithTrailingTrivia.prototype.leadingTriviaWidth = function () { return 0; };
            VariableWidthTokenWithTrailingTrivia.prototype.leadingTrivia = function () { return Syntax.emptyTriviaList; };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingTrivia = function () { return true; };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingComment = function () { return hasTriviaComment(this._trailingTriviaInfo); };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingNewLine = function () { return hasTriviaNewLine(this._trailingTriviaInfo); };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingSkippedText = function () { return false; };
            VariableWidthTokenWithTrailingTrivia.prototype.trailingTriviaWidth = function () { return getTriviaWidth(this._trailingTriviaInfo); };
            VariableWidthTokenWithTrailingTrivia.prototype.trailingTrivia = function () { return Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true); };
            VariableWidthTokenWithTrailingTrivia.prototype.hasSkippedToken = function () { return false; };
            VariableWidthTokenWithTrailingTrivia.prototype.toJSON = function (key) { return Syntax.tokenToJSON(this); };
            VariableWidthTokenWithTrailingTrivia.prototype.firstToken = function () { return this; };
            VariableWidthTokenWithTrailingTrivia.prototype.lastToken = function () { return this; };
            VariableWidthTokenWithTrailingTrivia.prototype.isTypeScriptSpecific = function () { return false; };
            VariableWidthTokenWithTrailingTrivia.prototype.isIncrementallyUnusable = function () { return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); };
            VariableWidthTokenWithTrailingTrivia.prototype.accept = function (visitor) { return visitor.visitToken(this); };
            VariableWidthTokenWithTrailingTrivia.prototype.realize = function () { return Syntax.realizeToken(this); };
            VariableWidthTokenWithTrailingTrivia.prototype.collectTextElements = function (elements) { collectTokenTextElements(this, elements); };
            VariableWidthTokenWithTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isExpression = function () {
                return Syntax.isExpression(this);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isPrimaryExpression = function () {
                return this.isExpression();
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isMemberExpression = function () {
                return this.isExpression();
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isPostfixExpression = function () {
                return this.isExpression();
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isUnaryExpression = function () {
                return this.isExpression();
            };
            return VariableWidthTokenWithTrailingTrivia;
        }());
        Syntax.VariableWidthTokenWithTrailingTrivia = VariableWidthTokenWithTrailingTrivia;
        var VariableWidthTokenWithLeadingAndTrailingTrivia = (function () {
            function VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, textOrWidth, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._textOrWidth = textOrWidth;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithLeadingAndTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._textOrWidth, this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isNode = function () { return false; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isToken = function () { return true; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isList = function () { return false; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isSeparatedList = function () { return false; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.kind = function () { return this.tokenKind; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.childCount = function () { return 0; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.childAt = function (index) { throw TypeScript.Errors.argumentOutOfRange('index'); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.fullWidth = function () { return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.start = function () { return this._fullStart + getTriviaWidth(this._leadingTriviaInfo); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.end = function () { return this.start() + this.width(); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.width = function () { return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === TypeScript.SyntaxKind.IdentifierName);
                }
                return this._textOrWidth;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.fullText = function () { return this._sourceText.substr(this._fullStart, this.fullWidth(), false); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.value = function () {
                if (this._value === undefined) {
                    this._value = Syntax.value(this);
                }
                return this._value;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.valueText = function () {
                if (this._valueText === undefined) {
                    this._valueText = Syntax.valueText(this);
                }
                return this._valueText;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingTrivia = function () { return true; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingComment = function () { return hasTriviaComment(this._leadingTriviaInfo); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingNewLine = function () { return hasTriviaNewLine(this._leadingTriviaInfo); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingSkippedText = function () { return false; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTriviaWidth = function () { return getTriviaWidth(this._leadingTriviaInfo); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTrivia = function () { return Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingTrivia = function () { return true; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingComment = function () { return hasTriviaComment(this._trailingTriviaInfo); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingNewLine = function () { return hasTriviaNewLine(this._trailingTriviaInfo); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingSkippedText = function () { return false; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTriviaWidth = function () { return getTriviaWidth(this._trailingTriviaInfo); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTrivia = function () { return Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasSkippedToken = function () { return false; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.toJSON = function (key) { return Syntax.tokenToJSON(this); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.firstToken = function () { return this; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.lastToken = function () { return this; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isTypeScriptSpecific = function () { return false; };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isIncrementallyUnusable = function () { return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.accept = function (visitor) { return visitor.visitToken(this); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.realize = function () { return Syntax.realizeToken(this); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.collectTextElements = function (elements) { collectTokenTextElements(this, elements); };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isExpression = function () {
                return Syntax.isExpression(this);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isPrimaryExpression = function () {
                return this.isExpression();
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isMemberExpression = function () {
                return this.isExpression();
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isPostfixExpression = function () {
                return this.isExpression();
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isUnaryExpression = function () {
                return this.isExpression();
            };
            return VariableWidthTokenWithLeadingAndTrailingTrivia;
        }());
        Syntax.VariableWidthTokenWithLeadingAndTrailingTrivia = VariableWidthTokenWithLeadingAndTrailingTrivia;
        var FixedWidthTokenWithNoTrivia = (function () {
            function FixedWidthTokenWithNoTrivia(kind) {
                this.tokenKind = kind;
            }
            FixedWidthTokenWithNoTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithNoTrivia(this.tokenKind);
            };
            FixedWidthTokenWithNoTrivia.prototype.isNode = function () { return false; };
            FixedWidthTokenWithNoTrivia.prototype.isToken = function () { return true; };
            FixedWidthTokenWithNoTrivia.prototype.isList = function () { return false; };
            FixedWidthTokenWithNoTrivia.prototype.isSeparatedList = function () { return false; };
            FixedWidthTokenWithNoTrivia.prototype.kind = function () { return this.tokenKind; };
            FixedWidthTokenWithNoTrivia.prototype.childCount = function () { return 0; };
            FixedWidthTokenWithNoTrivia.prototype.childAt = function (index) { throw TypeScript.Errors.argumentOutOfRange('index'); };
            FixedWidthTokenWithNoTrivia.prototype.fullWidth = function () { return this.width(); };
            FixedWidthTokenWithNoTrivia.prototype.width = function () { return this.text().length; };
            FixedWidthTokenWithNoTrivia.prototype.text = function () { return TypeScript.SyntaxFacts.getText(this.tokenKind); };
            FixedWidthTokenWithNoTrivia.prototype.fullText = function () { return this.text(); };
            FixedWidthTokenWithNoTrivia.prototype.value = function () { return Syntax.value(this); };
            FixedWidthTokenWithNoTrivia.prototype.valueText = function () { return Syntax.valueText(this); };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () { return false; };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () { return false; };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingNewLine = function () { return false; };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingSkippedText = function () { return false; };
            FixedWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () { return 0; };
            FixedWidthTokenWithNoTrivia.prototype.leadingTrivia = function () { return Syntax.emptyTriviaList; };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () { return false; };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () { return false; };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingNewLine = function () { return false; };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingSkippedText = function () { return false; };
            FixedWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () { return 0; };
            FixedWidthTokenWithNoTrivia.prototype.trailingTrivia = function () { return Syntax.emptyTriviaList; };
            FixedWidthTokenWithNoTrivia.prototype.hasSkippedToken = function () { return false; };
            FixedWidthTokenWithNoTrivia.prototype.toJSON = function (key) { return Syntax.tokenToJSON(this); };
            FixedWidthTokenWithNoTrivia.prototype.firstToken = function () { return this; };
            FixedWidthTokenWithNoTrivia.prototype.lastToken = function () { return this; };
            FixedWidthTokenWithNoTrivia.prototype.isTypeScriptSpecific = function () { return false; };
            FixedWidthTokenWithNoTrivia.prototype.isIncrementallyUnusable = function () { return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); };
            FixedWidthTokenWithNoTrivia.prototype.accept = function (visitor) { return visitor.visitToken(this); };
            FixedWidthTokenWithNoTrivia.prototype.realize = function () { return Syntax.realizeToken(this); };
            FixedWidthTokenWithNoTrivia.prototype.collectTextElements = function (elements) { collectTokenTextElements(this, elements); };
            FixedWidthTokenWithNoTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            FixedWidthTokenWithNoTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            FixedWidthTokenWithNoTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            FixedWidthTokenWithNoTrivia.prototype.isExpression = function () {
                return Syntax.isExpression(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.isPrimaryExpression = function () {
                return this.isExpression();
            };
            FixedWidthTokenWithNoTrivia.prototype.isMemberExpression = function () {
                return this.isExpression();
            };
            FixedWidthTokenWithNoTrivia.prototype.isPostfixExpression = function () {
                return this.isExpression();
            };
            FixedWidthTokenWithNoTrivia.prototype.isUnaryExpression = function () {
                return this.isExpression();
            };
            return FixedWidthTokenWithNoTrivia;
        }());
        Syntax.FixedWidthTokenWithNoTrivia = FixedWidthTokenWithNoTrivia;
        var FixedWidthTokenWithLeadingTrivia = (function () {
            function FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
            }
            FixedWidthTokenWithLeadingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithLeadingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isNode = function () { return false; };
            FixedWidthTokenWithLeadingTrivia.prototype.isToken = function () { return true; };
            FixedWidthTokenWithLeadingTrivia.prototype.isList = function () { return false; };
            FixedWidthTokenWithLeadingTrivia.prototype.isSeparatedList = function () { return false; };
            FixedWidthTokenWithLeadingTrivia.prototype.kind = function () { return this.tokenKind; };
            FixedWidthTokenWithLeadingTrivia.prototype.childCount = function () { return 0; };
            FixedWidthTokenWithLeadingTrivia.prototype.childAt = function (index) { throw TypeScript.Errors.argumentOutOfRange('index'); };
            FixedWidthTokenWithLeadingTrivia.prototype.fullWidth = function () { return getTriviaWidth(this._leadingTriviaInfo) + this.width(); };
            FixedWidthTokenWithLeadingTrivia.prototype.start = function () { return this._fullStart + getTriviaWidth(this._leadingTriviaInfo); };
            FixedWidthTokenWithLeadingTrivia.prototype.end = function () { return this.start() + this.width(); };
            FixedWidthTokenWithLeadingTrivia.prototype.width = function () { return this.text().length; };
            FixedWidthTokenWithLeadingTrivia.prototype.text = function () { return TypeScript.SyntaxFacts.getText(this.tokenKind); };
            FixedWidthTokenWithLeadingTrivia.prototype.fullText = function () { return this._sourceText.substr(this._fullStart, this.fullWidth(), false); };
            FixedWidthTokenWithLeadingTrivia.prototype.value = function () { return Syntax.value(this); };
            FixedWidthTokenWithLeadingTrivia.prototype.valueText = function () { return Syntax.valueText(this); };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingTrivia = function () { return true; };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingComment = function () { return hasTriviaComment(this._leadingTriviaInfo); };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingNewLine = function () { return hasTriviaNewLine(this._leadingTriviaInfo); };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingSkippedText = function () { return false; };
            FixedWidthTokenWithLeadingTrivia.prototype.leadingTriviaWidth = function () { return getTriviaWidth(this._leadingTriviaInfo); };
            FixedWidthTokenWithLeadingTrivia.prototype.leadingTrivia = function () { return Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false); };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingTrivia = function () { return false; };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingComment = function () { return false; };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingNewLine = function () { return false; };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingSkippedText = function () { return false; };
            FixedWidthTokenWithLeadingTrivia.prototype.trailingTriviaWidth = function () { return 0; };
            FixedWidthTokenWithLeadingTrivia.prototype.trailingTrivia = function () { return Syntax.emptyTriviaList; };
            FixedWidthTokenWithLeadingTrivia.prototype.hasSkippedToken = function () { return false; };
            FixedWidthTokenWithLeadingTrivia.prototype.toJSON = function (key) { return Syntax.tokenToJSON(this); };
            FixedWidthTokenWithLeadingTrivia.prototype.firstToken = function () { return this; };
            FixedWidthTokenWithLeadingTrivia.prototype.lastToken = function () { return this; };
            FixedWidthTokenWithLeadingTrivia.prototype.isTypeScriptSpecific = function () { return false; };
            FixedWidthTokenWithLeadingTrivia.prototype.isIncrementallyUnusable = function () { return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); };
            FixedWidthTokenWithLeadingTrivia.prototype.accept = function (visitor) { return visitor.visitToken(this); };
            FixedWidthTokenWithLeadingTrivia.prototype.realize = function () { return Syntax.realizeToken(this); };
            FixedWidthTokenWithLeadingTrivia.prototype.collectTextElements = function (elements) { collectTokenTextElements(this, elements); };
            FixedWidthTokenWithLeadingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isExpression = function () {
                return Syntax.isExpression(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isPrimaryExpression = function () {
                return this.isExpression();
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isMemberExpression = function () {
                return this.isExpression();
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isPostfixExpression = function () {
                return this.isExpression();
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isUnaryExpression = function () {
                return this.isExpression();
            };
            return FixedWidthTokenWithLeadingTrivia;
        }());
        Syntax.FixedWidthTokenWithLeadingTrivia = FixedWidthTokenWithLeadingTrivia;
        var FixedWidthTokenWithTrailingTrivia = (function () {
            function FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            FixedWidthTokenWithTrailingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isNode = function () { return false; };
            FixedWidthTokenWithTrailingTrivia.prototype.isToken = function () { return true; };
            FixedWidthTokenWithTrailingTrivia.prototype.isList = function () { return false; };
            FixedWidthTokenWithTrailingTrivia.prototype.isSeparatedList = function () { return false; };
            FixedWidthTokenWithTrailingTrivia.prototype.kind = function () { return this.tokenKind; };
            FixedWidthTokenWithTrailingTrivia.prototype.childCount = function () { return 0; };
            FixedWidthTokenWithTrailingTrivia.prototype.childAt = function (index) { throw TypeScript.Errors.argumentOutOfRange('index'); };
            FixedWidthTokenWithTrailingTrivia.prototype.fullWidth = function () { return this.width() + getTriviaWidth(this._trailingTriviaInfo); };
            FixedWidthTokenWithTrailingTrivia.prototype.start = function () { return this._fullStart; };
            FixedWidthTokenWithTrailingTrivia.prototype.end = function () { return this.start() + this.width(); };
            FixedWidthTokenWithTrailingTrivia.prototype.width = function () { return this.text().length; };
            FixedWidthTokenWithTrailingTrivia.prototype.text = function () { return TypeScript.SyntaxFacts.getText(this.tokenKind); };
            FixedWidthTokenWithTrailingTrivia.prototype.fullText = function () { return this._sourceText.substr(this._fullStart, this.fullWidth(), false); };
            FixedWidthTokenWithTrailingTrivia.prototype.value = function () { return Syntax.value(this); };
            FixedWidthTokenWithTrailingTrivia.prototype.valueText = function () { return Syntax.valueText(this); };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingTrivia = function () { return false; };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingComment = function () { return false; };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingNewLine = function () { return false; };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingSkippedText = function () { return false; };
            FixedWidthTokenWithTrailingTrivia.prototype.leadingTriviaWidth = function () { return 0; };
            FixedWidthTokenWithTrailingTrivia.prototype.leadingTrivia = function () { return Syntax.emptyTriviaList; };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingTrivia = function () { return true; };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingComment = function () { return hasTriviaComment(this._trailingTriviaInfo); };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingNewLine = function () { return hasTriviaNewLine(this._trailingTriviaInfo); };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingSkippedText = function () { return false; };
            FixedWidthTokenWithTrailingTrivia.prototype.trailingTriviaWidth = function () { return getTriviaWidth(this._trailingTriviaInfo); };
            FixedWidthTokenWithTrailingTrivia.prototype.trailingTrivia = function () { return Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true); };
            FixedWidthTokenWithTrailingTrivia.prototype.hasSkippedToken = function () { return false; };
            FixedWidthTokenWithTrailingTrivia.prototype.toJSON = function (key) { return Syntax.tokenToJSON(this); };
            FixedWidthTokenWithTrailingTrivia.prototype.firstToken = function () { return this; };
            FixedWidthTokenWithTrailingTrivia.prototype.lastToken = function () { return this; };
            FixedWidthTokenWithTrailingTrivia.prototype.isTypeScriptSpecific = function () { return false; };
            FixedWidthTokenWithTrailingTrivia.prototype.isIncrementallyUnusable = function () { return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); };
            FixedWidthTokenWithTrailingTrivia.prototype.accept = function (visitor) { return visitor.visitToken(this); };
            FixedWidthTokenWithTrailingTrivia.prototype.realize = function () { return Syntax.realizeToken(this); };
            FixedWidthTokenWithTrailingTrivia.prototype.collectTextElements = function (elements) { collectTokenTextElements(this, elements); };
            FixedWidthTokenWithTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isExpression = function () {
                return Syntax.isExpression(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isPrimaryExpression = function () {
                return this.isExpression();
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isMemberExpression = function () {
                return this.isExpression();
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isPostfixExpression = function () {
                return this.isExpression();
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isUnaryExpression = function () {
                return this.isExpression();
            };
            return FixedWidthTokenWithTrailingTrivia;
        }());
        Syntax.FixedWidthTokenWithTrailingTrivia = FixedWidthTokenWithTrailingTrivia;
        var FixedWidthTokenWithLeadingAndTrailingTrivia = (function () {
            function FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithLeadingAndTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isNode = function () { return false; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isToken = function () { return true; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isList = function () { return false; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isSeparatedList = function () { return false; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.kind = function () { return this.tokenKind; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.childCount = function () { return 0; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.childAt = function (index) { throw TypeScript.Errors.argumentOutOfRange('index'); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.fullWidth = function () { return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.start = function () { return this._fullStart + getTriviaWidth(this._leadingTriviaInfo); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.end = function () { return this.start() + this.width(); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.width = function () { return this.text().length; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.text = function () { return TypeScript.SyntaxFacts.getText(this.tokenKind); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.fullText = function () { return this._sourceText.substr(this._fullStart, this.fullWidth(), false); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.value = function () { return Syntax.value(this); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.valueText = function () { return Syntax.valueText(this); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingTrivia = function () { return true; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingComment = function () { return hasTriviaComment(this._leadingTriviaInfo); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingNewLine = function () { return hasTriviaNewLine(this._leadingTriviaInfo); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingSkippedText = function () { return false; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTriviaWidth = function () { return getTriviaWidth(this._leadingTriviaInfo); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTrivia = function () { return Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingTrivia = function () { return true; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingComment = function () { return hasTriviaComment(this._trailingTriviaInfo); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingNewLine = function () { return hasTriviaNewLine(this._trailingTriviaInfo); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingSkippedText = function () { return false; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTriviaWidth = function () { return getTriviaWidth(this._trailingTriviaInfo); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTrivia = function () { return Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasSkippedToken = function () { return false; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.toJSON = function (key) { return Syntax.tokenToJSON(this); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.firstToken = function () { return this; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.lastToken = function () { return this; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isTypeScriptSpecific = function () { return false; };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isIncrementallyUnusable = function () { return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.accept = function (visitor) { return visitor.visitToken(this); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.realize = function () { return Syntax.realizeToken(this); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.collectTextElements = function (elements) { collectTokenTextElements(this, elements); };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isExpression = function () {
                return Syntax.isExpression(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isPrimaryExpression = function () {
                return this.isExpression();
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isMemberExpression = function () {
                return this.isExpression();
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isPostfixExpression = function () {
                return this.isExpression();
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isUnaryExpression = function () {
                return this.isExpression();
            };
            return FixedWidthTokenWithLeadingAndTrailingTrivia;
        }());
        Syntax.FixedWidthTokenWithLeadingAndTrailingTrivia = FixedWidthTokenWithLeadingAndTrailingTrivia;
        function collectTokenTextElements(token, elements) {
            token.leadingTrivia().collectTextElements(elements);
            elements.push(token.text());
            token.trailingTrivia().collectTextElements(elements);
        }
        function fixedWidthToken(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo) {
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new FixedWidthTokenWithNoTrivia(kind);
                }
                else {
                    return new FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo);
                }
            }
            else if (trailingTriviaInfo === 0) {
                return new FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo);
            }
            else {
                return new FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
            }
        }
        Syntax.fixedWidthToken = fixedWidthToken;
        function variableWidthToken(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo) {
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, width);
                }
                else {
                    return new VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, width, trailingTriviaInfo);
                }
            }
            else if (trailingTriviaInfo === 0) {
                return new VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width);
            }
            else {
                return new VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
            }
        }
        Syntax.variableWidthToken = variableWidthToken;
        function getTriviaWidth(value) {
            return value >>> TypeScript.SyntaxConstants.TriviaFullWidthShift;
        }
        function hasTriviaComment(value) {
            return (value & TypeScript.SyntaxConstants.TriviaCommentMask) !== 0;
        }
        function hasTriviaNewLine(value) {
            return (value & TypeScript.SyntaxConstants.TriviaNewLineMask) !== 0;
        }
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        function isExpression(token) {
            switch (token.tokenKind) {
                case TypeScript.SyntaxKind.IdentifierName:
                case TypeScript.SyntaxKind.RegularExpressionLiteral:
                case TypeScript.SyntaxKind.NumericLiteral:
                case TypeScript.SyntaxKind.StringLiteral:
                case TypeScript.SyntaxKind.FalseKeyword:
                case TypeScript.SyntaxKind.NullKeyword:
                case TypeScript.SyntaxKind.ThisKeyword:
                case TypeScript.SyntaxKind.TrueKeyword:
                case TypeScript.SyntaxKind.SuperKeyword:
                    return true;
            }
            return false;
        }
        Syntax.isExpression = isExpression;
        function realizeToken(token) {
            return new RealizedToken(token.tokenKind, token.leadingTrivia(), token.text(), token.value(), token.valueText(), token.trailingTrivia());
        }
        Syntax.realizeToken = realizeToken;
        function convertToIdentifierName(token) {
            TypeScript.Debug.assert(TypeScript.SyntaxFacts.isAnyKeyword(token.tokenKind));
            return new RealizedToken(TypeScript.SyntaxKind.IdentifierName, token.leadingTrivia(), token.text(), token.text(), token.text(), token.trailingTrivia());
        }
        Syntax.convertToIdentifierName = convertToIdentifierName;
        function tokenToJSON(token) {
            var result = {};
            for (var name in TypeScript.SyntaxKind) {
                if (TypeScript.SyntaxKind[name] === token.kind()) {
                    result.kind = name;
                    break;
                }
            }
            result.width = token.width();
            if (token.fullWidth() !== token.width()) {
                result.fullWidth = token.fullWidth();
            }
            result.text = token.text();
            var value = token.value();
            if (value !== null) {
                result.value = value;
                result.valueText = token.valueText();
            }
            if (token.hasLeadingTrivia()) {
                result.hasLeadingTrivia = true;
            }
            if (token.hasLeadingComment()) {
                result.hasLeadingComment = true;
            }
            if (token.hasLeadingNewLine()) {
                result.hasLeadingNewLine = true;
            }
            if (token.hasLeadingSkippedText()) {
                result.hasLeadingSkippedText = true;
            }
            if (token.hasTrailingTrivia()) {
                result.hasTrailingTrivia = true;
            }
            if (token.hasTrailingComment()) {
                result.hasTrailingComment = true;
            }
            if (token.hasTrailingNewLine()) {
                result.hasTrailingNewLine = true;
            }
            if (token.hasTrailingSkippedText()) {
                result.hasTrailingSkippedText = true;
            }
            var trivia = token.leadingTrivia();
            if (trivia.count() > 0) {
                result.leadingTrivia = trivia;
            }
            trivia = token.trailingTrivia();
            if (trivia.count() > 0) {
                result.trailingTrivia = trivia;
            }
            return result;
        }
        Syntax.tokenToJSON = tokenToJSON;
        function value(token) {
            return value1(token.tokenKind, token.text());
        }
        Syntax.value = value;
        function hexValue(text, start, length) {
            var intChar = 0;
            for (var i = 0; i < length; i++) {
                var ch2 = text.charCodeAt(start + i);
                if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                    break;
                }
                intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
            }
            return intChar;
        }
        var characterArray = [];
        function convertEscapes(text) {
            characterArray.length = 0;
            var result = "";
            for (var i = 0, n = text.length; i < n; i++) {
                var ch = text.charCodeAt(i);
                if (ch === TypeScript.CharacterCodes.backslash) {
                    i++;
                    if (i < n) {
                        ch = text.charCodeAt(i);
                        switch (ch) {
                            case TypeScript.CharacterCodes._0:
                                characterArray.push(TypeScript.CharacterCodes.nullCharacter);
                                continue;
                            case TypeScript.CharacterCodes.b:
                                characterArray.push(TypeScript.CharacterCodes.backspace);
                                continue;
                            case TypeScript.CharacterCodes.f:
                                characterArray.push(TypeScript.CharacterCodes.formFeed);
                                continue;
                            case TypeScript.CharacterCodes.n:
                                characterArray.push(TypeScript.CharacterCodes.lineFeed);
                                continue;
                            case TypeScript.CharacterCodes.r:
                                characterArray.push(TypeScript.CharacterCodes.carriageReturn);
                                continue;
                            case TypeScript.CharacterCodes.t:
                                characterArray.push(TypeScript.CharacterCodes.tab);
                                continue;
                            case TypeScript.CharacterCodes.v:
                                characterArray.push(TypeScript.CharacterCodes.verticalTab);
                                continue;
                            case TypeScript.CharacterCodes.x:
                                characterArray.push(hexValue(text, i + 1, 2));
                                i += 2;
                                continue;
                            case TypeScript.CharacterCodes.u:
                                characterArray.push(hexValue(text, i + 1, 4));
                                i += 4;
                                continue;
                            case TypeScript.CharacterCodes.carriageReturn:
                                var nextIndex = i + 1;
                                if (nextIndex < text.length && text.charCodeAt(nextIndex) == TypeScript.CharacterCodes.lineFeed) {
                                    i++;
                                }
                                continue;
                            case TypeScript.CharacterCodes.lineFeed:
                            case TypeScript.CharacterCodes.paragraphSeparator:
                            case TypeScript.CharacterCodes.lineSeparator:
                                continue;
                            default:
                        }
                    }
                }
                characterArray.push(ch);
                if (i && !(i % 1024)) {
                    result = result.concat(TypeScript.StringUtilities.fromCharCodeArray(characterArray));
                    characterArray.length = 0;
                }
            }
            if (characterArray.length) {
                result = result.concat(TypeScript.StringUtilities.fromCharCodeArray(characterArray));
            }
            return result;
        }
        function massageEscapes(text) {
            return text.indexOf("\\") >= 0 ? convertEscapes(text) : text;
        }
        Syntax.massageEscapes = massageEscapes;
        function value1(kind, text) {
            if (kind === TypeScript.SyntaxKind.IdentifierName) {
                return massageEscapes(text);
            }
            switch (kind) {
                case TypeScript.SyntaxKind.TrueKeyword:
                    return true;
                case TypeScript.SyntaxKind.FalseKeyword:
                    return false;
                case TypeScript.SyntaxKind.NullKeyword:
                    return null;
            }
            if (TypeScript.SyntaxFacts.isAnyKeyword(kind) || TypeScript.SyntaxFacts.isAnyPunctuation(kind)) {
                return TypeScript.SyntaxFacts.getText(kind);
            }
            if (kind === TypeScript.SyntaxKind.NumericLiteral) {
                return TypeScript.IntegerUtilities.isHexInteger(text) ? parseInt(text, 16) : parseFloat(text);
            }
            else if (kind === TypeScript.SyntaxKind.StringLiteral) {
                if (text.length > 1 && text.charCodeAt(text.length - 1) === text.charCodeAt(0)) {
                    return massageEscapes(text.substr(1, text.length - 2));
                }
                else {
                    return massageEscapes(text.substr(1));
                }
            }
            else if (kind === TypeScript.SyntaxKind.RegularExpressionLiteral) {
                return regularExpressionValue(text);
            }
            else if (kind === TypeScript.SyntaxKind.EndOfFileToken || kind === TypeScript.SyntaxKind.ErrorToken) {
                return null;
            }
            else {
                throw TypeScript.Errors.invalidOperation();
            }
        }
        function regularExpressionValue(text) {
            try {
                var lastSlash = text.lastIndexOf("/");
                var body = text.substring(1, lastSlash);
                var flags = text.substring(lastSlash + 1);
                return new RegExp(body, flags);
            }
            catch (e) {
                return null;
            }
        }
        function valueText1(kind, text) {
            var value = value1(kind, text);
            return value === null ? "" : value.toString();
        }
        function valueText(token) {
            var value = token.value();
            return value === null ? "" : value.toString();
        }
        Syntax.valueText = valueText;
        var EmptyToken = (function () {
            function EmptyToken(kind) {
                this.tokenKind = kind;
            }
            EmptyToken.prototype.clone = function () {
                return new EmptyToken(this.tokenKind);
            };
            EmptyToken.prototype.kind = function () { return this.tokenKind; };
            EmptyToken.prototype.isToken = function () { return true; };
            EmptyToken.prototype.isNode = function () { return false; };
            EmptyToken.prototype.isList = function () { return false; };
            EmptyToken.prototype.isSeparatedList = function () { return false; };
            EmptyToken.prototype.childCount = function () {
                return 0;
            };
            EmptyToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            EmptyToken.prototype.toJSON = function (key) { return tokenToJSON(this); };
            EmptyToken.prototype.accept = function (visitor) { return visitor.visitToken(this); };
            EmptyToken.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            EmptyToken.prototype.firstToken = function () { return this; };
            EmptyToken.prototype.lastToken = function () { return this; };
            EmptyToken.prototype.isTypeScriptSpecific = function () { return false; };
            EmptyToken.prototype.isIncrementallyUnusable = function () { return true; };
            EmptyToken.prototype.fullWidth = function () { return 0; };
            EmptyToken.prototype.width = function () { return 0; };
            EmptyToken.prototype.text = function () { return ""; };
            EmptyToken.prototype.fullText = function () { return ""; };
            EmptyToken.prototype.value = function () { return null; };
            EmptyToken.prototype.valueText = function () { return ""; };
            EmptyToken.prototype.hasLeadingTrivia = function () { return false; };
            EmptyToken.prototype.hasLeadingComment = function () { return false; };
            EmptyToken.prototype.hasLeadingNewLine = function () { return false; };
            EmptyToken.prototype.hasLeadingSkippedText = function () { return false; };
            EmptyToken.prototype.leadingTriviaWidth = function () { return 0; };
            EmptyToken.prototype.hasTrailingTrivia = function () { return false; };
            EmptyToken.prototype.hasTrailingComment = function () { return false; };
            EmptyToken.prototype.hasTrailingNewLine = function () { return false; };
            EmptyToken.prototype.hasTrailingSkippedText = function () { return false; };
            EmptyToken.prototype.hasSkippedToken = function () { return false; };
            EmptyToken.prototype.trailingTriviaWidth = function () { return 0; };
            EmptyToken.prototype.leadingTrivia = function () { return Syntax.emptyTriviaList; };
            EmptyToken.prototype.trailingTrivia = function () { return Syntax.emptyTriviaList; };
            EmptyToken.prototype.realize = function () { return realizeToken(this); };
            EmptyToken.prototype.collectTextElements = function (elements) { };
            EmptyToken.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            EmptyToken.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            EmptyToken.prototype.isExpression = function () {
                return isExpression(this);
            };
            EmptyToken.prototype.isPrimaryExpression = function () {
                return this.isExpression();
            };
            EmptyToken.prototype.isMemberExpression = function () {
                return this.isExpression();
            };
            EmptyToken.prototype.isPostfixExpression = function () {
                return this.isExpression();
            };
            EmptyToken.prototype.isUnaryExpression = function () {
                return this.isExpression();
            };
            return EmptyToken;
        }());
        function emptyToken(kind) {
            return new EmptyToken(kind);
        }
        Syntax.emptyToken = emptyToken;
        var RealizedToken = (function () {
            function RealizedToken(tokenKind, leadingTrivia, text, value, valueText, trailingTrivia) {
                this.tokenKind = tokenKind;
                this._leadingTrivia = leadingTrivia;
                this._text = text;
                this._value = value;
                this._valueText = valueText;
                this._trailingTrivia = trailingTrivia;
            }
            RealizedToken.prototype.clone = function () {
                return new RealizedToken(this.tokenKind, this._leadingTrivia, this._text, this._value, this._valueText, this._trailingTrivia);
            };
            RealizedToken.prototype.kind = function () { return this.tokenKind; };
            RealizedToken.prototype.toJSON = function (key) { return tokenToJSON(this); };
            RealizedToken.prototype.firstToken = function () { return this; };
            RealizedToken.prototype.lastToken = function () { return this; };
            RealizedToken.prototype.isTypeScriptSpecific = function () { return false; };
            RealizedToken.prototype.isIncrementallyUnusable = function () { return true; };
            RealizedToken.prototype.accept = function (visitor) { return visitor.visitToken(this); };
            RealizedToken.prototype.childCount = function () {
                return 0;
            };
            RealizedToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            RealizedToken.prototype.isToken = function () { return true; };
            RealizedToken.prototype.isNode = function () { return false; };
            RealizedToken.prototype.isList = function () { return false; };
            RealizedToken.prototype.isSeparatedList = function () { return false; };
            RealizedToken.prototype.isTrivia = function () { return false; };
            RealizedToken.prototype.isTriviaList = function () { return false; };
            RealizedToken.prototype.fullWidth = function () { return this._leadingTrivia.fullWidth() + this.width() + this._trailingTrivia.fullWidth(); };
            RealizedToken.prototype.width = function () { return this.text().length; };
            RealizedToken.prototype.text = function () { return this._text; };
            RealizedToken.prototype.fullText = function () { return this._leadingTrivia.fullText() + this.text() + this._trailingTrivia.fullText(); };
            RealizedToken.prototype.value = function () { return this._value; };
            RealizedToken.prototype.valueText = function () { return this._valueText; };
            RealizedToken.prototype.hasLeadingTrivia = function () { return this._leadingTrivia.count() > 0; };
            RealizedToken.prototype.hasLeadingComment = function () { return this._leadingTrivia.hasComment(); };
            RealizedToken.prototype.hasLeadingNewLine = function () { return this._leadingTrivia.hasNewLine(); };
            RealizedToken.prototype.hasLeadingSkippedText = function () { return this._leadingTrivia.hasSkippedToken(); };
            RealizedToken.prototype.leadingTriviaWidth = function () { return this._leadingTrivia.fullWidth(); };
            RealizedToken.prototype.hasTrailingTrivia = function () { return this._trailingTrivia.count() > 0; };
            RealizedToken.prototype.hasTrailingComment = function () { return this._trailingTrivia.hasComment(); };
            RealizedToken.prototype.hasTrailingNewLine = function () { return this._trailingTrivia.hasNewLine(); };
            RealizedToken.prototype.hasTrailingSkippedText = function () { return this._trailingTrivia.hasSkippedToken(); };
            RealizedToken.prototype.trailingTriviaWidth = function () { return this._trailingTrivia.fullWidth(); };
            RealizedToken.prototype.hasSkippedToken = function () { return this.hasLeadingSkippedText() || this.hasTrailingSkippedText(); };
            RealizedToken.prototype.leadingTrivia = function () { return this._leadingTrivia; };
            RealizedToken.prototype.trailingTrivia = function () { return this._trailingTrivia; };
            RealizedToken.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            RealizedToken.prototype.collectTextElements = function (elements) {
                this.leadingTrivia().collectTextElements(elements);
                elements.push(this.text());
                this.trailingTrivia().collectTextElements(elements);
            };
            RealizedToken.prototype.withLeadingTrivia = function (leadingTrivia) {
                return new RealizedToken(this.tokenKind, leadingTrivia, this._text, this._value, this._valueText, this._trailingTrivia);
            };
            RealizedToken.prototype.withTrailingTrivia = function (trailingTrivia) {
                return new RealizedToken(this.tokenKind, this._leadingTrivia, this._text, this._value, this._valueText, trailingTrivia);
            };
            RealizedToken.prototype.isExpression = function () {
                return isExpression(this);
            };
            RealizedToken.prototype.isPrimaryExpression = function () {
                return this.isExpression();
            };
            RealizedToken.prototype.isMemberExpression = function () {
                return this.isExpression();
            };
            RealizedToken.prototype.isPostfixExpression = function () {
                return this.isExpression();
            };
            RealizedToken.prototype.isUnaryExpression = function () {
                return this.isExpression();
            };
            return RealizedToken;
        }());
        function token(kind, info) {
            if (info === void 0) { info = null; }
            var text = (info !== null && info.text !== undefined) ? info.text : TypeScript.SyntaxFacts.getText(kind);
            return new RealizedToken(kind, Syntax.triviaList(info === null ? null : info.leadingTrivia), text, value1(kind, text), valueText1(kind, text), Syntax.triviaList(info === null ? null : info.trailingTrivia));
        }
        Syntax.token = token;
        function identifier(text, info) {
            if (info === void 0) { info = null; }
            info = info || {};
            info.text = text;
            return token(TypeScript.SyntaxKind.IdentifierName, info);
        }
        Syntax.identifier = identifier;
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxTokenReplacer = (function (_super) {
        __extends(SyntaxTokenReplacer, _super);
        function SyntaxTokenReplacer(token1, token2) {
            var _this = _super.call(this) || this;
            _this.token1 = token1;
            _this.token2 = token2;
            return _this;
        }
        SyntaxTokenReplacer.prototype.visitToken = function (token) {
            if (token === this.token1) {
                var result = this.token2;
                this.token1 = null;
                this.token2 = null;
                return result;
            }
            return token;
        };
        SyntaxTokenReplacer.prototype.visitNode = function (node) {
            if (this.token1 === null) {
                return node;
            }
            return _super.prototype.visitNode.call(this, node);
        };
        SyntaxTokenReplacer.prototype.visitList = function (list) {
            if (this.token1 === null) {
                return list;
            }
            return _super.prototype.visitList.call(this, list);
        };
        SyntaxTokenReplacer.prototype.visitSeparatedList = function (list) {
            if (this.token1 === null) {
                return list;
            }
            return _super.prototype.visitSeparatedList.call(this, list);
        };
        return SyntaxTokenReplacer;
    }(TypeScript.SyntaxRewriter));
    TypeScript.SyntaxTokenReplacer = SyntaxTokenReplacer;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        var AbstractTrivia = (function () {
            function AbstractTrivia(_kind) {
                this._kind = _kind;
            }
            AbstractTrivia.prototype.fullWidth = function () {
                throw TypeScript.Errors.abstract();
            };
            AbstractTrivia.prototype.fullText = function () {
                throw TypeScript.Errors.abstract();
            };
            AbstractTrivia.prototype.skippedToken = function () {
                throw TypeScript.Errors.abstract();
            };
            AbstractTrivia.prototype.toJSON = function (key) {
                var result = {};
                for (var name in TypeScript.SyntaxKind) {
                    if (TypeScript.SyntaxKind[name] === this._kind) {
                        result.kind = name;
                        break;
                    }
                }
                if (this.isSkippedToken()) {
                    result.skippedToken = this.skippedToken();
                }
                else {
                    result.text = this.fullText();
                }
                return result;
            };
            AbstractTrivia.prototype.kind = function () {
                return this._kind;
            };
            AbstractTrivia.prototype.isWhitespace = function () {
                return this.kind() === TypeScript.SyntaxKind.WhitespaceTrivia;
            };
            AbstractTrivia.prototype.isComment = function () {
                return this.kind() === TypeScript.SyntaxKind.SingleLineCommentTrivia || this.kind() === TypeScript.SyntaxKind.MultiLineCommentTrivia;
            };
            AbstractTrivia.prototype.isNewLine = function () {
                return this.kind() === TypeScript.SyntaxKind.NewLineTrivia;
            };
            AbstractTrivia.prototype.isSkippedToken = function () {
                return this.kind() === TypeScript.SyntaxKind.SkippedTokenTrivia;
            };
            AbstractTrivia.prototype.collectTextElements = function (elements) {
                elements.push(this.fullText());
            };
            return AbstractTrivia;
        }());
        var NormalTrivia = (function (_super) {
            __extends(NormalTrivia, _super);
            function NormalTrivia(kind, _text) {
                var _this = _super.call(this, kind) || this;
                _this._text = _text;
                return _this;
            }
            NormalTrivia.prototype.fullWidth = function () {
                return this.fullText().length;
            };
            NormalTrivia.prototype.fullText = function () {
                return this._text;
            };
            NormalTrivia.prototype.skippedToken = function () {
                throw TypeScript.Errors.invalidOperation();
            };
            return NormalTrivia;
        }(AbstractTrivia));
        var SkippedTokenTrivia = (function (_super) {
            __extends(SkippedTokenTrivia, _super);
            function SkippedTokenTrivia(_skippedToken) {
                var _this = _super.call(this, TypeScript.SyntaxKind.SkippedTokenTrivia) || this;
                _this._skippedToken = _skippedToken;
                return _this;
            }
            SkippedTokenTrivia.prototype.fullWidth = function () {
                return this.fullText().length;
            };
            SkippedTokenTrivia.prototype.fullText = function () {
                return this.skippedToken().fullText();
            };
            SkippedTokenTrivia.prototype.skippedToken = function () {
                return this._skippedToken;
            };
            return SkippedTokenTrivia;
        }(AbstractTrivia));
        var DeferredTrivia = (function (_super) {
            __extends(DeferredTrivia, _super);
            function DeferredTrivia(kind, _text, _fullStart, _fullWidth) {
                var _this = _super.call(this, kind) || this;
                _this._text = _text;
                _this._fullStart = _fullStart;
                _this._fullWidth = _fullWidth;
                _this._fullText = null;
                return _this;
            }
            DeferredTrivia.prototype.fullWidth = function () {
                return this._fullWidth;
            };
            DeferredTrivia.prototype.fullText = function () {
                if (!this._fullText) {
                    this._fullText = this._text.substr(this._fullStart, this._fullWidth, false);
                    this._text = null;
                }
                return this._fullText;
            };
            DeferredTrivia.prototype.skippedToken = function () {
                throw TypeScript.Errors.invalidOperation();
            };
            return DeferredTrivia;
        }(AbstractTrivia));
        function deferredTrivia(kind, text, fullStart, fullWidth) {
            return new DeferredTrivia(kind, text, fullStart, fullWidth);
        }
        Syntax.deferredTrivia = deferredTrivia;
        function trivia(kind, text) {
            return new NormalTrivia(kind, text);
        }
        Syntax.trivia = trivia;
        function skippedTokenTrivia(token) {
            TypeScript.Debug.assert(!token.hasLeadingTrivia());
            TypeScript.Debug.assert(!token.hasTrailingTrivia());
            TypeScript.Debug.assert(token.fullWidth() > 0);
            return new SkippedTokenTrivia(token);
        }
        Syntax.skippedTokenTrivia = skippedTokenTrivia;
        function spaces(count) {
            return trivia(TypeScript.SyntaxKind.WhitespaceTrivia, TypeScript.StringUtilities.repeat(" ", count));
        }
        Syntax.spaces = spaces;
        function whitespace(text) {
            return trivia(TypeScript.SyntaxKind.WhitespaceTrivia, text);
        }
        Syntax.whitespace = whitespace;
        function multiLineComment(text) {
            return trivia(TypeScript.SyntaxKind.MultiLineCommentTrivia, text);
        }
        Syntax.multiLineComment = multiLineComment;
        function singleLineComment(text) {
            return trivia(TypeScript.SyntaxKind.SingleLineCommentTrivia, text);
        }
        Syntax.singleLineComment = singleLineComment;
        Syntax.spaceTrivia = spaces(1);
        Syntax.lineFeedTrivia = trivia(TypeScript.SyntaxKind.NewLineTrivia, "\n");
        Syntax.carriageReturnTrivia = trivia(TypeScript.SyntaxKind.NewLineTrivia, "\r");
        Syntax.carriageReturnLineFeedTrivia = trivia(TypeScript.SyntaxKind.NewLineTrivia, "\r\n");
        function splitMultiLineCommentTriviaIntoMultipleLines(trivia) {
            var result = [];
            var triviaText = trivia.fullText();
            var currentIndex = 0;
            for (var i = 0; i < triviaText.length; i++) {
                var ch = triviaText.charCodeAt(i);
                var isCarriageReturnLineFeed = false;
                switch (ch) {
                    case TypeScript.CharacterCodes.carriageReturn:
                        if (i < triviaText.length - 1 && triviaText.charCodeAt(i + 1) === TypeScript.CharacterCodes.lineFeed) {
                            i++;
                        }
                    case TypeScript.CharacterCodes.lineFeed:
                    case TypeScript.CharacterCodes.paragraphSeparator:
                    case TypeScript.CharacterCodes.lineSeparator:
                        result.push(triviaText.substring(currentIndex, i + 1));
                        currentIndex = i + 1;
                        continue;
                }
            }
            result.push(triviaText.substring(currentIndex));
            return result;
        }
        Syntax.splitMultiLineCommentTriviaIntoMultipleLines = splitMultiLineCommentTriviaIntoMultipleLines;
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        Syntax.emptyTriviaList = {
            kind: function () {
                return TypeScript.SyntaxKind.TriviaList;
            },
            count: function () {
                return 0;
            },
            syntaxTriviaAt: function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            },
            last: function () {
                throw TypeScript.Errors.argumentOutOfRange("index");
            },
            fullWidth: function () {
                return 0;
            },
            fullText: function () {
                return "";
            },
            hasComment: function () {
                return false;
            },
            hasNewLine: function () {
                return false;
            },
            hasSkippedToken: function () {
                return false;
            },
            toJSON: function (key) {
                return [];
            },
            collectTextElements: function (elements) {
            },
            toArray: function () {
                return [];
            },
            concat: function (trivia) {
                return trivia;
            }
        };
        function concatTrivia(list1, list2) {
            if (list1.count() === 0) {
                return list2;
            }
            if (list2.count() === 0) {
                return list1;
            }
            var trivia = list1.toArray();
            RT.applyVariadic(trivia, "push", list2.toArray());
            return triviaList(trivia);
        }
        function isComment(trivia) {
            return trivia.kind() === TypeScript.SyntaxKind.MultiLineCommentTrivia || trivia.kind() === TypeScript.SyntaxKind.SingleLineCommentTrivia;
        }
        var SingletonSyntaxTriviaList = (function () {
            function SingletonSyntaxTriviaList(item) {
                this.item = item;
            }
            SingletonSyntaxTriviaList.prototype.kind = function () { return TypeScript.SyntaxKind.TriviaList; };
            SingletonSyntaxTriviaList.prototype.count = function () {
                return 1;
            };
            SingletonSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.item;
            };
            SingletonSyntaxTriviaList.prototype.last = function () {
                return this.item;
            };
            SingletonSyntaxTriviaList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };
            SingletonSyntaxTriviaList.prototype.fullText = function () {
                return this.item.fullText();
            };
            SingletonSyntaxTriviaList.prototype.hasComment = function () {
                return isComment(this.item);
            };
            SingletonSyntaxTriviaList.prototype.hasNewLine = function () {
                return this.item.kind() === TypeScript.SyntaxKind.NewLineTrivia;
            };
            SingletonSyntaxTriviaList.prototype.hasSkippedToken = function () {
                return this.item.kind() === TypeScript.SyntaxKind.SkippedTokenTrivia;
            };
            SingletonSyntaxTriviaList.prototype.toJSON = function (key) {
                return [this.item];
            };
            SingletonSyntaxTriviaList.prototype.collectTextElements = function (elements) {
                this.item.collectTextElements(elements);
            };
            SingletonSyntaxTriviaList.prototype.toArray = function () {
                return [this.item];
            };
            SingletonSyntaxTriviaList.prototype.concat = function (trivia) {
                return concatTrivia(this, trivia);
            };
            return SingletonSyntaxTriviaList;
        }());
        var NormalSyntaxTriviaList = (function () {
            function NormalSyntaxTriviaList(trivia) {
                this.trivia = trivia;
            }
            NormalSyntaxTriviaList.prototype.kind = function () { return TypeScript.SyntaxKind.TriviaList; };
            NormalSyntaxTriviaList.prototype.count = function () {
                return this.trivia.length;
            };
            NormalSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index < 0 || index >= this.trivia.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.trivia[index];
            };
            NormalSyntaxTriviaList.prototype.last = function () {
                return this.trivia[this.trivia.length - 1];
            };
            NormalSyntaxTriviaList.prototype.fullWidth = function () {
                return TypeScript.ArrayUtilities.sum(this.trivia, function (t) { return t.fullWidth(); });
            };
            NormalSyntaxTriviaList.prototype.fullText = function () {
                var result = "";
                for (var i = 0, n = this.trivia.length; i < n; i++) {
                    result += this.trivia[i].fullText();
                }
                return result;
            };
            NormalSyntaxTriviaList.prototype.hasComment = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (isComment(this.trivia[i])) {
                        return true;
                    }
                }
                return false;
            };
            NormalSyntaxTriviaList.prototype.hasNewLine = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === TypeScript.SyntaxKind.NewLineTrivia) {
                        return true;
                    }
                }
                return false;
            };
            NormalSyntaxTriviaList.prototype.hasSkippedToken = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === TypeScript.SyntaxKind.SkippedTokenTrivia) {
                        return true;
                    }
                }
                return false;
            };
            NormalSyntaxTriviaList.prototype.toJSON = function (key) {
                return this.trivia;
            };
            NormalSyntaxTriviaList.prototype.collectTextElements = function (elements) {
                for (var i = 0; i < this.trivia.length; i++) {
                    this.trivia[i].collectTextElements(elements);
                }
            };
            NormalSyntaxTriviaList.prototype.toArray = function () {
                return this.trivia.slice(0);
            };
            NormalSyntaxTriviaList.prototype.concat = function (trivia) {
                return concatTrivia(this, trivia);
            };
            return NormalSyntaxTriviaList;
        }());
        function triviaList(trivia) {
            if (trivia === undefined || trivia === null || trivia.length === 0) {
                return Syntax.emptyTriviaList;
            }
            if (trivia.length === 1) {
                return new SingletonSyntaxTriviaList(trivia[0]);
            }
            return new NormalSyntaxTriviaList(trivia);
        }
        Syntax.triviaList = triviaList;
        Syntax.spaceTriviaList = triviaList([Syntax.spaceTrivia]);
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxUtilities = (function () {
        function SyntaxUtilities() {
        }
        SyntaxUtilities.isAngleBracket = function (positionedElement) {
            var element = positionedElement.element();
            var parent = positionedElement.parentElement();
            if (parent !== null && (element.kind() === TypeScript.SyntaxKind.LessThanToken || element.kind() === TypeScript.SyntaxKind.GreaterThanToken)) {
                switch (parent.kind()) {
                    case TypeScript.SyntaxKind.TypeArgumentList:
                    case TypeScript.SyntaxKind.TypeParameterList:
                    case TypeScript.SyntaxKind.CastExpression:
                        return true;
                }
            }
            return false;
        };
        SyntaxUtilities.getToken = function (list, kind) {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var token = list.childAt(i);
                if (token.tokenKind === kind) {
                    return token;
                }
            }
            return null;
        };
        SyntaxUtilities.containsToken = function (list, kind) {
            return SyntaxUtilities.getToken(list, kind) !== null;
        };
        SyntaxUtilities.hasExportKeyword = function (moduleElement) {
            return SyntaxUtilities.getExportKeyword(moduleElement) !== null;
        };
        SyntaxUtilities.getExportKeyword = function (moduleElement) {
            switch (moduleElement.kind()) {
                case TypeScript.SyntaxKind.ModuleDeclaration:
                case TypeScript.SyntaxKind.ClassDeclaration:
                case TypeScript.SyntaxKind.FunctionDeclaration:
                case TypeScript.SyntaxKind.VariableStatement:
                case TypeScript.SyntaxKind.EnumDeclaration:
                case TypeScript.SyntaxKind.InterfaceDeclaration:
                case TypeScript.SyntaxKind.ImportDeclaration:
                    return SyntaxUtilities.getToken(moduleElement.modifiers, TypeScript.SyntaxKind.ExportKeyword);
                default:
                    return null;
            }
        };
        SyntaxUtilities.isAmbientDeclarationSyntax = function (positionNode) {
            if (!positionNode) {
                return false;
            }
            var node = positionNode.node();
            switch (node.kind()) {
                case TypeScript.SyntaxKind.ModuleDeclaration:
                case TypeScript.SyntaxKind.ClassDeclaration:
                case TypeScript.SyntaxKind.FunctionDeclaration:
                case TypeScript.SyntaxKind.VariableStatement:
                case TypeScript.SyntaxKind.EnumDeclaration:
                    if (SyntaxUtilities.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword)) {
                        return true;
                    }
                case TypeScript.SyntaxKind.ImportDeclaration:
                case TypeScript.SyntaxKind.ConstructorDeclaration:
                case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                case TypeScript.SyntaxKind.GetAccessor:
                case TypeScript.SyntaxKind.SetAccessor:
                case TypeScript.SyntaxKind.MemberVariableDeclaration:
                    if (node.isClassElement() || node.isModuleElement()) {
                        return SyntaxUtilities.isAmbientDeclarationSyntax(positionNode.containingNode());
                    }
                case TypeScript.SyntaxKind.EnumElement:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(positionNode.containingNode().containingNode());
                default:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(positionNode.containingNode());
            }
        };
        return SyntaxUtilities;
    }());
    TypeScript.SyntaxUtilities = SyntaxUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxVisitor = (function () {
        function SyntaxVisitor() {
        }
        SyntaxVisitor.prototype.defaultVisit = function (node) {
            return null;
        };
        SyntaxVisitor.prototype.visitToken = function (token) {
            return this.defaultVisit(token);
        };
        SyntaxVisitor.prototype.visitSourceUnit = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitExternalModuleReference = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitModuleNameModuleReference = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitImportDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitExportAssignment = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitClassDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitInterfaceDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitHeritageClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitModuleDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitFunctionDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitVariableStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitVariableDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitVariableDeclarator = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitEqualsValueClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitArrayLiteralExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitOmittedExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitParenthesizedExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitQualifiedName = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitTypeArgumentList = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitConstructorType = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitFunctionType = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitObjectType = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitArrayType = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitGenericType = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitTypeQuery = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitTypeAnnotation = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitBlock = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitParameter = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitMemberAccessExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitElementAccessExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitInvocationExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitArgumentList = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitBinaryExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitConditionalExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitConstructSignature = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitMethodSignature = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitIndexSignature = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitPropertySignature = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitCallSignature = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitParameterList = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitTypeParameterList = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitTypeParameter = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitConstraint = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitElseClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitIfStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitExpressionStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitConstructorDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitGetAccessor = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitSetAccessor = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitIndexMemberDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitThrowStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitReturnStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitObjectCreationExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitSwitchStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitCaseSwitchClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitDefaultSwitchClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitBreakStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitContinueStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitForStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitForInStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitWhileStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitWithStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitEnumDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitEnumElement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitCastExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitObjectLiteralExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitFunctionPropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitEmptyStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitTryStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitCatchClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitFinallyClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitLabeledStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitDoStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitTypeOfExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitDeleteExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitVoidExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitDebuggerStatement = function (node) {
            return this.defaultVisit(node);
        };
        return SyntaxVisitor;
    }());
    TypeScript.SyntaxVisitor = SyntaxVisitor;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxWalker = (function () {
        function SyntaxWalker() {
        }
        SyntaxWalker.prototype.visitToken = function (token) {
        };
        SyntaxWalker.prototype.visitNode = function (node) {
            node.accept(this);
        };
        SyntaxWalker.prototype.visitNodeOrToken = function (nodeOrToken) {
            if (nodeOrToken.isToken()) {
                this.visitToken(nodeOrToken);
            }
            else {
                this.visitNode(nodeOrToken);
            }
        };
        SyntaxWalker.prototype.visitOptionalToken = function (token) {
            if (token === null) {
                return;
            }
            this.visitToken(token);
        };
        SyntaxWalker.prototype.visitOptionalNode = function (node) {
            if (node === null) {
                return;
            }
            this.visitNode(node);
        };
        SyntaxWalker.prototype.visitOptionalNodeOrToken = function (nodeOrToken) {
            if (nodeOrToken === null) {
                return;
            }
            this.visitNodeOrToken(nodeOrToken);
        };
        SyntaxWalker.prototype.visitList = function (list) {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                this.visitNodeOrToken(list.childAt(i));
            }
        };
        SyntaxWalker.prototype.visitSeparatedList = function (list) {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                this.visitNodeOrToken(item);
            }
        };
        SyntaxWalker.prototype.visitSourceUnit = function (node) {
            this.visitList(node.moduleElements);
            this.visitToken(node.endOfFileToken);
        };
        SyntaxWalker.prototype.visitExternalModuleReference = function (node) {
            this.visitToken(node.requireKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.stringLiteral);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitModuleNameModuleReference = function (node) {
            this.visitNodeOrToken(node.moduleName);
        };
        SyntaxWalker.prototype.visitImportDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.importKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.equalsToken);
            this.visitNodeOrToken(node.moduleReference);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitExportAssignment = function (node) {
            this.visitToken(node.exportKeyword);
            this.visitToken(node.equalsToken);
            this.visitToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitClassDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.classKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitToken(node.openBraceToken);
            this.visitList(node.classElements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitInterfaceDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.interfaceKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitNode(node.body);
        };
        SyntaxWalker.prototype.visitHeritageClause = function (node) {
            this.visitToken(node.extendsOrImplementsKeyword);
            this.visitSeparatedList(node.typeNames);
        };
        SyntaxWalker.prototype.visitModuleDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.moduleKeyword);
            this.visitOptionalNodeOrToken(node.name);
            this.visitOptionalToken(node.stringLiteral);
            this.visitToken(node.openBraceToken);
            this.visitList(node.moduleElements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.functionKeyword);
            this.visitToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitVariableStatement = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclaration);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitVariableDeclaration = function (node) {
            this.visitToken(node.varKeyword);
            this.visitSeparatedList(node.variableDeclarators);
        };
        SyntaxWalker.prototype.visitVariableDeclarator = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };
        SyntaxWalker.prototype.visitEqualsValueClause = function (node) {
            this.visitToken(node.equalsToken);
            this.visitNodeOrToken(node.value);
        };
        SyntaxWalker.prototype.visitPrefixUnaryExpression = function (node) {
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.operand);
        };
        SyntaxWalker.prototype.visitArrayLiteralExpression = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitSeparatedList(node.expressions);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitOmittedExpression = function (node) {
        };
        SyntaxWalker.prototype.visitParenthesizedExpression = function (node) {
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitSimpleArrowFunctionExpression = function (node) {
            this.visitToken(node.identifier);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitOptionalNode(node.block);
            this.visitOptionalNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            this.visitNode(node.callSignature);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitOptionalNode(node.block);
            this.visitOptionalNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitQualifiedName = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.dotToken);
            this.visitToken(node.right);
        };
        SyntaxWalker.prototype.visitTypeArgumentList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeArguments);
            this.visitToken(node.greaterThanToken);
        };
        SyntaxWalker.prototype.visitConstructorType = function (node) {
            this.visitToken(node.newKeyword);
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };
        SyntaxWalker.prototype.visitFunctionType = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };
        SyntaxWalker.prototype.visitObjectType = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.typeMembers);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitArrayType = function (node) {
            this.visitNodeOrToken(node.type);
            this.visitToken(node.openBracketToken);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitGenericType = function (node) {
            this.visitNodeOrToken(node.name);
            this.visitNode(node.typeArgumentList);
        };
        SyntaxWalker.prototype.visitTypeQuery = function (node) {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.name);
        };
        SyntaxWalker.prototype.visitTypeAnnotation = function (node) {
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.type);
        };
        SyntaxWalker.prototype.visitBlock = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitList(node.statements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitParameter = function (node) {
            this.visitOptionalToken(node.dotDotDotToken);
            this.visitList(node.modifiers);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };
        SyntaxWalker.prototype.visitMemberAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.dotToken);
            this.visitToken(node.name);
        };
        SyntaxWalker.prototype.visitPostfixUnaryExpression = function (node) {
            this.visitNodeOrToken(node.operand);
            this.visitToken(node.operatorToken);
        };
        SyntaxWalker.prototype.visitElementAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.openBracketToken);
            this.visitNodeOrToken(node.argumentExpression);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitInvocationExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitNode(node.argumentList);
        };
        SyntaxWalker.prototype.visitArgumentList = function (node) {
            this.visitOptionalNode(node.typeArgumentList);
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.args);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitBinaryExpression = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.right);
        };
        SyntaxWalker.prototype.visitConditionalExpression = function (node) {
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.questionToken);
            this.visitNodeOrToken(node.whenTrue);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.whenFalse);
        };
        SyntaxWalker.prototype.visitConstructSignature = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNode(node.callSignature);
        };
        SyntaxWalker.prototype.visitMethodSignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitNode(node.callSignature);
        };
        SyntaxWalker.prototype.visitIndexSignature = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitNode(node.parameter);
            this.visitToken(node.closeBracketToken);
            this.visitOptionalNode(node.typeAnnotation);
        };
        SyntaxWalker.prototype.visitPropertySignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
        };
        SyntaxWalker.prototype.visitCallSignature = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
        };
        SyntaxWalker.prototype.visitParameterList = function (node) {
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.parameters);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitTypeParameterList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeParameters);
            this.visitToken(node.greaterThanToken);
        };
        SyntaxWalker.prototype.visitTypeParameter = function (node) {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.constraint);
        };
        SyntaxWalker.prototype.visitConstraint = function (node) {
            this.visitToken(node.extendsKeyword);
            this.visitNodeOrToken(node.type);
        };
        SyntaxWalker.prototype.visitElseClause = function (node) {
            this.visitToken(node.elseKeyword);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitIfStatement = function (node) {
            this.visitToken(node.ifKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
            this.visitOptionalNode(node.elseClause);
        };
        SyntaxWalker.prototype.visitExpressionStatement = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitConstructorDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.constructorKeyword);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitGetAccessor = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.getKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitSetAccessor = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.setKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.parameterList);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitMemberVariableDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclarator);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitIndexMemberDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.indexSignature);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitThrowStatement = function (node) {
            this.visitToken(node.throwKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitReturnStatement = function (node) {
            this.visitToken(node.returnKeyword);
            this.visitOptionalNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitObjectCreationExpression = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitOptionalNode(node.argumentList);
        };
        SyntaxWalker.prototype.visitSwitchStatement = function (node) {
            this.visitToken(node.switchKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.openBraceToken);
            this.visitList(node.switchClauses);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitCaseSwitchClause = function (node) {
            this.visitToken(node.caseKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };
        SyntaxWalker.prototype.visitDefaultSwitchClause = function (node) {
            this.visitToken(node.defaultKeyword);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };
        SyntaxWalker.prototype.visitBreakStatement = function (node) {
            this.visitToken(node.breakKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitContinueStatement = function (node) {
            this.visitToken(node.continueKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitForStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.initializer);
            this.visitToken(node.firstSemicolonToken);
            this.visitOptionalNodeOrToken(node.condition);
            this.visitToken(node.secondSemicolonToken);
            this.visitOptionalNodeOrToken(node.incrementor);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitForInStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.left);
            this.visitToken(node.inKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitWhileStatement = function (node) {
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitWithStatement = function (node) {
            this.visitToken(node.withKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitEnumDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.enumKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.enumElements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitEnumElement = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalNode(node.equalsValueClause);
        };
        SyntaxWalker.prototype.visitCastExpression = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitNodeOrToken(node.type);
            this.visitToken(node.greaterThanToken);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitObjectLiteralExpression = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.propertyAssignments);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitSimplePropertyAssignment = function (node) {
            this.visitToken(node.propertyName);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitFunctionPropertyAssignment = function (node) {
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitFunctionExpression = function (node) {
            this.visitToken(node.functionKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitEmptyStatement = function (node) {
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitTryStatement = function (node) {
            this.visitToken(node.tryKeyword);
            this.visitNode(node.block);
            this.visitOptionalNode(node.catchClause);
            this.visitOptionalNode(node.finallyClause);
        };
        SyntaxWalker.prototype.visitCatchClause = function (node) {
            this.visitToken(node.catchKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitFinallyClause = function (node) {
            this.visitToken(node.finallyKeyword);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitLabeledStatement = function (node) {
            this.visitToken(node.identifier);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitDoStatement = function (node) {
            this.visitToken(node.doKeyword);
            this.visitNodeOrToken(node.statement);
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitTypeOfExpression = function (node) {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitDeleteExpression = function (node) {
            this.visitToken(node.deleteKeyword);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitVoidExpression = function (node) {
            this.visitToken(node.voidKeyword);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitDebuggerStatement = function (node) {
            this.visitToken(node.debuggerKeyword);
            this.visitToken(node.semicolonToken);
        };
        return SyntaxWalker;
    }());
    TypeScript.SyntaxWalker = SyntaxWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PositionTrackingWalker = (function (_super) {
        __extends(PositionTrackingWalker, _super);
        function PositionTrackingWalker() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._position = 0;
            return _this;
        }
        PositionTrackingWalker.prototype.visitToken = function (token) {
            this._position += token.fullWidth();
        };
        PositionTrackingWalker.prototype.position = function () {
            return this._position;
        };
        PositionTrackingWalker.prototype.skip = function (element) {
            this._position += element.fullWidth();
        };
        return PositionTrackingWalker;
    }(TypeScript.SyntaxWalker));
    TypeScript.PositionTrackingWalker = PositionTrackingWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxInformationMap = (function (_super) {
        __extends(SyntaxInformationMap, _super);
        function SyntaxInformationMap(trackParents, trackPreviousToken) {
            var _this = _super.call(this) || this;
            _this.trackParents = trackParents;
            _this.trackPreviousToken = trackPreviousToken;
            _this.tokenToInformation = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            _this.elementToPosition = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            _this._previousToken = null;
            _this._previousTokenInformation = null;
            _this._currentPosition = 0;
            _this._elementToParent = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            _this._parentStack = [];
            _this._parentStack.push(null);
            return _this;
        }
        SyntaxInformationMap.create = function (node, trackParents, trackPreviousToken) {
            var map = new SyntaxInformationMap(trackParents, trackPreviousToken);
            map.visitNode(node);
            return map;
        };
        SyntaxInformationMap.prototype.visitNode = function (node) {
            this.trackParents && this._elementToParent.add(node, TypeScript.ArrayUtilities.last(this._parentStack));
            this.elementToPosition.add(node, this._currentPosition);
            this.trackParents && this._parentStack.push(node);
            _super.prototype.visitNode.call(this, node);
            this.trackParents && this._parentStack.pop();
        };
        SyntaxInformationMap.prototype.visitToken = function (token) {
            this.trackParents && this._elementToParent.add(token, TypeScript.ArrayUtilities.last(this._parentStack));
            if (this.trackPreviousToken) {
                var tokenInformation = {
                    previousToken: this._previousToken,
                    nextToken: null
                };
                if (this._previousTokenInformation !== null) {
                    this._previousTokenInformation.nextToken = token;
                }
                this._previousToken = token;
                this._previousTokenInformation = tokenInformation;
                this.tokenToInformation.add(token, tokenInformation);
            }
            this.elementToPosition.add(token, this._currentPosition);
            this._currentPosition += token.fullWidth();
        };
        SyntaxInformationMap.prototype.parent = function (element) {
            return this._elementToParent.get(element);
        };
        SyntaxInformationMap.prototype.fullStart = function (element) {
            return this.elementToPosition.get(element);
        };
        SyntaxInformationMap.prototype.start = function (element) {
            return this.fullStart(element) + element.leadingTriviaWidth();
        };
        SyntaxInformationMap.prototype.end = function (element) {
            return this.start(element) + element.width();
        };
        SyntaxInformationMap.prototype.previousToken = function (token) {
            return this.tokenInformation(token).previousToken;
        };
        SyntaxInformationMap.prototype.tokenInformation = function (token) {
            return this.tokenToInformation.get(token);
        };
        SyntaxInformationMap.prototype.firstTokenInLineContainingToken = function (token) {
            var current = token;
            while (true) {
                var information = this.tokenInformation(current);
                if (this.isFirstTokenInLineWorker(information)) {
                    break;
                }
                current = information.previousToken;
            }
            return current;
        };
        SyntaxInformationMap.prototype.isFirstTokenInLine = function (token) {
            var information = this.tokenInformation(token);
            return this.isFirstTokenInLineWorker(information);
        };
        SyntaxInformationMap.prototype.isFirstTokenInLineWorker = function (information) {
            return information.previousToken === null || information.previousToken.hasTrailingNewLine();
        };
        return SyntaxInformationMap;
    }(TypeScript.SyntaxWalker));
    TypeScript.SyntaxInformationMap = SyntaxInformationMap;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxNodeInvariantsChecker = (function (_super) {
        __extends(SyntaxNodeInvariantsChecker, _super);
        function SyntaxNodeInvariantsChecker() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.tokenTable = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            return _this;
        }
        SyntaxNodeInvariantsChecker.checkInvariants = function (node) {
            node.accept(new SyntaxNodeInvariantsChecker());
        };
        SyntaxNodeInvariantsChecker.prototype.visitToken = function (token) {
            this.tokenTable.add(token, token);
        };
        return SyntaxNodeInvariantsChecker;
    }(TypeScript.SyntaxWalker));
    TypeScript.SyntaxNodeInvariantsChecker = SyntaxNodeInvariantsChecker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DepthLimitedWalker = (function (_super) {
        __extends(DepthLimitedWalker, _super);
        function DepthLimitedWalker(maximumDepth) {
            var _this = _super.call(this) || this;
            _this._depth = 0;
            _this._maximumDepth = 0;
            _this._maximumDepth = maximumDepth;
            return _this;
        }
        DepthLimitedWalker.prototype.visitNode = function (node) {
            if (this._depth < this._maximumDepth) {
                this._depth++;
                _super.prototype.visitNode.call(this, node);
                this._depth--;
            }
            else {
                this.skip(node);
            }
        };
        return DepthLimitedWalker;
    }(TypeScript.PositionTrackingWalker));
    TypeScript.DepthLimitedWalker = DepthLimitedWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxTree = (function () {
        function SyntaxTree(sourceUnit, isDeclaration, diagnostics, fileName, lineMap, parseOtions) {
            this._allDiagnostics = null;
            this._sourceUnit = sourceUnit;
            this._isDeclaration = isDeclaration;
            this._parserDiagnostics = diagnostics;
            this._fileName = fileName;
            this._lineMap = lineMap;
            this._parseOptions = parseOtions;
        }
        SyntaxTree.prototype.toJSON = function (key) {
            var result = {};
            result.isDeclaration = this._isDeclaration;
            result.languageVersion = TypeScript.LanguageVersion[this._parseOptions.languageVersion()];
            result.parseOptions = this._parseOptions;
            if (this.diagnostics().length > 0) {
                result.diagnostics = this.diagnostics();
            }
            result.sourceUnit = this._sourceUnit;
            result.lineMap = this._lineMap;
            return result;
        };
        SyntaxTree.prototype.sourceUnit = function () {
            return this._sourceUnit;
        };
        SyntaxTree.prototype.isDeclaration = function () {
            return this._isDeclaration;
        };
        SyntaxTree.prototype.computeDiagnostics = function () {
            if (this._parserDiagnostics.length > 0) {
                return this._parserDiagnostics;
            }
            var diagnostics = [];
            this.sourceUnit().accept(new GrammarCheckerWalker(this, diagnostics));
            return diagnostics;
        };
        SyntaxTree.prototype.diagnostics = function () {
            if (this._allDiagnostics === null) {
                this._allDiagnostics = this.computeDiagnostics();
            }
            return this._allDiagnostics;
        };
        SyntaxTree.prototype.fileName = function () {
            return this._fileName;
        };
        SyntaxTree.prototype.lineMap = function () {
            return this._lineMap;
        };
        SyntaxTree.prototype.parseOptions = function () {
            return this._parseOptions;
        };
        SyntaxTree.prototype.structuralEquals = function (tree) {
            return TypeScript.ArrayUtilities.sequenceEquals(this.diagnostics(), tree.diagnostics(), function (d1, d2) { return TypeScript.Diagnostic.equals(d1, d2); }) &&
                this.sourceUnit().structuralEquals(tree.sourceUnit());
        };
        return SyntaxTree;
    }());
    TypeScript.SyntaxTree = SyntaxTree;
    var GrammarCheckerWalker = (function (_super) {
        __extends(GrammarCheckerWalker, _super);
        function GrammarCheckerWalker(syntaxTree, diagnostics) {
            var _this = _super.call(this) || this;
            _this.syntaxTree = syntaxTree;
            _this.diagnostics = diagnostics;
            _this.inAmbientDeclaration = false;
            _this.inBlock = false;
            _this.inObjectLiteralExpression = false;
            _this.currentConstructor = null;
            return _this;
        }
        GrammarCheckerWalker.prototype.childFullStart = function (parent, child) {
            return this.position() + TypeScript.Syntax.childOffset(parent, child);
        };
        GrammarCheckerWalker.prototype.childStart = function (parent, child) {
            return this.childFullStart(parent, child) + child.leadingTriviaWidth();
        };
        GrammarCheckerWalker.prototype.pushDiagnostic = function (start, length, diagnosticKey, args) {
            if (args === void 0) { args = null; }
            this.diagnostics.push(new TypeScript.Diagnostic(this.syntaxTree.fileName(), this.syntaxTree.lineMap(), start, length, diagnosticKey, args));
        };
        GrammarCheckerWalker.prototype.pushDiagnostic1 = function (elementFullStart, element, diagnosticKey, args) {
            if (args === void 0) { args = null; }
            this.diagnostics.push(new TypeScript.Diagnostic(this.syntaxTree.fileName(), this.syntaxTree.lineMap(), elementFullStart + element.leadingTriviaWidth(), element.width(), diagnosticKey, args));
        };
        GrammarCheckerWalker.prototype.visitCatchClause = function (node) {
            if (node.typeAnnotation) {
                this.pushDiagnostic(this.childStart(node, node.typeAnnotation), node.typeAnnotation.width(), TypeScript.DiagnosticCode.Catch_clause_parameter_cannot_have_a_type_annotation);
            }
            _super.prototype.visitCatchClause.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkParameterListOrder = function (node) {
            var parameterFullStart = this.childFullStart(node, node.parameters);
            var seenOptionalParameter = false;
            var parameterCount = node.parameters.nonSeparatorCount();
            for (var i = 0, n = node.parameters.childCount(); i < n; i++) {
                var nodeOrToken = node.parameters.childAt(i);
                if (i % 2 === 0) {
                    var parameterIndex = i / 2;
                    var parameter = node.parameters.childAt(i);
                    if (parameter.dotDotDotToken) {
                        if (parameterIndex !== (parameterCount - 1)) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Rest_parameter_must_be_last_in_list);
                            return true;
                        }
                        if (parameter.questionToken) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Rest_parameter_cannot_be_optional);
                            return true;
                        }
                        if (parameter.equalsValueClause) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Rest_parameter_cannot_have_an_initializer);
                            return true;
                        }
                    }
                    else if (parameter.questionToken || parameter.equalsValueClause) {
                        seenOptionalParameter = true;
                        if (parameter.questionToken && parameter.equalsValueClause) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer);
                            return true;
                        }
                    }
                    else {
                        if (seenOptionalParameter) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Required_parameter_cannot_follow_optional_parameter);
                            return true;
                        }
                    }
                }
                parameterFullStart += nodeOrToken.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkParameterListAcessibilityModifiers = function (node) {
            var parameterFullStart = this.childFullStart(node, node.parameters);
            for (var i = 0, n = node.parameters.childCount(); i < n; i++) {
                var nodeOrToken = node.parameters.childAt(i);
                if (i % 2 === 0) {
                    var parameter = node.parameters.childAt(i);
                    if (this.checkParameterAccessibilityModifiers(node, parameter, parameterFullStart)) {
                        return true;
                    }
                }
                parameterFullStart += nodeOrToken.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkParameterAccessibilityModifiers = function (parameterList, parameter, parameterFullStart) {
            if (parameter.modifiers.childCount() > 0) {
                var modifiers = parameter.modifiers;
                var modifierFullStart = parameterFullStart + TypeScript.Syntax.childOffset(parameter, modifiers);
                for (var i = 0, n = modifiers.childCount(); i < n; i++) {
                    var modifier = modifiers.childAt(i);
                    if (this.checkParameterAccessibilityModifier(parameterList, modifier, modifierFullStart, i)) {
                        return true;
                    }
                    modifierFullStart += modifier.fullWidth();
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkParameterAccessibilityModifier = function (parameterList, modifier, modifierFullStart, modifierIndex) {
            if (modifier.tokenKind !== TypeScript.SyntaxKind.PublicKeyword && modifier.tokenKind !== TypeScript.SyntaxKind.PrivateKeyword) {
                this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_parameter, [modifier.text()]);
                return true;
            }
            else {
                if (modifierIndex > 0) {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                    return true;
                }
                if (this.inAmbientDeclaration) {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.Parameter_property_declarations_cannot_be_used_in_an_ambient_context);
                    return true;
                }
                else if (this.currentConstructor && !this.currentConstructor.block && this.currentConstructor.parameterList === parameterList) {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.Parameter_property_declarations_cannot_be_used_in_a_constructor_overload);
                    return true;
                }
                else if (this.currentConstructor === null || this.currentConstructor.parameterList !== parameterList) {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.Parameter_property_declarations_can_only_be_used_in_constructors);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForTrailingSeparator = function (parent, list) {
            if (list.childCount() === 0 || list.childCount() % 2 === 1) {
                return false;
            }
            var currentElementFullStart = this.childFullStart(parent, list);
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var child = list.childAt(i);
                if (i === n - 1) {
                    this.pushDiagnostic1(currentElementFullStart, child, TypeScript.DiagnosticCode.Trailing_separator_not_allowed);
                }
                currentElementFullStart += child.fullWidth();
            }
            return true;
        };
        GrammarCheckerWalker.prototype.checkForAtLeastOneElement = function (parent, list, expected) {
            if (list.childCount() > 0) {
                return false;
            }
            var listFullStart = this.childFullStart(parent, list);
            var tokenAtStart = this.syntaxTree.sourceUnit().findToken(listFullStart);
            this.pushDiagnostic1(listFullStart, tokenAtStart.token(), TypeScript.DiagnosticCode.Unexpected_token_0_expected, [expected]);
            return true;
        };
        GrammarCheckerWalker.prototype.visitParameterList = function (node) {
            if (this.checkParameterListAcessibilityModifiers(node) ||
                this.checkParameterListOrder(node) ||
                this.checkForTrailingSeparator(node, node.parameters)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitParameterList.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitHeritageClause = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeNames) ||
                this.checkForAtLeastOneElement(node, node.typeNames, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_name, null))) {
                this.skip(node);
                return;
            }
            _super.prototype.visitHeritageClause.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitArgumentList = function (node) {
            if (this.checkForTrailingSeparator(node, node.args)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitArgumentList.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitVariableDeclaration = function (node) {
            if (this.checkForTrailingSeparator(node, node.variableDeclarators) ||
                this.checkForAtLeastOneElement(node, node.variableDeclarators, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null))) {
                this.skip(node);
                return;
            }
            _super.prototype.visitVariableDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTypeArgumentList = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeArguments) ||
                this.checkForAtLeastOneElement(node, node.typeArguments, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null))) {
                this.skip(node);
                return;
            }
            _super.prototype.visitTypeArgumentList.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTypeParameterList = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeParameters) ||
                this.checkForAtLeastOneElement(node, node.typeParameters, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null))) {
                this.skip(node);
                return;
            }
            _super.prototype.visitTypeParameterList.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkIndexSignatureParameter = function (node) {
            var parameterFullStart = this.childFullStart(node, node.parameter);
            var parameter = node.parameter;
            if (parameter.dotDotDotToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signatures_cannot_have_rest_parameters);
                return true;
            }
            else if (parameter.modifiers.childCount() > 0) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_accessibility_modifiers);
                return true;
            }
            else if (parameter.questionToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_a_question_mark);
                return true;
            }
            else if (parameter.equalsValueClause) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_an_initializer);
                return true;
            }
            else if (!parameter.typeAnnotation) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_must_have_a_type_annotation);
                return true;
            }
            else if (parameter.typeAnnotation.type.kind() !== TypeScript.SyntaxKind.StringKeyword &&
                parameter.typeAnnotation.type.kind() !== TypeScript.SyntaxKind.NumberKeyword) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_type_must_be_string_or_number);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitIndexSignature = function (node) {
            if (this.checkIndexSignatureParameter(node)) {
                this.skip(node);
                return;
            }
            if (!node.typeAnnotation) {
                this.pushDiagnostic1(this.position(), node, TypeScript.DiagnosticCode.Index_signature_must_have_a_type_annotation);
                this.skip(node);
                return;
            }
            _super.prototype.visitIndexSignature.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkClassDeclarationHeritageClauses = function (node) {
            var heritageClauseFullStart = this.childFullStart(node, node.heritageClauses);
            var seenExtendsClause = false;
            var seenImplementsClause = false;
            for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                TypeScript.Debug.assert(i <= 2);
                var heritageClause = node.heritageClauses.childAt(i);
                if (heritageClause.extendsOrImplementsKeyword.tokenKind === TypeScript.SyntaxKind.ExtendsKeyword) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }
                    if (seenImplementsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.extends_clause_must_precede_implements_clause);
                        return true;
                    }
                    if (heritageClause.typeNames.nonSeparatorCount() > 1) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.Classes_can_only_extend_a_single_class);
                        return true;
                    }
                    seenExtendsClause = true;
                }
                else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.tokenKind === TypeScript.SyntaxKind.ImplementsKeyword);
                    if (seenImplementsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.implements_clause_already_seen);
                        return true;
                    }
                    seenImplementsClause = true;
                }
                heritageClauseFullStart += heritageClause.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifier = function (modifiers) {
            if (this.inAmbientDeclaration) {
                var declareToken = TypeScript.SyntaxUtilities.getToken(modifiers, TypeScript.SyntaxKind.DeclareKeyword);
                if (declareToken) {
                    this.pushDiagnostic1(this.childFullStart(modifiers, declareToken), declareToken, TypeScript.DiagnosticCode.declare_modifier_not_allowed_for_code_already_in_an_ambient_context);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForRequiredDeclareModifier = function (moduleElement, typeKeyword, modifiers) {
            if (!this.inAmbientDeclaration && this.syntaxTree.isDeclaration()) {
                if (!TypeScript.SyntaxUtilities.containsToken(modifiers, TypeScript.SyntaxKind.DeclareKeyword)) {
                    this.pushDiagnostic1(this.childFullStart(moduleElement, typeKeyword), typeKeyword.firstToken(), TypeScript.DiagnosticCode.declare_modifier_required_for_top_level_element);
                    return true;
                }
            }
        };
        GrammarCheckerWalker.prototype.checkFunctionOverloads = function (node, moduleElements) {
            if (!this.inAmbientDeclaration && !this.syntaxTree.isDeclaration()) {
                var moduleElementFullStart = this.childFullStart(node, moduleElements);
                var inFunctionOverloadChain = false;
                var functionOverloadChainName = null;
                var functionDeclaration;
                for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                    var moduleElement = moduleElements.childAt(i);
                    var lastElement = i === (n - 1);
                    if (inFunctionOverloadChain) {
                        if (moduleElement.kind() !== TypeScript.SyntaxKind.FunctionDeclaration) {
                            this.pushDiagnostic1(moduleElementFullStart, moduleElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return true;
                        }
                        functionDeclaration = moduleElement;
                        if (functionDeclaration.identifier.valueText() !== functionOverloadChainName) {
                            var identifierFullStart = moduleElementFullStart + TypeScript.Syntax.childOffset(moduleElement, functionDeclaration.identifier);
                            this.pushDiagnostic1(identifierFullStart, functionDeclaration.identifier, TypeScript.DiagnosticCode.Function_overload_name_must_be_0, [functionOverloadChainName]);
                            return true;
                        }
                    }
                    if (moduleElement.kind() === TypeScript.SyntaxKind.FunctionDeclaration) {
                        functionDeclaration = moduleElement;
                        if (!TypeScript.SyntaxUtilities.containsToken(functionDeclaration.modifiers, TypeScript.SyntaxKind.DeclareKeyword)) {
                            inFunctionOverloadChain = functionDeclaration.block === null;
                            functionOverloadChainName = functionDeclaration.identifier.valueText();
                            if (lastElement && inFunctionOverloadChain) {
                                this.pushDiagnostic1(moduleElementFullStart, moduleElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                                return true;
                            }
                        }
                        else {
                            inFunctionOverloadChain = false;
                            functionOverloadChainName = "";
                        }
                    }
                    moduleElementFullStart += moduleElement.fullWidth();
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkClassOverloads = function (node) {
            if (!this.inAmbientDeclaration && !TypeScript.SyntaxUtilities.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword)) {
                var classElementFullStart = this.childFullStart(node, node.classElements);
                var inFunctionOverloadChain = false;
                var inConstructorOverloadChain = false;
                var functionOverloadChainName = null;
                var isInStaticOverloadChain = null;
                var memberFunctionDeclaration = null;
                for (var i = 0, n = node.classElements.childCount(); i < n; i++) {
                    var classElement = node.classElements.childAt(i);
                    var lastElement = i === (n - 1);
                    var isStaticOverload = null;
                    if (inFunctionOverloadChain) {
                        if (classElement.kind() !== TypeScript.SyntaxKind.MemberFunctionDeclaration) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return true;
                        }
                        var propertyNameFullStart;
                        memberFunctionDeclaration = classElement;
                        if (memberFunctionDeclaration.propertyName.valueText() !== functionOverloadChainName) {
                            propertyNameFullStart = classElementFullStart + TypeScript.Syntax.childOffset(classElement, memberFunctionDeclaration.propertyName);
                            this.pushDiagnostic1(propertyNameFullStart, memberFunctionDeclaration.propertyName, TypeScript.DiagnosticCode.Function_overload_name_must_be_0, [functionOverloadChainName]);
                            return true;
                        }
                        isStaticOverload = TypeScript.SyntaxUtilities.containsToken(memberFunctionDeclaration.modifiers, TypeScript.SyntaxKind.StaticKeyword);
                        if (isStaticOverload !== isInStaticOverloadChain) {
                            propertyNameFullStart = classElementFullStart + TypeScript.Syntax.childOffset(classElement, memberFunctionDeclaration.propertyName);
                            var diagnostic = isInStaticOverloadChain ? TypeScript.DiagnosticCode.Function_overload_must_be_static : TypeScript.DiagnosticCode.Function_overload_must_not_be_static;
                            this.pushDiagnostic1(propertyNameFullStart, memberFunctionDeclaration.propertyName, diagnostic, null);
                            return true;
                        }
                    }
                    else if (inConstructorOverloadChain) {
                        if (classElement.kind() !== TypeScript.SyntaxKind.ConstructorDeclaration) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Constructor_implementation_expected);
                            return true;
                        }
                    }
                    if (classElement.kind() === TypeScript.SyntaxKind.MemberFunctionDeclaration) {
                        memberFunctionDeclaration = classElement;
                        inFunctionOverloadChain = memberFunctionDeclaration.block === null;
                        functionOverloadChainName = memberFunctionDeclaration.propertyName.valueText();
                        isInStaticOverloadChain = TypeScript.SyntaxUtilities.containsToken(memberFunctionDeclaration.modifiers, TypeScript.SyntaxKind.StaticKeyword);
                        if (lastElement && inFunctionOverloadChain) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return true;
                        }
                    }
                    else if (classElement.kind() === TypeScript.SyntaxKind.ConstructorDeclaration) {
                        var constructorDeclaration = classElement;
                        inConstructorOverloadChain = constructorDeclaration.block === null;
                        if (lastElement && inConstructorOverloadChain) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Constructor_implementation_expected);
                            return true;
                        }
                    }
                    classElementFullStart += classElement.fullWidth();
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForReservedName = function (parent, name, diagnosticKey) {
            var nameFullStart = this.childFullStart(parent, name);
            var token;
            var tokenFullStart;
            var current = name;
            while (current !== null) {
                if (current.kind() === TypeScript.SyntaxKind.QualifiedName) {
                    var qualifiedName = current;
                    token = qualifiedName.right;
                    tokenFullStart = nameFullStart + this.childFullStart(qualifiedName, token);
                    current = qualifiedName.left;
                }
                else {
                    TypeScript.Debug.assert(current.kind() === TypeScript.SyntaxKind.IdentifierName);
                    token = current;
                    tokenFullStart = nameFullStart;
                    current = null;
                }
                switch (token.valueText()) {
                    case "any":
                    case "number":
                    case "boolean":
                    case "string":
                    case "void":
                        this.pushDiagnostic(tokenFullStart + token.leadingTriviaWidth(), token.width(), diagnosticKey, [token.valueText()]);
                        return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitClassDeclaration = function (node) {
            if (this.checkForReservedName(node, node.identifier, TypeScript.DiagnosticCode.Class_name_cannot_be_0) ||
                this.checkForDisallowedDeclareModifier(node.modifiers) ||
                this.checkForRequiredDeclareModifier(node, node.classKeyword, node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers) ||
                this.checkClassDeclarationHeritageClauses(node) ||
                this.checkClassOverloads(node)) {
                this.skip(node);
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword);
            _super.prototype.visitClassDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkInterfaceDeclarationHeritageClauses = function (node) {
            var heritageClauseFullStart = this.childFullStart(node, node.heritageClauses);
            var seenExtendsClause = false;
            for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                TypeScript.Debug.assert(i <= 1);
                var heritageClause = node.heritageClauses.childAt(i);
                if (heritageClause.extendsOrImplementsKeyword.tokenKind === TypeScript.SyntaxKind.ExtendsKeyword) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }
                    seenExtendsClause = true;
                }
                else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.tokenKind === TypeScript.SyntaxKind.ImplementsKeyword);
                    this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.Interface_declaration_cannot_have_implements_clause);
                    return true;
                }
                heritageClauseFullStart += heritageClause.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkInterfaceModifiers = function (modifiers) {
            var modifierFullStart = this.position();
            for (var i = 0, n = modifiers.childCount(); i < n; i++) {
                var modifier = modifiers.childAt(i);
                if (modifier.tokenKind === TypeScript.SyntaxKind.DeclareKeyword) {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.declare_modifier_cannot_appear_on_an_interface_declaration);
                    return true;
                }
                modifierFullStart += modifier.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitInterfaceDeclaration = function (node) {
            if (this.checkForReservedName(node, node.identifier, TypeScript.DiagnosticCode.Interface_name_cannot_be_0) ||
                this.checkInterfaceModifiers(node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers) ||
                this.checkInterfaceDeclarationHeritageClauses(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitInterfaceDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkClassElementModifiers = function (list) {
            var modifierFullStart = this.position();
            var seenAccessibilityModifier = false;
            var seenStaticModifier = false;
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var modifier = list.childAt(i);
                if (modifier.tokenKind === TypeScript.SyntaxKind.PublicKeyword ||
                    modifier.tokenKind === TypeScript.SyntaxKind.PrivateKeyword) {
                    if (seenAccessibilityModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return true;
                    }
                    if (seenStaticModifier) {
                        var previousToken = list.childAt(i - 1);
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_must_precede_1_modifier, [modifier.text(), previousToken.text()]);
                        return true;
                    }
                    seenAccessibilityModifier = true;
                }
                else if (modifier.tokenKind === TypeScript.SyntaxKind.StaticKeyword) {
                    if (seenStaticModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return true;
                    }
                    seenStaticModifier = true;
                }
                else {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_class_element, [modifier.text()]);
                    return true;
                }
                modifierFullStart += modifier.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitMemberVariableDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitMemberVariableDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitMemberFunctionDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkGetAccessorParameter = function (node, getKeyword, parameterList) {
            var getKeywordFullStart = this.childFullStart(node, getKeyword);
            if (parameterList.parameters.childCount() !== 0) {
                this.pushDiagnostic1(getKeywordFullStart, getKeyword, TypeScript.DiagnosticCode.get_accessor_cannot_have_parameters);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitIndexMemberDeclaration = function (node) {
            if (this.checkIndexMemberModifiers(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitIndexMemberDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkIndexMemberModifiers = function (node) {
            if (node.modifiers.childCount() > 0) {
                var modifierFullStart = this.childFullStart(node, node.modifiers);
                this.pushDiagnostic1(modifierFullStart, node.modifiers.childAt(0), TypeScript.DiagnosticCode.Modifiers_cannot_appear_here);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkEcmaScriptVersionIsAtLeast = function (parent, node, languageVersion, diagnosticKey) {
            if (this.syntaxTree.parseOptions().languageVersion() < languageVersion) {
                var nodeFullStart = this.childFullStart(parent, node);
                this.pushDiagnostic1(nodeFullStart, node, diagnosticKey);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitObjectLiteralExpression = function (node) {
            var savedInObjectLiteralExpression = this.inObjectLiteralExpression;
            this.inObjectLiteralExpression = true;
            _super.prototype.visitObjectLiteralExpression.call(this, node);
            this.inObjectLiteralExpression = savedInObjectLiteralExpression;
        };
        GrammarCheckerWalker.prototype.visitGetAccessor = function (node) {
            if (this.checkForAccessorDeclarationInAmbientContext(node) ||
                this.checkEcmaScriptVersionIsAtLeast(node, node.getKeyword, TypeScript.LanguageVersion.EcmaScript5, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) ||
                this.checkForDisallowedModifiers(node, node.modifiers) ||
                this.checkClassElementModifiers(node.modifiers) ||
                this.checkGetAccessorParameter(node, node.getKeyword, node.parameterList)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitGetAccessor.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForAccessorDeclarationInAmbientContext = function (accessor) {
            if (this.inAmbientDeclaration) {
                this.pushDiagnostic1(this.position(), accessor, TypeScript.DiagnosticCode.Accessors_are_not_allowed_in_ambient_contexts, null);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkSetAccessorParameter = function (node, setKeyword, parameterList) {
            var setKeywordFullStart = this.childFullStart(node, setKeyword);
            if (parameterList.parameters.childCount() !== 1) {
                this.pushDiagnostic1(setKeywordFullStart, setKeyword, TypeScript.DiagnosticCode.set_accessor_must_have_one_and_only_one_parameter);
                return true;
            }
            var parameterListFullStart = this.childFullStart(node, parameterList);
            var parameterFullStart = parameterListFullStart + TypeScript.Syntax.childOffset(parameterList, parameterList.openParenToken);
            var parameter = parameterList.parameters.childAt(0);
            if (parameter.questionToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_be_optional);
                return true;
            }
            if (parameter.equalsValueClause) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_have_an_initializer);
                return true;
            }
            if (parameter.dotDotDotToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.set_accessor_cannot_have_rest_parameter);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitSetAccessor = function (node) {
            if (this.checkForAccessorDeclarationInAmbientContext(node) ||
                this.checkEcmaScriptVersionIsAtLeast(node, node.setKeyword, TypeScript.LanguageVersion.EcmaScript5, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) ||
                this.checkForDisallowedModifiers(node, node.modifiers) ||
                this.checkClassElementModifiers(node.modifiers) ||
                this.checkSetAccessorParameter(node, node.setKeyword, node.parameterList)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitSetAccessor.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitEnumDeclaration = function (node) {
            if (this.checkForReservedName(node, node.identifier, TypeScript.DiagnosticCode.Enum_name_cannot_be_0) ||
                this.checkForDisallowedDeclareModifier(node.modifiers) ||
                this.checkForRequiredDeclareModifier(node, node.enumKeyword, node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers),
                this.checkEnumElements(node)) {
                this.skip(node);
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword);
            _super.prototype.visitEnumDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkEnumElements = function (node) {
            var enumElementFullStart = this.childFullStart(node, node.enumElements);
            var seenComputedValue = false;
            for (var i = 0, n = node.enumElements.childCount(); i < n; i++) {
                var child = node.enumElements.childAt(i);
                if (i % 2 === 0) {
                    var enumElement = child;
                    if (!enumElement.equalsValueClause && seenComputedValue) {
                        this.pushDiagnostic1(enumElementFullStart, enumElement, TypeScript.DiagnosticCode.Enum_member_must_have_initializer, null);
                        return true;
                    }
                    if (enumElement.equalsValueClause) {
                        var value = enumElement.equalsValueClause.value;
                        if (!TypeScript.Syntax.isIntegerLiteral(value)) {
                            seenComputedValue = true;
                        }
                    }
                }
                enumElementFullStart += child.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitEnumElement = function (node) {
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                var expression = node.equalsValueClause.value;
                if (!TypeScript.Syntax.isIntegerLiteral(expression)) {
                    this.pushDiagnostic1(this.childFullStart(node, node.equalsValueClause), node.equalsValueClause.firstToken(), TypeScript.DiagnosticCode.Ambient_enum_elements_can_only_have_integer_literal_initializers);
                    this.skip(node);
                    return;
                }
            }
            _super.prototype.visitEnumElement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitInvocationExpression = function (node) {
            if (node.expression.kind() === TypeScript.SyntaxKind.SuperKeyword &&
                node.argumentList.typeArgumentList !== null) {
                this.pushDiagnostic1(this.position(), node, TypeScript.DiagnosticCode.super_invocation_cannot_have_type_arguments);
            }
            _super.prototype.visitInvocationExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkModuleElementModifiers = function (modifiers) {
            var modifierFullStart = this.position();
            var seenExportModifier = false;
            var seenDeclareModifier = false;
            for (var i = 0, n = modifiers.childCount(); i < n; i++) {
                var modifier = modifiers.childAt(i);
                if (modifier.tokenKind === TypeScript.SyntaxKind.PublicKeyword ||
                    modifier.tokenKind === TypeScript.SyntaxKind.PrivateKeyword ||
                    modifier.tokenKind === TypeScript.SyntaxKind.StaticKeyword) {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_module_element, [modifier.text()]);
                    return true;
                }
                if (modifier.tokenKind === TypeScript.SyntaxKind.DeclareKeyword) {
                    if (seenDeclareModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return;
                    }
                    seenDeclareModifier = true;
                }
                else if (modifier.tokenKind === TypeScript.SyntaxKind.ExportKeyword) {
                    if (seenExportModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return;
                    }
                    if (seenDeclareModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_must_precede_1_modifier, [TypeScript.SyntaxFacts.getText(TypeScript.SyntaxKind.ExportKeyword), TypeScript.SyntaxFacts.getText(TypeScript.SyntaxKind.DeclareKeyword)]);
                        return;
                    }
                    seenExportModifier = true;
                }
                modifierFullStart += modifier.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedImportDeclaration = function (node) {
            var currentElementFullStart = this.childFullStart(node, node.moduleElements);
            for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var child = node.moduleElements.childAt(i);
                if (child.kind() === TypeScript.SyntaxKind.ImportDeclaration) {
                    var importDeclaration = child;
                    if (importDeclaration.moduleReference.kind() === TypeScript.SyntaxKind.ExternalModuleReference) {
                        if (node.stringLiteral === null) {
                            this.pushDiagnostic1(currentElementFullStart, importDeclaration, TypeScript.DiagnosticCode.Import_declarations_in_an_internal_module_cannot_reference_an_external_module, null);
                        }
                    }
                }
                currentElementFullStart += child.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifierOnImportDeclaration = function (modifiers) {
            var declareToken = TypeScript.SyntaxUtilities.getToken(modifiers, TypeScript.SyntaxKind.DeclareKeyword);
            if (declareToken) {
                this.pushDiagnostic1(this.childFullStart(modifiers, declareToken), declareToken, TypeScript.DiagnosticCode.declare_modifier_not_allowed_on_import_declaration);
                return true;
            }
        };
        GrammarCheckerWalker.prototype.visitImportDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifierOnImportDeclaration(node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitImportDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitModuleDeclaration = function (node) {
            if (this.checkForReservedName(node, node.name, TypeScript.DiagnosticCode.Module_name_cannot_be_0) ||
                this.checkForDisallowedDeclareModifier(node.modifiers) ||
                this.checkForRequiredDeclareModifier(node, node.moduleKeyword, node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers) ||
                this.checkForDisallowedImportDeclaration(node) ||
                this.checkForDisallowedExports(node, node.moduleElements) ||
                this.checkForMultipleExportAssignments(node, node.moduleElements)) {
                this.skip(node);
                return;
            }
            if (!TypeScript.SyntaxUtilities.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword) && this.checkFunctionOverloads(node, node.moduleElements)) {
                this.skip(node);
                return;
            }
            if (node.stringLiteral) {
                if (!this.inAmbientDeclaration && !TypeScript.SyntaxUtilities.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword)) {
                    var stringLiteralFullStart = this.childFullStart(node, node.stringLiteral);
                    this.pushDiagnostic1(stringLiteralFullStart, node.stringLiteral, TypeScript.DiagnosticCode.Only_ambient_modules_can_use_quoted_names);
                    this.skip(node);
                    return;
                }
            }
            if (!node.stringLiteral &&
                this.checkForDisallowedExportAssignment(node)) {
                this.skip(node);
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword);
            _super.prototype.visitModuleDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedExports = function (node, moduleElements) {
            var seenExportedElement = false;
            for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                var child = moduleElements.childAt(i);
                if (TypeScript.SyntaxUtilities.hasExportKeyword(child)) {
                    seenExportedElement = true;
                    break;
                }
            }
            var moduleElementFullStart = this.childFullStart(node, moduleElements);
            if (seenExportedElement) {
                for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                    var child = moduleElements.childAt(i);
                    if (child.kind() === TypeScript.SyntaxKind.ExportAssignment) {
                        this.pushDiagnostic1(moduleElementFullStart, child, TypeScript.DiagnosticCode.Export_assignment_not_allowed_in_module_with_exported_element);
                        return true;
                    }
                    moduleElementFullStart += child.fullWidth();
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForMultipleExportAssignments = function (node, moduleElements) {
            var moduleElementFullStart = this.childFullStart(node, moduleElements);
            var seenExportAssignment = false;
            var errorFound = false;
            for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                var child = moduleElements.childAt(i);
                if (child.kind() === TypeScript.SyntaxKind.ExportAssignment) {
                    if (seenExportAssignment) {
                        this.pushDiagnostic1(moduleElementFullStart, child, TypeScript.DiagnosticCode.Module_cannot_have_multiple_export_assignments);
                        errorFound = true;
                    }
                    seenExportAssignment = true;
                }
                moduleElementFullStart += child.fullWidth();
            }
            return errorFound;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedExportAssignment = function (node) {
            var moduleElementFullStart = this.childFullStart(node, node.moduleElements);
            for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var child = node.moduleElements.childAt(i);
                if (child.kind() === TypeScript.SyntaxKind.ExportAssignment) {
                    this.pushDiagnostic1(moduleElementFullStart, child, TypeScript.DiagnosticCode.Export_assignment_cannot_be_used_in_internal_modules);
                    return true;
                }
                moduleElementFullStart += child.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitBlock = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                this.pushDiagnostic1(this.position(), node.firstToken(), TypeScript.DiagnosticCode.Implementations_are_not_allowed_in_ambient_contexts);
                this.skip(node);
                return;
            }
            if (this.checkFunctionOverloads(node, node.statements)) {
                this.skip(node);
                return;
            }
            var savedInBlock = this.inBlock;
            this.inBlock = true;
            _super.prototype.visitBlock.call(this, node);
            this.inBlock = savedInBlock;
        };
        GrammarCheckerWalker.prototype.checkForStatementInAmbientContxt = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                this.pushDiagnostic1(this.position(), node.firstToken(), TypeScript.DiagnosticCode.Statements_are_not_allowed_in_ambient_contexts);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitBreakStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitBreakStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitContinueStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitContinueStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitDebuggerStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitDebuggerStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitDoStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitDoStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitEmptyStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitEmptyStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitExpressionStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitExpressionStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitForInStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitForInStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitForStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitForStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitIfStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitIfStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitLabeledStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitLabeledStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitReturnStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitReturnStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitSwitchStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitSwitchStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitThrowStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitThrowStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTryStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitTryStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitWhileStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitWhileStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitWithStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitWithStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForDisallowedModifiers = function (parent, modifiers) {
            if (this.inBlock || this.inObjectLiteralExpression) {
                if (modifiers.childCount() > 0) {
                    var modifierFullStart = this.childFullStart(parent, modifiers);
                    this.pushDiagnostic1(modifierFullStart, modifiers.childAt(0), TypeScript.DiagnosticCode.Modifiers_cannot_appear_here);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitFunctionDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) ||
                this.checkForDisallowedModifiers(node, node.modifiers) ||
                this.checkForRequiredDeclareModifier(node, node.functionKeyword, node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword);
            _super.prototype.visitFunctionDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitVariableStatement = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) ||
                this.checkForDisallowedModifiers(node, node.modifiers) ||
                this.checkForRequiredDeclareModifier(node, node.variableDeclaration, node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword);
            _super.prototype.visitVariableStatement.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkListSeparators = function (parent, list, kind) {
            var currentElementFullStart = this.childFullStart(parent, list);
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var child = list.childAt(i);
                if (i % 2 === 1 && child.kind() !== kind) {
                    this.pushDiagnostic1(currentElementFullStart, child, TypeScript.DiagnosticCode._0_expected, [TypeScript.SyntaxFacts.getText(kind)]);
                }
                currentElementFullStart += child.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitObjectType = function (node) {
            if (this.checkListSeparators(node, node.typeMembers, TypeScript.SyntaxKind.SemicolonToken)) {
                this.skip(node);
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitObjectType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitArrayType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitArrayType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitTupleType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitTupleType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitFunctionType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitFunctionType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitConstructorType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitConstructorType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitVariableDeclarator = function (node) {
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                this.pushDiagnostic1(this.childFullStart(node, node.equalsValueClause), node.equalsValueClause.firstToken(), TypeScript.DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts);
                this.skip(node);
                return;
            }
            _super.prototype.visitVariableDeclarator.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitConstructorDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers) ||
                this.checkConstructorModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }
            var savedCurrentConstructor = this.currentConstructor;
            this.currentConstructor = node;
            _super.prototype.visitConstructorDeclaration.call(this, node);
            this.currentConstructor = savedCurrentConstructor;
        };
        GrammarCheckerWalker.prototype.checkConstructorModifiers = function (modifiers) {
            var currentElementFullStart = this.position();
            for (var i = 0, n = modifiers.childCount(); i < n; i++) {
                var child = modifiers.childAt(i);
                if (child.kind() !== TypeScript.SyntaxKind.PublicKeyword) {
                    this.pushDiagnostic1(currentElementFullStart, child, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_constructor_declaration, [TypeScript.SyntaxFacts.getText(child.kind())]);
                    return true;
                }
                currentElementFullStart += child.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitSourceUnit = function (node) {
            if (this.checkFunctionOverloads(node, node.moduleElements) ||
                this.checkForDisallowedExports(node, node.moduleElements) ||
                this.checkForMultipleExportAssignments(node, node.moduleElements)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitSourceUnit.call(this, node);
        };
        return GrammarCheckerWalker;
    }(TypeScript.PositionTrackingWalker));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Unicode = (function () {
        function Unicode() {
        }
        Unicode.lookupInUnicodeMap = function (code, map) {
            if (code < map[0]) {
                return false;
            }
            var lo = 0;
            var hi = map.length;
            var mid;
            while (lo + 1 < hi) {
                mid = lo + (hi - lo) / 2;
                mid -= mid % 2;
                if (map[mid] <= code && code <= map[mid + 1]) {
                    return true;
                }
                if (code < map[mid]) {
                    hi = mid;
                }
                else {
                    lo = mid + 2;
                }
            }
            return false;
        };
        Unicode.isIdentifierStart = function (code, languageVersion) {
            if (languageVersion === TypeScript.LanguageVersion.EcmaScript3) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierStart);
            }
            else if (languageVersion === TypeScript.LanguageVersion.EcmaScript5) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierStart);
            }
            else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };
        Unicode.isIdentifierPart = function (code, languageVersion) {
            if (languageVersion === TypeScript.LanguageVersion.EcmaScript3) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierPart);
            }
            else if (languageVersion === TypeScript.LanguageVersion.EcmaScript5) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierPart);
            }
            else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };
        Unicode.unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
        Unicode.unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
        Unicode.unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
        Unicode.unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
        return Unicode;
    }());
    TypeScript.Unicode = Unicode;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CompilerDiagnostics;
    (function (CompilerDiagnostics) {
        CompilerDiagnostics.debug = false;
        CompilerDiagnostics.diagnosticWriter = null;
        CompilerDiagnostics.analysisPass = 0;
        function Alert(output) {
            if (CompilerDiagnostics.diagnosticWriter) {
                CompilerDiagnostics.diagnosticWriter.Alert(output);
            }
        }
        CompilerDiagnostics.Alert = Alert;
        function debugPrint(s) {
            if (CompilerDiagnostics.debug) {
                Alert(s);
            }
        }
        CompilerDiagnostics.debugPrint = debugPrint;
        function assert(condition, s) {
            if (CompilerDiagnostics.debug) {
                if (!condition) {
                    Alert(s);
                }
            }
        }
        CompilerDiagnostics.assert = assert;
    })(CompilerDiagnostics = TypeScript.CompilerDiagnostics || (TypeScript.CompilerDiagnostics = {}));
    var NullLogger = (function () {
        function NullLogger() {
        }
        NullLogger.prototype.information = function () { return false; };
        NullLogger.prototype.debug = function () { return false; };
        NullLogger.prototype.warning = function () { return false; };
        NullLogger.prototype.error = function () { return false; };
        NullLogger.prototype.fatal = function () { return false; };
        NullLogger.prototype.log = function (s) {
        };
        return NullLogger;
    }());
    TypeScript.NullLogger = NullLogger;
    function timeFunction(logger, funcDescription, func) {
        var start = (new Date()).getTime();
        var result = func();
        var end = (new Date()).getTime();
        logger.log(funcDescription + " completed in " + (end - start) + " msec");
        return result;
    }
    TypeScript.timeFunction = timeFunction;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Document = (function () {
        function Document(_compiler, _semanticInfoChain, fileName, referencedFiles, _scriptSnapshot, byteOrderMark, version, isOpen, _syntaxTree, _topLevelDecl) {
            this._compiler = _compiler;
            this._semanticInfoChain = _semanticInfoChain;
            this.fileName = fileName;
            this.referencedFiles = referencedFiles;
            this._scriptSnapshot = _scriptSnapshot;
            this.byteOrderMark = byteOrderMark;
            this.version = version;
            this.isOpen = isOpen;
            this._syntaxTree = _syntaxTree;
            this._topLevelDecl = _topLevelDecl;
            this._diagnostics = null;
            this._bloomFilter = null;
            this._sourceUnit = null;
            this._lineMap = null;
            this._declASTMap = [];
            this._astDeclMap = [];
            this._isExternalModule = undefined;
            this._amdDependencies = undefined;
        }
        Document.prototype.invalidate = function () {
            this._declASTMap.length = 0;
            this._astDeclMap.length = 0;
            this._topLevelDecl = null;
            this._syntaxTree = null;
            this._sourceUnit = null;
            this._diagnostics = null;
            this._bloomFilter = null;
        };
        Document.prototype.isDeclareFile = function () {
            return TypeScript.isDTSFile(this.fileName);
        };
        Document.prototype.cacheSyntaxTreeInfo = function (syntaxTree) {
            var start = new Date().getTime();
            this._diagnostics = syntaxTree.diagnostics();
            TypeScript.syntaxDiagnosticsTime += new Date().getTime() - start;
            this._lineMap = syntaxTree.lineMap();
            var sourceUnit = syntaxTree.sourceUnit();
            var leadingComments = this.getLeadingComments(sourceUnit);
            this._isExternalModule = this.hasImplicitImport(leadingComments) || this.hasTopLevelImportOrExport(sourceUnit);
            var amdDependencies = [];
            for (var i = 0, n = leadingComments.length; i < n; i++) {
                var trivia = leadingComments[i];
                var amdDependency = this.getAmdDependency(trivia.fullText());
                if (amdDependency) {
                    amdDependencies.push(amdDependency);
                }
            }
            this._amdDependencies = amdDependencies;
        };
        Document.prototype.getLeadingComments = function (node) {
            var firstToken = node.firstToken();
            var result = [];
            if (firstToken.hasLeadingComment()) {
                var leadingTrivia = firstToken.leadingTrivia();
                for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
                    var trivia = leadingTrivia.syntaxTriviaAt(i);
                    if (trivia.isComment()) {
                        result.push(trivia);
                    }
                }
            }
            return result;
        };
        Document.prototype.getAmdDependency = function (comment) {
            var amdDependencyRegEx = /^\/\/\/\s*<amd-dependency\s+path=('|")(.+?)\1/gim;
            var match = amdDependencyRegEx.exec(comment);
            return match ? match[2] : null;
        };
        Document.prototype.hasImplicitImport = function (sourceUnitLeadingComments) {
            for (var i = 0, n = sourceUnitLeadingComments.length; i < n; i++) {
                var trivia = sourceUnitLeadingComments[i];
                if (this.getImplicitImport(trivia.fullText())) {
                    return true;
                }
            }
            return false;
        };
        Document.prototype.getImplicitImport = function (comment) {
            var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/gim;
            var match = implicitImportRegEx.exec(comment);
            if (match) {
                return true;
            }
            return false;
        };
        Document.prototype.hasTopLevelImportOrExport = function (node) {
            var firstToken;
            for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var moduleElement = node.moduleElements.childAt(i);
                firstToken = moduleElement.firstToken();
                if (firstToken !== null && firstToken.tokenKind === TypeScript.SyntaxKind.ExportKeyword) {
                    return true;
                }
                if (moduleElement.kind() === TypeScript.SyntaxKind.ImportDeclaration) {
                    var importDecl = moduleElement;
                    if (importDecl.moduleReference.kind() === TypeScript.SyntaxKind.ExternalModuleReference) {
                        return true;
                    }
                }
            }
            return false;
        };
        Document.prototype.sourceUnit = function () {
            if (!this._sourceUnit) {
                var start = new Date().getTime();
                var syntaxTree = this.syntaxTree();
                this._sourceUnit = TypeScript.SyntaxTreeToAstVisitor.visit(syntaxTree, this.fileName, this._compiler.compilationSettings(), false);
                TypeScript.astTranslationTime += new Date().getTime() - start;
                if (!this.isOpen) {
                    this._syntaxTree = null;
                }
            }
            return this._sourceUnit;
        };
        Document.prototype.diagnostics = function () {
            if (this._diagnostics === null) {
                this.syntaxTree();
                TypeScript.Debug.assert(this._diagnostics);
            }
            return this._diagnostics;
        };
        Document.prototype.lineMap = function () {
            if (this._lineMap === null) {
                this.syntaxTree();
                TypeScript.Debug.assert(this._lineMap);
            }
            return this._lineMap;
        };
        Document.prototype.isExternalModule = function () {
            if (this._isExternalModule === undefined) {
                this.syntaxTree();
                TypeScript.Debug.assert(this._isExternalModule !== undefined);
            }
            return this._isExternalModule;
        };
        Document.prototype.amdDependencies = function () {
            if (this._amdDependencies === undefined) {
                this.syntaxTree();
                TypeScript.Debug.assert(this._amdDependencies !== undefined);
            }
            return this._amdDependencies;
        };
        Document.prototype.syntaxTree = function () {
            var result = this._syntaxTree;
            if (!result) {
                var start = new Date().getTime();
                result = Parser.parse(this.fileName, TypeScript.SimpleText.fromScriptSnapshot(this._scriptSnapshot), TypeScript.isDTSFile(this.fileName), TypeScript.getParseOptions(this._compiler.compilationSettings()));
                TypeScript.syntaxTreeParseTime += new Date().getTime() - start;
                if (this.isOpen || !this._sourceUnit) {
                    this._syntaxTree = result;
                }
            }
            this.cacheSyntaxTreeInfo(result);
            return result;
        };
        Document.prototype.bloomFilter = function () {
            if (!this._bloomFilter) {
                var identifiers = TypeScript.createIntrinsicsObject();
                var pre = function (cur) {
                    if (TypeScript.isValidAstNode(cur)) {
                        if (cur.kind() === TypeScript.SyntaxKind.IdentifierName) {
                            var nodeText = cur.valueText();
                            identifiers[nodeText] = true;
                        }
                    }
                };
                TypeScript.getAstWalkerFactory().simpleWalk(this.sourceUnit(), pre, null, identifiers);
                var identifierCount = 0;
                for (var name in identifiers) {
                    if (identifiers[name]) {
                        identifierCount++;
                    }
                }
                this._bloomFilter = new TypeScript.BloomFilter(identifierCount);
                this._bloomFilter.addKeys(identifiers);
            }
            return this._bloomFilter;
        };
        Document.prototype.emitToOwnOutputFile = function () {
            return !this._compiler.compilationSettings().outFileOption() || this.isExternalModule();
        };
        Document.prototype.update = function (scriptSnapshot, version, isOpen, textChangeRange) {
            var oldSyntaxTree = this._syntaxTree;
            if (textChangeRange !== null && TypeScript.Debug.shouldAssert(TypeScript.AssertionLevel.Normal)) {
                var oldText = this._scriptSnapshot;
                var newText = scriptSnapshot;
                TypeScript.Debug.assert((oldText.getLength() - textChangeRange.span().length() + textChangeRange.newLength()) === newText.getLength());
                if (TypeScript.Debug.shouldAssert(TypeScript.AssertionLevel.VeryAggressive)) {
                    var oldTextPrefix = oldText.getText(0, textChangeRange.span().start());
                    var newTextPrefix = newText.getText(0, textChangeRange.span().start());
                    TypeScript.Debug.assert(oldTextPrefix === newTextPrefix);
                    var oldTextSuffix = oldText.getText(textChangeRange.span().end(), oldText.getLength());
                    var newTextSuffix = newText.getText(textChangeRange.newSpan().end(), newText.getLength());
                    TypeScript.Debug.assert(oldTextSuffix === newTextSuffix);
                }
            }
            var text = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);
            var newSyntaxTree = textChangeRange === null || oldSyntaxTree === null
                ? TypeScript.Parser.parse(this.fileName, text, TypeScript.isDTSFile(this.fileName), TypeScript.getParseOptions(this._compiler.compilationSettings()))
                : TypeScript.Parser.incrementalParse(oldSyntaxTree, textChangeRange, text);
            return new Document(this._compiler, this._semanticInfoChain, this.fileName, this.referencedFiles, scriptSnapshot, this.byteOrderMark, version, isOpen, newSyntaxTree, null);
        };
        Document.create = function (compiler, semanticInfoChain, fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles) {
            return new Document(compiler, semanticInfoChain, fileName, referencedFiles, scriptSnapshot, byteOrderMark, version, isOpen, null, null);
        };
        Document.prototype.topLevelDecl = function () {
            if (this._topLevelDecl === null) {
                this._topLevelDecl = TypeScript.DeclarationCreator.create(this, this._semanticInfoChain, this._compiler.compilationSettings());
            }
            return this._topLevelDecl;
        };
        Document.prototype._getDeclForAST = function (ast) {
            this.topLevelDecl();
            return this._astDeclMap[ast.syntaxID()];
        };
        Document.prototype.getEnclosingDecl = function (ast) {
            if (ast.kind() === TypeScript.SyntaxKind.SourceUnit) {
                return this._getDeclForAST(ast);
            }
            ast = ast.parent;
            var decl = null;
            while (ast) {
                decl = this._getDeclForAST(ast);
                if (decl) {
                    break;
                }
                ast = ast.parent;
            }
            return decl._getEnclosingDeclFromParentDecl();
        };
        Document.prototype._setDeclForAST = function (ast, decl) {
            TypeScript.Debug.assert(decl.fileName() === this.fileName);
            this._astDeclMap[ast.syntaxID()] = decl;
        };
        Document.prototype._getASTForDecl = function (decl) {
            return this._declASTMap[decl.declID];
        };
        Document.prototype._setASTForDecl = function (decl, ast) {
            TypeScript.Debug.assert(decl.fileName() === this.fileName);
            this._declASTMap[decl.declID] = ast;
        };
        return Document;
    }());
    TypeScript.Document = Document;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function hasFlag(val, flag) {
        return (val & flag) !== 0;
    }
    TypeScript.hasFlag = hasFlag;
    var TypeRelationshipFlags;
    (function (TypeRelationshipFlags) {
        TypeRelationshipFlags[TypeRelationshipFlags["SuccessfulComparison"] = 0] = "SuccessfulComparison";
        TypeRelationshipFlags[TypeRelationshipFlags["RequiredPropertyIsMissing"] = 2] = "RequiredPropertyIsMissing";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatibleSignatures"] = 4] = "IncompatibleSignatures";
        TypeRelationshipFlags[TypeRelationshipFlags["SourceSignatureHasTooManyParameters"] = 3] = "SourceSignatureHasTooManyParameters";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatibleReturnTypes"] = 16] = "IncompatibleReturnTypes";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatiblePropertyTypes"] = 32] = "IncompatiblePropertyTypes";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatibleParameterTypes"] = 64] = "IncompatibleParameterTypes";
        TypeRelationshipFlags[TypeRelationshipFlags["InconsistantPropertyAccesibility"] = 128] = "InconsistantPropertyAccesibility";
    })(TypeRelationshipFlags = TypeScript.TypeRelationshipFlags || (TypeScript.TypeRelationshipFlags = {}));
    var ModuleGenTarget;
    (function (ModuleGenTarget) {
        ModuleGenTarget[ModuleGenTarget["Unspecified"] = 0] = "Unspecified";
        ModuleGenTarget[ModuleGenTarget["Synchronous"] = 1] = "Synchronous";
        ModuleGenTarget[ModuleGenTarget["Asynchronous"] = 2] = "Asynchronous";
    })(ModuleGenTarget = TypeScript.ModuleGenTarget || (TypeScript.ModuleGenTarget = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var proto = "__proto__";
    var BlockIntrinsics = (function () {
        function BlockIntrinsics() {
            this.prototype = undefined;
            this.toString = undefined;
            this.toLocaleString = undefined;
            this.valueOf = undefined;
            this.hasOwnProperty = undefined;
            this.propertyIsEnumerable = undefined;
            this.isPrototypeOf = undefined;
            this["constructor"] = undefined;
            this[proto] = null;
            this[proto] = undefined;
        }
        return BlockIntrinsics;
    }());
    function createIntrinsicsObject() {
        return new BlockIntrinsics();
    }
    TypeScript.createIntrinsicsObject = createIntrinsicsObject;
    var StringHashTable = (function () {
        function StringHashTable() {
            this.itemCount = 0;
            this.table = createIntrinsicsObject();
        }
        StringHashTable.prototype.getAllKeys = function () {
            var result = [];
            for (var k in this.table) {
                if (this.table[k] !== undefined) {
                    result.push(k);
                }
            }
            return result;
        };
        StringHashTable.prototype.add = function (key, data) {
            if (this.table[key] !== undefined) {
                return false;
            }
            this.table[key] = data;
            this.itemCount++;
            return true;
        };
        StringHashTable.prototype.addOrUpdate = function (key, data) {
            if (this.table[key] !== undefined) {
                this.table[key] = data;
                return false;
            }
            this.table[key] = data;
            this.itemCount++;
            return true;
        };
        StringHashTable.prototype.map = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];
                if (data !== undefined) {
                    fn(k, this.table[k], context);
                }
            }
        };
        StringHashTable.prototype.every = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];
                if (data !== undefined) {
                    if (!fn(k, this.table[k], context)) {
                        return false;
                    }
                }
            }
            return true;
        };
        StringHashTable.prototype.some = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];
                if (data !== undefined) {
                    if (fn(k, this.table[k], context)) {
                        return true;
                    }
                }
            }
            return false;
        };
        StringHashTable.prototype.count = function () {
            return this.itemCount;
        };
        StringHashTable.prototype.lookup = function (key) {
            var data = this.table[key];
            return data === undefined ? null : data;
        };
        StringHashTable.prototype.remove = function (key) {
            if (this.table[key] !== undefined) {
                this.table[key] = undefined;
                this.itemCount--;
            }
        };
        return StringHashTable;
    }());
    TypeScript.StringHashTable = StringHashTable;
    var IdentiferNameHashTable = (function (_super) {
        __extends(IdentiferNameHashTable, _super);
        function IdentiferNameHashTable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IdentiferNameHashTable.prototype.getAllKeys = function () {
            var result = [];
            _super.prototype.map.call(this, function (k, v, c) {
                if (v !== undefined) {
                    result.push(k.substring(1));
                }
            }, null);
            return result;
        };
        IdentiferNameHashTable.prototype.add = function (key, data) {
            return _super.prototype.add.call(this, "#" + key, data);
        };
        IdentiferNameHashTable.prototype.addOrUpdate = function (key, data) {
            return _super.prototype.addOrUpdate.call(this, "#" + key, data);
        };
        IdentiferNameHashTable.prototype.map = function (fn, context) {
            return _super.prototype.map.call(this, function (k, v, c) { return fn(k.substring(1), v, c); }, context);
        };
        IdentiferNameHashTable.prototype.every = function (fn, context) {
            return _super.prototype.every.call(this, function (k, v, c) { return fn(k.substring(1), v, c); }, context);
        };
        IdentiferNameHashTable.prototype.some = function (fn, context) {
            return _super.prototype.some.call(this, function (k, v, c) { return fn(k.substring(1), v, c); }, context);
        };
        IdentiferNameHashTable.prototype.lookup = function (key) {
            return _super.prototype.lookup.call(this, "#" + key);
        };
        return IdentiferNameHashTable;
    }(StringHashTable));
    TypeScript.IdentiferNameHashTable = IdentiferNameHashTable;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TypeName;
    (function (TypeName) {
        TypeName[TypeName["Void"] = 0] = "Void";
        TypeName[TypeName["String"] = 1] = "String";
        TypeName[TypeName["Number"] = 2] = "Number";
        TypeName[TypeName["Bool"] = 3] = "Bool";
        TypeName[TypeName["Any"] = 4] = "Any";
        TypeName[TypeName["Un"] = 5] = "Un";
        TypeName[TypeName["Record"] = 6] = "Record";
        TypeName[TypeName["Arrow"] = 7] = "Arrow";
        TypeName[TypeName["IndexMap"] = 8] = "IndexMap";
        TypeName[TypeName["Object"] = 9] = "Object";
        TypeName[TypeName["Class"] = 10] = "Class";
        TypeName[TypeName["Interface"] = 11] = "Interface";
        TypeName[TypeName["Enum"] = 12] = "Enum";
        TypeName[TypeName["Module"] = 13] = "Module";
        TypeName[TypeName["Variable"] = 14] = "Variable";
        TypeName[TypeName["Poly"] = 15] = "Poly";
        TypeName[TypeName["Inst"] = 16] = "Inst";
        TypeName[TypeName["Just"] = 17] = "Just";
        TypeName[TypeName["Null"] = 18] = "Null";
        TypeName[TypeName["UVar"] = 19] = "UVar";
    })(TypeName = TypeScript.TypeName || (TypeScript.TypeName = {}));
    var NewLineMode;
    (function (NewLineMode) {
        NewLineMode[NewLineMode["None"] = 0] = "None";
        NewLineMode[NewLineMode["Suppress"] = 1] = "Suppress";
        NewLineMode[NewLineMode["Force"] = 2] = "Force";
    })(NewLineMode = TypeScript.NewLineMode || (TypeScript.NewLineMode = {}));
    var SoundType = (function () {
        function SoundType(typeName) {
            this.typeName = typeName;
            this.virtual = false;
            this.nominal = false;
            this.instantiated = false;
        }
        SoundType.prototype.isIndexable = function () {
            return false;
        };
        SoundType.prototype.toRTTI = function () {
            throw new Error("Abstract method: " + this.typeName);
        };
        SoundType.prototype.equals = function (t) {
            throw new Error("Abstract method!" + this.typeName);
        };
        SoundType.prototype.unFree = function () {
            throw new Error("Abstract method!" + this.typeName);
        };
        SoundType.prototype.toString = function () {
            throw new Error("Abstract method!" + this.typeName);
        };
        SoundType.prototype.callSignature = function (overload) {
            if (overload === void 0) { overload = 0; }
            return null;
        };
        SoundType.prototype.indexSignature = function (overload) {
            if (overload === void 0) { overload = 0; }
            return null;
        };
        SoundType.prototype.subst = function (s, decend) {
            return this;
        };
        SoundType.prototype.unfold = function () {
            return this;
        };
        SoundType.prototype.isArray = function () {
            return false;
        };
        SoundType.prototype.isCheckedArray = function () {
            return false;
        };
        SoundType.prototype.isNominal = function () {
            return this.nominal;
        };
        SoundType.prototype.isVirtual = function () {
            return this.virtual;
        };
        SoundType.prototype.isUn = function () {
            return false;
        };
        SoundType.prototype.getConstraint = function () {
            return undefined;
        };
        return SoundType;
    }());
    TypeScript.SoundType = SoundType;
    var ASTSpan = (function () {
        function ASTSpan(_start, _end) {
            this._start = _start;
            this._end = _end;
        }
        ASTSpan.prototype.start = function () {
            return this._start;
        };
        ASTSpan.prototype.end = function () {
            return this._end;
        };
        return ASTSpan;
    }());
    TypeScript.ASTSpan = ASTSpan;
    var astID = 0;
    function structuralEqualsNotIncludingPosition(ast1, ast2) {
        return structuralEquals(ast1, ast2, false);
    }
    TypeScript.structuralEqualsNotIncludingPosition = structuralEqualsNotIncludingPosition;
    function structuralEqualsIncludingPosition(ast1, ast2) {
        return structuralEquals(ast1, ast2, true);
    }
    TypeScript.structuralEqualsIncludingPosition = structuralEqualsIncludingPosition;
    function commentStructuralEqualsNotIncludingPosition(ast1, ast2) {
        return commentStructuralEquals(ast1, ast2, false);
    }
    function commentStructuralEqualsIncludingPosition(ast1, ast2) {
        return commentStructuralEquals(ast1, ast2, true);
    }
    function structuralEquals(ast1, ast2, includingPosition) {
        if (ast1 === ast2) {
            return true;
        }
        return ast1 !== null && ast2 !== null &&
            ast1.kind() === ast2.kind() &&
            ast1.structuralEquals(ast2, includingPosition);
    }
    function commentStructuralEquals(ast1, ast2, includingPosition) {
        if (ast1 === ast2) {
            return true;
        }
        return ast1 !== null && ast2 !== null &&
            ast1.structuralEquals(ast2, includingPosition);
    }
    function astArrayStructuralEquals(array1, array2, includingPosition) {
        return TypeScript.ArrayUtilities.sequenceEquals(array1, array2, includingPosition ? structuralEqualsIncludingPosition : structuralEqualsNotIncludingPosition);
    }
    function commentArrayStructuralEquals(array1, array2, includingPosition) {
        return TypeScript.ArrayUtilities.sequenceEquals(array1, array2, includingPosition ? commentStructuralEqualsIncludingPosition : commentStructuralEqualsNotIncludingPosition);
    }
    var AST = (function () {
        function AST() {
            this.parent = null;
            this._start = 0;
            this._end = 0;
            this._trailingTriviaWidth = 0;
            this._astID = astID++;
            this.inferredType = null;
            this.soundType = null;
            this._preComments = null;
            this._postComments = null;
        }
        AST.prototype.syntaxID = function () {
            return this._astID;
        };
        AST.prototype.start = function () {
            return this._start;
        };
        AST.prototype.end = function () {
            return this._end;
        };
        AST.prototype.trailingTriviaWidth = function () {
            return this._trailingTriviaWidth;
        };
        AST.prototype.fileName = function () {
            return this.parent.fileName();
        };
        AST.prototype.kind = function () {
            throw TypeScript.Errors.abstract();
        };
        AST.prototype.preComments = function () {
            return this._preComments;
        };
        AST.prototype.postComments = function () {
            return this._postComments;
        };
        AST.prototype.setPreComments = function (comments) {
            if (comments && comments.length) {
                this._preComments = comments;
            }
            else if (this._preComments) {
                this._preComments = null;
            }
        };
        AST.prototype.setPostComments = function (comments) {
            if (comments && comments.length) {
                this._postComments = comments;
            }
            else if (this._postComments) {
                this._postComments = null;
            }
        };
        AST.prototype.width = function () {
            return this.end() - this.start();
        };
        AST.prototype.structuralEquals = function (ast, includingPosition) {
            if (includingPosition) {
                if (this.start() !== ast.start() || this.end() !== ast.end()) {
                    return false;
                }
            }
            return commentArrayStructuralEquals(this.preComments(), ast.preComments(), includingPosition) &&
                commentArrayStructuralEquals(this.postComments(), ast.postComments(), includingPosition);
        };
        return AST;
    }());
    TypeScript.AST = AST;
    var ISyntaxList2 = (function (_super) {
        __extends(ISyntaxList2, _super);
        function ISyntaxList2(_fileName, members) {
            var _this = _super.call(this) || this;
            _this._fileName = _fileName;
            _this.members = members;
            for (var i = 0, n = members.length; i < n; i++) {
                members[i].parent = _this;
            }
            return _this;
        }
        ISyntaxList2.prototype.childCount = function () {
            return this.members.length;
        };
        ISyntaxList2.prototype.childAt = function (index) {
            return this.members[index];
        };
        ISyntaxList2.prototype.fileName = function () {
            return this._fileName;
        };
        ISyntaxList2.prototype.kind = function () {
            return TypeScript.SyntaxKind.List;
        };
        ISyntaxList2.prototype.firstOrDefault = function (func) {
            return TypeScript.ArrayUtilities.firstOrDefault(this.members, func);
        };
        ISyntaxList2.prototype.lastOrDefault = function (func) {
            return TypeScript.ArrayUtilities.lastOrDefault(this.members, func);
        };
        ISyntaxList2.prototype.any = function (func) {
            return TypeScript.ArrayUtilities.any(this.members, func);
        };
        ISyntaxList2.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                astArrayStructuralEquals(this.members, ast.members, includingPosition);
        };
        return ISyntaxList2;
    }(AST));
    TypeScript.ISyntaxList2 = ISyntaxList2;
    var ISeparatedSyntaxList2 = (function (_super) {
        __extends(ISeparatedSyntaxList2, _super);
        function ISeparatedSyntaxList2(_fileName, members, _separatorCount) {
            var _this = _super.call(this) || this;
            _this._fileName = _fileName;
            _this.members = members;
            _this._separatorCount = _separatorCount;
            for (var i = 0, n = members.length; i < n; i++) {
                members[i].parent = _this;
            }
            return _this;
        }
        ISeparatedSyntaxList2.prototype.nonSeparatorCount = function () {
            return this.members.length;
        };
        ISeparatedSyntaxList2.prototype.separatorCount = function () {
            return this._separatorCount;
        };
        ISeparatedSyntaxList2.prototype.nonSeparatorAt = function (index) {
            return this.members[index];
        };
        ISeparatedSyntaxList2.prototype.nonSeparatorIndexOf = function (ast) {
            for (var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                if (this.nonSeparatorAt(i) === ast) {
                    return i;
                }
            }
            return -1;
        };
        ISeparatedSyntaxList2.prototype.fileName = function () {
            return this._fileName;
        };
        ISeparatedSyntaxList2.prototype.kind = function () {
            return TypeScript.SyntaxKind.SeparatedList;
        };
        ISeparatedSyntaxList2.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                astArrayStructuralEquals(this.members, ast.members, includingPosition);
        };
        return ISeparatedSyntaxList2;
    }(AST));
    TypeScript.ISeparatedSyntaxList2 = ISeparatedSyntaxList2;
    var SourceUnit = (function (_super) {
        __extends(SourceUnit, _super);
        function SourceUnit(moduleElements, _fileName) {
            var _this = _super.call(this) || this;
            _this.moduleElements = moduleElements;
            _this._fileName = _fileName;
            moduleElements && (moduleElements.parent = _this);
            return _this;
        }
        SourceUnit.prototype.fileName = function () {
            return this._fileName;
        };
        SourceUnit.prototype.kind = function () {
            return TypeScript.SyntaxKind.SourceUnit;
        };
        SourceUnit.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.moduleElements, ast.moduleElements, includingPosition);
        };
        return SourceUnit;
    }(AST));
    TypeScript.SourceUnit = SourceUnit;
    var Identifier = (function (_super) {
        __extends(Identifier, _super);
        function Identifier(_text) {
            var _this = _super.call(this) || this;
            _this._text = _text;
            _this._valueText = null;
            return _this;
        }
        Identifier.prototype.text = function () {
            return this._text;
        };
        Identifier.prototype.valueText = function () {
            if (!this._valueText) {
                var text = this._text;
                if (text === "__proto__") {
                    this._valueText = "#__proto__";
                }
                else {
                    this._valueText = TypeScript.Syntax.massageEscapes(text);
                }
            }
            return this._valueText;
        };
        Identifier.prototype.kind = function () {
            return TypeScript.SyntaxKind.IdentifierName;
        };
        Identifier.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                (ast instanceof Identifier ? this._text === ast._text : false);
        };
        return Identifier;
    }(AST));
    TypeScript.Identifier = Identifier;
    var LiteralExpression = (function (_super) {
        __extends(LiteralExpression, _super);
        function LiteralExpression(_nodeType, _text, _valueText) {
            var _this = _super.call(this) || this;
            _this._nodeType = _nodeType;
            _this._text = _text;
            _this._valueText = _valueText;
            return _this;
        }
        LiteralExpression.prototype.text = function () {
            return this._text;
        };
        LiteralExpression.prototype.valueText = function () {
            return this._valueText;
        };
        LiteralExpression.prototype.kind = function () {
            return this._nodeType;
        };
        LiteralExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return LiteralExpression;
    }(AST));
    TypeScript.LiteralExpression = LiteralExpression;
    var ThisExpression = (function (_super) {
        __extends(ThisExpression, _super);
        function ThisExpression(_text, _valueText) {
            var _this = _super.call(this) || this;
            _this._text = _text;
            _this._valueText = _valueText;
            return _this;
        }
        ThisExpression.prototype.text = function () {
            return this._text;
        };
        ThisExpression.prototype.valueText = function () {
            return this._valueText;
        };
        ThisExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.ThisKeyword;
        };
        ThisExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return ThisExpression;
    }(AST));
    TypeScript.ThisExpression = ThisExpression;
    var SuperExpression = (function (_super) {
        __extends(SuperExpression, _super);
        function SuperExpression(_text, _valueText) {
            var _this = _super.call(this) || this;
            _this._text = _text;
            _this._valueText = _valueText;
            return _this;
        }
        SuperExpression.prototype.text = function () {
            return this._text;
        };
        SuperExpression.prototype.valueText = function () {
            return this._valueText;
        };
        SuperExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.SuperKeyword;
        };
        SuperExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return SuperExpression;
    }(AST));
    TypeScript.SuperExpression = SuperExpression;
    var NumericLiteral = (function (_super) {
        __extends(NumericLiteral, _super);
        function NumericLiteral(_value, _text, _valueText) {
            var _this = _super.call(this) || this;
            _this._value = _value;
            _this._text = _text;
            _this._valueText = _valueText;
            return _this;
        }
        NumericLiteral.prototype.text = function () { return this._text; };
        NumericLiteral.prototype.valueText = function () { return this._valueText; };
        NumericLiteral.prototype.value = function () { return this._value; };
        NumericLiteral.prototype.kind = function () {
            return TypeScript.SyntaxKind.NumericLiteral;
        };
        NumericLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            if (_super.prototype.structuralEquals.call(this, ast, includingPosition)) {
                var n;
                if (ast instanceof NumericLiteral) {
                    n = ast;
                    return (this._value === n._value || (isNaN(this._value) && isNaN(n._value))) &&
                        this._text === n._text;
                }
                return false;
            }
            return false;
        };
        return NumericLiteral;
    }(AST));
    TypeScript.NumericLiteral = NumericLiteral;
    var RegularExpressionLiteral = (function (_super) {
        __extends(RegularExpressionLiteral, _super);
        function RegularExpressionLiteral(_text, _valueText) {
            var _this = _super.call(this) || this;
            _this._text = _text;
            _this._valueText = _valueText;
            return _this;
        }
        RegularExpressionLiteral.prototype.text = function () {
            return this._text;
        };
        RegularExpressionLiteral.prototype.valueText = function () {
            return this._valueText;
        };
        RegularExpressionLiteral.prototype.kind = function () {
            return TypeScript.SyntaxKind.RegularExpressionLiteral;
        };
        return RegularExpressionLiteral;
    }(AST));
    TypeScript.RegularExpressionLiteral = RegularExpressionLiteral;
    var StringLiteral = (function (_super) {
        __extends(StringLiteral, _super);
        function StringLiteral(_text, _valueText) {
            var _this = _super.call(this) || this;
            _this._text = _text;
            _this._valueText = _valueText;
            _this._valueText = _valueText === "__proto__" ? "#__proto__" : _valueText;
            return _this;
        }
        StringLiteral.prototype.text = function () { return this._text; };
        StringLiteral.prototype.valueText = function () { return this._valueText; };
        StringLiteral.prototype.kind = function () {
            return TypeScript.SyntaxKind.StringLiteral;
        };
        StringLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                this._text === ast._text;
        };
        return StringLiteral;
    }(AST));
    TypeScript.StringLiteral = StringLiteral;
    var TypeAnnotation = (function (_super) {
        __extends(TypeAnnotation, _super);
        function TypeAnnotation(type) {
            var _this = _super.call(this) || this;
            _this.type = type;
            type && (type.parent = _this);
            return _this;
        }
        TypeAnnotation.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeAnnotation;
        };
        return TypeAnnotation;
    }(AST));
    TypeScript.TypeAnnotation = TypeAnnotation;
    var BuiltInType = (function (_super) {
        __extends(BuiltInType, _super);
        function BuiltInType(_nodeType, _text, _valueText) {
            var _this = _super.call(this) || this;
            _this._nodeType = _nodeType;
            _this._text = _text;
            _this._valueText = _valueText;
            return _this;
        }
        BuiltInType.prototype.text = function () {
            return this._text;
        };
        BuiltInType.prototype.valueText = function () {
            return this._valueText;
        };
        BuiltInType.prototype.kind = function () {
            return this._nodeType;
        };
        return BuiltInType;
    }(AST));
    TypeScript.BuiltInType = BuiltInType;
    var ExternalModuleReference = (function (_super) {
        __extends(ExternalModuleReference, _super);
        function ExternalModuleReference(stringLiteral) {
            var _this = _super.call(this) || this;
            _this.stringLiteral = stringLiteral;
            stringLiteral && (stringLiteral.parent = _this);
            return _this;
        }
        ExternalModuleReference.prototype.kind = function () {
            return TypeScript.SyntaxKind.ExternalModuleReference;
        };
        return ExternalModuleReference;
    }(AST));
    TypeScript.ExternalModuleReference = ExternalModuleReference;
    var ModuleNameModuleReference = (function (_super) {
        __extends(ModuleNameModuleReference, _super);
        function ModuleNameModuleReference(moduleName) {
            var _this = _super.call(this) || this;
            _this.moduleName = moduleName;
            moduleName && (moduleName.parent = _this);
            return _this;
        }
        ModuleNameModuleReference.prototype.kind = function () {
            return TypeScript.SyntaxKind.ModuleNameModuleReference;
        };
        return ModuleNameModuleReference;
    }(AST));
    TypeScript.ModuleNameModuleReference = ModuleNameModuleReference;
    var ImportDeclaration = (function (_super) {
        __extends(ImportDeclaration, _super);
        function ImportDeclaration(modifiers, identifier, moduleReference) {
            var _this = _super.call(this) || this;
            _this.modifiers = modifiers;
            _this.identifier = identifier;
            _this.moduleReference = moduleReference;
            identifier && (identifier.parent = _this);
            moduleReference && (moduleReference.parent = _this);
            return _this;
        }
        ImportDeclaration.prototype.kind = function () {
            return TypeScript.SyntaxKind.ImportDeclaration;
        };
        ImportDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.identifier, ast.identifier, includingPosition) &&
                structuralEquals(this.moduleReference, ast.moduleReference, includingPosition);
        };
        return ImportDeclaration;
    }(AST));
    TypeScript.ImportDeclaration = ImportDeclaration;
    var ExportAssignment = (function (_super) {
        __extends(ExportAssignment, _super);
        function ExportAssignment(identifier) {
            var _this = _super.call(this) || this;
            _this.identifier = identifier;
            identifier && (identifier.parent = _this);
            return _this;
        }
        ExportAssignment.prototype.kind = function () {
            return TypeScript.SyntaxKind.ExportAssignment;
        };
        ExportAssignment.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.identifier, ast.identifier, includingPosition);
        };
        return ExportAssignment;
    }(AST));
    TypeScript.ExportAssignment = ExportAssignment;
    var TypeParameterList = (function (_super) {
        __extends(TypeParameterList, _super);
        function TypeParameterList(typeParameters) {
            var _this = _super.call(this) || this;
            _this.typeParameters = typeParameters;
            typeParameters && (typeParameters.parent = _this);
            return _this;
        }
        TypeParameterList.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeParameterList;
        };
        return TypeParameterList;
    }(AST));
    TypeScript.TypeParameterList = TypeParameterList;
    var ClassDeclaration = (function (_super) {
        __extends(ClassDeclaration, _super);
        function ClassDeclaration(modifiers, identifier, typeParameterList, heritageClauses, classElements, closeBraceToken) {
            var _this = _super.call(this) || this;
            _this.modifiers = modifiers;
            _this.identifier = identifier;
            _this.typeParameterList = typeParameterList;
            _this.heritageClauses = heritageClauses;
            _this.classElements = classElements;
            _this.closeBraceToken = closeBraceToken;
            identifier && (identifier.parent = _this);
            typeParameterList && (typeParameterList.parent = _this);
            heritageClauses && (heritageClauses.parent = _this);
            classElements && (classElements.parent = _this);
            return _this;
        }
        ClassDeclaration.prototype.kind = function () {
            return TypeScript.SyntaxKind.ClassDeclaration;
        };
        ClassDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.identifier, ast.identifier, includingPosition) &&
                structuralEquals(this.classElements, ast.classElements, includingPosition) &&
                structuralEquals(this.typeParameterList, ast.typeParameterList, includingPosition) &&
                structuralEquals(this.heritageClauses, ast.heritageClauses, includingPosition);
        };
        return ClassDeclaration;
    }(AST));
    TypeScript.ClassDeclaration = ClassDeclaration;
    var InterfaceDeclaration = (function (_super) {
        __extends(InterfaceDeclaration, _super);
        function InterfaceDeclaration(modifiers, identifier, typeParameterList, heritageClauses, body) {
            var _this = _super.call(this) || this;
            _this.modifiers = modifiers;
            _this.identifier = identifier;
            _this.typeParameterList = typeParameterList;
            _this.heritageClauses = heritageClauses;
            _this.body = body;
            identifier && (identifier.parent = _this);
            typeParameterList && (typeParameterList.parent = _this);
            body && (body.parent = _this);
            heritageClauses && (heritageClauses.parent = _this);
            return _this;
        }
        InterfaceDeclaration.prototype.kind = function () {
            return TypeScript.SyntaxKind.InterfaceDeclaration;
        };
        InterfaceDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.identifier, ast.identifier, includingPosition) &&
                structuralEquals(this.body, ast.body, includingPosition) &&
                structuralEquals(this.typeParameterList, ast.typeParameterList, includingPosition) &&
                structuralEquals(this.heritageClauses, ast.heritageClauses, includingPosition);
        };
        return InterfaceDeclaration;
    }(AST));
    TypeScript.InterfaceDeclaration = InterfaceDeclaration;
    var HeritageClause = (function (_super) {
        __extends(HeritageClause, _super);
        function HeritageClause(_nodeType, typeNames) {
            var _this = _super.call(this) || this;
            _this._nodeType = _nodeType;
            _this.typeNames = typeNames;
            typeNames && (typeNames.parent = _this);
            return _this;
        }
        HeritageClause.prototype.kind = function () {
            return this._nodeType;
        };
        HeritageClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.typeNames, ast.typeNames, includingPosition);
        };
        return HeritageClause;
    }(AST));
    TypeScript.HeritageClause = HeritageClause;
    var ModuleDeclaration = (function (_super) {
        __extends(ModuleDeclaration, _super);
        function ModuleDeclaration(modifiers, name, stringLiteral, moduleElements, endingToken) {
            var _this = _super.call(this) || this;
            _this.modifiers = modifiers;
            _this.name = name;
            _this.stringLiteral = stringLiteral;
            _this.moduleElements = moduleElements;
            _this.endingToken = endingToken;
            name && (name.parent = _this);
            stringLiteral && (stringLiteral.parent = _this);
            moduleElements && (moduleElements.parent = _this);
            return _this;
        }
        ModuleDeclaration.prototype.kind = function () {
            return TypeScript.SyntaxKind.ModuleDeclaration;
        };
        ModuleDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.name, ast.name, includingPosition) &&
                structuralEquals(this.moduleElements, ast.moduleElements, includingPosition);
        };
        return ModuleDeclaration;
    }(AST));
    TypeScript.ModuleDeclaration = ModuleDeclaration;
    var FunctionDeclaration = (function (_super) {
        __extends(FunctionDeclaration, _super);
        function FunctionDeclaration(modifiers, identifier, callSignature, block) {
            var _this = _super.call(this) || this;
            _this.modifiers = modifiers;
            _this.identifier = identifier;
            _this.callSignature = callSignature;
            _this.block = block;
            identifier && (identifier.parent = _this);
            callSignature && (callSignature.parent = _this);
            block && (block.parent = _this);
            return _this;
        }
        FunctionDeclaration.prototype.kind = function () {
            return TypeScript.SyntaxKind.FunctionDeclaration;
        };
        FunctionDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.identifier, ast.identifier, includingPosition) &&
                structuralEquals(this.block, ast.block, includingPosition) &&
                structuralEquals(this.callSignature, ast.callSignature, includingPosition);
        };
        return FunctionDeclaration;
    }(AST));
    TypeScript.FunctionDeclaration = FunctionDeclaration;
    var VariableStatement = (function (_super) {
        __extends(VariableStatement, _super);
        function VariableStatement(modifiers, declaration) {
            var _this = _super.call(this) || this;
            _this.modifiers = modifiers;
            _this.declaration = declaration;
            declaration && (declaration.parent = _this);
            return _this;
        }
        VariableStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.VariableStatement;
        };
        VariableStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.declaration, ast.declaration, includingPosition);
        };
        return VariableStatement;
    }(AST));
    TypeScript.VariableStatement = VariableStatement;
    var VariableDeclaration = (function (_super) {
        __extends(VariableDeclaration, _super);
        function VariableDeclaration(declarators) {
            var _this = _super.call(this) || this;
            _this.declarators = declarators;
            declarators && (declarators.parent = _this);
            return _this;
        }
        VariableDeclaration.prototype.kind = function () {
            return TypeScript.SyntaxKind.VariableDeclaration;
        };
        VariableDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.declarators, ast.declarators, includingPosition);
        };
        return VariableDeclaration;
    }(AST));
    TypeScript.VariableDeclaration = VariableDeclaration;
    var VariableDeclarator = (function (_super) {
        __extends(VariableDeclarator, _super);
        function VariableDeclarator(propertyName, typeAnnotation, equalsValueClause) {
            var _this = _super.call(this) || this;
            _this.propertyName = propertyName;
            _this.typeAnnotation = typeAnnotation;
            _this.equalsValueClause = equalsValueClause;
            propertyName && (propertyName.parent = _this);
            typeAnnotation && (typeAnnotation.parent = _this);
            equalsValueClause && (equalsValueClause.parent = _this);
            return _this;
        }
        VariableDeclarator.prototype.kind = function () {
            return TypeScript.SyntaxKind.VariableDeclarator;
        };
        return VariableDeclarator;
    }(AST));
    TypeScript.VariableDeclarator = VariableDeclarator;
    var EqualsValueClause = (function (_super) {
        __extends(EqualsValueClause, _super);
        function EqualsValueClause(value) {
            var _this = _super.call(this) || this;
            _this.value = value;
            value && (value.parent = _this);
            return _this;
        }
        EqualsValueClause.prototype.kind = function () {
            return TypeScript.SyntaxKind.EqualsValueClause;
        };
        return EqualsValueClause;
    }(AST));
    TypeScript.EqualsValueClause = EqualsValueClause;
    var PrefixUnaryExpression = (function (_super) {
        __extends(PrefixUnaryExpression, _super);
        function PrefixUnaryExpression(_nodeType, operand) {
            var _this = _super.call(this) || this;
            _this._nodeType = _nodeType;
            _this.operand = operand;
            operand && (operand.parent = _this);
            return _this;
        }
        PrefixUnaryExpression.prototype.kind = function () {
            return this._nodeType;
        };
        PrefixUnaryExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.operand, ast.operand, includingPosition);
        };
        return PrefixUnaryExpression;
    }(AST));
    TypeScript.PrefixUnaryExpression = PrefixUnaryExpression;
    var ArrayLiteralExpression = (function (_super) {
        __extends(ArrayLiteralExpression, _super);
        function ArrayLiteralExpression(expressions, newLineMode) {
            if (newLineMode === void 0) { newLineMode = NewLineMode.None; }
            var _this = _super.call(this) || this;
            _this.expressions = expressions;
            _this.newLineMode = newLineMode;
            expressions && (expressions.parent = _this);
            return _this;
        }
        ArrayLiteralExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.ArrayLiteralExpression;
        };
        ArrayLiteralExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.expressions, ast.expressions, includingPosition);
        };
        return ArrayLiteralExpression;
    }(AST));
    TypeScript.ArrayLiteralExpression = ArrayLiteralExpression;
    var OmittedExpression = (function (_super) {
        __extends(OmittedExpression, _super);
        function OmittedExpression() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OmittedExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.OmittedExpression;
        };
        OmittedExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return OmittedExpression;
    }(AST));
    TypeScript.OmittedExpression = OmittedExpression;
    var ParenthesizedExpression = (function (_super) {
        __extends(ParenthesizedExpression, _super);
        function ParenthesizedExpression(openParenTrailingComments, expression) {
            var _this = _super.call(this) || this;
            _this.openParenTrailingComments = openParenTrailingComments;
            _this.expression = expression;
            expression && (expression.parent = _this);
            return _this;
        }
        ParenthesizedExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.ParenthesizedExpression;
        };
        ParenthesizedExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ParenthesizedExpression;
    }(AST));
    TypeScript.ParenthesizedExpression = ParenthesizedExpression;
    var SimpleArrowFunctionExpression = (function (_super) {
        __extends(SimpleArrowFunctionExpression, _super);
        function SimpleArrowFunctionExpression(identifier, block, expression) {
            var _this = _super.call(this) || this;
            _this.identifier = identifier;
            _this.block = block;
            _this.expression = expression;
            identifier && (identifier.parent = _this);
            block && (block.parent = _this);
            expression && (expression.parent = _this);
            return _this;
        }
        SimpleArrowFunctionExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.SimpleArrowFunctionExpression;
        };
        return SimpleArrowFunctionExpression;
    }(AST));
    TypeScript.SimpleArrowFunctionExpression = SimpleArrowFunctionExpression;
    var ParenthesizedArrowFunctionExpression = (function (_super) {
        __extends(ParenthesizedArrowFunctionExpression, _super);
        function ParenthesizedArrowFunctionExpression(callSignature, block, expression) {
            var _this = _super.call(this) || this;
            _this.callSignature = callSignature;
            _this.block = block;
            _this.expression = expression;
            callSignature && (callSignature.parent = _this);
            block && (block.parent = _this);
            expression && (expression.parent = _this);
            return _this;
        }
        ParenthesizedArrowFunctionExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression;
        };
        return ParenthesizedArrowFunctionExpression;
    }(AST));
    TypeScript.ParenthesizedArrowFunctionExpression = ParenthesizedArrowFunctionExpression;
    var QualifiedName = (function (_super) {
        __extends(QualifiedName, _super);
        function QualifiedName(left, right) {
            var _this = _super.call(this) || this;
            _this.left = left;
            _this.right = right;
            left && (left.parent = _this);
            right && (right.parent = _this);
            return _this;
        }
        QualifiedName.prototype.kind = function () {
            return TypeScript.SyntaxKind.QualifiedName;
        };
        QualifiedName.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.left, ast.left, includingPosition) &&
                structuralEquals(this.right, ast.right, includingPosition);
        };
        return QualifiedName;
    }(AST));
    TypeScript.QualifiedName = QualifiedName;
    var ParameterList = (function (_super) {
        __extends(ParameterList, _super);
        function ParameterList(openParenTrailingComments, parameters) {
            var _this = _super.call(this) || this;
            _this.openParenTrailingComments = openParenTrailingComments;
            _this.parameters = parameters;
            parameters && (parameters.parent = _this);
            return _this;
        }
        ParameterList.prototype.kind = function () {
            return TypeScript.SyntaxKind.ParameterList;
        };
        return ParameterList;
    }(AST));
    TypeScript.ParameterList = ParameterList;
    var ConstructorType = (function (_super) {
        __extends(ConstructorType, _super);
        function ConstructorType(typeParameterList, parameterList, type) {
            var _this = _super.call(this) || this;
            _this.typeParameterList = typeParameterList;
            _this.parameterList = parameterList;
            _this.type = type;
            typeParameterList && (typeParameterList.parent = _this);
            parameterList && (parameterList.parent = _this);
            type && (type.parent = _this);
            return _this;
        }
        ConstructorType.prototype.kind = function () {
            return TypeScript.SyntaxKind.ConstructorType;
        };
        return ConstructorType;
    }(AST));
    TypeScript.ConstructorType = ConstructorType;
    var FunctionType = (function (_super) {
        __extends(FunctionType, _super);
        function FunctionType(typeParameterList, parameterList, type) {
            var _this = _super.call(this) || this;
            _this.typeParameterList = typeParameterList;
            _this.parameterList = parameterList;
            _this.type = type;
            typeParameterList && (typeParameterList.parent = _this);
            parameterList && (parameterList.parent = _this);
            type && (type.parent = _this);
            return _this;
        }
        FunctionType.prototype.kind = function () {
            return TypeScript.SyntaxKind.FunctionType;
        };
        return FunctionType;
    }(AST));
    TypeScript.FunctionType = FunctionType;
    var ObjectType = (function (_super) {
        __extends(ObjectType, _super);
        function ObjectType(typeMembers) {
            var _this = _super.call(this) || this;
            _this.typeMembers = typeMembers;
            typeMembers && (typeMembers.parent = _this);
            return _this;
        }
        ObjectType.prototype.kind = function () {
            return TypeScript.SyntaxKind.ObjectType;
        };
        ObjectType.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.typeMembers, ast.typeMembers, includingPosition);
        };
        return ObjectType;
    }(AST));
    TypeScript.ObjectType = ObjectType;
    var ArrayType = (function (_super) {
        __extends(ArrayType, _super);
        function ArrayType(type) {
            var _this = _super.call(this) || this;
            _this.type = type;
            type && (type.parent = _this);
            return _this;
        }
        ArrayType.prototype.kind = function () {
            return TypeScript.SyntaxKind.ArrayType;
        };
        ArrayType.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.type, ast.type, includingPosition);
        };
        return ArrayType;
    }(AST));
    TypeScript.ArrayType = ArrayType;
    var TupleType = (function (_super) {
        __extends(TupleType, _super);
        function TupleType(type) {
            var _this = _super.call(this) || this;
            _this.type = type;
            type && (type.parent = _this);
            return _this;
        }
        TupleType.prototype.kind = function () {
            return TypeScript.SyntaxKind.TupleType;
        };
        TupleType.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.type, ast.type, includingPosition);
        };
        return TupleType;
    }(AST));
    TypeScript.TupleType = TupleType;
    var TypeArgumentList = (function (_super) {
        __extends(TypeArgumentList, _super);
        function TypeArgumentList(typeArguments) {
            var _this = _super.call(this) || this;
            _this.typeArguments = typeArguments;
            typeArguments && (typeArguments.parent = _this);
            return _this;
        }
        TypeArgumentList.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeArgumentList;
        };
        return TypeArgumentList;
    }(AST));
    TypeScript.TypeArgumentList = TypeArgumentList;
    var GenericType = (function (_super) {
        __extends(GenericType, _super);
        function GenericType(name, typeArgumentList) {
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.typeArgumentList = typeArgumentList;
            name && (name.parent = _this);
            typeArgumentList && (typeArgumentList.parent = _this);
            return _this;
        }
        GenericType.prototype.kind = function () {
            return TypeScript.SyntaxKind.GenericType;
        };
        GenericType.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.name, ast.name, includingPosition) &&
                structuralEquals(this.typeArgumentList, ast.typeArgumentList, includingPosition);
        };
        return GenericType;
    }(AST));
    TypeScript.GenericType = GenericType;
    var TypeQuery = (function (_super) {
        __extends(TypeQuery, _super);
        function TypeQuery(name) {
            var _this = _super.call(this) || this;
            _this.name = name;
            name && (name.parent = _this);
            return _this;
        }
        TypeQuery.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeQuery;
        };
        TypeQuery.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.name, ast.name, includingPosition);
        };
        return TypeQuery;
    }(AST));
    TypeScript.TypeQuery = TypeQuery;
    var Block = (function (_super) {
        __extends(Block, _super);
        function Block(statements, closeBraceLeadingComments, closeBraceToken) {
            var _this = _super.call(this) || this;
            _this.statements = statements;
            _this.closeBraceLeadingComments = closeBraceLeadingComments;
            _this.closeBraceToken = closeBraceToken;
            statements && (statements.parent = _this);
            return _this;
        }
        Block.prototype.kind = function () {
            return TypeScript.SyntaxKind.Block;
        };
        Block.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.statements, ast.statements, includingPosition);
        };
        return Block;
    }(AST));
    TypeScript.Block = Block;
    var Parameter = (function (_super) {
        __extends(Parameter, _super);
        function Parameter(dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause) {
            var _this = _super.call(this) || this;
            _this.dotDotDotToken = dotDotDotToken;
            _this.modifiers = modifiers;
            _this.identifier = identifier;
            _this.questionToken = questionToken;
            _this.typeAnnotation = typeAnnotation;
            _this.equalsValueClause = equalsValueClause;
            identifier && (identifier.parent = _this);
            typeAnnotation && (typeAnnotation.parent = _this);
            equalsValueClause && (equalsValueClause.parent = _this);
            return _this;
        }
        Parameter.prototype.kind = function () {
            return TypeScript.SyntaxKind.Parameter;
        };
        return Parameter;
    }(AST));
    TypeScript.Parameter = Parameter;
    var MemberAccessExpression = (function (_super) {
        __extends(MemberAccessExpression, _super);
        function MemberAccessExpression(expression, name) {
            var _this = _super.call(this) || this;
            _this.expression = expression;
            _this.name = name;
            expression && (expression.parent = _this);
            name && (name.parent = _this);
            return _this;
        }
        MemberAccessExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.MemberAccessExpression;
        };
        MemberAccessExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition) &&
                structuralEquals(this.name, ast.name, includingPosition);
        };
        return MemberAccessExpression;
    }(AST));
    TypeScript.MemberAccessExpression = MemberAccessExpression;
    var PostfixUnaryExpression = (function (_super) {
        __extends(PostfixUnaryExpression, _super);
        function PostfixUnaryExpression(_nodeType, operand) {
            var _this = _super.call(this) || this;
            _this._nodeType = _nodeType;
            _this.operand = operand;
            operand && (operand.parent = _this);
            return _this;
        }
        PostfixUnaryExpression.prototype.kind = function () {
            return this._nodeType;
        };
        PostfixUnaryExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.operand, ast.operand, includingPosition);
        };
        return PostfixUnaryExpression;
    }(AST));
    TypeScript.PostfixUnaryExpression = PostfixUnaryExpression;
    var ElementAccessExpression = (function (_super) {
        __extends(ElementAccessExpression, _super);
        function ElementAccessExpression(expression, argumentExpression) {
            var _this = _super.call(this) || this;
            _this.expression = expression;
            _this.argumentExpression = argumentExpression;
            expression && (expression.parent = _this);
            argumentExpression && (argumentExpression.parent = _this);
            return _this;
        }
        ElementAccessExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.ElementAccessExpression;
        };
        ElementAccessExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition) &&
                structuralEquals(this.argumentExpression, ast.argumentExpression, includingPosition);
        };
        return ElementAccessExpression;
    }(AST));
    TypeScript.ElementAccessExpression = ElementAccessExpression;
    var InvocationExpression = (function (_super) {
        __extends(InvocationExpression, _super);
        function InvocationExpression(expression, argumentList) {
            var _this = _super.call(this) || this;
            _this.expression = expression;
            _this.argumentList = argumentList;
            _this.inferredTypeArgs = null;
            _this.resolvedSignatureIndex = 0;
            expression && (expression.parent = _this);
            argumentList && (argumentList.parent = _this);
            return _this;
        }
        InvocationExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.InvocationExpression;
        };
        InvocationExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition) &&
                structuralEquals(this.argumentList, ast.argumentList, includingPosition);
        };
        return InvocationExpression;
    }(AST));
    TypeScript.InvocationExpression = InvocationExpression;
    var ArgumentList = (function (_super) {
        __extends(ArgumentList, _super);
        function ArgumentList(typeArgumentList, args, closeParenToken) {
            var _this = _super.call(this) || this;
            _this.typeArgumentList = typeArgumentList;
            _this.args = args;
            _this.closeParenToken = closeParenToken;
            typeArgumentList && (typeArgumentList.parent = _this);
            args && (args.parent = _this);
            return _this;
        }
        ArgumentList.prototype.kind = function () {
            return TypeScript.SyntaxKind.ArgumentList;
        };
        return ArgumentList;
    }(AST));
    TypeScript.ArgumentList = ArgumentList;
    var BinaryExpression = (function (_super) {
        __extends(BinaryExpression, _super);
        function BinaryExpression(_nodeType, left, right) {
            var _this = _super.call(this) || this;
            _this._nodeType = _nodeType;
            _this.left = left;
            _this.right = right;
            left && (left.parent = _this);
            right && (right.parent = _this);
            return _this;
        }
        BinaryExpression.prototype.kind = function () {
            return this._nodeType;
        };
        BinaryExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.left, ast.left, includingPosition) &&
                structuralEquals(this.right, ast.right, includingPosition);
        };
        return BinaryExpression;
    }(AST));
    TypeScript.BinaryExpression = BinaryExpression;
    var ConditionalExpression = (function (_super) {
        __extends(ConditionalExpression, _super);
        function ConditionalExpression(condition, whenTrue, whenFalse) {
            var _this = _super.call(this) || this;
            _this.condition = condition;
            _this.whenTrue = whenTrue;
            _this.whenFalse = whenFalse;
            condition && (condition.parent = _this);
            whenTrue && (whenTrue.parent = _this);
            whenFalse && (whenFalse.parent = _this);
            return _this;
        }
        ConditionalExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.ConditionalExpression;
        };
        ConditionalExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.condition, ast.condition, includingPosition) &&
                structuralEquals(this.whenTrue, ast.whenTrue, includingPosition) &&
                structuralEquals(this.whenFalse, ast.whenFalse, includingPosition);
        };
        return ConditionalExpression;
    }(AST));
    TypeScript.ConditionalExpression = ConditionalExpression;
    var ConstructSignature = (function (_super) {
        __extends(ConstructSignature, _super);
        function ConstructSignature(callSignature) {
            var _this = _super.call(this) || this;
            _this.callSignature = callSignature;
            callSignature && (callSignature.parent = _this);
            return _this;
        }
        ConstructSignature.prototype.kind = function () {
            return TypeScript.SyntaxKind.ConstructSignature;
        };
        return ConstructSignature;
    }(AST));
    TypeScript.ConstructSignature = ConstructSignature;
    var MethodSignature = (function (_super) {
        __extends(MethodSignature, _super);
        function MethodSignature(propertyName, questionToken, callSignature) {
            var _this = _super.call(this) || this;
            _this.propertyName = propertyName;
            _this.questionToken = questionToken;
            _this.callSignature = callSignature;
            propertyName && (propertyName.parent = _this);
            callSignature && (callSignature.parent = _this);
            return _this;
        }
        MethodSignature.prototype.kind = function () {
            return TypeScript.SyntaxKind.MethodSignature;
        };
        return MethodSignature;
    }(AST));
    TypeScript.MethodSignature = MethodSignature;
    var IndexSignature = (function (_super) {
        __extends(IndexSignature, _super);
        function IndexSignature(parameter, typeAnnotation) {
            var _this = _super.call(this) || this;
            _this.parameter = parameter;
            _this.typeAnnotation = typeAnnotation;
            parameter && (parameter.parent = _this);
            typeAnnotation && (typeAnnotation.parent = _this);
            return _this;
        }
        IndexSignature.prototype.kind = function () {
            return TypeScript.SyntaxKind.IndexSignature;
        };
        return IndexSignature;
    }(AST));
    TypeScript.IndexSignature = IndexSignature;
    var PropertySignature = (function (_super) {
        __extends(PropertySignature, _super);
        function PropertySignature(propertyName, questionToken, typeAnnotation) {
            var _this = _super.call(this) || this;
            _this.propertyName = propertyName;
            _this.questionToken = questionToken;
            _this.typeAnnotation = typeAnnotation;
            propertyName && (propertyName.parent = _this);
            typeAnnotation && (typeAnnotation.parent = _this);
            return _this;
        }
        PropertySignature.prototype.kind = function () {
            return TypeScript.SyntaxKind.PropertySignature;
        };
        return PropertySignature;
    }(AST));
    TypeScript.PropertySignature = PropertySignature;
    var CallSignature = (function (_super) {
        __extends(CallSignature, _super);
        function CallSignature(typeParameterList, parameterList, typeAnnotation) {
            var _this = _super.call(this) || this;
            _this.typeParameterList = typeParameterList;
            _this.parameterList = parameterList;
            _this.typeAnnotation = typeAnnotation;
            typeParameterList && (typeParameterList.parent = _this);
            parameterList && (parameterList.parent = _this);
            typeAnnotation && (typeAnnotation.parent = _this);
            return _this;
        }
        CallSignature.prototype.kind = function () {
            return TypeScript.SyntaxKind.CallSignature;
        };
        return CallSignature;
    }(AST));
    TypeScript.CallSignature = CallSignature;
    var TypeParameter = (function (_super) {
        __extends(TypeParameter, _super);
        function TypeParameter(identifier, constraint) {
            var _this = _super.call(this) || this;
            _this.identifier = identifier;
            _this.constraint = constraint;
            identifier && (identifier.parent = _this);
            constraint && (constraint.parent = _this);
            return _this;
        }
        TypeParameter.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeParameter;
        };
        TypeParameter.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.identifier, ast.identifier, includingPosition) &&
                structuralEquals(this.constraint, ast.constraint, includingPosition);
        };
        return TypeParameter;
    }(AST));
    TypeScript.TypeParameter = TypeParameter;
    var Constraint = (function (_super) {
        __extends(Constraint, _super);
        function Constraint(type) {
            var _this = _super.call(this) || this;
            _this.type = type;
            type && (type.parent = _this);
            return _this;
        }
        Constraint.prototype.kind = function () {
            return TypeScript.SyntaxKind.Constraint;
        };
        return Constraint;
    }(AST));
    TypeScript.Constraint = Constraint;
    var ElseClause = (function (_super) {
        __extends(ElseClause, _super);
        function ElseClause(statement) {
            var _this = _super.call(this) || this;
            _this.statement = statement;
            statement && (statement.parent = _this);
            return _this;
        }
        ElseClause.prototype.kind = function () {
            return TypeScript.SyntaxKind.ElseClause;
        };
        ElseClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.statement, ast.statement, includingPosition);
        };
        return ElseClause;
    }(AST));
    TypeScript.ElseClause = ElseClause;
    var IfStatement = (function (_super) {
        __extends(IfStatement, _super);
        function IfStatement(condition, statement, elseClause) {
            var _this = _super.call(this) || this;
            _this.condition = condition;
            _this.statement = statement;
            _this.elseClause = elseClause;
            condition && (condition.parent = _this);
            statement && (statement.parent = _this);
            elseClause && (elseClause.parent = _this);
            return _this;
        }
        IfStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.IfStatement;
        };
        IfStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.condition, ast.condition, includingPosition) &&
                structuralEquals(this.statement, ast.statement, includingPosition) &&
                structuralEquals(this.elseClause, ast.elseClause, includingPosition);
        };
        return IfStatement;
    }(AST));
    TypeScript.IfStatement = IfStatement;
    var ExpressionStatement = (function (_super) {
        __extends(ExpressionStatement, _super);
        function ExpressionStatement(expression) {
            var _this = _super.call(this) || this;
            _this.expression = expression;
            expression && (expression.parent = _this);
            return _this;
        }
        ExpressionStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.ExpressionStatement;
        };
        ExpressionStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ExpressionStatement;
    }(AST));
    TypeScript.ExpressionStatement = ExpressionStatement;
    var ConstructorDeclaration = (function (_super) {
        __extends(ConstructorDeclaration, _super);
        function ConstructorDeclaration(parameterList, block) {
            var _this = _super.call(this) || this;
            _this.parameterList = parameterList;
            _this.block = block;
            parameterList && (parameterList.parent = _this);
            block && (block.parent = _this);
            return _this;
        }
        ConstructorDeclaration.prototype.kind = function () {
            return TypeScript.SyntaxKind.ConstructorDeclaration;
        };
        return ConstructorDeclaration;
    }(AST));
    TypeScript.ConstructorDeclaration = ConstructorDeclaration;
    var MemberFunctionDeclaration = (function (_super) {
        __extends(MemberFunctionDeclaration, _super);
        function MemberFunctionDeclaration(modifiers, propertyName, callSignature, block) {
            var _this = _super.call(this) || this;
            _this.modifiers = modifiers;
            _this.propertyName = propertyName;
            _this.callSignature = callSignature;
            _this.block = block;
            propertyName && (propertyName.parent = _this);
            callSignature && (callSignature.parent = _this);
            block && (block.parent = _this);
            return _this;
        }
        MemberFunctionDeclaration.prototype.kind = function () {
            return TypeScript.SyntaxKind.MemberFunctionDeclaration;
        };
        return MemberFunctionDeclaration;
    }(AST));
    TypeScript.MemberFunctionDeclaration = MemberFunctionDeclaration;
    var GetAccessor = (function (_super) {
        __extends(GetAccessor, _super);
        function GetAccessor(modifiers, propertyName, parameterList, typeAnnotation, block) {
            var _this = _super.call(this) || this;
            _this.modifiers = modifiers;
            _this.propertyName = propertyName;
            _this.parameterList = parameterList;
            _this.typeAnnotation = typeAnnotation;
            _this.block = block;
            propertyName && (propertyName.parent = _this);
            parameterList && (parameterList.parent = _this);
            typeAnnotation && (typeAnnotation.parent = _this);
            block && (block.parent = _this);
            return _this;
        }
        GetAccessor.prototype.kind = function () {
            return TypeScript.SyntaxKind.GetAccessor;
        };
        return GetAccessor;
    }(AST));
    TypeScript.GetAccessor = GetAccessor;
    var SetAccessor = (function (_super) {
        __extends(SetAccessor, _super);
        function SetAccessor(modifiers, propertyName, parameterList, block) {
            var _this = _super.call(this) || this;
            _this.modifiers = modifiers;
            _this.propertyName = propertyName;
            _this.parameterList = parameterList;
            _this.block = block;
            propertyName && (propertyName.parent = _this);
            parameterList && (parameterList.parent = _this);
            block && (block.parent = _this);
            return _this;
        }
        SetAccessor.prototype.kind = function () {
            return TypeScript.SyntaxKind.SetAccessor;
        };
        return SetAccessor;
    }(AST));
    TypeScript.SetAccessor = SetAccessor;
    var MemberVariableDeclaration = (function (_super) {
        __extends(MemberVariableDeclaration, _super);
        function MemberVariableDeclaration(modifiers, variableDeclarator) {
            var _this = _super.call(this) || this;
            _this.modifiers = modifiers;
            _this.variableDeclarator = variableDeclarator;
            variableDeclarator && (variableDeclarator.parent = _this);
            return _this;
        }
        MemberVariableDeclaration.prototype.kind = function () {
            return TypeScript.SyntaxKind.MemberVariableDeclaration;
        };
        return MemberVariableDeclaration;
    }(AST));
    TypeScript.MemberVariableDeclaration = MemberVariableDeclaration;
    var IndexMemberDeclaration = (function (_super) {
        __extends(IndexMemberDeclaration, _super);
        function IndexMemberDeclaration(indexSignature) {
            var _this = _super.call(this) || this;
            _this.indexSignature = indexSignature;
            indexSignature && (indexSignature.parent = _this);
            return _this;
        }
        IndexMemberDeclaration.prototype.kind = function () {
            return TypeScript.SyntaxKind.IndexMemberDeclaration;
        };
        return IndexMemberDeclaration;
    }(AST));
    TypeScript.IndexMemberDeclaration = IndexMemberDeclaration;
    var ThrowStatement = (function (_super) {
        __extends(ThrowStatement, _super);
        function ThrowStatement(expression) {
            var _this = _super.call(this) || this;
            _this.expression = expression;
            expression && (expression.parent = _this);
            return _this;
        }
        ThrowStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.ThrowStatement;
        };
        ThrowStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ThrowStatement;
    }(AST));
    TypeScript.ThrowStatement = ThrowStatement;
    var ReturnStatement = (function (_super) {
        __extends(ReturnStatement, _super);
        function ReturnStatement(expression) {
            var _this = _super.call(this) || this;
            _this.expression = expression;
            expression && (expression.parent = _this);
            return _this;
        }
        ReturnStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.ReturnStatement;
        };
        ReturnStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ReturnStatement;
    }(AST));
    TypeScript.ReturnStatement = ReturnStatement;
    var ObjectCreationExpression = (function (_super) {
        __extends(ObjectCreationExpression, _super);
        function ObjectCreationExpression(expression, argumentList) {
            var _this = _super.call(this) || this;
            _this.expression = expression;
            _this.argumentList = argumentList;
            _this.inferredTypeArgs = null;
            _this.resolvedSignatureIndex = 0;
            expression && (expression.parent = _this);
            argumentList && (argumentList.parent = _this);
            return _this;
        }
        ObjectCreationExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.ObjectCreationExpression;
        };
        ObjectCreationExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition) &&
                structuralEquals(this.argumentList, ast.argumentList, includingPosition);
        };
        return ObjectCreationExpression;
    }(AST));
    TypeScript.ObjectCreationExpression = ObjectCreationExpression;
    var SwitchStatement = (function (_super) {
        __extends(SwitchStatement, _super);
        function SwitchStatement(expression, closeParenToken, switchClauses) {
            var _this = _super.call(this) || this;
            _this.expression = expression;
            _this.closeParenToken = closeParenToken;
            _this.switchClauses = switchClauses;
            expression && (expression.parent = _this);
            switchClauses && (switchClauses.parent = _this);
            return _this;
        }
        SwitchStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.SwitchStatement;
        };
        SwitchStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.switchClauses, ast.switchClauses, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return SwitchStatement;
    }(AST));
    TypeScript.SwitchStatement = SwitchStatement;
    var CaseSwitchClause = (function (_super) {
        __extends(CaseSwitchClause, _super);
        function CaseSwitchClause(expression, statements) {
            var _this = _super.call(this) || this;
            _this.expression = expression;
            _this.statements = statements;
            expression && (expression.parent = _this);
            statements && (statements.parent = _this);
            return _this;
        }
        CaseSwitchClause.prototype.kind = function () {
            return TypeScript.SyntaxKind.CaseSwitchClause;
        };
        CaseSwitchClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition) &&
                structuralEquals(this.statements, ast.statements, includingPosition);
        };
        return CaseSwitchClause;
    }(AST));
    TypeScript.CaseSwitchClause = CaseSwitchClause;
    var DefaultSwitchClause = (function (_super) {
        __extends(DefaultSwitchClause, _super);
        function DefaultSwitchClause(statements) {
            var _this = _super.call(this) || this;
            _this.statements = statements;
            statements && (statements.parent = _this);
            return _this;
        }
        DefaultSwitchClause.prototype.kind = function () {
            return TypeScript.SyntaxKind.DefaultSwitchClause;
        };
        DefaultSwitchClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.statements, ast.statements, includingPosition);
        };
        return DefaultSwitchClause;
    }(AST));
    TypeScript.DefaultSwitchClause = DefaultSwitchClause;
    var BreakStatement = (function (_super) {
        __extends(BreakStatement, _super);
        function BreakStatement(identifier) {
            var _this = _super.call(this) || this;
            _this.identifier = identifier;
            return _this;
        }
        BreakStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.BreakStatement;
        };
        BreakStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return BreakStatement;
    }(AST));
    TypeScript.BreakStatement = BreakStatement;
    var ContinueStatement = (function (_super) {
        __extends(ContinueStatement, _super);
        function ContinueStatement(identifier) {
            var _this = _super.call(this) || this;
            _this.identifier = identifier;
            return _this;
        }
        ContinueStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.ContinueStatement;
        };
        ContinueStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return ContinueStatement;
    }(AST));
    TypeScript.ContinueStatement = ContinueStatement;
    var ForStatement = (function (_super) {
        __extends(ForStatement, _super);
        function ForStatement(variableDeclaration, initializer, condition, incrementor, statement) {
            var _this = _super.call(this) || this;
            _this.variableDeclaration = variableDeclaration;
            _this.initializer = initializer;
            _this.condition = condition;
            _this.incrementor = incrementor;
            _this.statement = statement;
            variableDeclaration && (variableDeclaration.parent = _this);
            initializer && (initializer.parent = _this);
            condition && (condition.parent = _this);
            incrementor && (incrementor.parent = _this);
            statement && (statement.parent = _this);
            return _this;
        }
        ForStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.ForStatement;
        };
        ForStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.initializer, ast.initializer, includingPosition) &&
                structuralEquals(this.condition, ast.condition, includingPosition) &&
                structuralEquals(this.incrementor, ast.incrementor, includingPosition) &&
                structuralEquals(this.statement, ast.statement, includingPosition);
        };
        return ForStatement;
    }(AST));
    TypeScript.ForStatement = ForStatement;
    var ForInStatement = (function (_super) {
        __extends(ForInStatement, _super);
        function ForInStatement(variableDeclaration, left, expression, statement) {
            var _this = _super.call(this) || this;
            _this.variableDeclaration = variableDeclaration;
            _this.left = left;
            _this.expression = expression;
            _this.statement = statement;
            variableDeclaration && (variableDeclaration.parent = _this);
            left && (left.parent = _this);
            expression && (expression.parent = _this);
            statement && (statement.parent = _this);
            return _this;
        }
        ForInStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.ForInStatement;
        };
        ForInStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.variableDeclaration, ast.variableDeclaration, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition) &&
                structuralEquals(this.statement, ast.statement, includingPosition);
        };
        return ForInStatement;
    }(AST));
    TypeScript.ForInStatement = ForInStatement;
    var WhileStatement = (function (_super) {
        __extends(WhileStatement, _super);
        function WhileStatement(condition, statement) {
            var _this = _super.call(this) || this;
            _this.condition = condition;
            _this.statement = statement;
            condition && (condition.parent = _this);
            statement && (statement.parent = _this);
            return _this;
        }
        WhileStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.WhileStatement;
        };
        WhileStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.condition, ast.condition, includingPosition) &&
                structuralEquals(this.statement, ast.statement, includingPosition);
        };
        return WhileStatement;
    }(AST));
    TypeScript.WhileStatement = WhileStatement;
    var WithStatement = (function (_super) {
        __extends(WithStatement, _super);
        function WithStatement(condition, statement) {
            var _this = _super.call(this) || this;
            _this.condition = condition;
            _this.statement = statement;
            condition && (condition.parent = _this);
            statement && (statement.parent = _this);
            return _this;
        }
        WithStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.WithStatement;
        };
        WithStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.condition, ast.condition, includingPosition) &&
                structuralEquals(this.statement, ast.statement, includingPosition);
        };
        return WithStatement;
    }(AST));
    TypeScript.WithStatement = WithStatement;
    var EnumDeclaration = (function (_super) {
        __extends(EnumDeclaration, _super);
        function EnumDeclaration(modifiers, identifier, enumElements) {
            var _this = _super.call(this) || this;
            _this.modifiers = modifiers;
            _this.identifier = identifier;
            _this.enumElements = enumElements;
            identifier && (identifier.parent = _this);
            enumElements && (enumElements.parent = _this);
            return _this;
        }
        EnumDeclaration.prototype.kind = function () {
            return TypeScript.SyntaxKind.EnumDeclaration;
        };
        return EnumDeclaration;
    }(AST));
    TypeScript.EnumDeclaration = EnumDeclaration;
    var EnumElement = (function (_super) {
        __extends(EnumElement, _super);
        function EnumElement(propertyName, equalsValueClause) {
            var _this = _super.call(this) || this;
            _this.propertyName = propertyName;
            _this.equalsValueClause = equalsValueClause;
            propertyName && (propertyName.parent = _this);
            equalsValueClause && (equalsValueClause.parent = _this);
            return _this;
        }
        EnumElement.prototype.kind = function () {
            return TypeScript.SyntaxKind.EnumElement;
        };
        return EnumElement;
    }(AST));
    TypeScript.EnumElement = EnumElement;
    var CastExpression = (function (_super) {
        __extends(CastExpression, _super);
        function CastExpression(type, expression) {
            var _this = _super.call(this) || this;
            _this.type = type;
            _this.expression = expression;
            type && (type.parent = _this);
            expression && (expression.parent = _this);
            return _this;
        }
        CastExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.CastExpression;
        };
        CastExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.type, ast.type, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return CastExpression;
    }(AST));
    TypeScript.CastExpression = CastExpression;
    var ObjectLiteralExpression = (function (_super) {
        __extends(ObjectLiteralExpression, _super);
        function ObjectLiteralExpression(propertyAssignments, newLineMode) {
            if (newLineMode === void 0) { newLineMode = NewLineMode.None; }
            var _this = _super.call(this) || this;
            _this.propertyAssignments = propertyAssignments;
            _this.newLineMode = newLineMode;
            propertyAssignments && (propertyAssignments.parent = _this);
            return _this;
        }
        ObjectLiteralExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.ObjectLiteralExpression;
        };
        ObjectLiteralExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.propertyAssignments, ast.propertyAssignments, includingPosition);
        };
        return ObjectLiteralExpression;
    }(AST));
    TypeScript.ObjectLiteralExpression = ObjectLiteralExpression;
    var SimplePropertyAssignment = (function (_super) {
        __extends(SimplePropertyAssignment, _super);
        function SimplePropertyAssignment(propertyName, expression) {
            var _this = _super.call(this) || this;
            _this.propertyName = propertyName;
            _this.expression = expression;
            propertyName && (propertyName.parent = _this);
            expression && (expression.parent = _this);
            return _this;
        }
        SimplePropertyAssignment.prototype.kind = function () {
            return TypeScript.SyntaxKind.SimplePropertyAssignment;
        };
        return SimplePropertyAssignment;
    }(AST));
    TypeScript.SimplePropertyAssignment = SimplePropertyAssignment;
    var FunctionPropertyAssignment = (function (_super) {
        __extends(FunctionPropertyAssignment, _super);
        function FunctionPropertyAssignment(propertyName, callSignature, block) {
            var _this = _super.call(this) || this;
            _this.propertyName = propertyName;
            _this.callSignature = callSignature;
            _this.block = block;
            propertyName && (propertyName.parent = _this);
            callSignature && (callSignature.parent = _this);
            block && (block.parent = _this);
            return _this;
        }
        FunctionPropertyAssignment.prototype.kind = function () {
            return TypeScript.SyntaxKind.FunctionPropertyAssignment;
        };
        return FunctionPropertyAssignment;
    }(AST));
    TypeScript.FunctionPropertyAssignment = FunctionPropertyAssignment;
    var FunctionExpression = (function (_super) {
        __extends(FunctionExpression, _super);
        function FunctionExpression(identifier, callSignature, block) {
            var _this = _super.call(this) || this;
            _this.identifier = identifier;
            _this.callSignature = callSignature;
            _this.block = block;
            identifier && (identifier.parent = _this);
            callSignature && (callSignature.parent = _this);
            block && (block.parent = _this);
            return _this;
        }
        FunctionExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.FunctionExpression;
        };
        return FunctionExpression;
    }(AST));
    TypeScript.FunctionExpression = FunctionExpression;
    var EmptyStatement = (function (_super) {
        __extends(EmptyStatement, _super);
        function EmptyStatement() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EmptyStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.EmptyStatement;
        };
        EmptyStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return EmptyStatement;
    }(AST));
    TypeScript.EmptyStatement = EmptyStatement;
    var TryStatement = (function (_super) {
        __extends(TryStatement, _super);
        function TryStatement(block, catchClause, finallyClause) {
            var _this = _super.call(this) || this;
            _this.block = block;
            _this.catchClause = catchClause;
            _this.finallyClause = finallyClause;
            block && (block.parent = _this);
            catchClause && (catchClause.parent = _this);
            finallyClause && (finallyClause.parent = _this);
            return _this;
        }
        TryStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.TryStatement;
        };
        TryStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.block, ast.block, includingPosition) &&
                structuralEquals(this.catchClause, ast.catchClause, includingPosition) &&
                structuralEquals(this.finallyClause, ast.finallyClause, includingPosition);
        };
        return TryStatement;
    }(AST));
    TypeScript.TryStatement = TryStatement;
    var CatchClause = (function (_super) {
        __extends(CatchClause, _super);
        function CatchClause(identifier, typeAnnotation, block) {
            var _this = _super.call(this) || this;
            _this.identifier = identifier;
            _this.typeAnnotation = typeAnnotation;
            _this.block = block;
            identifier && (identifier.parent = _this);
            typeAnnotation && (typeAnnotation.parent = _this);
            block && (block.parent = _this);
            return _this;
        }
        CatchClause.prototype.kind = function () {
            return TypeScript.SyntaxKind.CatchClause;
        };
        CatchClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.identifier, ast.identifier, includingPosition) &&
                structuralEquals(this.typeAnnotation, ast.typeAnnotation, includingPosition) &&
                structuralEquals(this.block, ast.block, includingPosition);
        };
        return CatchClause;
    }(AST));
    TypeScript.CatchClause = CatchClause;
    var FinallyClause = (function (_super) {
        __extends(FinallyClause, _super);
        function FinallyClause(block) {
            var _this = _super.call(this) || this;
            _this.block = block;
            block && (block.parent = _this);
            return _this;
        }
        FinallyClause.prototype.kind = function () {
            return TypeScript.SyntaxKind.FinallyClause;
        };
        FinallyClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.block, ast.block, includingPosition);
        };
        return FinallyClause;
    }(AST));
    TypeScript.FinallyClause = FinallyClause;
    var LabeledStatement = (function (_super) {
        __extends(LabeledStatement, _super);
        function LabeledStatement(identifier, statement) {
            var _this = _super.call(this) || this;
            _this.identifier = identifier;
            _this.statement = statement;
            identifier && (identifier.parent = _this);
            statement && (statement.parent = _this);
            return _this;
        }
        LabeledStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.LabeledStatement;
        };
        LabeledStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.identifier, ast.identifier, includingPosition) &&
                structuralEquals(this.statement, ast.statement, includingPosition);
        };
        return LabeledStatement;
    }(AST));
    TypeScript.LabeledStatement = LabeledStatement;
    var DoStatement = (function (_super) {
        __extends(DoStatement, _super);
        function DoStatement(statement, whileKeyword, condition) {
            var _this = _super.call(this) || this;
            _this.statement = statement;
            _this.whileKeyword = whileKeyword;
            _this.condition = condition;
            statement && (statement.parent = _this);
            condition && (condition.parent = _this);
            return _this;
        }
        DoStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.DoStatement;
        };
        DoStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.statement, ast.statement, includingPosition) &&
                structuralEquals(this.condition, ast.condition, includingPosition);
        };
        return DoStatement;
    }(AST));
    TypeScript.DoStatement = DoStatement;
    var TypeOfExpression = (function (_super) {
        __extends(TypeOfExpression, _super);
        function TypeOfExpression(expression) {
            var _this = _super.call(this) || this;
            _this.expression = expression;
            expression && (expression.parent = _this);
            return _this;
        }
        TypeOfExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeOfExpression;
        };
        TypeOfExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return TypeOfExpression;
    }(AST));
    TypeScript.TypeOfExpression = TypeOfExpression;
    var DeleteExpression = (function (_super) {
        __extends(DeleteExpression, _super);
        function DeleteExpression(expression) {
            var _this = _super.call(this) || this;
            _this.expression = expression;
            expression && (expression.parent = _this);
            return _this;
        }
        DeleteExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.DeleteExpression;
        };
        DeleteExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return DeleteExpression;
    }(AST));
    TypeScript.DeleteExpression = DeleteExpression;
    var VoidExpression = (function (_super) {
        __extends(VoidExpression, _super);
        function VoidExpression(expression) {
            var _this = _super.call(this) || this;
            _this.expression = expression;
            expression && (expression.parent = _this);
            return _this;
        }
        VoidExpression.prototype.kind = function () {
            return TypeScript.SyntaxKind.VoidExpression;
        };
        VoidExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) &&
                structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return VoidExpression;
    }(AST));
    TypeScript.VoidExpression = VoidExpression;
    var DebuggerStatement = (function (_super) {
        __extends(DebuggerStatement, _super);
        function DebuggerStatement() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DebuggerStatement.prototype.kind = function () {
            return TypeScript.SyntaxKind.DebuggerStatement;
        };
        return DebuggerStatement;
    }(AST));
    TypeScript.DebuggerStatement = DebuggerStatement;
    var Comment = (function () {
        function Comment(_trivia, endsLine, _start, _end) {
            this._trivia = _trivia;
            this.endsLine = endsLine;
            this._start = _start;
            this._end = _end;
        }
        Comment.prototype.start = function () {
            return this._start;
        };
        Comment.prototype.end = function () {
            return this._end;
        };
        Comment.prototype.fullText = function () {
            return this._trivia.fullText();
        };
        Comment.prototype.kind = function () {
            return this._trivia.kind();
        };
        Comment.prototype.structuralEquals = function (ast, includingPosition) {
            if (includingPosition) {
                if (this.start() !== ast.start() || this.end() !== ast.end()) {
                    return false;
                }
            }
            return this._trivia.fullText() === ast._trivia.fullText() &&
                this.endsLine === ast.endsLine;
        };
        return Comment;
    }());
    TypeScript.Comment = Comment;
    function diagnosticFromDecl(decl, diagnosticKey, args) {
        if (args === void 0) { args = null; }
        var span = decl.getSpan();
        return new TypeScript.Diagnostic(decl.fileName(), decl.semanticInfoChain().lineMap(decl.fileName()), span.start(), span.length(), diagnosticKey, args);
    }
    TypeScript.diagnosticFromDecl = diagnosticFromDecl;
    function min(a, b) {
        return a <= b ? a : b;
    }
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function scriptIsElided(sourceUnit) {
        return TypeScript.isDTSFile(sourceUnit.fileName()) || moduleMembersAreElided(sourceUnit.moduleElements);
    }
    TypeScript.scriptIsElided = scriptIsElided;
    function moduleIsElided(declaration) {
        return TypeScript.hasModifier(declaration.modifiers, TypeScript.PullElementFlags.Ambient) || moduleMembersAreElided(declaration.moduleElements);
    }
    TypeScript.moduleIsElided = moduleIsElided;
    function moduleMembersAreElided(members) {
        for (var i = 0, n = members.childCount(); i < n; i++) {
            var member = members.childAt(i);
            if (member.kind() === TypeScript.SyntaxKind.ModuleDeclaration) {
                if (!moduleIsElided(member)) {
                    return false;
                }
            }
            else if (member.kind() !== TypeScript.SyntaxKind.InterfaceDeclaration) {
                return false;
            }
        }
        return true;
    }
    function enumIsElided(declaration) {
        if (TypeScript.hasModifier(declaration.modifiers, TypeScript.PullElementFlags.Ambient)) {
            return true;
        }
        return false;
    }
    TypeScript.enumIsElided = enumIsElided;
    function importDeclarationIsElided(importDeclAST, semanticInfoChain, compilationSettings) {
        if (compilationSettings === void 0) { compilationSettings = null; }
        var isExternalModuleReference = importDeclAST.moduleReference.kind() === TypeScript.SyntaxKind.ExternalModuleReference;
        var importDecl = semanticInfoChain.getDeclForAST(importDeclAST);
        var isExported = TypeScript.hasFlag(importDecl.flags, TypeScript.PullElementFlags.Exported);
        var isAmdCodeGen = compilationSettings && compilationSettings.moduleGenTarget() == TypeScript.ModuleGenTarget.Asynchronous;
        if (!isExternalModuleReference ||
            isExported ||
            !isAmdCodeGen) {
            var importSymbol = importDecl.getSymbol();
            if (importDeclAST.moduleReference.kind() !== TypeScript.SyntaxKind.ExternalModuleReference) {
                if (importSymbol.getExportAssignedValueSymbol()) {
                    return true;
                }
                var containerSymbol = importSymbol.getExportAssignedContainerSymbol();
                if (containerSymbol && containerSymbol.getInstanceSymbol()) {
                    return true;
                }
            }
            return importSymbol.isUsedAsValue();
        }
        return false;
    }
    TypeScript.importDeclarationIsElided = importDeclarationIsElided;
    function isValidAstNode(ast) {
        if (!ast)
            return false;
        if (ast.start() === -1 || ast.end() === -1)
            return false;
        return true;
    }
    TypeScript.isValidAstNode = isValidAstNode;
    function getAstAtPosition(script, pos, useTrailingTriviaAsLimChar, forceInclusive) {
        if (useTrailingTriviaAsLimChar === void 0) { useTrailingTriviaAsLimChar = true; }
        if (forceInclusive === void 0) { forceInclusive = false; }
        var top = null;
        var pre = function (cur, walker) {
            if (isValidAstNode(cur)) {
                var isInvalid1 = cur.kind() === TypeScript.SyntaxKind.ExpressionStatement && cur.width() === 0;
                if (isInvalid1) {
                    walker.options.goChildren = false;
                }
                else {
                    var inclusive = forceInclusive ||
                        cur.kind() === TypeScript.SyntaxKind.IdentifierName ||
                        cur.kind() === TypeScript.SyntaxKind.MemberAccessExpression ||
                        cur.kind() === TypeScript.SyntaxKind.QualifiedName ||
                        cur.kind() === TypeScript.SyntaxKind.VariableDeclaration ||
                        cur.kind() === TypeScript.SyntaxKind.VariableDeclarator ||
                        cur.kind() === TypeScript.SyntaxKind.InvocationExpression ||
                        pos === script.end() + script.trailingTriviaWidth();
                    var minChar = cur.start();
                    var limChar = cur.end() + (useTrailingTriviaAsLimChar ? cur.trailingTriviaWidth() : 0) + (inclusive ? 1 : 0);
                    if (pos >= minChar && pos < limChar) {
                        if ((cur.kind() !== TypeScript.SyntaxKind.List && cur.kind() !== TypeScript.SyntaxKind.SeparatedList) || cur.end() > cur.start()) {
                            if (top === null) {
                                top = cur;
                            }
                            else if (cur.start() >= top.start() &&
                                (cur.end() + (useTrailingTriviaAsLimChar ? cur.trailingTriviaWidth() : 0)) <= (top.end() + (useTrailingTriviaAsLimChar ? top.trailingTriviaWidth() : 0))) {
                                if (top.width() !== 0 || cur.width() !== 0) {
                                    top = cur;
                                }
                            }
                        }
                    }
                    walker.options.goChildren = (minChar <= pos && pos <= limChar);
                }
            }
        };
        TypeScript.getAstWalkerFactory().walk(script, pre);
        return top;
    }
    TypeScript.getAstAtPosition = getAstAtPosition;
    function getExtendsHeritageClause(clauses) {
        if (!clauses) {
            return null;
        }
        return clauses.firstOrDefault(function (a) {
            var c = a;
            return c.typeNames.nonSeparatorCount() > 0 && c.kind() === TypeScript.SyntaxKind.ExtendsHeritageClause;
        });
    }
    TypeScript.getExtendsHeritageClause = getExtendsHeritageClause;
    function getImplementsHeritageClause(clauses) {
        if (!clauses) {
            return null;
        }
        return clauses.firstOrDefault(function (a) {
            var c = a;
            return c.typeNames.nonSeparatorCount() > 0 && c.kind() === TypeScript.SyntaxKind.ImplementsHeritageClause;
        });
    }
    TypeScript.getImplementsHeritageClause = getImplementsHeritageClause;
    function isCallExpression(ast) {
        return (ast && ast.kind() === TypeScript.SyntaxKind.InvocationExpression) ||
            (ast && ast.kind() === TypeScript.SyntaxKind.ObjectCreationExpression);
    }
    TypeScript.isCallExpression = isCallExpression;
    function isCallExpressionTarget(ast) {
        if (!ast) {
            return false;
        }
        var current = ast;
        while (current && current.parent) {
            if (current.parent.kind() === TypeScript.SyntaxKind.MemberAccessExpression &&
                current.parent.name === current) {
                current = current.parent;
                continue;
            }
            break;
        }
        if (current && current.parent) {
            if (current.parent.kind() === TypeScript.SyntaxKind.InvocationExpression || current.parent.kind() === TypeScript.SyntaxKind.ObjectCreationExpression) {
                return current === current.parent.expression;
            }
        }
        return false;
    }
    TypeScript.isCallExpressionTarget = isCallExpressionTarget;
    function isNameOfSomeDeclaration(ast) {
        if (ast === null || ast.parent === null) {
            return false;
        }
        if (ast.kind() !== TypeScript.SyntaxKind.IdentifierName) {
            return false;
        }
        switch (ast.parent.kind()) {
            case TypeScript.SyntaxKind.ClassDeclaration:
                return ast.parent.identifier === ast;
            case TypeScript.SyntaxKind.InterfaceDeclaration:
                return ast.parent.identifier === ast;
            case TypeScript.SyntaxKind.EnumDeclaration:
                return ast.parent.identifier === ast;
            case TypeScript.SyntaxKind.ModuleDeclaration:
                return ast.parent.name === ast || ast.parent.stringLiteral === ast;
            case TypeScript.SyntaxKind.VariableDeclarator:
                return ast.parent.propertyName === ast;
            case TypeScript.SyntaxKind.FunctionDeclaration:
                return ast.parent.identifier === ast;
            case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                return ast.parent.propertyName === ast;
            case TypeScript.SyntaxKind.Parameter:
                return ast.parent.identifier === ast;
            case TypeScript.SyntaxKind.TypeParameter:
                return ast.parent.identifier === ast;
            case TypeScript.SyntaxKind.SimplePropertyAssignment:
                return ast.parent.propertyName === ast;
            case TypeScript.SyntaxKind.FunctionPropertyAssignment:
                return ast.parent.propertyName === ast;
            case TypeScript.SyntaxKind.EnumElement:
                return ast.parent.propertyName === ast;
            case TypeScript.SyntaxKind.ImportDeclaration:
                return ast.parent.identifier === ast;
        }
        return false;
    }
    function isDeclarationASTOrDeclarationNameAST(ast) {
        return isNameOfSomeDeclaration(ast) || isDeclarationAST(ast);
    }
    TypeScript.isDeclarationASTOrDeclarationNameAST = isDeclarationASTOrDeclarationNameAST;
    function isNameOfFunction(ast) {
        return ast
            && ast.parent
            && ast.kind() === TypeScript.SyntaxKind.IdentifierName
            && ast.parent.kind() === TypeScript.SyntaxKind.FunctionDeclaration
            && ast.parent.identifier === ast;
    }
    TypeScript.isNameOfFunction = isNameOfFunction;
    function isNameOfMemberFunction(ast) {
        return ast
            && ast.parent
            && ast.kind() === TypeScript.SyntaxKind.IdentifierName
            && ast.parent.kind() === TypeScript.SyntaxKind.MemberFunctionDeclaration
            && ast.parent.propertyName === ast;
    }
    TypeScript.isNameOfMemberFunction = isNameOfMemberFunction;
    function isNameOfMemberAccessExpression(ast) {
        if (ast &&
            ast.parent &&
            ast.parent.kind() === TypeScript.SyntaxKind.MemberAccessExpression &&
            ast.parent.name === ast) {
            return true;
        }
        return false;
    }
    TypeScript.isNameOfMemberAccessExpression = isNameOfMemberAccessExpression;
    function isRightSideOfQualifiedName(ast) {
        if (ast &&
            ast.parent &&
            ast.parent.kind() === TypeScript.SyntaxKind.QualifiedName &&
            ast.parent.right === ast) {
            return true;
        }
        return false;
    }
    TypeScript.isRightSideOfQualifiedName = isRightSideOfQualifiedName;
    var Parameters;
    (function (Parameters) {
        function fromIdentifier(id) {
            return {
                length: 1,
                lastParameterIsRest: function () {
                    return false;
                },
                ast: id,
                astAt: function (index) {
                    return id;
                },
                identifierAt: function (index) {
                    return id;
                },
                typeAt: function (index) {
                    return null;
                },
                initializerAt: function (index) {
                    return null;
                },
                isOptionalAt: function (index) {
                    return false;
                },
            };
        }
        Parameters.fromIdentifier = fromIdentifier;
        function fromParameter(parameter) {
            return {
                length: 1,
                lastParameterIsRest: function () {
                    return parameter.dotDotDotToken !== null;
                },
                ast: parameter,
                astAt: function (index) {
                    return parameter;
                },
                identifierAt: function (index) {
                    return parameter.identifier;
                },
                typeAt: function (index) {
                    return getType(parameter);
                },
                initializerAt: function (index) {
                    return parameter.equalsValueClause;
                },
                isOptionalAt: function (index) {
                    return parameterIsOptional(parameter);
                },
            };
        }
        Parameters.fromParameter = fromParameter;
        function parameterIsOptional(parameter) {
            return parameter.questionToken !== null || parameter.equalsValueClause !== null;
        }
        function fromParameterList(list) {
            var lpr = TypeScript.lastParameterIsRest;
            return {
                length: list.parameters.nonSeparatorCount(),
                lastParameterIsRest: function () {
                    return lpr(list);
                },
                ast: list.parameters,
                astAt: function (index) {
                    return list.parameters.nonSeparatorAt(index);
                },
                identifierAt: function (index) {
                    return list.parameters.nonSeparatorAt(index).identifier;
                },
                typeAt: function (index) {
                    return getType(list.parameters.nonSeparatorAt(index));
                },
                initializerAt: function (index) {
                    return list.parameters.nonSeparatorAt(index).equalsValueClause;
                },
                isOptionalAt: function (index) {
                    return parameterIsOptional(list.parameters.nonSeparatorAt(index));
                }
            };
        }
        Parameters.fromParameterList = fromParameterList;
    })(Parameters = TypeScript.Parameters || (TypeScript.Parameters = {}));
    function isDeclarationAST(ast) {
        switch (ast.kind()) {
            case TypeScript.SyntaxKind.VariableDeclarator:
                return getVariableStatement(ast) !== null;
            case TypeScript.SyntaxKind.ImportDeclaration:
            case TypeScript.SyntaxKind.ClassDeclaration:
            case TypeScript.SyntaxKind.InterfaceDeclaration:
            case TypeScript.SyntaxKind.Parameter:
            case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
            case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
            case TypeScript.SyntaxKind.IndexSignature:
            case TypeScript.SyntaxKind.FunctionDeclaration:
            case TypeScript.SyntaxKind.ModuleDeclaration:
            case TypeScript.SyntaxKind.ArrayType:
            case TypeScript.SyntaxKind.TupleType:
            case TypeScript.SyntaxKind.ObjectType:
            case TypeScript.SyntaxKind.TypeParameter:
            case TypeScript.SyntaxKind.ConstructorDeclaration:
            case TypeScript.SyntaxKind.MemberFunctionDeclaration:
            case TypeScript.SyntaxKind.GetAccessor:
            case TypeScript.SyntaxKind.SetAccessor:
            case TypeScript.SyntaxKind.MemberVariableDeclaration:
            case TypeScript.SyntaxKind.IndexMemberDeclaration:
            case TypeScript.SyntaxKind.EnumDeclaration:
            case TypeScript.SyntaxKind.EnumElement:
            case TypeScript.SyntaxKind.SimplePropertyAssignment:
            case TypeScript.SyntaxKind.FunctionPropertyAssignment:
            case TypeScript.SyntaxKind.FunctionExpression:
            case TypeScript.SyntaxKind.CallSignature:
            case TypeScript.SyntaxKind.ConstructSignature:
            case TypeScript.SyntaxKind.MethodSignature:
            case TypeScript.SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }
    TypeScript.isDeclarationAST = isDeclarationAST;
    function docComments(ast) {
        if (isDeclarationAST(ast)) {
            var preComments = ast.kind() === TypeScript.SyntaxKind.VariableDeclarator
                ? getVariableStatement(ast).preComments()
                : ast.preComments();
            if (preComments && preComments.length > 0) {
                var preCommentsLength = preComments.length;
                var docComments = new Array();
                for (var i = preCommentsLength - 1; i >= 0; i--) {
                    if (isDocComment(preComments[i])) {
                        docComments.push(preComments[i]);
                        continue;
                    }
                    break;
                }
                return docComments.reverse();
            }
        }
        return [];
    }
    TypeScript.docComments = docComments;
    function isDocComment(comment) {
        if (comment.kind() === TypeScript.SyntaxKind.MultiLineCommentTrivia) {
            var fullText = comment.fullText();
            return fullText.charAt(2) === "*" && fullText.charAt(3) !== "/";
        }
        return false;
    }
    function getParameterList(ast) {
        if (ast) {
            switch (ast.kind()) {
                case TypeScript.SyntaxKind.ConstructorDeclaration:
                    return ast.parameterList;
                case TypeScript.SyntaxKind.FunctionDeclaration:
                    return getParameterList(ast.callSignature);
                case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                    return getParameterList(ast.callSignature);
                case TypeScript.SyntaxKind.ConstructSignature:
                    return getParameterList(ast.callSignature);
                case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                    return getParameterList(ast.callSignature);
                case TypeScript.SyntaxKind.FunctionPropertyAssignment:
                    return getParameterList(ast.callSignature);
                case TypeScript.SyntaxKind.FunctionExpression:
                    return getParameterList(ast.callSignature);
                case TypeScript.SyntaxKind.MethodSignature:
                    return getParameterList(ast.callSignature);
                case TypeScript.SyntaxKind.ConstructorType:
                    return ast.parameterList;
                case TypeScript.SyntaxKind.FunctionType:
                    return ast.parameterList;
                case TypeScript.SyntaxKind.CallSignature:
                    return ast.parameterList;
                case TypeScript.SyntaxKind.GetAccessor:
                    return ast.parameterList;
                case TypeScript.SyntaxKind.SetAccessor:
                    return ast.parameterList;
            }
        }
        return null;
    }
    TypeScript.getParameterList = getParameterList;
    function getType(ast) {
        if (ast) {
            switch (ast.kind()) {
                case TypeScript.SyntaxKind.FunctionDeclaration:
                    return getType(ast.callSignature);
                case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                    return getType(ast.callSignature);
                case TypeScript.SyntaxKind.ConstructSignature:
                    return getType(ast.callSignature);
                case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                    return getType(ast.callSignature);
                case TypeScript.SyntaxKind.FunctionPropertyAssignment:
                    return getType(ast.callSignature);
                case TypeScript.SyntaxKind.FunctionExpression:
                    return getType(ast.callSignature);
                case TypeScript.SyntaxKind.MethodSignature:
                    return getType(ast.callSignature);
                case TypeScript.SyntaxKind.CallSignature:
                    return getType(ast.typeAnnotation);
                case TypeScript.SyntaxKind.IndexSignature:
                    return getType(ast.typeAnnotation);
                case TypeScript.SyntaxKind.PropertySignature:
                    return getType(ast.typeAnnotation);
                case TypeScript.SyntaxKind.GetAccessor:
                    return getType(ast.typeAnnotation);
                case TypeScript.SyntaxKind.Parameter:
                    return getType(ast.typeAnnotation);
                case TypeScript.SyntaxKind.MemberVariableDeclaration:
                    return getType(ast.variableDeclarator);
                case TypeScript.SyntaxKind.VariableDeclarator:
                    return getType(ast.typeAnnotation);
                case TypeScript.SyntaxKind.CatchClause:
                    return getType(ast.typeAnnotation);
                case TypeScript.SyntaxKind.ConstructorType:
                    return ast.type;
                case TypeScript.SyntaxKind.FunctionType:
                    return ast.type;
                case TypeScript.SyntaxKind.TypeAnnotation:
                    return ast.type;
            }
        }
        return null;
    }
    TypeScript.getType = getType;
    function getVariableStatement(variableDeclarator) {
        if (variableDeclarator && variableDeclarator.parent && variableDeclarator.parent.parent && variableDeclarator.parent.parent.parent &&
            variableDeclarator.parent.kind() === TypeScript.SyntaxKind.SeparatedList &&
            variableDeclarator.parent.parent.kind() === TypeScript.SyntaxKind.VariableDeclaration &&
            variableDeclarator.parent.parent.parent.kind() === TypeScript.SyntaxKind.VariableStatement) {
            return variableDeclarator.parent.parent.parent;
        }
        return null;
    }
    function getVariableDeclaratorModifiers(variableDeclarator) {
        var variableStatement = getVariableStatement(variableDeclarator);
        return variableStatement ? variableStatement.modifiers : [];
    }
    TypeScript.getVariableDeclaratorModifiers = getVariableDeclaratorModifiers;
    function isIntegerLiteralAST(expression) {
        if (expression) {
            switch (expression.kind()) {
                case TypeScript.SyntaxKind.PlusExpression:
                case TypeScript.SyntaxKind.NegateExpression:
                    expression = expression.operand;
                    return expression.kind() === TypeScript.SyntaxKind.NumericLiteral && TypeScript.IntegerUtilities.isInteger(expression.text());
                case TypeScript.SyntaxKind.NumericLiteral:
                    var text = expression.text();
                    return TypeScript.IntegerUtilities.isInteger(text) || TypeScript.IntegerUtilities.isHexInteger(text);
            }
        }
        return false;
    }
    TypeScript.isIntegerLiteralAST = isIntegerLiteralAST;
    function getEnclosingModuleDeclaration(ast) {
        while (ast) {
            if (ast.kind() === TypeScript.SyntaxKind.ModuleDeclaration) {
                return ast;
            }
            ast = ast.parent;
        }
        return null;
    }
    TypeScript.getEnclosingModuleDeclaration = getEnclosingModuleDeclaration;
    function isLastNameOfModule(ast, astName) {
        if (ast) {
            if (ast.stringLiteral) {
                return astName === ast.stringLiteral;
            }
            else {
                var moduleNames = TypeScript.getModuleNames(ast.name);
                var nameIndex = moduleNames.indexOf(astName);
                return nameIndex === (moduleNames.length - 1);
            }
        }
        return false;
    }
    TypeScript.isLastNameOfModule = isLastNameOfModule;
    function isAnyNameOfModule(ast, astName) {
        if (ast) {
            if (ast.stringLiteral) {
                return ast.stringLiteral === astName;
            }
            else if (astName.kind() === TypeScript.SyntaxKind.IdentifierName) {
                var moduleNames = TypeScript.getModuleNames(ast.name);
                var nameIndex = moduleNames.indexOf(astName);
                return nameIndex >= 0;
            }
        }
        return false;
    }
    TypeScript.isAnyNameOfModule = isAnyNameOfModule;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function walkListChildren(ast, walker) {
        var preAst = ast;
        for (var i = 0, n = preAst.childCount(); i < n; i++) {
            walker.walk(preAst.childAt(i));
        }
    }
    function walkThrowStatementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expression);
    }
    function walkPrefixUnaryExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.operand);
    }
    function walkPostfixUnaryExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.operand);
    }
    function walkDeleteExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expression);
    }
    function walkTypeArgumentListChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.typeArguments);
    }
    function walkTypeOfExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expression);
    }
    function walkVoidExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expression);
    }
    function walkArgumentListChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.typeArgumentList);
        walker.walk(preAst.args);
    }
    function walkArrayLiteralExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expressions);
    }
    function walkSimplePropertyAssignmentChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.propertyName);
        walker.walk(preAst.expression);
    }
    function walkFunctionPropertyAssignmentChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }
    function walkGetAccessorChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.propertyName);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.block);
    }
    function walkSeparatedListChildren(ast, walker) {
        var preAst = ast;
        for (var i = 0, n = preAst.nonSeparatorCount(); i < n; i++) {
            walker.walk(preAst.nonSeparatorAt(i));
        }
    }
    function walkSetAccessorChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.propertyName);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.block);
    }
    function walkObjectLiteralExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.propertyAssignments);
    }
    function walkCastExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.type);
        walker.walk(preAst.expression);
    }
    function walkParenthesizedExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expression);
    }
    function walkElementAccessExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expression);
        walker.walk(preAst.argumentExpression);
    }
    function walkMemberAccessExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expression);
        walker.walk(preAst.name);
    }
    function walkQualifiedNameChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.left);
        walker.walk(preAst.right);
    }
    function walkBinaryExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.left);
        walker.walk(preAst.right);
    }
    function walkEqualsValueClauseChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.value);
    }
    function walkTypeParameterChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.identifier);
        walker.walk(preAst.constraint);
    }
    function walkTypeParameterListChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.typeParameters);
    }
    function walkGenericTypeChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.name);
        walker.walk(preAst.typeArgumentList);
    }
    function walkTypeAnnotationChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.type);
    }
    function walkTypeQueryChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.name);
    }
    function walkInvocationExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expression);
        walker.walk(preAst.argumentList);
    }
    function walkObjectCreationExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expression);
        walker.walk(preAst.argumentList);
    }
    function walkTrinaryExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.condition);
        walker.walk(preAst.whenTrue);
        walker.walk(preAst.whenFalse);
    }
    function walkFunctionExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.identifier);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }
    function walkFunctionTypeChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.type);
    }
    function walkParenthesizedArrowFunctionExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
        walker.walk(preAst.expression);
    }
    function walkSimpleArrowFunctionExpressionChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.identifier);
        walker.walk(preAst.block);
        walker.walk(preAst.expression);
    }
    function walkMemberFunctionDeclarationChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }
    function walkFuncDeclChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.identifier);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }
    function walkIndexMemberDeclarationChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.indexSignature);
    }
    function walkIndexSignatureChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.parameter);
        walker.walk(preAst.typeAnnotation);
    }
    function walkCallSignatureChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.typeAnnotation);
    }
    function walkConstraintChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.type);
    }
    function walkConstructorDeclarationChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.parameterList);
        walker.walk(preAst.block);
    }
    function walkConstructorTypeChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.type);
    }
    function walkConstructSignatureChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.callSignature);
    }
    function walkParameterChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.equalsValueClause);
    }
    function walkParameterListChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.parameters);
    }
    function walkPropertySignatureChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.propertyName);
        walker.walk(preAst.typeAnnotation);
    }
    function walkVariableDeclaratorChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.propertyName);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.equalsValueClause);
    }
    function walkMemberVariableDeclarationChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.variableDeclarator);
    }
    function walkMethodSignatureChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
    }
    function walkReturnStatementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expression);
    }
    function walkForStatementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.variableDeclaration);
        walker.walk(preAst.initializer);
        walker.walk(preAst.condition);
        walker.walk(preAst.incrementor);
        walker.walk(preAst.statement);
    }
    function walkForInStatementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.variableDeclaration);
        walker.walk(preAst.left);
        walker.walk(preAst.expression);
        walker.walk(preAst.statement);
    }
    function walkIfStatementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
        walker.walk(preAst.elseClause);
    }
    function walkElseClauseChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.statement);
    }
    function walkWhileStatementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
    }
    function walkDoStatementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
    }
    function walkBlockChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.statements);
    }
    function walkVariableDeclarationChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.declarators);
    }
    function walkCaseSwitchClauseChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expression);
        walker.walk(preAst.statements);
    }
    function walkDefaultSwitchClauseChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.statements);
    }
    function walkSwitchStatementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expression);
        walker.walk(preAst.switchClauses);
    }
    function walkTryStatementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.block);
        walker.walk(preAst.catchClause);
        walker.walk(preAst.finallyClause);
    }
    function walkCatchClauseChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.block);
    }
    function walkExternalModuleReferenceChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.stringLiteral);
    }
    function walkFinallyClauseChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.block);
    }
    function walkClassDeclChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.heritageClauses);
        walker.walk(preAst.classElements);
    }
    function walkScriptChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.moduleElements);
    }
    function walkHeritageClauseChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.typeNames);
    }
    function walkInterfaceDeclerationChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.heritageClauses);
        walker.walk(preAst.body);
    }
    function walkObjectTypeChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.typeMembers);
    }
    function walkArrayTypeChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.type);
    }
    function walkTupleTypeChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.type);
    }
    function walkModuleDeclarationChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.name);
        walker.walk(preAst.stringLiteral);
        walker.walk(preAst.moduleElements);
    }
    function walkModuleNameModuleReferenceChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.moduleName);
    }
    function walkEnumDeclarationChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.identifier);
        walker.walk(preAst.enumElements);
    }
    function walkEnumElementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.propertyName);
        walker.walk(preAst.equalsValueClause);
    }
    function walkImportDeclarationChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.identifier);
        walker.walk(preAst.moduleReference);
    }
    function walkExportAssignmentChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.identifier);
    }
    function walkWithStatementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
    }
    function walkExpressionStatementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.expression);
    }
    function walkLabeledStatementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.identifier);
        walker.walk(preAst.statement);
    }
    function walkVariableStatementChildren(ast, walker) {
        var preAst = ast;
        walker.walk(preAst.declaration);
    }
    var childrenWalkers = new Array(TypeScript.SyntaxKind.Last + 1);
    for (var i = TypeScript.SyntaxKind.FirstToken, n = TypeScript.SyntaxKind.LastToken; i <= n; i++) {
        childrenWalkers[i] = null;
    }
    for (var i = TypeScript.SyntaxKind.FirstTrivia, n = TypeScript.SyntaxKind.LastTrivia; i <= n; i++) {
        childrenWalkers[i] = null;
    }
    childrenWalkers[TypeScript.SyntaxKind.AddAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.AddExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.AndAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.AnyKeyword] = null;
    childrenWalkers[TypeScript.SyntaxKind.ArgumentList] = walkArgumentListChildren;
    childrenWalkers[TypeScript.SyntaxKind.ArrayLiteralExpression] = walkArrayLiteralExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.ArrayType] = walkArrayTypeChildren;
    childrenWalkers[TypeScript.SyntaxKind.TupleType] = walkTupleTypeChildren;
    childrenWalkers[TypeScript.SyntaxKind.SimpleArrowFunctionExpression] = walkSimpleArrowFunctionExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression] = walkParenthesizedArrowFunctionExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.AssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.BitwiseAndExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.BitwiseExclusiveOrExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.BitwiseNotExpression] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.BitwiseOrExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.Block] = walkBlockChildren;
    childrenWalkers[TypeScript.SyntaxKind.BooleanKeyword] = null;
    childrenWalkers[TypeScript.SyntaxKind.BreakStatement] = null;
    childrenWalkers[TypeScript.SyntaxKind.CallSignature] = walkCallSignatureChildren;
    childrenWalkers[TypeScript.SyntaxKind.CaseSwitchClause] = walkCaseSwitchClauseChildren;
    childrenWalkers[TypeScript.SyntaxKind.CastExpression] = walkCastExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.CatchClause] = walkCatchClauseChildren;
    childrenWalkers[TypeScript.SyntaxKind.ClassDeclaration] = walkClassDeclChildren;
    childrenWalkers[TypeScript.SyntaxKind.CommaExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.ConditionalExpression] = walkTrinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.Constraint] = walkConstraintChildren;
    childrenWalkers[TypeScript.SyntaxKind.ConstructorDeclaration] = walkConstructorDeclarationChildren;
    childrenWalkers[TypeScript.SyntaxKind.ConstructSignature] = walkConstructSignatureChildren;
    childrenWalkers[TypeScript.SyntaxKind.ContinueStatement] = null;
    childrenWalkers[TypeScript.SyntaxKind.ConstructorType] = walkConstructorTypeChildren;
    childrenWalkers[TypeScript.SyntaxKind.DebuggerStatement] = null;
    childrenWalkers[TypeScript.SyntaxKind.DefaultSwitchClause] = walkDefaultSwitchClauseChildren;
    childrenWalkers[TypeScript.SyntaxKind.DeleteExpression] = walkDeleteExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.DivideAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.DivideExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.DoStatement] = walkDoStatementChildren;
    childrenWalkers[TypeScript.SyntaxKind.ElementAccessExpression] = walkElementAccessExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.ElseClause] = walkElseClauseChildren;
    childrenWalkers[TypeScript.SyntaxKind.EmptyStatement] = null;
    childrenWalkers[TypeScript.SyntaxKind.EnumDeclaration] = walkEnumDeclarationChildren;
    childrenWalkers[TypeScript.SyntaxKind.EnumElement] = walkEnumElementChildren;
    childrenWalkers[TypeScript.SyntaxKind.EqualsExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.EqualsValueClause] = walkEqualsValueClauseChildren;
    childrenWalkers[TypeScript.SyntaxKind.EqualsWithTypeConversionExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.ExportAssignment] = walkExportAssignmentChildren;
    childrenWalkers[TypeScript.SyntaxKind.ExpressionStatement] = walkExpressionStatementChildren;
    childrenWalkers[TypeScript.SyntaxKind.ExtendsHeritageClause] = walkHeritageClauseChildren;
    childrenWalkers[TypeScript.SyntaxKind.ExternalModuleReference] = walkExternalModuleReferenceChildren;
    childrenWalkers[TypeScript.SyntaxKind.FalseKeyword] = null;
    childrenWalkers[TypeScript.SyntaxKind.FinallyClause] = walkFinallyClauseChildren;
    childrenWalkers[TypeScript.SyntaxKind.ForInStatement] = walkForInStatementChildren;
    childrenWalkers[TypeScript.SyntaxKind.ForStatement] = walkForStatementChildren;
    childrenWalkers[TypeScript.SyntaxKind.FunctionDeclaration] = walkFuncDeclChildren;
    childrenWalkers[TypeScript.SyntaxKind.FunctionExpression] = walkFunctionExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.FunctionPropertyAssignment] = walkFunctionPropertyAssignmentChildren;
    childrenWalkers[TypeScript.SyntaxKind.FunctionType] = walkFunctionTypeChildren;
    childrenWalkers[TypeScript.SyntaxKind.GenericType] = walkGenericTypeChildren;
    childrenWalkers[TypeScript.SyntaxKind.GetAccessor] = walkGetAccessorChildren;
    childrenWalkers[TypeScript.SyntaxKind.GreaterThanExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.GreaterThanOrEqualExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.IfStatement] = walkIfStatementChildren;
    childrenWalkers[TypeScript.SyntaxKind.ImplementsHeritageClause] = walkHeritageClauseChildren;
    childrenWalkers[TypeScript.SyntaxKind.ImportDeclaration] = walkImportDeclarationChildren;
    childrenWalkers[TypeScript.SyntaxKind.IndexMemberDeclaration] = walkIndexMemberDeclarationChildren;
    childrenWalkers[TypeScript.SyntaxKind.IndexSignature] = walkIndexSignatureChildren;
    childrenWalkers[TypeScript.SyntaxKind.InExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.InstanceOfExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.InterfaceDeclaration] = walkInterfaceDeclerationChildren;
    childrenWalkers[TypeScript.SyntaxKind.InvocationExpression] = walkInvocationExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.LabeledStatement] = walkLabeledStatementChildren;
    childrenWalkers[TypeScript.SyntaxKind.LeftShiftAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.LeftShiftExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.LessThanExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.LessThanOrEqualExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.List] = walkListChildren;
    childrenWalkers[TypeScript.SyntaxKind.LogicalAndExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.LogicalNotExpression] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.LogicalOrExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.MemberAccessExpression] = walkMemberAccessExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.MemberFunctionDeclaration] = walkMemberFunctionDeclarationChildren;
    childrenWalkers[TypeScript.SyntaxKind.MemberVariableDeclaration] = walkMemberVariableDeclarationChildren;
    childrenWalkers[TypeScript.SyntaxKind.MethodSignature] = walkMethodSignatureChildren;
    childrenWalkers[TypeScript.SyntaxKind.ModuleDeclaration] = walkModuleDeclarationChildren;
    childrenWalkers[TypeScript.SyntaxKind.ModuleNameModuleReference] = walkModuleNameModuleReferenceChildren;
    childrenWalkers[TypeScript.SyntaxKind.ModuloAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.ModuloExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.MultiplyAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.MultiplyExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.IdentifierName] = null;
    childrenWalkers[TypeScript.SyntaxKind.NegateExpression] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.None] = null;
    childrenWalkers[TypeScript.SyntaxKind.NotEqualsExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.NotEqualsWithTypeConversionExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.NullKeyword] = null;
    childrenWalkers[TypeScript.SyntaxKind.NumberKeyword] = null;
    childrenWalkers[TypeScript.SyntaxKind.NumericLiteral] = null;
    childrenWalkers[TypeScript.SyntaxKind.ObjectCreationExpression] = walkObjectCreationExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.ObjectLiteralExpression] = walkObjectLiteralExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.ObjectType] = walkObjectTypeChildren;
    childrenWalkers[TypeScript.SyntaxKind.OmittedExpression] = null;
    childrenWalkers[TypeScript.SyntaxKind.OrAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.Parameter] = walkParameterChildren;
    childrenWalkers[TypeScript.SyntaxKind.ParameterList] = walkParameterListChildren;
    childrenWalkers[TypeScript.SyntaxKind.ParenthesizedExpression] = walkParenthesizedExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.PlusExpression] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.PostDecrementExpression] = walkPostfixUnaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.PostIncrementExpression] = walkPostfixUnaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.PreDecrementExpression] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.PreIncrementExpression] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.PropertySignature] = walkPropertySignatureChildren;
    childrenWalkers[TypeScript.SyntaxKind.QualifiedName] = walkQualifiedNameChildren;
    childrenWalkers[TypeScript.SyntaxKind.RegularExpressionLiteral] = null;
    childrenWalkers[TypeScript.SyntaxKind.ReturnStatement] = walkReturnStatementChildren;
    childrenWalkers[TypeScript.SyntaxKind.SourceUnit] = walkScriptChildren;
    childrenWalkers[TypeScript.SyntaxKind.SeparatedList] = walkSeparatedListChildren;
    childrenWalkers[TypeScript.SyntaxKind.SetAccessor] = walkSetAccessorChildren;
    childrenWalkers[TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.SignedRightShiftExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.SimplePropertyAssignment] = walkSimplePropertyAssignmentChildren;
    childrenWalkers[TypeScript.SyntaxKind.StringLiteral] = null;
    childrenWalkers[TypeScript.SyntaxKind.StringKeyword] = null;
    childrenWalkers[TypeScript.SyntaxKind.SubtractAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.SubtractExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.SuperKeyword] = null;
    childrenWalkers[TypeScript.SyntaxKind.SwitchStatement] = walkSwitchStatementChildren;
    childrenWalkers[TypeScript.SyntaxKind.ThisKeyword] = null;
    childrenWalkers[TypeScript.SyntaxKind.ThrowStatement] = walkThrowStatementChildren;
    childrenWalkers[TypeScript.SyntaxKind.TriviaList] = null;
    childrenWalkers[TypeScript.SyntaxKind.TrueKeyword] = null;
    childrenWalkers[TypeScript.SyntaxKind.TryStatement] = walkTryStatementChildren;
    childrenWalkers[TypeScript.SyntaxKind.TypeAnnotation] = walkTypeAnnotationChildren;
    childrenWalkers[TypeScript.SyntaxKind.TypeArgumentList] = walkTypeArgumentListChildren;
    childrenWalkers[TypeScript.SyntaxKind.TypeOfExpression] = walkTypeOfExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.TypeParameter] = walkTypeParameterChildren;
    childrenWalkers[TypeScript.SyntaxKind.TypeParameterList] = walkTypeParameterListChildren;
    childrenWalkers[TypeScript.SyntaxKind.TypeQuery] = walkTypeQueryChildren;
    childrenWalkers[TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.UnsignedRightShiftExpression] = walkBinaryExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.VariableDeclaration] = walkVariableDeclarationChildren;
    childrenWalkers[TypeScript.SyntaxKind.VariableDeclarator] = walkVariableDeclaratorChildren;
    childrenWalkers[TypeScript.SyntaxKind.VariableStatement] = walkVariableStatementChildren;
    childrenWalkers[TypeScript.SyntaxKind.VoidExpression] = walkVoidExpressionChildren;
    childrenWalkers[TypeScript.SyntaxKind.VoidKeyword] = null;
    childrenWalkers[TypeScript.SyntaxKind.WhileStatement] = walkWhileStatementChildren;
    childrenWalkers[TypeScript.SyntaxKind.WithStatement] = walkWithStatementChildren;
    for (var e in TypeScript.SyntaxKind) {
        if (TypeScript.SyntaxKind.hasOwnProperty(e) && TypeScript.StringUtilities.isString(TypeScript.SyntaxKind[e])) {
            TypeScript.Debug.assert(childrenWalkers[e] !== undefined, "Fix initWalkers: " + TypeScript.SyntaxKind[e]);
        }
    }
    var AstWalkOptions = (function () {
        function AstWalkOptions() {
            this.goChildren = true;
            this.stopWalking = false;
        }
        return AstWalkOptions;
    }());
    TypeScript.AstWalkOptions = AstWalkOptions;
    var SimplePreAstWalker = (function () {
        function SimplePreAstWalker(pre, state) {
            this.pre = pre;
            this.state = state;
            this.options = new AstWalkOptions();
        }
        SimplePreAstWalker.prototype.walk = function (ast) {
            if (!ast) {
                return;
            }
            this.pre(ast, this.state);
            var walker = childrenWalkers[ast.kind()];
            if (walker) {
                walker(ast, this);
            }
        };
        return SimplePreAstWalker;
    }());
    var SimplePrePostAstWalker = (function () {
        function SimplePrePostAstWalker(pre, post, state) {
            this.pre = pre;
            this.post = post;
            this.state = state;
            this.options = new AstWalkOptions();
        }
        SimplePrePostAstWalker.prototype.walk = function (ast) {
            if (!ast) {
                return;
            }
            this.pre(ast, this.state);
            var walker = childrenWalkers[ast.kind()];
            if (walker) {
                walker(ast, this);
            }
            this.post(ast, this.state);
        };
        return SimplePrePostAstWalker;
    }());
    var NormalAstWalker = (function () {
        function NormalAstWalker(pre, post, state) {
            this.pre = pre;
            this.post = post;
            this.state = state;
            this.options = new AstWalkOptions();
        }
        NormalAstWalker.prototype.walk = function (ast) {
            if (!ast) {
                return;
            }
            if (this.options.stopWalking) {
                return;
            }
            this.pre(ast, this);
            if (this.options.stopWalking) {
                return;
            }
            if (this.options.goChildren) {
                var walker = childrenWalkers[ast.kind()];
                if (walker) {
                    walker(ast, this);
                }
            }
            else {
                this.options.goChildren = true;
            }
            if (this.post) {
                this.post(ast, this);
            }
        };
        return NormalAstWalker;
    }());
    var AstWalkerFactory = (function () {
        function AstWalkerFactory() {
        }
        AstWalkerFactory.prototype.walk = function (ast, pre, post, state) {
            new NormalAstWalker(pre, post, state).walk(ast);
        };
        AstWalkerFactory.prototype.simpleWalk = function (ast, pre, post, state) {
            if (post) {
                new SimplePrePostAstWalker(pre, post, state).walk(ast);
            }
            else {
                new SimplePreAstWalker(pre, state).walk(ast);
            }
        };
        return AstWalkerFactory;
    }());
    TypeScript.AstWalkerFactory = AstWalkerFactory;
    var globalAstWalkerFactory = new AstWalkerFactory();
    function getAstWalkerFactory() {
        return globalAstWalkerFactory;
    }
    TypeScript.getAstWalkerFactory = getAstWalkerFactory;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Base64Format = (function () {
        function Base64Format() {
        }
        Base64Format.encode = function (inValue) {
            if (inValue < 64) {
                return Base64Format.encodedValues.charAt(inValue);
            }
            throw TypeError(inValue + ": not a 64 based value");
        };
        Base64Format.decodeChar = function (inChar) {
            if (inChar.length === 1) {
                return Base64Format.encodedValues.indexOf(inChar);
            }
            else {
                throw TypeError('"' + inChar + '" must have length 1');
            }
        };
        Base64Format.encodedValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        return Base64Format;
    }());
    var Base64VLQFormat = (function () {
        function Base64VLQFormat() {
        }
        Base64VLQFormat.encode = function (inValue) {
            if (inValue < 0) {
                inValue = ((-inValue) << 1) + 1;
            }
            else {
                inValue = inValue << 1;
            }
            var encodedStr = "";
            do {
                var currentDigit = inValue & 31;
                inValue = inValue >> 5;
                if (inValue > 0) {
                    currentDigit = currentDigit | 32;
                }
                encodedStr = encodedStr + Base64Format.encode(currentDigit);
            } while (inValue > 0);
            return encodedStr;
        };
        Base64VLQFormat.decode = function (inString) {
            var result = 0;
            var negative = false;
            var shift = 0;
            for (var i = 0; i < inString.length; i++) {
                var byte = Base64Format.decodeChar(inString[i]);
                if (i === 0) {
                    if ((byte & 1) === 1) {
                        negative = true;
                    }
                    result = (byte >> 1) & 15;
                }
                else {
                    result = result | ((byte & 31) << shift);
                }
                shift += (i === 0) ? 4 : 5;
                if ((byte & 32) === 32) {
                }
                else {
                    return { value: negative ? -(result) : result, rest: inString.substr(i + 1) };
                }
            }
            throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Base64_value_0_finished_with_a_continuation_bit, [inString]));
        };
        return Base64VLQFormat;
    }());
    TypeScript.Base64VLQFormat = Base64VLQFormat;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SourceMapPosition = (function () {
        function SourceMapPosition() {
        }
        return SourceMapPosition;
    }());
    TypeScript.SourceMapPosition = SourceMapPosition;
    var SourceMapping = (function () {
        function SourceMapping() {
            this.start = new SourceMapPosition();
            this.end = new SourceMapPosition();
            this.nameIndex = -1;
            this.childMappings = [];
        }
        return SourceMapping;
    }());
    TypeScript.SourceMapping = SourceMapping;
    var SourceMapEntry = (function () {
        function SourceMapEntry(emittedFile, emittedLine, emittedColumn, sourceFile, sourceLine, sourceColumn, sourceName) {
            this.emittedFile = emittedFile;
            this.emittedLine = emittedLine;
            this.emittedColumn = emittedColumn;
            this.sourceFile = sourceFile;
            this.sourceLine = sourceLine;
            this.sourceColumn = sourceColumn;
            this.sourceName = sourceName;
            TypeScript.Debug.assert(isFinite(emittedLine));
            TypeScript.Debug.assert(isFinite(emittedColumn));
            TypeScript.Debug.assert(isFinite(sourceColumn));
            TypeScript.Debug.assert(isFinite(sourceLine));
        }
        return SourceMapEntry;
    }());
    TypeScript.SourceMapEntry = SourceMapEntry;
    var SourceMapper = (function () {
        function SourceMapper(jsFile, sourceMapOut, document, jsFilePath, emitOptions, resolvePath) {
            this.jsFile = jsFile;
            this.sourceMapOut = sourceMapOut;
            this.names = [];
            this.mappingLevel = [];
            this.tsFilePaths = [];
            this.allSourceMappings = [];
            this.sourceMapEntries = [];
            this.setSourceMapOptions(document, jsFilePath, emitOptions, resolvePath);
            this.setNewSourceFile(document, emitOptions);
        }
        SourceMapper.prototype.getOutputFile = function () {
            var result = this.sourceMapOut.getOutputFile();
            result.sourceMapEntries = this.sourceMapEntries;
            return result;
        };
        SourceMapper.prototype.increaseMappingLevel = function (ast) {
            this.mappingLevel.push(ast);
        };
        SourceMapper.prototype.decreaseMappingLevel = function (ast) {
            TypeScript.Debug.assert(this.mappingLevel.length > 0, "Mapping level should never be less than 0. This suggests a missing start call.");
            var expectedAst = this.mappingLevel.pop();
            var expectedAstInfo = (expectedAst instanceof TypeScript.AST) ? TypeScript.SyntaxKind[expectedAst.kind()] : [expectedAst.start(), expectedAst.end()];
            var astInfo = (ast instanceof TypeScript.AST) ? TypeScript.SyntaxKind[ast.kind()] : [ast.start(), ast.end()];
            TypeScript.Debug.assert(ast === expectedAst, "Provided ast is not the expected AST, Expected: " + expectedAstInfo + " Given: " + astInfo);
        };
        SourceMapper.prototype.setNewSourceFile = function (document, emitOptions) {
            var sourceMappings = [];
            this.allSourceMappings.push(sourceMappings);
            this.currentMappings = [sourceMappings];
            this.currentNameIndex = [];
            this.setNewSourceFilePath(document, emitOptions);
        };
        SourceMapper.prototype.setSourceMapOptions = function (document, jsFilePath, emitOptions, resolvePath) {
            var prettyJsFileName = TypeScript.getPrettyName(jsFilePath, false, true);
            var prettyMapFileName = prettyJsFileName + SourceMapper.MapFileExtension;
            this.jsFileName = prettyJsFileName;
            if (emitOptions.sourceMapRootDirectory()) {
                this.sourceMapDirectory = emitOptions.sourceMapRootDirectory();
                if (document.emitToOwnOutputFile()) {
                    this.sourceMapDirectory = this.sourceMapDirectory + TypeScript.switchToForwardSlashes(TypeScript.getRootFilePath((document.fileName)).replace(emitOptions.commonDirectoryPath(), ""));
                }
                if (TypeScript.isRelative(this.sourceMapDirectory)) {
                    this.sourceMapDirectory = emitOptions.commonDirectoryPath() + this.sourceMapDirectory;
                    this.sourceMapDirectory = TypeScript.convertToDirectoryPath(TypeScript.switchToForwardSlashes(resolvePath(this.sourceMapDirectory)));
                    this.sourceMapPath = TypeScript.getRelativePathToFixedPath(TypeScript.getRootFilePath(jsFilePath), this.sourceMapDirectory + prettyMapFileName);
                }
                else {
                    this.sourceMapPath = this.sourceMapDirectory + prettyMapFileName;
                }
            }
            else {
                this.sourceMapPath = prettyMapFileName;
                this.sourceMapDirectory = TypeScript.getRootFilePath(jsFilePath);
            }
            this.sourceRoot = emitOptions.sourceRootDirectory();
        };
        SourceMapper.prototype.setNewSourceFilePath = function (document, emitOptions) {
            var tsFilePath = TypeScript.switchToForwardSlashes(document.fileName);
            if (emitOptions.sourceRootDirectory()) {
                tsFilePath = TypeScript.getRelativePathToFixedPath(emitOptions.commonDirectoryPath(), tsFilePath);
            }
            else {
                tsFilePath = TypeScript.getRelativePathToFixedPath(this.sourceMapDirectory, tsFilePath);
            }
            this.tsFilePaths.push(tsFilePath);
        };
        SourceMapper.prototype.emitSourceMapping = function () {
            var _this = this;
            TypeScript.Debug.assert(this.mappingLevel.length === 0, "Mapping level is not 0. This suggest a missing end call. Value: " +
                this.mappingLevel.map(function (item) { return ['Node of type', TypeScript.SyntaxKind[item.kind()], 'at', item.start(), 'to', item.end()].join(' '); }).join(', '));
            this.jsFile.WriteLine("//# sourceMappingURL=" + this.sourceMapPath);
            var mappingsString = "";
            var prevEmittedColumn = 0;
            var prevEmittedLine = 0;
            var prevSourceColumn = 0;
            var prevSourceLine = 0;
            var prevSourceIndex = 0;
            var prevNameIndex = 0;
            var emitComma = false;
            var recordedPosition = null;
            for (var sourceIndex = 0; sourceIndex < this.tsFilePaths.length; sourceIndex++) {
                var recordSourceMapping = function (mappedPosition, nameIndex) {
                    if (recordedPosition !== null &&
                        recordedPosition.emittedColumn === mappedPosition.emittedColumn &&
                        recordedPosition.emittedLine === mappedPosition.emittedLine) {
                        return;
                    }
                    if (prevEmittedLine !== mappedPosition.emittedLine) {
                        while (prevEmittedLine < mappedPosition.emittedLine) {
                            prevEmittedColumn = 0;
                            mappingsString = mappingsString + ";";
                            prevEmittedLine++;
                        }
                        emitComma = false;
                    }
                    else if (emitComma) {
                        mappingsString = mappingsString + ",";
                    }
                    _this.sourceMapEntries.push(new SourceMapEntry(_this.jsFileName, mappedPosition.emittedLine + 1, mappedPosition.emittedColumn + 1, _this.tsFilePaths[sourceIndex], mappedPosition.sourceLine, mappedPosition.sourceColumn + 1, nameIndex >= 0 ? _this.names[nameIndex] : undefined));
                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);
                    prevEmittedColumn = mappedPosition.emittedColumn;
                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(sourceIndex - prevSourceIndex);
                    prevSourceIndex = sourceIndex;
                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);
                    prevSourceLine = mappedPosition.sourceLine - 1;
                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);
                    prevSourceColumn = mappedPosition.sourceColumn;
                    if (nameIndex >= 0) {
                        mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(nameIndex - prevNameIndex);
                        prevNameIndex = nameIndex;
                    }
                    emitComma = true;
                    recordedPosition = mappedPosition;
                };
                var recordSourceMappingSiblings = function (sourceMappings) {
                    for (var i = 0; i < sourceMappings.length; i++) {
                        var sourceMapping = sourceMappings[i];
                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);
                        recordSourceMappingSiblings(sourceMapping.childMappings);
                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);
                    }
                };
                recordSourceMappingSiblings(this.allSourceMappings[sourceIndex]);
            }
            this.sourceMapOut.Write(JSON.stringify({
                version: 3,
                file: this.jsFileName,
                sourceRoot: this.sourceRoot,
                sources: this.tsFilePaths,
                names: this.names,
                mappings: mappingsString
            }));
            this.sourceMapOut.Close();
        };
        SourceMapper.MapFileExtension = ".map";
        return SourceMapper;
    }());
    TypeScript.SourceMapper = SourceMapper;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var EmitContainer;
    (function (EmitContainer) {
        EmitContainer[EmitContainer["Prog"] = 0] = "Prog";
        EmitContainer[EmitContainer["Module"] = 1] = "Module";
        EmitContainer[EmitContainer["DynamicModule"] = 2] = "DynamicModule";
        EmitContainer[EmitContainer["Class"] = 3] = "Class";
        EmitContainer[EmitContainer["Constructor"] = 4] = "Constructor";
        EmitContainer[EmitContainer["Function"] = 5] = "Function";
        EmitContainer[EmitContainer["Args"] = 6] = "Args";
        EmitContainer[EmitContainer["Interface"] = 7] = "Interface";
    })(EmitContainer = TypeScript.EmitContainer || (TypeScript.EmitContainer = {}));
    var EmitState = (function () {
        function EmitState() {
            this.column = 0;
            this.line = 0;
            this.container = EmitContainer.Prog;
        }
        return EmitState;
    }());
    TypeScript.EmitState = EmitState;
    var EmitOptions = (function () {
        function EmitOptions(compiler, resolvePath) {
            this.resolvePath = resolvePath;
            this._diagnostic = null;
            this._settings = null;
            this._commonDirectoryPath = "";
            this._sharedOutputFile = "";
            this._sourceRootDirectory = "";
            this._sourceMapRootDirectory = "";
            this._outputDirectory = "";
            var settings = compiler.compilationSettings();
            this._settings = settings;
            if (settings.moduleGenTarget() === TypeScript.ModuleGenTarget.Unspecified && compiler._isDynamicModuleCompilation()) {
                this._diagnostic = new TypeScript.Diagnostic(null, null, 0, 0, TypeScript.DiagnosticCode.Cannot_compile_external_modules_unless_the_module_flag_is_provided, null);
                return;
            }
            if (!settings.mapSourceFiles()) {
                if (settings.mapRoot()) {
                    if (settings.sourceRoot()) {
                        this._diagnostic = new TypeScript.Diagnostic(null, null, 0, 0, TypeScript.DiagnosticCode.Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                        return;
                    }
                    else {
                        this._diagnostic = new TypeScript.Diagnostic(null, null, 0, 0, TypeScript.DiagnosticCode.Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                        return;
                    }
                }
                else if (settings.sourceRoot()) {
                    this._diagnostic = new TypeScript.Diagnostic(null, null, 0, 0, TypeScript.DiagnosticCode.Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                    return;
                }
            }
            this._sourceMapRootDirectory = TypeScript.convertToDirectoryPath(TypeScript.switchToForwardSlashes(settings.mapRoot()));
            this._sourceRootDirectory = TypeScript.convertToDirectoryPath(TypeScript.switchToForwardSlashes(settings.sourceRoot()));
            if (settings.outFileOption() ||
                settings.outDirOption() ||
                settings.mapRoot() ||
                settings.sourceRoot()) {
                if (settings.outFileOption()) {
                    this._sharedOutputFile = TypeScript.switchToForwardSlashes(resolvePath(settings.outFileOption()));
                }
                if (settings.outDirOption()) {
                    this._outputDirectory = TypeScript.convertToDirectoryPath(TypeScript.switchToForwardSlashes(resolvePath(settings.outDirOption())));
                }
                if (this._outputDirectory || this._sourceMapRootDirectory || this.sourceRootDirectory()) {
                    this.determineCommonDirectoryPath(compiler);
                }
            }
        }
        EmitOptions.prototype.diagnostic = function () { return this._diagnostic; };
        EmitOptions.prototype.commonDirectoryPath = function () { return this._commonDirectoryPath; };
        EmitOptions.prototype.sharedOutputFile = function () { return this._sharedOutputFile; };
        EmitOptions.prototype.sourceRootDirectory = function () { return this._sourceRootDirectory; };
        EmitOptions.prototype.sourceMapRootDirectory = function () { return this._sourceMapRootDirectory; };
        EmitOptions.prototype.outputDirectory = function () { return this._outputDirectory; };
        EmitOptions.prototype.compilationSettings = function () { return this._settings; };
        EmitOptions.prototype.determineCommonDirectoryPath = function (compiler) {
            var commonComponents = [];
            var commonComponentsLength = -1;
            var fileNames = compiler.fileNames();
            for (var i = 0, len = fileNames.length; i < len; i++) {
                var fileName = fileNames[i];
                var document = compiler.getDocument(fileNames[i]);
                var sourceUnit = document.sourceUnit();
                if (!document.isDeclareFile()) {
                    var fileComponents = TypeScript.filePathComponents(fileName);
                    if (commonComponentsLength === -1) {
                        commonComponents = fileComponents;
                        commonComponentsLength = commonComponents.length;
                    }
                    else {
                        var updatedPath = false;
                        for (var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {
                            if (commonComponents[j] !== fileComponents[j]) {
                                commonComponentsLength = j;
                                updatedPath = true;
                                if (j === 0) {
                                    if (this._outputDirectory ||
                                        this._sourceRootDirectory ||
                                        (this._sourceMapRootDirectory &&
                                            (!this._sharedOutputFile || compiler._isDynamicModuleCompilation()))) {
                                        this._diagnostic = new TypeScript.Diagnostic(null, null, 0, 0, TypeScript.DiagnosticCode.Cannot_find_the_common_subdirectory_path_for_the_input_files, null);
                                        return;
                                    }
                                    return;
                                }
                                break;
                            }
                        }
                        if (!updatedPath && fileComponents.length < commonComponentsLength) {
                            commonComponentsLength = fileComponents.length;
                        }
                    }
                }
            }
            this._commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";
        };
        return EmitOptions;
    }());
    TypeScript.EmitOptions = EmitOptions;
    var Indenter = (function () {
        function Indenter() {
            this.indentAmt = 0;
        }
        Indenter.prototype.increaseIndent = function () {
            this.indentAmt += Indenter.indentStep;
        };
        Indenter.prototype.decreaseIndent = function () {
            this.indentAmt -= Indenter.indentStep;
        };
        Indenter.prototype.getIndent = function () {
            var indentString = Indenter.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for (var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {
                    indentString += Indenter.indentStepString;
                }
                Indenter.indentStrings[this.indentAmt] = indentString;
            }
            return indentString;
        };
        Indenter.indentStep = 4;
        Indenter.indentStepString = "    ";
        Indenter.indentStrings = [];
        return Indenter;
    }());
    TypeScript.Indenter = Indenter;
    function lastParameterIsRest(parameterList) {
        var parameters = parameterList.parameters;
        return parameters.nonSeparatorCount() > 0 && parameters.nonSeparatorAt(parameters.nonSeparatorCount() - 1).dotDotDotToken !== null;
    }
    TypeScript.lastParameterIsRest = lastParameterIsRest;
    var Emitter = (function () {
        function Emitter(emittingFileName, outfile, emitOptions, semanticInfoChain) {
            this.emittingFileName = emittingFileName;
            this.outfile = outfile;
            this.emitOptions = emitOptions;
            this.semanticInfoChain = semanticInfoChain;
            this.globalThisCapturePrologueEmitted = false;
            this.extendsPrologueEmitted = false;
            this.thisClassNode = null;
            this.inArrowFunction = false;
            this.moduleName = "";
            this.emitState = new EmitState();
            this.indenter = new Indenter();
            this.sourceMapper = null;
            this.captureThisStmtString = "var _this = this;";
            this.declStack = [];
            this.exportAssignmentIdentifier = null;
            this.inWithBlock = false;
            this.document = null;
            this.copyrightElement = null;
        }
        Emitter.prototype.pushDecl = function (decl) {
            if (decl) {
                this.declStack[this.declStack.length] = decl;
            }
        };
        Emitter.prototype.popDecl = function (decl) {
            if (decl) {
                this.declStack.length--;
            }
        };
        Emitter.prototype.getEnclosingDecl = function () {
            var declStackLen = this.declStack.length;
            var enclosingDecl = declStackLen > 0 ? this.declStack[declStackLen - 1] : null;
            return enclosingDecl;
        };
        Emitter.prototype.setExportAssignmentIdentifier = function (id) {
            this.exportAssignmentIdentifier = id;
        };
        Emitter.prototype.getExportAssignmentIdentifier = function () {
            return this.exportAssignmentIdentifier;
        };
        Emitter.prototype.setDocument = function (document) {
            this.document = document;
        };
        Emitter.prototype.shouldEmitImportDeclaration = function (importDeclAST) {
            return TypeScript.importDeclarationIsElided(importDeclAST, this.semanticInfoChain, this.emitOptions.compilationSettings());
        };
        Emitter.prototype.emitImportDeclaration = function (importDeclAST) {
            var isExternalModuleReference = importDeclAST.moduleReference.kind() === TypeScript.SyntaxKind.ExternalModuleReference;
            var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST);
            var isExported = TypeScript.hasFlag(importDecl.flags, TypeScript.PullElementFlags.Exported);
            var isAmdCodeGen = this.emitOptions.compilationSettings().moduleGenTarget() == TypeScript.ModuleGenTarget.Asynchronous;
            this.emitComments(importDeclAST, true);
            var importSymbol = importDecl.getSymbol();
            var parentSymbol = importSymbol.getContainer();
            var parentKind = parentSymbol ? parentSymbol.kind : TypeScript.PullElementKind.None;
            var associatedParentSymbol = parentSymbol ? parentSymbol.getAssociatedContainerType() : null;
            var associatedParentSymbolKind = associatedParentSymbol ? associatedParentSymbol.kind : TypeScript.PullElementKind.None;
            var needsPropertyAssignment = false;
            var usePropertyAssignmentInsteadOfVarDecl = false;
            var moduleNamePrefix;
            if (isExported &&
                (parentKind == TypeScript.PullElementKind.Container ||
                    parentKind === TypeScript.PullElementKind.DynamicModule ||
                    associatedParentSymbolKind === TypeScript.PullElementKind.Container ||
                    associatedParentSymbolKind === TypeScript.PullElementKind.DynamicModule)) {
                if (importSymbol.getExportAssignedTypeSymbol() || importSymbol.getExportAssignedContainerSymbol()) {
                    needsPropertyAssignment = true;
                }
                else {
                    var valueSymbol = importSymbol.getExportAssignedValueSymbol();
                    if (valueSymbol &&
                        (valueSymbol.kind == TypeScript.PullElementKind.Method || valueSymbol.kind == TypeScript.PullElementKind.Function)) {
                        needsPropertyAssignment = true;
                    }
                    else {
                        usePropertyAssignmentInsteadOfVarDecl = true;
                    }
                }
                if (this.emitState.container === EmitContainer.DynamicModule) {
                    moduleNamePrefix = "exports.";
                }
                else {
                    moduleNamePrefix = this.moduleName + ".";
                }
            }
            if (isAmdCodeGen && isExternalModuleReference) {
                needsPropertyAssignment = true;
            }
            else {
                this.recordSourceMappingStart(importDeclAST);
                if (usePropertyAssignmentInsteadOfVarDecl) {
                    this.writeToOutput(moduleNamePrefix);
                }
                else {
                    this.writeToOutput("var ");
                }
                this.writeToOutput(importDeclAST.identifier.text() + " = ");
                var aliasAST = importDeclAST.moduleReference;
                if (isExternalModuleReference) {
                    this.writeToOutput("require(" + aliasAST.stringLiteral.text() + ")");
                }
                else {
                    this.emitJavascript(aliasAST.moduleName, false);
                }
                this.recordSourceMappingEnd(importDeclAST);
                this.writeToOutput(";");
                if (needsPropertyAssignment) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                }
            }
            if (needsPropertyAssignment) {
                this.writeToOutputWithSourceMapRecord(moduleNamePrefix + importDeclAST.identifier.text() + " = " + importDeclAST.identifier.text(), importDeclAST);
                this.writeToOutput(";");
            }
            this.emitComments(importDeclAST, false);
        };
        Emitter.prototype.createSourceMapper = function (document, jsFileName, jsFile, sourceMapOut, resolvePath) {
            this.sourceMapper = new TypeScript.SourceMapper(jsFile, sourceMapOut, document, jsFileName, this.emitOptions, resolvePath);
        };
        Emitter.prototype.setSourceMapperNewSourceFile = function (document) {
            this.sourceMapper.setNewSourceFile(document, this.emitOptions);
        };
        Emitter.prototype.updateLineAndColumn = function (s) {
            var lineNumbers = TypeScript.TextUtilities.parseLineStarts(new String(s));
            if (lineNumbers.length > 1) {
                this.emitState.line += lineNumbers.length - 1;
                this.emitState.column = s.length - lineNumbers[lineNumbers.length - 1];
            }
            else {
                this.emitState.column += s.length;
            }
        };
        Emitter.prototype.writeToOutputWithSourceMapRecord = function (s, astSpan) {
            this.recordSourceMappingStart(astSpan);
            this.writeToOutput(s);
            this.recordSourceMappingEnd(astSpan);
        };
        Emitter.prototype.writeToOutput = function (s) {
            this.outfile.Write(s);
            this.updateLineAndColumn(s);
        };
        Emitter.prototype.writeLineToOutput = function (s, force) {
            if (force === void 0) { force = false; }
            if (!force && s === "" && this.emitState.column === 0) {
                return;
            }
            this.outfile.WriteLine(s);
            this.updateLineAndColumn(s);
            this.emitState.column = 0;
            this.emitState.line++;
        };
        Emitter.prototype.writeCaptureThisStatement = function (ast) {
            this.emitIndent();
            this.writeToOutputWithSourceMapRecord(this.captureThisStmtString, ast);
            this.writeLineToOutput("");
        };
        Emitter.prototype.setContainer = function (c) {
            var temp = this.emitState.container;
            this.emitState.container = c;
            return temp;
        };
        Emitter.prototype.getIndentString = function () {
            return this.indenter.getIndent();
        };
        Emitter.prototype.emitIndent = function () {
            this.writeToOutput(this.getIndentString());
        };
        Emitter.prototype.emitComment = function (comment, trailing, first) {
            if (this.emitOptions.compilationSettings().removeComments()) {
                return;
            }
            var text = getTrimmedTextLines(comment);
            var emitColumn = this.emitState.column;
            if (emitColumn === 0) {
                this.emitIndent();
            }
            else if (trailing && first) {
                this.writeToOutput(" ");
            }
            if (comment.kind() === TypeScript.SyntaxKind.MultiLineCommentTrivia) {
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                if (text.length > 1 || comment.endsLine) {
                    for (var i = 1; i < text.length; i++) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput(text[i]);
                    }
                    this.recordSourceMappingEnd(comment);
                    this.writeLineToOutput("");
                }
                else {
                    this.recordSourceMappingEnd(comment);
                    this.writeToOutput(" ");
                    return;
                }
            }
            else {
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                this.recordSourceMappingEnd(comment);
                this.writeLineToOutput("");
            }
            if (!trailing && emitColumn != 0) {
                this.emitIndent();
            }
        };
        Emitter.prototype.emitComments = function (ast, pre, onlyPinnedOrTripleSlashComments) {
            var _this = this;
            if (onlyPinnedOrTripleSlashComments === void 0) { onlyPinnedOrTripleSlashComments = false; }
            if (ast && ast.kind() !== TypeScript.SyntaxKind.Block) {
                if (ast.parent.kind() === TypeScript.SyntaxKind.SimpleArrowFunctionExpression || ast.parent.kind() === TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression) {
                    return;
                }
            }
            if (pre) {
                var preComments = ast.preComments();
                if (preComments && ast === this.copyrightElement) {
                    var copyrightComments = this.getCopyrightComments();
                    preComments = preComments.slice(copyrightComments.length);
                }
                if (onlyPinnedOrTripleSlashComments) {
                    preComments = TypeScript.ArrayUtilities.where(preComments, function (c) { return _this.isPinnedOrTripleSlash(c); });
                }
                this.emitCommentsArray(preComments, false);
            }
            else {
                this.emitCommentsArray(ast.postComments(), true);
            }
        };
        Emitter.prototype.isPinnedOrTripleSlash = function (comment) {
            var fullText = comment.fullText();
            if (fullText.match(TypeScript.tripleSlashReferenceRegExp)) {
                return true;
            }
            else {
                return fullText.indexOf("/*!") === 0;
            }
        };
        Emitter.prototype.emitCommentsArray = function (comments, trailing) {
            if (!this.emitOptions.compilationSettings().removeComments() && comments) {
                for (var i = 0, n = comments.length; i < n; i++) {
                    this.emitComment(comments[i], trailing, i === 0);
                }
            }
        };
        Emitter.prototype.emitObjectLiteralExpression = function (objectLiteral) {
            this.recordSourceMappingStart(objectLiteral);
            this.writeToOutput("{");
            this.emitCommaSeparatedList(objectLiteral, objectLiteral.propertyAssignments, " ", true, objectLiteral.newLineMode);
            this.writeToOutput("}");
            this.recordSourceMappingEnd(objectLiteral);
        };
        Emitter.prototype.emitArrayLiteralExpression = function (arrayLiteral) {
            this.recordSourceMappingStart(arrayLiteral);
            this.writeToOutput("[");
            this.emitCommaSeparatedList(arrayLiteral, arrayLiteral.expressions, "", true, arrayLiteral.newLineMode);
            this.writeToOutput("]");
            this.recordSourceMappingEnd(arrayLiteral);
        };
        Emitter.prototype.emitObjectCreationExpression = function (objectCreationExpression) {
            this.recordSourceMappingStart(objectCreationExpression);
            this.writeToOutput("new ");
            var target = objectCreationExpression.expression;
            this.emit(target);
            if (objectCreationExpression.argumentList) {
                this.recordSourceMappingStart(objectCreationExpression.argumentList);
                this.writeToOutput("(");
                this.emitCommaSeparatedList(objectCreationExpression.argumentList, objectCreationExpression.argumentList.args, "", false);
                this.writeToOutputWithSourceMapRecord(")", objectCreationExpression.argumentList.closeParenToken);
                this.recordSourceMappingEnd(objectCreationExpression.argumentList);
            }
            this.recordSourceMappingEnd(objectCreationExpression);
        };
        Emitter.prototype.getConstantDecl = function (dotExpr) {
            var pullSymbol = this.semanticInfoChain.getSymbolForAST(dotExpr);
            if (pullSymbol && pullSymbol.kind === TypeScript.PullElementKind.EnumMember) {
                var pullDecls = pullSymbol.getDeclarations();
                if (pullDecls.length === 1) {
                    var pullDecl = pullDecls[0];
                    if (pullDecl.kind === TypeScript.PullElementKind.EnumMember) {
                        return pullDecl;
                    }
                }
            }
            return null;
        };
        Emitter.prototype.tryEmitConstant = function (dotExpr) {
            var propertyName = dotExpr.name;
            var boundDecl = this.getConstantDecl(dotExpr);
            if (boundDecl) {
                var value = boundDecl.constantValue;
                if (value !== null) {
                    this.recordSourceMappingStart(dotExpr);
                    this.writeToOutput(value.toString());
                    var comment = " /* ";
                    comment += propertyName.text();
                    comment += " */";
                    this.writeToOutput(comment);
                    this.recordSourceMappingEnd(dotExpr);
                    return true;
                }
            }
            return false;
        };
        Emitter.prototype.emitInvocationExpression = function (callNode) {
            this.recordSourceMappingStart(callNode);
            var target = callNode.expression;
            var args = callNode.argumentList.args;
            if (target.kind() === TypeScript.SyntaxKind.MemberAccessExpression && target.expression.kind() === TypeScript.SyntaxKind.SuperKeyword) {
                this.emit(target);
                this.writeToOutput(".call");
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                this.emitThis();
                if (args && args.nonSeparatorCount() > 0) {
                    this.writeToOutput(", ");
                    this.emitCommaSeparatedList(callNode.argumentList, args, "", false);
                }
            }
            else {
                if (callNode.expression.kind() === TypeScript.SyntaxKind.SuperKeyword && this.emitState.container === EmitContainer.Constructor) {
                    this.writeToOutput("_super.call");
                }
                else {
                    this.emitJavascript(target, false);
                }
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                if (callNode.expression.kind() === TypeScript.SyntaxKind.SuperKeyword && this.emitState.container === EmitContainer.Constructor) {
                    this.writeToOutput("this");
                    if (args && args.nonSeparatorCount() > 0) {
                        this.writeToOutput(", ");
                    }
                }
                this.emitCommaSeparatedList(callNode.argumentList, args, "", false);
            }
            this.writeToOutputWithSourceMapRecord(")", callNode.argumentList.closeParenToken);
            this.recordSourceMappingEnd(args);
            this.recordSourceMappingEnd(callNode);
        };
        Emitter.prototype.emitParameterList = function (list) {
            this.writeToOutput("(");
            this.emitCommentsArray(list.openParenTrailingComments, true);
            this.emitFunctionParameters(TypeScript.Parameters.fromParameterList(list));
            this.writeToOutput(")");
        };
        Emitter.prototype.emitFunctionParameters = function (parameters) {
            var argsLen = 0;
            if (parameters) {
                this.emitComments(parameters.ast, true);
                var tempContainer = this.setContainer(EmitContainer.Args);
                argsLen = parameters.length;
                var printLen = argsLen;
                if (parameters.lastParameterIsRest()) {
                    printLen--;
                }
                for (var i = 0; i < printLen; i++) {
                    var arg = parameters.astAt(i);
                    this.emit(arg);
                    if (i < (printLen - 1)) {
                        this.writeToOutput(", ");
                    }
                }
                this.setContainer(tempContainer);
                this.emitComments(parameters.ast, false);
            }
        };
        Emitter.prototype.emitFunctionBodyStatements = function (name, funcDecl, parameterList, block, bodyExpression) {
            this.writeLineToOutput(" {");
            if (name) {
                this.recordSourceMappingNameStart(name);
            }
            this.indenter.increaseIndent();
            if (parameterList) {
                this.emitDefaultValueAssignments(parameterList);
                this.emitRestParameterInitializer(parameterList);
            }
            if (this.shouldCaptureThis(funcDecl)) {
                this.writeCaptureThisStatement(funcDecl);
            }
            if (block) {
                this.emitList(block.statements);
                this.emitCommentsArray(block.closeBraceLeadingComments, false);
            }
            else {
                this.emitIndent();
                this.emitCommentsArray(bodyExpression.preComments(), false);
                this.writeToOutput("return ");
                this.emit(bodyExpression);
                this.writeLineToOutput(";");
                this.emitCommentsArray(bodyExpression.postComments(), true);
            }
            this.indenter.decreaseIndent();
            this.emitIndent();
            if (block) {
                this.writeToOutputWithSourceMapRecord("}", block.closeBraceToken);
            }
            else {
                this.writeToOutputWithSourceMapRecord("}", bodyExpression);
            }
            if (name) {
                this.recordSourceMappingNameEnd();
            }
        };
        Emitter.prototype.emitDefaultValueAssignments = function (parameters) {
            var n = parameters.length;
            if (parameters.lastParameterIsRest()) {
                n--;
            }
            for (var i = 0; i < n; i++) {
                var arg = parameters.astAt(i);
                var id = parameters.identifierAt(i);
                var equalsValueClause = parameters.initializerAt(i);
                if (equalsValueClause) {
                    this.emitIndent();
                    this.recordSourceMappingStart(arg);
                    this.writeToOutput("if (typeof " + id.text() + " === \"undefined\") { ");
                    this.writeToOutputWithSourceMapRecord(id.text(), id);
                    this.emitJavascript(equalsValueClause, false);
                    this.writeLineToOutput("; }");
                    this.recordSourceMappingEnd(arg);
                }
            }
        };
        Emitter.prototype.emitRestParameterInitializer = function (parameters) {
            if (parameters.lastParameterIsRest()) {
                var n = parameters.length;
                var lastArg = parameters.astAt(n - 1);
                var id = parameters.identifierAt(n - 1);
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var ");
                this.writeToOutputWithSourceMapRecord(id.text(), id);
                this.writeLineToOutput(" = [];");
                this.recordSourceMappingEnd(lastArg);
                this.emitIndent();
                this.writeToOutput("for (");
                this.writeToOutputWithSourceMapRecord("var _i = 0;", lastArg);
                this.writeToOutput(" ");
                this.writeToOutputWithSourceMapRecord("_i < (arguments.length - " + (n - 1) + ")", lastArg);
                this.writeToOutput("; ");
                this.writeToOutputWithSourceMapRecord("_i++", lastArg);
                this.writeLineToOutput(") {");
                this.indenter.increaseIndent();
                this.emitIndent();
                this.writeToOutputWithSourceMapRecord(id.text() + "[_i] = arguments[_i + " + (n - 1) + "];", lastArg);
                this.writeLineToOutput("");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
            }
        };
        Emitter.prototype.getImportDecls = function (fileName) {
            var topLevelDecl = this.semanticInfoChain.topLevelDecl(this.document.fileName);
            var result = [];
            var dynamicModuleDecl = topLevelDecl.getChildDecls()[0];
            var queue = dynamicModuleDecl.getChildDecls();
            for (var i = 0, n = queue.length; i < n; i++) {
                var decl = queue[i];
                if (decl.kind & TypeScript.PullElementKind.TypeAlias) {
                    var importStatementAST = this.semanticInfoChain.getASTForDecl(decl);
                    if (importStatementAST.moduleReference.kind() === TypeScript.SyntaxKind.ExternalModuleReference) {
                        var symbol = decl.getSymbol();
                        var typeSymbol = symbol && symbol.type;
                        if (typeSymbol && typeSymbol !== this.semanticInfoChain.anyTypeSymbol && !typeSymbol.isError()) {
                            result.push(decl);
                        }
                    }
                }
            }
            return result;
        };
        Emitter.prototype.getModuleImportAndDependencyList = function (sourceUnit) {
            var importList = "";
            var dependencyList = "";
            var importDecls = this.getImportDecls(this.document.fileName);
            if (importDecls.length) {
                for (var i = 0; i < importDecls.length; i++) {
                    var importStatementDecl = importDecls[i];
                    var importStatementSymbol = importStatementDecl.getSymbol();
                    var importStatementAST = this.semanticInfoChain.getASTForDecl(importStatementDecl);
                    if (importStatementSymbol.isUsedAsValue()) {
                        if (i <= importDecls.length - 1) {
                            dependencyList += ", ";
                            importList += ", ";
                        }
                        importList += importStatementDecl.name;
                        dependencyList += importStatementAST.moduleReference.stringLiteral.text();
                    }
                }
            }
            var amdDependencies = this.document.amdDependencies();
            for (var i = 0; i < amdDependencies.length; i++) {
                dependencyList += ", \"" + amdDependencies[i] + "\"";
            }
            return {
                importList: importList,
                dependencyList: dependencyList
            };
        };
        Emitter.prototype.shouldCaptureThis = function (ast) {
            if (ast.kind() === TypeScript.SyntaxKind.SourceUnit) {
                var scriptDecl = this.semanticInfoChain.topLevelDecl(this.document.fileName);
                return TypeScript.hasFlag(scriptDecl.flags, TypeScript.PullElementFlags.MustCaptureThis);
            }
            var decl = this.semanticInfoChain.getDeclForAST(ast);
            if (decl) {
                return TypeScript.hasFlag(decl.flags, TypeScript.PullElementFlags.MustCaptureThis);
            }
            return false;
        };
        Emitter.prototype.emitEnum = function (moduleDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(moduleDecl);
            this.pushDecl(pullDecl);
            var svModuleName = this.moduleName;
            this.moduleName = moduleDecl.identifier.text();
            var temp = this.setContainer(EmitContainer.Module);
            var isExported = TypeScript.hasFlag(pullDecl.flags, TypeScript.PullElementFlags.Exported);
            if (!isExported) {
                this.recordSourceMappingStart(moduleDecl);
                this.writeToOutput("var ");
                this.recordSourceMappingStart(moduleDecl.identifier);
                this.writeToOutput(this.moduleName);
                this.recordSourceMappingEnd(moduleDecl.identifier);
                this.writeLineToOutput(";");
                this.recordSourceMappingEnd(moduleDecl);
                this.emitIndent();
            }
            this.writeToOutput("(");
            this.recordSourceMappingStart(moduleDecl);
            this.writeToOutput("function (");
            this.writeToOutputWithSourceMapRecord(this.moduleName, moduleDecl.identifier);
            this.writeLineToOutput(") {");
            this.recordSourceMappingNameStart(this.moduleName);
            this.indenter.increaseIndent();
            if (this.shouldCaptureThis(moduleDecl)) {
                this.writeCaptureThisStatement(moduleDecl);
            }
            this.emitSeparatedList(moduleDecl.enumElements);
            this.indenter.decreaseIndent();
            this.emitIndent();
            var parentIsDynamic = temp === EmitContainer.DynamicModule;
            if (temp === EmitContainer.Prog && isExported) {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
            }
            else if (isExported || temp === EmitContainer.Prog) {
                var dotMod = svModuleName !== "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
            }
            else if (!isExported && temp !== EmitContainer.Prog) {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
            }
            else {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.writeToOutput(")();");
            }
            this.recordSourceMappingEnd(moduleDecl);
            if (temp !== EmitContainer.Prog && isExported) {
                this.recordSourceMappingStart(moduleDecl);
                if (parentIsDynamic) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    this.writeToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                }
                else {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    this.writeToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                }
                this.recordSourceMappingEnd(moduleDecl);
            }
            this.setContainer(temp);
            this.moduleName = svModuleName;
            this.popDecl(pullDecl);
        };
        Emitter.prototype.getModuleDeclToVerifyChildNameCollision = function (moduleDecl, changeNameIfAnyDeclarationInContext) {
            if (TypeScript.ArrayUtilities.contains(this.declStack, moduleDecl)) {
                return moduleDecl;
            }
            else if (changeNameIfAnyDeclarationInContext) {
                var symbol = moduleDecl.getSymbol();
                if (symbol) {
                    var otherDecls = symbol.getDeclarations();
                    for (var i = 0; i < otherDecls.length; i++) {
                        if (TypeScript.ArrayUtilities.contains(this.declStack, otherDecls[i])) {
                            return otherDecls[i];
                        }
                    }
                }
            }
            return null;
        };
        Emitter.prototype.hasChildNameCollision = function (moduleName, childDecls) {
            var _this = this;
            return TypeScript.ArrayUtilities.any(childDecls, function (childDecl) {
                if (childDecl.name == moduleName) {
                    var childAST = _this.semanticInfoChain.getASTForDecl(childDecl);
                    if (_this.shouldEmit(childAST)) {
                        return true;
                    }
                }
                return false;
            });
        };
        Emitter.prototype.getModuleName = function (moduleDecl, changeNameIfAnyDeclarationInContext) {
            var moduleName = moduleDecl.name;
            var moduleDisplayName = moduleDecl.getDisplayName();
            moduleDecl = this.getModuleDeclToVerifyChildNameCollision(moduleDecl, changeNameIfAnyDeclarationInContext);
            if (moduleDecl) {
                var childDecls = moduleDecl.getChildDecls();
                while (this.hasChildNameCollision(moduleName, childDecls)) {
                    moduleName = "_" + moduleName;
                    moduleDisplayName = "_" + moduleDisplayName;
                }
            }
            return moduleDisplayName;
        };
        Emitter.prototype.emitModuleDeclarationWorker = function (moduleDecl) {
            if (moduleDecl.stringLiteral) {
                this.emitSingleModuleDeclaration(moduleDecl, moduleDecl.stringLiteral);
            }
            else {
                var moduleNames = TypeScript.getModuleNames(moduleDecl.name);
                this.emitSingleModuleDeclaration(moduleDecl, moduleNames[0]);
            }
        };
        Emitter.prototype.emitSingleModuleDeclaration = function (moduleDecl, moduleName) {
            var isLastName = TypeScript.isLastNameOfModule(moduleDecl, moduleName);
            if (isLastName) {
                this.emitComments(moduleDecl, true);
            }
            var pullDecl = this.semanticInfoChain.getDeclForAST(moduleName);
            this.pushDecl(pullDecl);
            var svModuleName = this.moduleName;
            if (moduleDecl.stringLiteral) {
                this.moduleName = moduleDecl.stringLiteral.valueText();
                if (TypeScript.isTSFile(this.moduleName)) {
                    this.moduleName = this.moduleName.substring(0, this.moduleName.length - ".ts".length);
                }
            }
            else {
                this.moduleName = moduleName.text();
            }
            var temp = this.setContainer(EmitContainer.Module);
            var isExported = TypeScript.hasFlag(pullDecl.flags, TypeScript.PullElementFlags.Exported);
            if (!isExported) {
                this.recordSourceMappingStart(moduleDecl);
                this.writeToOutput("var ");
                this.recordSourceMappingStart(moduleName);
                this.writeToOutput(this.moduleName);
                this.recordSourceMappingEnd(moduleName);
                this.writeLineToOutput(";");
                this.recordSourceMappingEnd(moduleDecl);
                this.emitIndent();
            }
            this.writeToOutput("(");
            this.recordSourceMappingStart(moduleDecl);
            this.writeToOutput("function (");
            this.moduleName = this.getModuleName(pullDecl);
            this.writeToOutputWithSourceMapRecord(this.moduleName, moduleName);
            this.writeLineToOutput(") {");
            this.recordSourceMappingNameStart(moduleName.text());
            this.indenter.increaseIndent();
            if (this.shouldCaptureThis(moduleDecl)) {
                this.writeCaptureThisStatement(moduleDecl);
            }
            if (moduleName === moduleDecl.stringLiteral) {
                this.emitList(moduleDecl.moduleElements);
            }
            else {
                var moduleNames = TypeScript.getModuleNames(moduleDecl.name);
                var nameIndex = moduleNames.indexOf(moduleName);
                TypeScript.Debug.assert(nameIndex >= 0);
                if (isLastName) {
                    this.emitList(moduleDecl.moduleElements);
                }
                else {
                    this.emitIndent();
                    this.emitSingleModuleDeclaration(moduleDecl, moduleNames[nameIndex + 1]);
                    this.writeLineToOutput("");
                }
            }
            this.moduleName = moduleName.text();
            this.indenter.decreaseIndent();
            this.emitIndent();
            var parentIsDynamic = temp === EmitContainer.DynamicModule;
            this.recordSourceMappingStart(moduleDecl.endingToken);
            if (temp === EmitContainer.Prog && isExported) {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(moduleDecl.endingToken);
                this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
            }
            else if (isExported || temp === EmitContainer.Prog) {
                var dotMod = svModuleName !== "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(moduleDecl.endingToken);
                this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
            }
            else if (!isExported && temp !== EmitContainer.Prog) {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(moduleDecl.endingToken);
                this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
            }
            else {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(moduleDecl.endingToken);
                this.writeToOutput(")();");
            }
            this.recordSourceMappingEnd(moduleDecl);
            if (temp !== EmitContainer.Prog && isExported) {
                this.recordSourceMappingStart(moduleDecl);
                if (parentIsDynamic) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    this.writeToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                }
                else {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    this.writeToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                }
                this.recordSourceMappingEnd(moduleDecl);
            }
            this.setContainer(temp);
            this.moduleName = svModuleName;
            this.popDecl(pullDecl);
            if (isLastName) {
                this.emitComments(moduleDecl, false);
            }
        };
        Emitter.prototype.emitEnumElement = function (varDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(varDecl);
            TypeScript.Debug.assert(pullDecl && pullDecl.kind === TypeScript.PullElementKind.EnumMember);
            this.emitComments(varDecl, true);
            this.recordSourceMappingStart(varDecl);
            var name = varDecl.propertyName.text();
            var quoted = TypeScript.isQuoted(name);
            this.writeToOutput(this.moduleName);
            this.writeToOutput('[');
            this.writeToOutput(this.moduleName);
            this.writeToOutput('[');
            this.writeToOutput(quoted ? name : '"' + name + '"');
            this.writeToOutput(']');
            if (varDecl.equalsValueClause) {
                this.emit(varDecl.equalsValueClause);
            }
            else if (pullDecl.constantValue !== null) {
                this.writeToOutput(' = ');
                this.writeToOutput(pullDecl.constantValue.toString());
            }
            else {
                this.writeToOutput(' = null');
            }
            this.writeToOutput('] = ');
            this.writeToOutput(quoted ? name : '"' + name + '"');
            this.recordSourceMappingEnd(varDecl);
            this.emitComments(varDecl, false);
            this.writeToOutput(';');
        };
        Emitter.prototype.emitElementAccessExpression = function (expression) {
            this.recordSourceMappingStart(expression);
            this.emit(expression.expression);
            this.writeToOutput("[");
            this.emit(expression.argumentExpression);
            this.writeToOutput("]");
            this.recordSourceMappingEnd(expression);
        };
        Emitter.prototype.emitSimpleArrowFunctionExpression = function (arrowFunction) {
            this.emitAnyArrowFunctionExpression(arrowFunction, null, TypeScript.Parameters.fromIdentifier(arrowFunction.identifier), arrowFunction.block, arrowFunction.expression);
        };
        Emitter.prototype.emitParenthesizedArrowFunctionExpression = function (arrowFunction) {
            this.emitAnyArrowFunctionExpression(arrowFunction, null, TypeScript.Parameters.fromParameterList(arrowFunction.callSignature.parameterList), arrowFunction.block, arrowFunction.expression);
        };
        Emitter.prototype.emitAnyArrowFunctionExpression = function (arrowFunction, funcName, parameters, block, expression) {
            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = true;
            var temp = this.setContainer(EmitContainer.Function);
            this.recordSourceMappingStart(arrowFunction);
            var pullDecl = this.semanticInfoChain.getDeclForAST(arrowFunction);
            this.pushDecl(pullDecl);
            this.emitComments(arrowFunction, true);
            this.recordSourceMappingStart(arrowFunction);
            this.writeToOutput("function ");
            this.writeToOutput("(");
            this.emitFunctionParameters(parameters);
            this.writeToOutput(")");
            this.emitFunctionBodyStatements(funcName, arrowFunction, parameters, block, expression);
            this.recordSourceMappingEnd(arrowFunction);
            this.recordSourceMappingEnd(arrowFunction);
            this.emitComments(arrowFunction, false);
            this.popDecl(pullDecl);
            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;
        };
        Emitter.prototype.emitConstructor = function (funcDecl) {
            if (!funcDecl.block) {
                return;
            }
            var temp = this.setContainer(EmitContainer.Constructor);
            this.recordSourceMappingStart(funcDecl);
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);
            this.emitComments(funcDecl, true);
            this.recordSourceMappingStart(funcDecl);
            this.writeToOutput("function ");
            this.writeToOutput(this.thisClassNode.identifier.text());
            this.writeToOutput("(");
            var parameters = TypeScript.Parameters.fromParameterList(funcDecl.parameterList);
            this.emitFunctionParameters(parameters);
            this.writeLineToOutput(") {");
            this.recordSourceMappingNameStart("constructor");
            this.indenter.increaseIndent();
            this.emitDefaultValueAssignments(parameters);
            this.emitRestParameterInitializer(parameters);
            if (this.shouldCaptureThis(funcDecl)) {
                this.writeCaptureThisStatement(funcDecl);
            }
            this.emitConstructorStatements(funcDecl);
            this.emitCommentsArray(funcDecl.block.closeBraceLeadingComments, false);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutputWithSourceMapRecord("}", funcDecl.block.closeBraceToken);
            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(funcDecl);
            this.recordSourceMappingEnd(funcDecl);
            this.emitComments(funcDecl, false);
            this.popDecl(pullDecl);
            this.setContainer(temp);
        };
        Emitter.prototype.emitGetAccessor = function (accessor) {
            this.recordSourceMappingStart(accessor);
            this.writeToOutput("get ");
            var temp = this.setContainer(EmitContainer.Function);
            this.recordSourceMappingStart(accessor);
            var pullDecl = this.semanticInfoChain.getDeclForAST(accessor);
            this.pushDecl(pullDecl);
            this.recordSourceMappingStart(accessor);
            var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(accessor, this.semanticInfoChain);
            var container = accessorSymbol.getContainer();
            var containerKind = container.kind;
            this.recordSourceMappingNameStart(accessor.propertyName.text());
            this.writeToOutput(accessor.propertyName.text());
            this.writeToOutput("(");
            this.writeToOutput(")");
            this.emitFunctionBodyStatements(null, accessor, TypeScript.Parameters.fromParameterList(accessor.parameterList), accessor.block, null);
            this.recordSourceMappingEnd(accessor);
            this.recordSourceMappingEnd(accessor);
            this.popDecl(pullDecl);
            this.setContainer(temp);
            this.recordSourceMappingEnd(accessor);
        };
        Emitter.prototype.emitSetAccessor = function (accessor) {
            this.recordSourceMappingStart(accessor);
            this.writeToOutput("set ");
            var temp = this.setContainer(EmitContainer.Function);
            this.recordSourceMappingStart(accessor);
            var pullDecl = this.semanticInfoChain.getDeclForAST(accessor);
            this.pushDecl(pullDecl);
            this.recordSourceMappingStart(accessor);
            var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(accessor, this.semanticInfoChain);
            var container = accessorSymbol.getContainer();
            var containerKind = container.kind;
            this.recordSourceMappingNameStart(accessor.propertyName.text());
            this.writeToOutput(accessor.propertyName.text());
            this.writeToOutput("(");
            var parameters = TypeScript.Parameters.fromParameterList(accessor.parameterList);
            this.emitFunctionParameters(parameters);
            this.writeToOutput(")");
            this.emitFunctionBodyStatements(null, accessor, parameters, accessor.block, null);
            this.recordSourceMappingEnd(accessor);
            this.recordSourceMappingEnd(accessor);
            this.popDecl(pullDecl);
            this.setContainer(temp);
            this.recordSourceMappingEnd(accessor);
        };
        Emitter.prototype.emitFunctionExpression = function (funcDecl) {
            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = false;
            var temp = this.setContainer(EmitContainer.Function);
            var funcName = funcDecl.identifier ? funcDecl.identifier.text() : null;
            this.recordSourceMappingStart(funcDecl);
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);
            this.recordSourceMappingStart(funcDecl);
            this.writeToOutput("function ");
            if (funcDecl.identifier) {
                this.recordSourceMappingStart(funcDecl.identifier);
                this.writeToOutput(funcDecl.identifier.text());
                this.recordSourceMappingEnd(funcDecl.identifier);
            }
            this.writeToOutput("(");
            var parameters = TypeScript.Parameters.fromParameterList(funcDecl.callSignature.parameterList);
            this.emitFunctionParameters(parameters);
            this.writeToOutput(")");
            this.emitFunctionBodyStatements(funcName, funcDecl, parameters, funcDecl.block, null);
            this.recordSourceMappingEnd(funcDecl);
            this.recordSourceMappingEnd(funcDecl);
            this.emitComments(funcDecl, false);
            this.popDecl(pullDecl);
            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;
        };
        Emitter.prototype.emitFunction = function (funcDecl) {
            if (funcDecl.block === null) {
                return;
            }
            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = false;
            var temp = this.setContainer(EmitContainer.Function);
            var funcName = funcDecl.identifier.text();
            this.recordSourceMappingStart(funcDecl);
            var printName = funcDecl.identifier !== null;
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);
            this.emitComments(funcDecl, true);
            this.recordSourceMappingStart(funcDecl);
            this.writeToOutput("function ");
            if (printName) {
                var id = funcDecl.identifier.text();
                if (id) {
                    if (funcDecl.identifier) {
                        this.recordSourceMappingStart(funcDecl.identifier);
                    }
                    this.writeToOutput(id);
                    if (funcDecl.identifier) {
                        this.recordSourceMappingEnd(funcDecl.identifier);
                    }
                }
            }
            this.emitParameterList(funcDecl.callSignature.parameterList);
            var parameters = TypeScript.Parameters.fromParameterList(funcDecl.callSignature.parameterList);
            this.emitFunctionBodyStatements(funcDecl.identifier.text(), funcDecl, parameters, funcDecl.block, null);
            this.recordSourceMappingEnd(funcDecl);
            this.recordSourceMappingEnd(funcDecl);
            this.emitComments(funcDecl, false);
            this.popDecl(pullDecl);
            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;
            if (funcDecl.block) {
                var pullFunctionDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
                if ((this.emitState.container === EmitContainer.Module || this.emitState.container === EmitContainer.DynamicModule) && pullFunctionDecl && TypeScript.hasFlag(pullFunctionDecl.flags, TypeScript.PullElementFlags.Exported)) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    var modName = this.emitState.container === EmitContainer.Module ? this.moduleName : "exports";
                    this.recordSourceMappingStart(funcDecl);
                    this.writeToOutput(modName + "." + funcName + " = " + funcName + ";");
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
        };
        Emitter.prototype.emitAmbientVarDecl = function (varDecl) {
            this.recordSourceMappingStart(this.currentVariableDeclaration);
            if (varDecl.equalsValueClause) {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                this.writeToOutputWithSourceMapRecord(varDecl.propertyName.text(), varDecl.propertyName);
                this.emitJavascript(varDecl.equalsValueClause, false);
                this.recordSourceMappingEnd(varDecl);
                this.emitComments(varDecl, false);
            }
        };
        Emitter.prototype.emitVarDeclVar = function () {
            if (this.currentVariableDeclaration) {
                this.writeToOutput("var ");
            }
        };
        Emitter.prototype.emitVariableDeclaration = function (declaration) {
            var varDecl = declaration.declarators.nonSeparatorAt(0);
            var symbol = this.semanticInfoChain.getSymbolForAST(varDecl);
            var parentSymbol = symbol ? symbol.getContainer() : null;
            var parentKind = parentSymbol ? parentSymbol.kind : TypeScript.PullElementKind.None;
            this.emitComments(declaration, true);
            var pullVarDecl = this.semanticInfoChain.getDeclForAST(varDecl);
            var isAmbientWithoutInit = pullVarDecl && TypeScript.hasFlag(pullVarDecl.flags, TypeScript.PullElementFlags.Ambient) && varDecl.equalsValueClause === null;
            if (!isAmbientWithoutInit) {
                var prevVariableDeclaration = this.currentVariableDeclaration;
                this.currentVariableDeclaration = declaration;
                for (var i = 0, n = declaration.declarators.nonSeparatorCount(); i < n; i++) {
                    var declarator = declaration.declarators.nonSeparatorAt(i);
                    if (i > 0) {
                        this.writeToOutput(", ");
                    }
                    this.emit(declarator);
                }
                this.currentVariableDeclaration = prevVariableDeclaration;
                this.recordSourceMappingEnd(declaration);
            }
            this.emitComments(declaration, false);
        };
        Emitter.prototype.emitMemberVariableDeclaration = function (varDecl) {
            TypeScript.Debug.assert(!TypeScript.hasModifier(varDecl.modifiers, TypeScript.PullElementFlags.Static) && varDecl.variableDeclarator.equalsValueClause);
            var pullDecl = this.semanticInfoChain.getDeclForAST(varDecl);
            this.pushDecl(pullDecl);
            this.emitComments(varDecl, true);
            this.recordSourceMappingStart(varDecl);
            var varDeclName = varDecl.variableDeclarator.propertyName.text();
            var quotedOrNumber = TypeScript.isQuoted(varDeclName) || varDecl.variableDeclarator.propertyName.kind() !== TypeScript.SyntaxKind.IdentifierName;
            var symbol = this.semanticInfoChain.getSymbolForAST(varDecl);
            var parentSymbol = symbol ? symbol.getContainer() : null;
            var parentDecl = pullDecl && pullDecl.getParentDecl();
            if (quotedOrNumber) {
                this.writeToOutput("this[");
            }
            else {
                this.writeToOutput("this.");
            }
            this.writeToOutputWithSourceMapRecord(varDecl.variableDeclarator.propertyName.text(), varDecl.variableDeclarator.propertyName);
            if (quotedOrNumber) {
                this.writeToOutput("]");
            }
            if (varDecl.variableDeclarator.equalsValueClause) {
                var prevVariableDeclaration = this.currentVariableDeclaration;
                this.emit(varDecl.variableDeclarator.equalsValueClause);
                this.currentVariableDeclaration = prevVariableDeclaration;
            }
            if (this.emitState.container !== EmitContainer.Args) {
                this.writeToOutput(";");
            }
            this.recordSourceMappingEnd(varDecl);
            this.emitComments(varDecl, false);
            this.popDecl(pullDecl);
        };
        Emitter.prototype.emitVariableDeclarator = function (varDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(varDecl);
            this.pushDecl(pullDecl);
            if (pullDecl && (pullDecl.flags & TypeScript.PullElementFlags.Ambient) === TypeScript.PullElementFlags.Ambient) {
                this.emitAmbientVarDecl(varDecl);
            }
            else {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(this.currentVariableDeclaration);
                this.recordSourceMappingStart(varDecl);
                var varDeclName = varDecl.propertyName.text();
                var symbol = this.semanticInfoChain.getSymbolForAST(varDecl);
                var parentSymbol = symbol ? symbol.getContainer() : null;
                var parentDecl = pullDecl && pullDecl.getParentDecl();
                var parentIsModule = parentDecl && (parentDecl.flags & TypeScript.PullElementFlags.SomeInitializedModule);
                if (parentIsModule) {
                    if (!TypeScript.hasFlag(pullDecl.flags, TypeScript.PullElementFlags.Exported)) {
                        this.emitVarDeclVar();
                    }
                    else {
                        if (this.emitState.container === EmitContainer.DynamicModule) {
                            this.writeToOutput("exports.");
                        }
                        else {
                            this.writeToOutput(this.moduleName + ".");
                        }
                    }
                }
                else {
                    this.emitVarDeclVar();
                }
                this.writeToOutputWithSourceMapRecord(varDecl.propertyName.text(), varDecl.propertyName);
                if (varDecl.equalsValueClause) {
                    var prevVariableDeclaration = this.currentVariableDeclaration;
                    this.emit(varDecl.equalsValueClause);
                    this.currentVariableDeclaration = prevVariableDeclaration;
                }
                this.recordSourceMappingEnd(varDecl);
                this.emitComments(varDecl, false);
            }
            this.currentVariableDeclaration = undefined;
            this.popDecl(pullDecl);
        };
        Emitter.prototype.symbolIsUsedInItsEnclosingContainer = function (symbol, dynamic) {
            if (dynamic === void 0) { dynamic = false; }
            var symDecls = symbol.getDeclarations();
            if (symDecls.length) {
                var enclosingDecl = this.getEnclosingDecl();
                if (enclosingDecl) {
                    var parentDecl = symDecls[0].getParentDecl();
                    if (parentDecl) {
                        var symbolDeclarationEnclosingContainer = parentDecl;
                        var enclosingContainer = enclosingDecl;
                        while (symbolDeclarationEnclosingContainer) {
                            if (symbolDeclarationEnclosingContainer.kind === (dynamic ? TypeScript.PullElementKind.DynamicModule : TypeScript.PullElementKind.Container)) {
                                break;
                            }
                            symbolDeclarationEnclosingContainer = symbolDeclarationEnclosingContainer.getParentDecl();
                        }
                        if (symbolDeclarationEnclosingContainer) {
                            while (enclosingContainer) {
                                if (enclosingContainer.kind === (dynamic ? TypeScript.PullElementKind.DynamicModule : TypeScript.PullElementKind.Container)) {
                                    break;
                                }
                                enclosingContainer = enclosingContainer.getParentDecl();
                            }
                        }
                        if (symbolDeclarationEnclosingContainer && enclosingContainer) {
                            var same = symbolDeclarationEnclosingContainer === enclosingContainer;
                            if (!same && symbol.anyDeclHasFlag(TypeScript.PullElementFlags.InitializedModule)) {
                                same = symbolDeclarationEnclosingContainer === enclosingContainer.getParentDecl();
                            }
                            return same;
                        }
                    }
                }
            }
            return false;
        };
        Emitter.prototype.getPotentialDeclPathInfoForEmit = function (pullSymbol) {
            var decl = pullSymbol.getDeclarations()[0];
            var parentDecl = decl.getParentDecl();
            var symbolContainerDeclPath = parentDecl ? parentDecl.getParentPath() : [];
            var enclosingContextDeclPath = this.declStack;
            var commonNodeIndex = -1;
            if (enclosingContextDeclPath.length) {
                for (var i = symbolContainerDeclPath.length - 1; i >= 0; i--) {
                    var symbolContainerDeclPathNode = symbolContainerDeclPath[i];
                    for (var j = enclosingContextDeclPath.length - 1; j >= 0; j--) {
                        var enclosingContextDeclPathNode = enclosingContextDeclPath[j];
                        if (symbolContainerDeclPathNode === enclosingContextDeclPathNode) {
                            commonNodeIndex = i;
                            break;
                        }
                    }
                    if (commonNodeIndex >= 0) {
                        break;
                    }
                }
            }
            var startingIndex = symbolContainerDeclPath.length - 1;
            for (var i = startingIndex - 1; i > commonNodeIndex; i--) {
                if (symbolContainerDeclPath[i + 1].flags & TypeScript.PullElementFlags.Exported) {
                    startingIndex = i;
                }
                else {
                    break;
                }
            }
            return { potentialPath: symbolContainerDeclPath, startingIndex: startingIndex };
        };
        Emitter.prototype.emitDottedNameFromDeclPath = function (declPath, startingIndex, lastIndex) {
            for (var i = startingIndex; i <= lastIndex; i++) {
                if (declPath[i].kind === TypeScript.PullElementKind.DynamicModule ||
                    declPath[i].flags & TypeScript.PullElementFlags.InitializedDynamicModule) {
                    this.writeToOutput("exports.");
                }
                else {
                    this.writeToOutput(this.getModuleName(declPath[i], true) + ".");
                }
            }
        };
        Emitter.prototype.emitSymbolContainerNameInEnclosingContext = function (pullSymbol) {
            var declPathInfo = this.getPotentialDeclPathInfoForEmit(pullSymbol);
            var potentialDeclPath = declPathInfo.potentialPath;
            var startingIndex = declPathInfo.startingIndex;
            this.emitDottedNameFromDeclPath(potentialDeclPath, startingIndex, potentialDeclPath.length - 1);
        };
        Emitter.prototype.getSymbolForEmit = function (ast) {
            var pullSymbol = this.semanticInfoChain.getSymbolForAST(ast);
            var pullSymbolAlias = this.semanticInfoChain.getAliasSymbolForAST(ast);
            if (pullSymbol && pullSymbolAlias) {
                var symbolToCompare = TypeScript.isTypesOnlyLocation(ast) ?
                    pullSymbolAlias.getExportAssignedTypeSymbol() :
                    pullSymbolAlias.getExportAssignedValueSymbol();
                if (pullSymbol == symbolToCompare) {
                    pullSymbol = pullSymbolAlias;
                    pullSymbolAlias = null;
                }
            }
            return { symbol: pullSymbol, aliasSymbol: pullSymbolAlias };
        };
        Emitter.prototype.emitName = function (name, addThis) {
            this.emitComments(name, true);
            this.recordSourceMappingStart(name);
            if (name.text().length > 0) {
                var symbolForEmit = this.getSymbolForEmit(name);
                var pullSymbol = symbolForEmit.symbol;
                if (!pullSymbol) {
                    pullSymbol = this.semanticInfoChain.anyTypeSymbol;
                }
                var pullSymbolAlias = symbolForEmit.aliasSymbol;
                var pullSymbolKind = pullSymbol.kind;
                var isLocalAlias = pullSymbolAlias && (pullSymbolAlias.getDeclarations()[0].getParentDecl() == this.getEnclosingDecl());
                if (addThis && (this.emitState.container !== EmitContainer.Args) && pullSymbol) {
                    var pullSymbolContainer = pullSymbol.getContainer();
                    if (pullSymbolContainer) {
                        var pullSymbolContainerKind = pullSymbolContainer.kind;
                        if (pullSymbolContainerKind === TypeScript.PullElementKind.Class) {
                            if (pullSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.Static)) {
                                this.emitSymbolContainerNameInEnclosingContext(pullSymbol);
                            }
                            else if (pullSymbolKind === TypeScript.PullElementKind.Property) {
                                this.emitThis();
                                this.writeToOutput(".");
                            }
                        }
                        else if (TypeScript.PullHelpers.symbolIsModule(pullSymbolContainer) || pullSymbolContainerKind === TypeScript.PullElementKind.Enum ||
                            pullSymbolContainer.anyDeclHasFlag(TypeScript.PullElementFlags.InitializedModule | TypeScript.PullElementFlags.Enum)) {
                            if (pullSymbolKind === TypeScript.PullElementKind.Property || pullSymbolKind === TypeScript.PullElementKind.EnumMember) {
                                this.emitSymbolContainerNameInEnclosingContext(pullSymbol);
                            }
                            else if (pullSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.Exported) &&
                                pullSymbolKind === TypeScript.PullElementKind.Variable &&
                                !pullSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.InitializedModule | TypeScript.PullElementFlags.Enum)) {
                                this.emitSymbolContainerNameInEnclosingContext(pullSymbol);
                            }
                            else if (pullSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.Exported) && !this.symbolIsUsedInItsEnclosingContainer(pullSymbol)) {
                                this.emitSymbolContainerNameInEnclosingContext(pullSymbol);
                            }
                        }
                        else if (pullSymbolContainerKind === TypeScript.PullElementKind.DynamicModule ||
                            pullSymbolContainer.anyDeclHasFlag(TypeScript.PullElementFlags.InitializedDynamicModule)) {
                            if (pullSymbolKind === TypeScript.PullElementKind.Property) {
                                this.writeToOutput("exports.");
                            }
                            else if (pullSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.Exported) &&
                                !isLocalAlias &&
                                !pullSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.ImplicitVariable) &&
                                pullSymbol.kind !== TypeScript.PullElementKind.ConstructorMethod &&
                                pullSymbol.kind !== TypeScript.PullElementKind.Class &&
                                pullSymbol.kind !== TypeScript.PullElementKind.Enum) {
                                this.writeToOutput("exports.");
                            }
                        }
                    }
                }
                this.writeToOutput(name.text());
            }
            this.recordSourceMappingEnd(name);
            this.emitComments(name, false);
        };
        Emitter.prototype.recordSourceMappingNameStart = function (name) {
            if (this.sourceMapper) {
                var nameIndex = -1;
                if (name) {
                    if (this.sourceMapper.currentNameIndex.length > 0) {
                        var parentNameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                        if (parentNameIndex != -1) {
                            name = this.sourceMapper.names[parentNameIndex] + "." + name;
                        }
                    }
                    var nameIndex = this.sourceMapper.names.length - 1;
                    for (nameIndex; nameIndex >= 0; nameIndex--) {
                        if (this.sourceMapper.names[nameIndex] == name) {
                            break;
                        }
                    }
                    if (nameIndex == -1) {
                        nameIndex = this.sourceMapper.names.length;
                        this.sourceMapper.names.push(name);
                    }
                }
                this.sourceMapper.currentNameIndex.push(nameIndex);
            }
        };
        Emitter.prototype.recordSourceMappingNameEnd = function () {
            if (this.sourceMapper) {
                this.sourceMapper.currentNameIndex.pop();
            }
        };
        Emitter.prototype.recordSourceMappingStart = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                var lineCol = { line: -1, character: -1 };
                var sourceMapping = new TypeScript.SourceMapping();
                sourceMapping.start.emittedColumn = this.emitState.column;
                sourceMapping.start.emittedLine = this.emitState.line;
                var lineMap = this.document.lineMap();
                lineMap.fillLineAndCharacterFromPosition(ast.start(), lineCol);
                sourceMapping.start.sourceColumn = lineCol.character;
                sourceMapping.start.sourceLine = lineCol.line + 1;
                lineMap.fillLineAndCharacterFromPosition(ast.end(), lineCol);
                sourceMapping.end.sourceColumn = lineCol.character;
                sourceMapping.end.sourceLine = lineCol.line + 1;
                TypeScript.Debug.assert(!isNaN(sourceMapping.start.emittedColumn));
                TypeScript.Debug.assert(!isNaN(sourceMapping.start.emittedLine));
                TypeScript.Debug.assert(!isNaN(sourceMapping.start.sourceColumn));
                TypeScript.Debug.assert(!isNaN(sourceMapping.start.sourceLine));
                TypeScript.Debug.assert(!isNaN(sourceMapping.end.sourceColumn));
                TypeScript.Debug.assert(!isNaN(sourceMapping.end.sourceLine));
                if (this.sourceMapper.currentNameIndex.length > 0) {
                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                }
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                siblings.push(sourceMapping);
                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);
                this.sourceMapper.increaseMappingLevel(ast);
            }
        };
        Emitter.prototype.recordSourceMappingEnd = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                this.sourceMapper.currentMappings.pop();
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                var sourceMapping = siblings[siblings.length - 1];
                sourceMapping.end.emittedColumn = this.emitState.column;
                sourceMapping.end.emittedLine = this.emitState.line;
                TypeScript.Debug.assert(!isNaN(sourceMapping.end.emittedColumn));
                TypeScript.Debug.assert(!isNaN(sourceMapping.end.emittedLine));
                this.sourceMapper.decreaseMappingLevel(ast);
            }
        };
        Emitter.prototype.getOutputFiles = function () {
            var result = [];
            if (this.sourceMapper !== null) {
                this.sourceMapper.emitSourceMapping();
                result.push(this.sourceMapper.getOutputFile());
            }
            result.push(this.outfile.getOutputFile());
            return result;
        };
        Emitter.prototype.emitParameterPropertyAndMemberVariableAssignments = function () {
            var constructorDecl = getLastConstructor(this.thisClassNode);
            if (constructorDecl && constructorDecl.parameterList) {
                for (var i = 0, n = constructorDecl.parameterList.parameters.nonSeparatorCount(); i < n; i++) {
                    var parameter = constructorDecl.parameterList.parameters.nonSeparatorAt(i);
                    var parameterDecl = this.semanticInfoChain.getDeclForAST(parameter);
                    if (TypeScript.hasFlag(parameterDecl.flags, TypeScript.PullElementFlags.PropertyParameter)) {
                        this.emitIndent();
                        this.recordSourceMappingStart(parameter);
                        this.writeToOutputWithSourceMapRecord("this." + parameter.identifier.text(), parameter.identifier);
                        this.writeToOutput(" = ");
                        this.writeToOutputWithSourceMapRecord(parameter.identifier.text(), parameter.identifier);
                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(parameter);
                    }
                }
            }
            for (var i = 0, n = this.thisClassNode.classElements.childCount(); i < n; i++) {
                if (this.thisClassNode.classElements.childAt(i).kind() === TypeScript.SyntaxKind.MemberVariableDeclaration) {
                    var varDecl = this.thisClassNode.classElements.childAt(i);
                    if (!TypeScript.hasModifier(varDecl.modifiers, TypeScript.PullElementFlags.Static) && varDecl.variableDeclarator.equalsValueClause) {
                        this.emitIndent();
                        this.emitMemberVariableDeclaration(varDecl);
                        this.writeLineToOutput("");
                    }
                }
            }
        };
        Emitter.prototype.isOnSameLine = function (pos1, pos2) {
            var lineMap = this.document.lineMap();
            return lineMap.getLineNumberFromPosition(pos1) === lineMap.getLineNumberFromPosition(pos2);
        };
        Emitter.prototype.emitCommaSeparatedList = function (parent, list, buffer, preserveNewLines, newLineMode) {
            if (newLineMode === void 0) { newLineMode = TypeScript.NewLineMode.None; }
            if (list === null || list.nonSeparatorCount() === 0) {
                return;
            }
            preserveNewLines = (preserveNewLines && (newLineMode !== TypeScript.NewLineMode.Suppress));
            var forceNewLines = (newLineMode === TypeScript.NewLineMode.Force);
            var startLine = forceNewLines || (preserveNewLines && !this.isOnSameLine(parent.end(), list.nonSeparatorAt(0).end()));
            if (preserveNewLines) {
                this.indenter.increaseIndent();
            }
            if (startLine) {
                this.writeLineToOutput("");
            }
            else {
                this.writeToOutput(buffer);
            }
            for (var i = 0, n = list.nonSeparatorCount(); i < n; i++) {
                var emitNode = list.nonSeparatorAt(i);
                this.emitJavascript(emitNode, startLine);
                if (i < (n - 1)) {
                    startLine = forceNewLines || (preserveNewLines && !this.isOnSameLine(emitNode.end(), list.nonSeparatorAt(i + 1).start()));
                    if (startLine) {
                        this.writeLineToOutput(",");
                    }
                    else {
                        this.writeToOutput(", ");
                    }
                }
            }
            if (preserveNewLines) {
                this.indenter.decreaseIndent();
            }
            if (preserveNewLines && !this.isOnSameLine(parent.end(), list.nonSeparatorAt(list.nonSeparatorCount() - 1).end())) {
                this.writeLineToOutput("");
                this.emitIndent();
            }
            else {
                this.writeToOutput(buffer);
            }
        };
        Emitter.prototype.emitList = function (list, useNewLineSeparator, startInclusive, endExclusive) {
            if (useNewLineSeparator === void 0) { useNewLineSeparator = true; }
            if (startInclusive === void 0) { startInclusive = 0; }
            if (endExclusive === void 0) { endExclusive = list.childCount(); }
            if (list === null) {
                return;
            }
            this.emitComments(list, true);
            var lastEmittedNode = null;
            for (var i = startInclusive; i < endExclusive; i++) {
                var node = list.childAt(i);
                if (this.shouldEmit(node)) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);
                    this.emitJavascript(node, true);
                    if (useNewLineSeparator) {
                        this.writeLineToOutput("");
                    }
                    lastEmittedNode = node;
                }
            }
            this.emitComments(list, false);
        };
        Emitter.prototype.emitSeparatedList = function (list, useNewLineSeparator, startInclusive, endExclusive) {
            if (useNewLineSeparator === void 0) { useNewLineSeparator = true; }
            if (startInclusive === void 0) { startInclusive = 0; }
            if (endExclusive === void 0) { endExclusive = list.nonSeparatorCount(); }
            if (list === null) {
                return;
            }
            this.emitComments(list, true);
            var lastEmittedNode = null;
            for (var i = startInclusive; i < endExclusive; i++) {
                var node = list.nonSeparatorAt(i);
                if (this.shouldEmit(node)) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);
                    this.emitJavascript(node, true);
                    if (useNewLineSeparator) {
                        this.writeLineToOutput("");
                    }
                    lastEmittedNode = node;
                }
            }
            this.emitComments(list, false);
        };
        Emitter.prototype.isDirectivePrologueElement = function (node) {
            if (node.kind() === TypeScript.SyntaxKind.ExpressionStatement) {
                var exprStatement = node;
                return exprStatement.expression.kind() === TypeScript.SyntaxKind.StringLiteral;
            }
            return false;
        };
        Emitter.prototype.emitSpaceBetweenConstructs = function (node1, node2) {
            if (node1 === null || node2 === null) {
                return;
            }
            if (node1.start() === -1 || node1.end() === -1 || node2.start() === -1 || node2.end() === -1) {
                return;
            }
            var lineMap = this.document.lineMap();
            var node1EndLine = lineMap.getLineNumberFromPosition(node1.end());
            var node2StartLine = lineMap.getLineNumberFromPosition(node2.start());
            if ((node2StartLine - node1EndLine) > 1) {
                this.writeLineToOutput("", true);
            }
        };
        Emitter.prototype.getCopyrightComments = function () {
            var preComments = this.copyrightElement.preComments();
            if (preComments) {
                var lineMap = this.document.lineMap();
                var copyrightComments = [];
                var lastComment = null;
                for (var i = 0, n = preComments.length; i < n; i++) {
                    var comment = preComments[i];
                    if (lastComment) {
                        var lastCommentLine = lineMap.getLineNumberFromPosition(lastComment.end());
                        var commentLine = lineMap.getLineNumberFromPosition(comment.start());
                        if (commentLine >= lastCommentLine + 2) {
                            return copyrightComments;
                        }
                    }
                    copyrightComments.push(comment);
                    lastComment = comment;
                }
                var lastCommentLine = lineMap.getLineNumberFromPosition(TypeScript.ArrayUtilities.last(copyrightComments).end());
                var astLine = lineMap.getLineNumberFromPosition(this.copyrightElement.start());
                if (astLine >= lastCommentLine + 2) {
                    return copyrightComments;
                }
            }
            return [];
        };
        Emitter.prototype.emitPossibleCopyrightHeaders = function (script) {
            var list = script.moduleElements;
            if (list.childCount() > 0) {
                var firstElement = list.childAt(0);
                this.copyrightElement = firstElement;
                this.emitCommentsArray(this.getCopyrightComments(), false);
            }
        };
        Emitter.prototype.emitScriptElements = function (sourceUnit) {
            if (this.emitOptions.compilationSettings().shouldInstrument(sourceUnit.fileName())
                && (this.emitOptions.compilationSettings().safe() ||
                    this.emitOptions.compilationSettings().secure()) && !sourceUnit.rewrittenModuleElements) {
                if (this.emitOptions.compilationSettings().serviceMode()) {
                    this.writeToOutput("//SOMETHING WENT WRONG; TRY REFRESHING THE PAGE");
                }
                else {
                    var scriptName = sourceUnit.fileName().substring(sourceUnit.fileName().lastIndexOf("/") + 1);
                    this.writeToOutput("//SOUND TYPE CHECKER FAILED ON " + scriptName + "; NO CODE TO EMIT\n");
                }
                return;
            }
            var list = sourceUnit.rewrittenModuleElements ? sourceUnit.rewrittenModuleElements : sourceUnit.moduleElements;
            this.emitPossibleCopyrightHeaders(sourceUnit);
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var node = list.childAt(i);
                if (!this.isDirectivePrologueElement(node)) {
                    break;
                }
                this.emitJavascript(node, true);
                this.writeLineToOutput("");
            }
            this.emitPrologue(sourceUnit);
            var isExternalModule = this.document.isExternalModule();
            var isNonElidedExternalModule = isExternalModule && !TypeScript.scriptIsElided(sourceUnit);
            if (isNonElidedExternalModule) {
                this.recordSourceMappingStart(sourceUnit);
                if (this.emitOptions.compilationSettings().moduleGenTarget() === TypeScript.ModuleGenTarget.Asynchronous) {
                    var dependencyList = "[\"require\", \"exports\"";
                    var importList = "require, exports";
                    var importAndDependencyList = this.getModuleImportAndDependencyList(sourceUnit);
                    importList += importAndDependencyList.importList;
                    dependencyList += importAndDependencyList.dependencyList + "]";
                    this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");
                }
            }
            var externalModule;
            var temp;
            var svModuleName;
            if (isExternalModule) {
                temp = this.setContainer(EmitContainer.DynamicModule);
                svModuleName = this.moduleName;
                this.moduleName = sourceUnit.fileName();
                if (TypeScript.isTSFile(this.moduleName)) {
                    this.moduleName = this.moduleName.substring(0, this.moduleName.length - ".ts".length);
                }
                this.setExportAssignmentIdentifier(null);
                if (this.emitOptions.compilationSettings().moduleGenTarget() === TypeScript.ModuleGenTarget.Asynchronous) {
                    this.indenter.increaseIndent();
                }
                externalModule = this.semanticInfoChain.getDeclForAST(this.document.sourceUnit());
                if (TypeScript.hasFlag(externalModule.flags, TypeScript.PullElementFlags.MustCaptureThis)) {
                    this.writeCaptureThisStatement(sourceUnit);
                }
                this.pushDecl(externalModule);
            }
            this.emitList(list, true, i, n);
            if (isExternalModule) {
                if (this.emitOptions.compilationSettings().moduleGenTarget() === TypeScript.ModuleGenTarget.Asynchronous) {
                    this.indenter.decreaseIndent();
                }
                if (isNonElidedExternalModule) {
                    var exportAssignmentIdentifier = this.getExportAssignmentIdentifier();
                    var exportAssignmentValueSymbol = externalModule.getSymbol().getExportAssignedValueSymbol();
                    if (this.emitOptions.compilationSettings().moduleGenTarget() === TypeScript.ModuleGenTarget.Asynchronous) {
                        if (exportAssignmentIdentifier && exportAssignmentValueSymbol && !(exportAssignmentValueSymbol.kind & TypeScript.PullElementKind.SomeTypeReference)) {
                            this.indenter.increaseIndent();
                            this.emitIndent();
                            this.writeLineToOutput("return " + exportAssignmentIdentifier + ";");
                            this.indenter.decreaseIndent();
                        }
                        this.writeToOutput("});");
                    }
                    else if (exportAssignmentIdentifier && exportAssignmentValueSymbol && !(exportAssignmentValueSymbol.kind & TypeScript.PullElementKind.SomeTypeReference)) {
                        this.emitIndent();
                        this.writeToOutput("module.exports = " + exportAssignmentIdentifier + ";");
                    }
                    this.recordSourceMappingEnd(sourceUnit);
                    this.writeLineToOutput("");
                }
                this.setContainer(temp);
                this.moduleName = svModuleName;
                this.popDecl(externalModule);
            }
        };
        Emitter.prototype.emitConstructorStatements = function (funcDecl) {
            var list = funcDecl.block.statements;
            if (list === null) {
                return;
            }
            this.emitComments(list, true);
            var emitPropertyAssignmentsAfterSuperCall = TypeScript.getExtendsHeritageClause(this.thisClassNode.heritageClauses) !== null;
            var propertyAssignmentIndex = emitPropertyAssignmentsAfterSuperCall ? 1 : 0;
            var lastEmittedNode = null;
            for (var i = 0, n = list.childCount(); i < n; i++) {
                if (i === propertyAssignmentIndex) {
                    this.emitParameterPropertyAndMemberVariableAssignments();
                }
                var node = list.childAt(i);
                if (this.shouldEmit(node)) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);
                    this.emitJavascript(node, true);
                    this.writeLineToOutput("");
                    lastEmittedNode = node;
                }
            }
            if (i === propertyAssignmentIndex) {
                this.emitParameterPropertyAndMemberVariableAssignments();
            }
            this.emitComments(list, false);
        };
        Emitter.prototype.emitJavascript = function (ast, startLine) {
            if (ast === null) {
                return;
            }
            if (startLine &&
                this.indenter.indentAmt > 0) {
                this.emitIndent();
            }
            this.emit(ast);
        };
        Emitter.prototype.emitAccessorMemberDeclaration = function (funcDecl, name, className, isProto) {
            if (funcDecl.kind() !== TypeScript.SyntaxKind.GetAccessor) {
                var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain);
                if (accessorSymbol.getGetter()) {
                    return;
                }
            }
            this.emitIndent();
            this.recordSourceMappingStart(funcDecl);
            this.writeToOutput("Object.defineProperty(" + className);
            if (isProto) {
                this.writeToOutput(".prototype, ");
            }
            else {
                this.writeToOutput(", ");
            }
            var functionName = name.text();
            if (TypeScript.isQuoted(functionName)) {
                this.writeToOutput(functionName);
            }
            else {
                this.writeToOutput('"' + functionName + '"');
            }
            this.writeLineToOutput(", {");
            this.indenter.increaseIndent();
            var accessors = TypeScript.PullHelpers.getGetterAndSetterFunction(funcDecl, this.semanticInfoChain);
            if (accessors.getter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.getter);
                this.emitComments(accessors.getter, true);
                this.writeToOutput("get: ");
                this.emitAccessorBody(accessors.getter, accessors.getter.parameterList, accessors.getter.block);
                this.writeLineToOutput(",");
            }
            if (accessors.setter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.setter);
                this.emitComments(accessors.setter, true);
                this.writeToOutput("set: ");
                this.emitAccessorBody(accessors.setter, accessors.setter.parameterList, accessors.setter.block);
                this.writeLineToOutput(",");
            }
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeLineToOutput("});");
            this.recordSourceMappingEnd(funcDecl);
        };
        Emitter.prototype.emitAccessorBody = function (funcDecl, parameterList, block) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);
            this.recordSourceMappingStart(funcDecl);
            this.writeToOutput("function ");
            this.writeToOutput("(");
            var parameters = TypeScript.Parameters.fromParameterList(parameterList);
            this.emitFunctionParameters(parameters);
            this.writeToOutput(")");
            this.emitFunctionBodyStatements(null, funcDecl, parameters, block, null);
            this.recordSourceMappingEnd(funcDecl);
            this.recordSourceMappingEnd(funcDecl);
            this.popDecl(pullDecl);
        };
        Emitter.prototype.emitClass = function (classDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(classDecl);
            this.pushDecl(pullDecl);
            var svClassNode = this.thisClassNode;
            this.thisClassNode = classDecl;
            var className = classDecl.identifier.text();
            this.emitComments(classDecl, true);
            var temp = this.setContainer(EmitContainer.Class);
            this.recordSourceMappingStart(classDecl);
            this.writeToOutput("var " + className);
            var hasBaseClass = TypeScript.getExtendsHeritageClause(classDecl.heritageClauses) !== null;
            var baseTypeReference = null;
            var varDecl = null;
            if (hasBaseClass) {
                this.writeLineToOutput(" = (function (_super) {");
            }
            else {
                this.writeLineToOutput(" = (function () {");
            }
            this.recordSourceMappingNameStart(className);
            this.indenter.increaseIndent();
            if (hasBaseClass) {
                baseTypeReference = TypeScript.getExtendsHeritageClause(classDecl.heritageClauses).typeNames.nonSeparatorAt(0);
                this.emitIndent();
                this.writeLineToOutput("__extends(" + className + ", _super);");
            }
            this.emitIndent();
            var constrDecl = getLastConstructor(classDecl);
            if (constrDecl) {
                this.emit(constrDecl);
                this.writeLineToOutput("");
            }
            else {
                this.recordSourceMappingStart(classDecl);
                this.indenter.increaseIndent();
                this.writeLineToOutput("function " + classDecl.identifier.text() + "() {");
                this.recordSourceMappingNameStart("constructor");
                if (hasBaseClass) {
                    this.emitIndent();
                    this.writeLineToOutput("_super.apply(this, arguments);");
                }
                if (this.shouldCaptureThis(classDecl)) {
                    this.writeCaptureThisStatement(classDecl);
                }
                this.emitParameterPropertyAndMemberVariableAssignments();
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(classDecl);
            }
            this.emitClassMembers(classDecl);
            this.emitIndent();
            this.writeToOutputWithSourceMapRecord("return " + className + ";", classDecl.closeBraceToken);
            this.writeLineToOutput("");
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutputWithSourceMapRecord("}", classDecl.closeBraceToken);
            this.recordSourceMappingNameEnd();
            this.recordSourceMappingStart(classDecl);
            this.writeToOutput(")(");
            if (hasBaseClass) {
                this.emitJavascript(baseTypeReference, false);
            }
            this.writeToOutput(");");
            this.recordSourceMappingEnd(classDecl);
            if ((temp === EmitContainer.Module || temp === EmitContainer.DynamicModule) && TypeScript.hasFlag(pullDecl.flags, TypeScript.PullElementFlags.Exported)) {
                this.writeLineToOutput("");
                this.emitIndent();
                var modName = temp === EmitContainer.Module ? this.moduleName : "exports";
                this.writeToOutputWithSourceMapRecord(modName + "." + className + " = " + className + ";", classDecl);
            }
            this.recordSourceMappingEnd(classDecl);
            this.emitComments(classDecl, false);
            this.setContainer(temp);
            this.thisClassNode = svClassNode;
            this.popDecl(pullDecl);
        };
        Emitter.prototype.emitClassMembers = function (classDecl) {
            var lastEmittedMember = null;
            for (var i = 0, n = classDecl.classElements.childCount(); i < n; i++) {
                var memberDecl = classDecl.classElements.childAt(i);
                if (memberDecl.kind() === TypeScript.SyntaxKind.GetAccessor) {
                    this.emitSpaceBetweenConstructs(lastEmittedMember, memberDecl);
                    var getter = memberDecl;
                    this.emitAccessorMemberDeclaration(getter, getter.propertyName, classDecl.identifier.text(), !TypeScript.hasModifier(getter.modifiers, TypeScript.PullElementFlags.Static));
                    lastEmittedMember = memberDecl;
                }
                else if (memberDecl.kind() === TypeScript.SyntaxKind.SetAccessor) {
                    this.emitSpaceBetweenConstructs(lastEmittedMember, memberDecl);
                    var setter = memberDecl;
                    this.emitAccessorMemberDeclaration(setter, setter.propertyName, classDecl.identifier.text(), !TypeScript.hasModifier(setter.modifiers, TypeScript.PullElementFlags.Static));
                    lastEmittedMember = memberDecl;
                }
                else if (memberDecl.kind() === TypeScript.SyntaxKind.MemberFunctionDeclaration) {
                    var memberFunction = memberDecl;
                    if (memberFunction.block) {
                        this.emitSpaceBetweenConstructs(lastEmittedMember, memberDecl);
                        this.emitClassMemberFunctionDeclaration(classDecl, memberFunction);
                        lastEmittedMember = memberDecl;
                    }
                }
            }
            for (var i = 0, n = classDecl.classElements.childCount(); i < n; i++) {
                var memberDecl = classDecl.classElements.childAt(i);
                if (memberDecl.kind() === TypeScript.SyntaxKind.MemberVariableDeclaration) {
                    var varDecl = memberDecl;
                    if (TypeScript.hasModifier(varDecl.modifiers, TypeScript.PullElementFlags.Static) && varDecl.variableDeclarator.equalsValueClause) {
                        this.emitSpaceBetweenConstructs(lastEmittedMember, varDecl);
                        this.emitIndent();
                        this.recordSourceMappingStart(varDecl);
                        var varDeclName = varDecl.variableDeclarator.propertyName.text();
                        if (TypeScript.isQuoted(varDeclName) || varDecl.variableDeclarator.propertyName.kind() !== TypeScript.SyntaxKind.IdentifierName) {
                            this.writeToOutput(classDecl.identifier.text() + "[" + varDeclName + "]");
                        }
                        else {
                            this.writeToOutput(classDecl.identifier.text() + "." + varDeclName);
                        }
                        this.emit(varDecl.variableDeclarator.equalsValueClause);
                        this.recordSourceMappingEnd(varDecl);
                        this.writeLineToOutput(";");
                        lastEmittedMember = varDecl;
                    }
                }
            }
        };
        Emitter.prototype.emitClassMemberFunctionDeclaration = function (classDecl, funcDecl) {
            this.emitIndent();
            this.recordSourceMappingStart(funcDecl);
            this.emitComments(funcDecl, true);
            var functionName = funcDecl.propertyName.text();
            this.writeToOutput(classDecl.identifier.text());
            if (!TypeScript.hasModifier(funcDecl.modifiers, TypeScript.PullElementFlags.Static)) {
                this.writeToOutput(".prototype");
            }
            if (TypeScript.isQuoted(functionName) || funcDecl.propertyName.kind() !== TypeScript.SyntaxKind.IdentifierName) {
                this.writeToOutput("[" + functionName + "] = ");
            }
            else {
                this.writeToOutput("." + functionName + " = ");
            }
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);
            this.recordSourceMappingStart(funcDecl);
            this.writeToOutput("function ");
            this.emitParameterList(funcDecl.callSignature.parameterList);
            var parameters = TypeScript.Parameters.fromParameterList(funcDecl.callSignature.parameterList);
            this.emitFunctionBodyStatements(funcDecl.propertyName.text(), funcDecl, parameters, funcDecl.block, null);
            this.recordSourceMappingEnd(funcDecl);
            this.emitComments(funcDecl, false);
            this.recordSourceMappingEnd(funcDecl);
            this.popDecl(pullDecl);
            this.writeLineToOutput(";");
        };
        Emitter.prototype.requiresExtendsBlock = function (moduleElements) {
            for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                var moduleElement = moduleElements.childAt(i);
                if (moduleElement.kind() === TypeScript.SyntaxKind.ModuleDeclaration) {
                    var moduleAST = moduleElement;
                    if (!TypeScript.hasModifier(moduleAST.modifiers, TypeScript.PullElementFlags.Ambient) && this.requiresExtendsBlock(moduleAST.moduleElements)) {
                        return true;
                    }
                }
                else if (moduleElement.kind() === TypeScript.SyntaxKind.ClassDeclaration) {
                    var classDeclaration = moduleElement;
                    if (!TypeScript.hasModifier(classDeclaration.modifiers, TypeScript.PullElementFlags.Ambient) && TypeScript.getExtendsHeritageClause(classDeclaration.heritageClauses) !== null) {
                        return true;
                    }
                }
            }
            return false;
        };
        Emitter.prototype.emitPrologue = function (sourceUnit) {
            if (!this.extendsPrologueEmitted) {
                if (this.requiresExtendsBlock(sourceUnit.moduleElements)) {
                    this.extendsPrologueEmitted = true;
                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");
                    this.writeLineToOutput("    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];");
                    this.writeLineToOutput("    function __() { this.constructor = d; }");
                    this.writeLineToOutput("    __.prototype = b.prototype;");
                    this.writeLineToOutput("    d.prototype = new __();");
                    this.writeLineToOutput("};");
                }
            }
            if (!this.globalThisCapturePrologueEmitted) {
                if (this.shouldCaptureThis(sourceUnit)) {
                    this.globalThisCapturePrologueEmitted = true;
                    this.writeLineToOutput(this.captureThisStmtString);
                }
            }
        };
        Emitter.prototype.emitThis = function () {
            if (!this.inWithBlock && this.inArrowFunction) {
                this.writeToOutput("_this");
            }
            else {
                this.writeToOutput("this");
            }
        };
        Emitter.prototype.emitBlockOrStatement = function (node) {
            if (node.kind() === TypeScript.SyntaxKind.Block) {
                this.emit(node);
            }
            else {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emitJavascript(node, true);
                this.indenter.decreaseIndent();
            }
        };
        Emitter.prototype.emitLiteralExpression = function (expression) {
            switch (expression.kind()) {
                case TypeScript.SyntaxKind.NullKeyword:
                    this.writeToOutputWithSourceMapRecord("null", expression);
                    break;
                case TypeScript.SyntaxKind.FalseKeyword:
                    this.writeToOutputWithSourceMapRecord("false", expression);
                    break;
                case TypeScript.SyntaxKind.TrueKeyword:
                    this.writeToOutputWithSourceMapRecord("true", expression);
                    break;
                default:
                    throw TypeScript.Errors.abstract();
            }
        };
        Emitter.prototype.emitThisExpression = function (expression) {
            if (!this.inWithBlock && this.inArrowFunction) {
                this.writeToOutputWithSourceMapRecord("_this", expression);
            }
            else {
                this.writeToOutputWithSourceMapRecord("this", expression);
            }
        };
        Emitter.prototype.emitSuperExpression = function (expression) {
            this.writeToOutputWithSourceMapRecord("_super.prototype", expression);
        };
        Emitter.prototype.emitParenthesizedExpression = function (parenthesizedExpression) {
            if (parenthesizedExpression.expression.kind() === TypeScript.SyntaxKind.CastExpression && parenthesizedExpression.openParenTrailingComments === null) {
                this.emit(parenthesizedExpression.expression);
            }
            else {
                this.recordSourceMappingStart(parenthesizedExpression);
                this.writeToOutput("(");
                this.emitCommentsArray(parenthesizedExpression.openParenTrailingComments, false);
                this.emit(parenthesizedExpression.expression);
                this.writeToOutput(")");
                this.recordSourceMappingEnd(parenthesizedExpression);
            }
        };
        Emitter.prototype.emitCastExpression = function (expression) {
            this.emit(expression.expression);
        };
        Emitter.prototype.emitPrefixUnaryExpression = function (expression) {
            var nodeType = expression.kind();
            this.recordSourceMappingStart(expression);
            switch (nodeType) {
                case TypeScript.SyntaxKind.LogicalNotExpression:
                    this.writeToOutput("!");
                    this.emit(expression.operand);
                    break;
                case TypeScript.SyntaxKind.BitwiseNotExpression:
                    this.writeToOutput("~");
                    this.emit(expression.operand);
                    break;
                case TypeScript.SyntaxKind.NegateExpression:
                    this.writeToOutput("-");
                    if (expression.operand.kind() === TypeScript.SyntaxKind.NegateExpression || expression.operand.kind() === TypeScript.SyntaxKind.PreDecrementExpression) {
                        this.writeToOutput(" ");
                    }
                    this.emit(expression.operand);
                    break;
                case TypeScript.SyntaxKind.PlusExpression:
                    this.writeToOutput("+");
                    if (expression.operand.kind() === TypeScript.SyntaxKind.PlusExpression || expression.operand.kind() === TypeScript.SyntaxKind.PreIncrementExpression) {
                        this.writeToOutput(" ");
                    }
                    this.emit(expression.operand);
                    break;
                case TypeScript.SyntaxKind.PreIncrementExpression:
                    this.writeToOutput("++");
                    this.emit(expression.operand);
                    break;
                case TypeScript.SyntaxKind.PreDecrementExpression:
                    this.writeToOutput("--");
                    this.emit(expression.operand);
                    break;
                default:
                    throw TypeScript.Errors.abstract();
            }
            this.recordSourceMappingEnd(expression);
        };
        Emitter.prototype.emitPostfixUnaryExpression = function (expression) {
            var nodeType = expression.kind();
            this.recordSourceMappingStart(expression);
            switch (nodeType) {
                case TypeScript.SyntaxKind.PostIncrementExpression:
                    this.emit(expression.operand);
                    this.writeToOutput("++");
                    break;
                case TypeScript.SyntaxKind.PostDecrementExpression:
                    this.emit(expression.operand);
                    this.writeToOutput("--");
                    break;
                default:
                    throw TypeScript.Errors.abstract();
            }
            this.recordSourceMappingEnd(expression);
        };
        Emitter.prototype.emitTypeOfExpression = function (expression) {
            this.recordSourceMappingStart(expression);
            this.writeToOutput("typeof ");
            this.emit(expression.expression);
            this.recordSourceMappingEnd(expression);
        };
        Emitter.prototype.emitDeleteExpression = function (expression) {
            this.recordSourceMappingStart(expression);
            this.writeToOutput("delete ");
            this.emit(expression.expression);
            this.recordSourceMappingEnd(expression);
        };
        Emitter.prototype.emitVoidExpression = function (expression) {
            this.recordSourceMappingStart(expression);
            this.writeToOutput("void ");
            this.emit(expression.expression);
            this.recordSourceMappingEnd(expression);
        };
        Emitter.prototype.canEmitDottedNameMemberAccessExpression = function (expression) {
            var memberExpressionNodeType = expression.expression.kind();
            if (memberExpressionNodeType == TypeScript.SyntaxKind.IdentifierName || memberExpressionNodeType == TypeScript.SyntaxKind.MemberAccessExpression) {
                var memberAccessSymbol = this.getSymbolForEmit(expression).symbol;
                var memberAccessExpressionSymbol = this.getSymbolForEmit(expression.expression).symbol;
                if (memberAccessSymbol && memberAccessExpressionSymbol
                    && !this.semanticInfoChain.getAliasSymbolForAST(expression.expression)
                    && (TypeScript.PullHelpers.symbolIsModule(memberAccessExpressionSymbol) || memberAccessExpressionSymbol.kind === TypeScript.PullElementKind.Enum ||
                        memberAccessExpressionSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.InitializedModule | TypeScript.PullElementFlags.Enum))) {
                    var memberAccessSymbolKind = memberAccessSymbol.kind;
                    if (memberAccessSymbolKind === TypeScript.PullElementKind.Property
                        || memberAccessSymbolKind === TypeScript.PullElementKind.EnumMember
                        || (memberAccessSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.Exported) && memberAccessSymbolKind === TypeScript.PullElementKind.Variable && !memberAccessSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.InitializedModule | TypeScript.PullElementFlags.Enum))
                        || ((memberAccessSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.Exported) && !this.symbolIsUsedInItsEnclosingContainer(memberAccessSymbol)))) {
                        if (memberExpressionNodeType == TypeScript.SyntaxKind.MemberAccessExpression) {
                            return this.canEmitDottedNameMemberAccessExpression(expression.expression);
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        Emitter.prototype.emitDottedNameMemberAccessExpressionWorker = function (expression, potentialPath, startingIndex, lastIndex) {
            this.recordSourceMappingStart(expression);
            if (expression.expression.kind() == TypeScript.SyntaxKind.MemberAccessExpression) {
                this.emitDottedNameMemberAccessExpressionRecurse(expression.expression, potentialPath, startingIndex, lastIndex - 1);
            }
            else {
                this.emitComments(expression.expression, true);
                this.recordSourceMappingStart(expression.expression);
                this.emitDottedNameFromDeclPath(potentialPath, startingIndex, lastIndex - 2);
                this.writeToOutput(expression.expression.text());
                this.recordSourceMappingEnd(expression.expression);
                this.emitComments(expression.expression, false);
            }
            this.writeToOutput(".");
            this.emitName(expression.name, false);
            this.recordSourceMappingEnd(expression);
        };
        Emitter.prototype.emitDottedNameMemberAccessExpressionRecurse = function (expression, potentialPath, startingIndex, lastIndex) {
            this.emitComments(expression, true);
            if (lastIndex - startingIndex < 1) {
                startingIndex = lastIndex - 1;
                TypeScript.Debug.assert(startingIndex >= 0);
            }
            this.emitDottedNameMemberAccessExpressionWorker(expression, potentialPath, startingIndex, lastIndex);
            this.emitComments(expression, false);
        };
        Emitter.prototype.emitDottedNameMemberAccessExpression = function (expression) {
            var memberAccessSymbol = this.getSymbolForEmit(expression).symbol;
            var potentialDeclInfo = this.getPotentialDeclPathInfoForEmit(memberAccessSymbol);
            this.emitDottedNameMemberAccessExpressionWorker(expression, potentialDeclInfo.potentialPath, potentialDeclInfo.startingIndex, potentialDeclInfo.potentialPath.length);
        };
        Emitter.prototype.emitMemberAccessExpression = function (expression) {
            if (!this.tryEmitConstant(expression)) {
                if (this.canEmitDottedNameMemberAccessExpression(expression)) {
                    this.emitDottedNameMemberAccessExpression(expression);
                }
                else {
                    this.recordSourceMappingStart(expression);
                    this.emit(expression.expression);
                    this.writeToOutput(".");
                    this.emitName(expression.name, false);
                    this.recordSourceMappingEnd(expression);
                }
            }
        };
        Emitter.prototype.emitQualifiedName = function (name) {
            this.recordSourceMappingStart(name);
            this.emit(name.left);
            this.writeToOutput(".");
            this.emitName(name.right, false);
            this.recordSourceMappingEnd(name);
        };
        Emitter.prototype.emitBinaryExpression = function (expression) {
            this.recordSourceMappingStart(expression);
            switch (expression.kind()) {
                case TypeScript.SyntaxKind.CommaExpression:
                    this.emit(expression.left);
                    this.writeToOutput(", ");
                    this.emit(expression.right);
                    break;
                default:
                    {
                        this.emit(expression.left);
                        var binOp = TypeScript.SyntaxFacts.getText(TypeScript.SyntaxFacts.getOperatorTokenFromBinaryExpression(expression.kind()));
                        if (binOp === "instanceof") {
                            this.writeToOutput(" instanceof ");
                        }
                        else if (binOp === "in") {
                            this.writeToOutput(" in ");
                        }
                        else {
                            this.writeToOutput(" " + binOp + " ");
                        }
                        this.emit(expression.right);
                    }
            }
            this.recordSourceMappingEnd(expression);
        };
        Emitter.prototype.emitSimplePropertyAssignment = function (property) {
            this.recordSourceMappingStart(property);
            this.emit(property.propertyName);
            this.writeToOutput(": ");
            this.emit(property.expression);
            this.recordSourceMappingEnd(property);
        };
        Emitter.prototype.emitFunctionPropertyAssignment = function (funcProp) {
            this.recordSourceMappingStart(funcProp);
            this.emit(funcProp.propertyName);
            this.writeToOutput(": ");
            var pullFunctionDecl = this.semanticInfoChain.getDeclForAST(funcProp);
            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = false;
            var temp = this.setContainer(EmitContainer.Function);
            var funcName = funcProp.propertyName;
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcProp);
            this.pushDecl(pullDecl);
            this.recordSourceMappingStart(funcProp);
            this.writeToOutput("function ");
            this.writeToOutput("(");
            var parameters = TypeScript.Parameters.fromParameterList(funcProp.callSignature.parameterList);
            this.emitFunctionParameters(parameters);
            this.writeToOutput(")");
            this.emitFunctionBodyStatements(funcProp.propertyName.text(), funcProp, parameters, funcProp.block, null);
            this.recordSourceMappingEnd(funcProp);
            this.recordSourceMappingEnd(funcProp);
            this.emitComments(funcProp, false);
            this.popDecl(pullDecl);
            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;
            this.recordSourceMappingEnd(funcProp);
        };
        Emitter.prototype.emitConditionalExpression = function (expression) {
            this.emit(expression.condition);
            this.writeToOutput(" ? ");
            this.emit(expression.whenTrue);
            this.writeToOutput(" : ");
            this.emit(expression.whenFalse);
        };
        Emitter.prototype.emitThrowStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("throw ");
            this.emit(statement.expression);
            this.recordSourceMappingEnd(statement);
            this.writeToOutput(";");
        };
        Emitter.prototype.emitExpressionStatement = function (statement) {
            var isArrowExpression = statement.expression.kind() === TypeScript.SyntaxKind.SimpleArrowFunctionExpression || statement.expression.kind() === TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression;
            this.recordSourceMappingStart(statement);
            if (isArrowExpression) {
                this.writeToOutput("(");
            }
            this.emit(statement.expression);
            if (isArrowExpression) {
                this.writeToOutput(")");
            }
            this.recordSourceMappingEnd(statement);
            this.writeToOutput(";");
        };
        Emitter.prototype.emitLabeledStatement = function (statement) {
            this.writeToOutputWithSourceMapRecord(statement.identifier.text(), statement.identifier);
            this.writeLineToOutput(":");
            this.emitJavascript(statement.statement, true);
        };
        Emitter.prototype.emitBlock = function (block) {
            this.recordSourceMappingStart(block);
            this.writeLineToOutput(" {");
            this.indenter.increaseIndent();
            if (block.statements) {
                this.emitList(block.statements);
            }
            this.emitCommentsArray(block.closeBraceLeadingComments, false);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutput("}");
            this.recordSourceMappingEnd(block);
        };
        Emitter.prototype.emitBreakStatement = function (jump) {
            this.recordSourceMappingStart(jump);
            this.writeToOutput("break");
            if (jump.identifier) {
                this.writeToOutput(" " + jump.identifier.text());
            }
            this.recordSourceMappingEnd(jump);
            this.writeToOutput(";");
        };
        Emitter.prototype.emitContinueStatement = function (jump) {
            this.recordSourceMappingStart(jump);
            this.writeToOutput("continue");
            if (jump.identifier) {
                this.writeToOutput(" " + jump.identifier.text());
            }
            this.recordSourceMappingEnd(jump);
            this.writeToOutput(";");
        };
        Emitter.prototype.emitWhileStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("while (");
            this.emit(statement.condition);
            this.writeToOutput(")");
            this.emitBlockOrStatement(statement.statement);
            this.recordSourceMappingEnd(statement);
        };
        Emitter.prototype.emitDoStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("do");
            this.emitBlockOrStatement(statement.statement);
            this.writeToOutputWithSourceMapRecord(" while", statement.whileKeyword);
            this.writeToOutput('(');
            this.emit(statement.condition);
            this.writeToOutput(")");
            this.recordSourceMappingEnd(statement);
            this.writeToOutput(";");
        };
        Emitter.prototype.emitIfStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("if (");
            this.emit(statement.condition);
            this.writeToOutput(")");
            this.emitBlockOrStatement(statement.statement);
            if (statement.elseClause) {
                if (statement.statement.kind() !== TypeScript.SyntaxKind.Block) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                }
                else {
                    this.writeToOutput(" ");
                }
                this.emit(statement.elseClause);
            }
            this.recordSourceMappingEnd(statement);
        };
        Emitter.prototype.emitElseClause = function (elseClause) {
            if (elseClause.statement.kind() === TypeScript.SyntaxKind.IfStatement) {
                this.writeToOutput("else ");
                this.emit(elseClause.statement);
            }
            else {
                this.writeToOutput("else");
                this.emitBlockOrStatement(elseClause.statement);
            }
        };
        Emitter.prototype.emitReturnStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            if (statement.expression) {
                this.writeToOutput("return ");
                this.emit(statement.expression);
            }
            else {
                this.writeToOutput("return");
            }
            this.recordSourceMappingEnd(statement);
            this.writeToOutput(";");
        };
        Emitter.prototype.emitForInStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("for (");
            if (statement.left) {
                this.emit(statement.left);
            }
            else {
                this.emit(statement.variableDeclaration);
            }
            this.writeToOutput(" in ");
            this.emit(statement.expression);
            this.writeToOutput(")");
            this.emitBlockOrStatement(statement.statement);
            this.recordSourceMappingEnd(statement);
        };
        Emitter.prototype.emitForStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("for (");
            if (statement.variableDeclaration) {
                this.emit(statement.variableDeclaration);
            }
            else if (statement.initializer) {
                this.emit(statement.initializer);
            }
            this.writeToOutput("; ");
            this.emitJavascript(statement.condition, false);
            this.writeToOutput(";");
            if (statement.incrementor) {
                this.writeToOutput(" ");
                this.emitJavascript(statement.incrementor, false);
            }
            this.writeToOutput(")");
            this.emitBlockOrStatement(statement.statement);
            this.recordSourceMappingEnd(statement);
        };
        Emitter.prototype.emitWithStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("with (");
            if (statement.condition) {
                this.emit(statement.condition);
            }
            this.writeToOutput(")");
            var prevInWithBlock = this.inWithBlock;
            this.inWithBlock = true;
            this.emitBlockOrStatement(statement.statement);
            this.inWithBlock = prevInWithBlock;
            this.recordSourceMappingEnd(statement);
        };
        Emitter.prototype.emitSwitchStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("switch (");
            this.emit(statement.expression);
            this.recordSourceMappingStart(statement.closeParenToken);
            this.writeToOutput(")");
            this.recordSourceMappingEnd(statement.closeParenToken);
            this.writeLineToOutput(" {");
            this.indenter.increaseIndent();
            this.emitList(statement.switchClauses, false);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutput("}");
            this.recordSourceMappingEnd(statement);
        };
        Emitter.prototype.emitCaseSwitchClause = function (clause) {
            this.recordSourceMappingStart(clause);
            this.writeToOutput("case ");
            this.emit(clause.expression);
            this.writeToOutput(":");
            this.emitSwitchClauseBody(clause.statements);
            this.recordSourceMappingEnd(clause);
        };
        Emitter.prototype.emitSwitchClauseBody = function (body) {
            if (body.childCount() === 1 && body.childAt(0).kind() === TypeScript.SyntaxKind.Block) {
                this.emit(body.childAt(0));
                this.writeLineToOutput("");
            }
            else {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emit(body);
                this.indenter.decreaseIndent();
            }
        };
        Emitter.prototype.emitDefaultSwitchClause = function (clause) {
            this.recordSourceMappingStart(clause);
            this.writeToOutput("default:");
            this.emitSwitchClauseBody(clause.statements);
            this.recordSourceMappingEnd(clause);
        };
        Emitter.prototype.emitTryStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("try ");
            this.emit(statement.block);
            this.emitJavascript(statement.catchClause, false);
            if (statement.finallyClause) {
                this.emit(statement.finallyClause);
            }
            this.recordSourceMappingEnd(statement);
        };
        Emitter.prototype.emitCatchClause = function (clause) {
            this.writeToOutput(" ");
            this.recordSourceMappingStart(clause);
            this.writeToOutput("catch (");
            this.emit(clause.identifier);
            this.writeToOutput(")");
            this.emit(clause.block);
            this.recordSourceMappingEnd(clause);
        };
        Emitter.prototype.emitFinallyClause = function (clause) {
            this.writeToOutput(" finally");
            this.emit(clause.block);
        };
        Emitter.prototype.emitDebuggerStatement = function (statement) {
            this.writeToOutputWithSourceMapRecord("debugger", statement);
            this.writeToOutput(";");
        };
        Emitter.prototype.emitNumericLiteral = function (literal) {
            this.writeToOutputWithSourceMapRecord(literal.text(), literal);
        };
        Emitter.prototype.emitRegularExpressionLiteral = function (literal) {
            this.writeToOutputWithSourceMapRecord(literal.text(), literal);
        };
        Emitter.prototype.emitStringLiteral = function (literal) {
            this.writeToOutputWithSourceMapRecord(literal.text(), literal);
        };
        Emitter.prototype.emitEqualsValueClause = function (clause) {
            this.writeToOutput(" = ");
            this.emit(clause.value);
        };
        Emitter.prototype.emitParameter = function (parameter) {
            this.writeToOutputWithSourceMapRecord(parameter.identifier.text(), parameter);
        };
        Emitter.prototype.emitConstructorDeclaration = function (declaration) {
            if (declaration.block) {
                this.emitConstructor(declaration);
            }
            else {
                this.emitComments(declaration, true, true);
            }
        };
        Emitter.prototype.shouldEmitFunctionDeclaration = function (declaration) {
            return declaration.preComments() !== null || (!TypeScript.hasModifier(declaration.modifiers, TypeScript.PullElementFlags.Ambient) && declaration.block !== null);
        };
        Emitter.prototype.emitFunctionDeclaration = function (declaration) {
            if (!TypeScript.hasModifier(declaration.modifiers, TypeScript.PullElementFlags.Ambient) && declaration.block !== null) {
                this.emitFunction(declaration);
            }
            else {
                this.emitComments(declaration, true, true);
            }
        };
        Emitter.prototype.emitSourceUnit = function (sourceUnit) {
            if (!this.document.isDeclareFile()) {
                var pullDecl = this.semanticInfoChain.getDeclForAST(sourceUnit);
                this.pushDecl(pullDecl);
                this.emitScriptElements(sourceUnit);
                this.popDecl(pullDecl);
            }
        };
        Emitter.prototype.shouldEmitEnumDeclaration = function (declaration) {
            return declaration.preComments() !== null || !TypeScript.enumIsElided(declaration);
        };
        Emitter.prototype.emitEnumDeclaration = function (declaration) {
            if (!TypeScript.enumIsElided(declaration)) {
                this.emitComments(declaration, true);
                this.emitEnum(declaration);
                this.emitComments(declaration, false);
            }
            else {
                this.emitComments(declaration, true, true);
            }
        };
        Emitter.prototype.shouldEmitModuleDeclaration = function (declaration) {
            return declaration.preComments() !== null || !TypeScript.moduleIsElided(declaration);
        };
        Emitter.prototype.emitModuleDeclaration = function (declaration) {
            if (!TypeScript.moduleIsElided(declaration)) {
                this.emitModuleDeclarationWorker(declaration);
            }
            else {
                this.emitComments(declaration, true, true);
            }
        };
        Emitter.prototype.shouldEmitClassDeclaration = function (declaration) {
            return declaration.preComments() !== null || !TypeScript.hasModifier(declaration.modifiers, TypeScript.PullElementFlags.Ambient);
        };
        Emitter.prototype.emitClassDeclaration = function (declaration) {
            if (!TypeScript.hasModifier(declaration.modifiers, TypeScript.PullElementFlags.Ambient)) {
                this.emitClass(declaration);
            }
            else {
                this.emitComments(declaration, true, true);
            }
        };
        Emitter.prototype.shouldEmitInterfaceDeclaration = function (declaration) {
            return declaration.preComments() !== null;
        };
        Emitter.prototype.emitInterfaceDeclaration = function (declaration) {
            this.emitComments(declaration, true, true);
        };
        Emitter.prototype.firstVariableDeclarator = function (statement) {
            return statement.declaration.declarators.nonSeparatorAt(0);
        };
        Emitter.prototype.isNotAmbientOrHasInitializer = function (variableStatement) {
            return !TypeScript.hasModifier(variableStatement.modifiers, TypeScript.PullElementFlags.Ambient) || this.firstVariableDeclarator(variableStatement).equalsValueClause !== null;
        };
        Emitter.prototype.shouldEmitVariableStatement = function (statement) {
            return statement.preComments() !== null || this.isNotAmbientOrHasInitializer(statement);
        };
        Emitter.prototype.emitVariableStatement = function (statement) {
            if (this.isNotAmbientOrHasInitializer(statement)) {
                this.emitComments(statement, true);
                this.emit(statement.declaration);
                this.writeToOutput(";");
                this.emitComments(statement, false);
            }
            else {
                this.emitComments(statement, true, true);
            }
        };
        Emitter.prototype.emitGenericType = function (type) {
            this.emit(type.name);
        };
        Emitter.prototype.shouldEmit = function (ast) {
            if (!ast) {
                return false;
            }
            switch (ast.kind()) {
                case TypeScript.SyntaxKind.ImportDeclaration:
                    return this.shouldEmitImportDeclaration(ast);
                case TypeScript.SyntaxKind.ClassDeclaration:
                    return this.shouldEmitClassDeclaration(ast);
                case TypeScript.SyntaxKind.InterfaceDeclaration:
                    return this.shouldEmitInterfaceDeclaration(ast);
                case TypeScript.SyntaxKind.FunctionDeclaration:
                    return this.shouldEmitFunctionDeclaration(ast);
                case TypeScript.SyntaxKind.ModuleDeclaration:
                    return this.shouldEmitModuleDeclaration(ast);
                case TypeScript.SyntaxKind.VariableStatement:
                    return this.shouldEmitVariableStatement(ast);
                case TypeScript.SyntaxKind.OmittedExpression:
                    return false;
                case TypeScript.SyntaxKind.EnumDeclaration:
                    return this.shouldEmitEnumDeclaration(ast);
            }
            return true;
        };
        Emitter.prototype.emit = function (ast) {
            if (!ast) {
                return;
            }
            switch (ast.kind()) {
                case TypeScript.SyntaxKind.SeparatedList:
                    return this.emitSeparatedList(ast);
                case TypeScript.SyntaxKind.List:
                    return this.emitList(ast);
                case TypeScript.SyntaxKind.SourceUnit:
                    return this.emitSourceUnit(ast);
                case TypeScript.SyntaxKind.ImportDeclaration:
                    return this.emitImportDeclaration(ast);
                case TypeScript.SyntaxKind.ExportAssignment:
                    return this.setExportAssignmentIdentifier(ast.identifier.text());
                case TypeScript.SyntaxKind.ClassDeclaration:
                    return this.emitClassDeclaration(ast);
                case TypeScript.SyntaxKind.InterfaceDeclaration:
                    return this.emitInterfaceDeclaration(ast);
                case TypeScript.SyntaxKind.IdentifierName:
                    return this.emitName(ast, true);
                case TypeScript.SyntaxKind.VariableDeclarator:
                    return this.emitVariableDeclarator(ast);
                case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
                    return this.emitSimpleArrowFunctionExpression(ast);
                case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                    return this.emitParenthesizedArrowFunctionExpression(ast);
                case TypeScript.SyntaxKind.FunctionDeclaration:
                    return this.emitFunctionDeclaration(ast);
                case TypeScript.SyntaxKind.ModuleDeclaration:
                    return this.emitModuleDeclaration(ast);
                case TypeScript.SyntaxKind.VariableDeclaration:
                    return this.emitVariableDeclaration(ast);
                case TypeScript.SyntaxKind.GenericType:
                    return this.emitGenericType(ast);
                case TypeScript.SyntaxKind.ConstructorDeclaration:
                    return this.emitConstructorDeclaration(ast);
                case TypeScript.SyntaxKind.EnumDeclaration:
                    return this.emitEnumDeclaration(ast);
                case TypeScript.SyntaxKind.EnumElement:
                    return this.emitEnumElement(ast);
                case TypeScript.SyntaxKind.FunctionExpression:
                    return this.emitFunctionExpression(ast);
                case TypeScript.SyntaxKind.VariableStatement:
                    return this.emitVariableStatement(ast);
            }
            this.emitComments(ast, true);
            this.emitWorker(ast);
            this.emitComments(ast, false);
        };
        Emitter.prototype.emitWorker = function (ast) {
            if (!ast) {
                return;
            }
            switch (ast.kind()) {
                case TypeScript.SyntaxKind.NumericLiteral:
                    return this.emitNumericLiteral(ast);
                case TypeScript.SyntaxKind.RegularExpressionLiteral:
                    return this.emitRegularExpressionLiteral(ast);
                case TypeScript.SyntaxKind.StringLiteral:
                    return this.emitStringLiteral(ast);
                case TypeScript.SyntaxKind.FalseKeyword:
                case TypeScript.SyntaxKind.NullKeyword:
                case TypeScript.SyntaxKind.TrueKeyword:
                    return this.emitLiteralExpression(ast);
                case TypeScript.SyntaxKind.ThisKeyword:
                    return this.emitThisExpression(ast);
                case TypeScript.SyntaxKind.SuperKeyword:
                    return this.emitSuperExpression(ast);
                case TypeScript.SyntaxKind.ParenthesizedExpression:
                    return this.emitParenthesizedExpression(ast);
                case TypeScript.SyntaxKind.ArrayLiteralExpression:
                    return this.emitArrayLiteralExpression(ast);
                case TypeScript.SyntaxKind.PostDecrementExpression:
                case TypeScript.SyntaxKind.PostIncrementExpression:
                    return this.emitPostfixUnaryExpression(ast);
                case TypeScript.SyntaxKind.LogicalNotExpression:
                case TypeScript.SyntaxKind.BitwiseNotExpression:
                case TypeScript.SyntaxKind.NegateExpression:
                case TypeScript.SyntaxKind.PlusExpression:
                case TypeScript.SyntaxKind.PreIncrementExpression:
                case TypeScript.SyntaxKind.PreDecrementExpression:
                    return this.emitPrefixUnaryExpression(ast);
                case TypeScript.SyntaxKind.InvocationExpression:
                    return this.emitInvocationExpression(ast);
                case TypeScript.SyntaxKind.ElementAccessExpression:
                    return this.emitElementAccessExpression(ast);
                case TypeScript.SyntaxKind.MemberAccessExpression:
                    return this.emitMemberAccessExpression(ast);
                case TypeScript.SyntaxKind.QualifiedName:
                    return this.emitQualifiedName(ast);
                case TypeScript.SyntaxKind.CommaExpression:
                case TypeScript.SyntaxKind.AssignmentExpression:
                case TypeScript.SyntaxKind.AddAssignmentExpression:
                case TypeScript.SyntaxKind.SubtractAssignmentExpression:
                case TypeScript.SyntaxKind.MultiplyAssignmentExpression:
                case TypeScript.SyntaxKind.DivideAssignmentExpression:
                case TypeScript.SyntaxKind.ModuloAssignmentExpression:
                case TypeScript.SyntaxKind.AndAssignmentExpression:
                case TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression:
                case TypeScript.SyntaxKind.OrAssignmentExpression:
                case TypeScript.SyntaxKind.LeftShiftAssignmentExpression:
                case TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression:
                case TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression:
                case TypeScript.SyntaxKind.LogicalOrExpression:
                case TypeScript.SyntaxKind.LogicalAndExpression:
                case TypeScript.SyntaxKind.BitwiseOrExpression:
                case TypeScript.SyntaxKind.BitwiseExclusiveOrExpression:
                case TypeScript.SyntaxKind.BitwiseAndExpression:
                case TypeScript.SyntaxKind.EqualsWithTypeConversionExpression:
                case TypeScript.SyntaxKind.NotEqualsWithTypeConversionExpression:
                case TypeScript.SyntaxKind.EqualsExpression:
                case TypeScript.SyntaxKind.NotEqualsExpression:
                case TypeScript.SyntaxKind.LessThanExpression:
                case TypeScript.SyntaxKind.GreaterThanExpression:
                case TypeScript.SyntaxKind.LessThanOrEqualExpression:
                case TypeScript.SyntaxKind.GreaterThanOrEqualExpression:
                case TypeScript.SyntaxKind.InstanceOfExpression:
                case TypeScript.SyntaxKind.InExpression:
                case TypeScript.SyntaxKind.LeftShiftExpression:
                case TypeScript.SyntaxKind.SignedRightShiftExpression:
                case TypeScript.SyntaxKind.UnsignedRightShiftExpression:
                case TypeScript.SyntaxKind.MultiplyExpression:
                case TypeScript.SyntaxKind.DivideExpression:
                case TypeScript.SyntaxKind.ModuloExpression:
                case TypeScript.SyntaxKind.AddExpression:
                case TypeScript.SyntaxKind.SubtractExpression:
                    return this.emitBinaryExpression(ast);
                case TypeScript.SyntaxKind.ConditionalExpression:
                    return this.emitConditionalExpression(ast);
                case TypeScript.SyntaxKind.EqualsValueClause:
                    return this.emitEqualsValueClause(ast);
                case TypeScript.SyntaxKind.Parameter:
                    return this.emitParameter(ast);
                case TypeScript.SyntaxKind.Block:
                    return this.emitBlock(ast);
                case TypeScript.SyntaxKind.ElseClause:
                    return this.emitElseClause(ast);
                case TypeScript.SyntaxKind.IfStatement:
                    return this.emitIfStatement(ast);
                case TypeScript.SyntaxKind.ExpressionStatement:
                    return this.emitExpressionStatement(ast);
                case TypeScript.SyntaxKind.GetAccessor:
                    return this.emitGetAccessor(ast);
                case TypeScript.SyntaxKind.SetAccessor:
                    return this.emitSetAccessor(ast);
                case TypeScript.SyntaxKind.ThrowStatement:
                    return this.emitThrowStatement(ast);
                case TypeScript.SyntaxKind.ReturnStatement:
                    return this.emitReturnStatement(ast);
                case TypeScript.SyntaxKind.ObjectCreationExpression:
                    return this.emitObjectCreationExpression(ast);
                case TypeScript.SyntaxKind.SwitchStatement:
                    return this.emitSwitchStatement(ast);
                case TypeScript.SyntaxKind.CaseSwitchClause:
                    return this.emitCaseSwitchClause(ast);
                case TypeScript.SyntaxKind.DefaultSwitchClause:
                    return this.emitDefaultSwitchClause(ast);
                case TypeScript.SyntaxKind.BreakStatement:
                    return this.emitBreakStatement(ast);
                case TypeScript.SyntaxKind.ContinueStatement:
                    return this.emitContinueStatement(ast);
                case TypeScript.SyntaxKind.ForStatement:
                    return this.emitForStatement(ast);
                case TypeScript.SyntaxKind.ForInStatement:
                    return this.emitForInStatement(ast);
                case TypeScript.SyntaxKind.WhileStatement:
                    return this.emitWhileStatement(ast);
                case TypeScript.SyntaxKind.WithStatement:
                    return this.emitWithStatement(ast);
                case TypeScript.SyntaxKind.CastExpression:
                    return this.emitCastExpression(ast);
                case TypeScript.SyntaxKind.ObjectLiteralExpression:
                    return this.emitObjectLiteralExpression(ast);
                case TypeScript.SyntaxKind.SimplePropertyAssignment:
                    return this.emitSimplePropertyAssignment(ast);
                case TypeScript.SyntaxKind.FunctionPropertyAssignment:
                    return this.emitFunctionPropertyAssignment(ast);
                case TypeScript.SyntaxKind.EmptyStatement:
                    return this.writeToOutputWithSourceMapRecord(";", ast);
                case TypeScript.SyntaxKind.TryStatement:
                    return this.emitTryStatement(ast);
                case TypeScript.SyntaxKind.CatchClause:
                    return this.emitCatchClause(ast);
                case TypeScript.SyntaxKind.FinallyClause:
                    return this.emitFinallyClause(ast);
                case TypeScript.SyntaxKind.LabeledStatement:
                    return this.emitLabeledStatement(ast);
                case TypeScript.SyntaxKind.DoStatement:
                    return this.emitDoStatement(ast);
                case TypeScript.SyntaxKind.TypeOfExpression:
                    return this.emitTypeOfExpression(ast);
                case TypeScript.SyntaxKind.DeleteExpression:
                    return this.emitDeleteExpression(ast);
                case TypeScript.SyntaxKind.VoidExpression:
                    return this.emitVoidExpression(ast);
                case TypeScript.SyntaxKind.DebuggerStatement:
                    return this.emitDebuggerStatement(ast);
            }
        };
        return Emitter;
    }());
    TypeScript.Emitter = Emitter;
    function getLastConstructor(classDecl) {
        return classDecl.classElements.lastOrDefault(function (e) { return e.kind() === TypeScript.SyntaxKind.ConstructorDeclaration; });
    }
    TypeScript.getLastConstructor = getLastConstructor;
    function getTrimmedTextLines(comment) {
        if (comment.kind() === TypeScript.SyntaxKind.MultiLineCommentTrivia) {
            return comment.fullText().split("\n").map(function (s) { return s.trim(); });
        }
        else {
            return [comment.fullText().trim()];
        }
    }
    TypeScript.getTrimmedTextLines = getTrimmedTextLines;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var MemberName = (function () {
        function MemberName() {
            this.prefix = "";
            this.suffix = "";
        }
        MemberName.prototype.isString = function () { return false; };
        MemberName.prototype.isArray = function () { return false; };
        MemberName.prototype.isMarker = function () { return !this.isString() && !this.isArray(); };
        MemberName.prototype.toString = function () {
            return MemberName.memberNameToString(this);
        };
        MemberName.memberNameToString = function (memberName, markerInfo, markerBaseLength) {
            if (markerBaseLength === void 0) { markerBaseLength = 0; }
            var result = memberName.prefix;
            if (memberName.isString()) {
                result += memberName.text;
            }
            else if (memberName.isArray()) {
                var ar = memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    if (ar.entries[index].isMarker()) {
                        if (markerInfo) {
                            markerInfo.push(markerBaseLength + result.length);
                        }
                        continue;
                    }
                    result += MemberName.memberNameToString(ar.entries[index], markerInfo, markerBaseLength + result.length);
                    result += ar.delim;
                }
            }
            result += memberName.suffix;
            return result;
        };
        MemberName.create = function (arg1, arg2, arg3) {
            if (typeof arg1 === "string") {
                return new MemberNameString(arg1);
            }
            else {
                var result = new MemberNameArray();
                if (arg2)
                    result.prefix = arg2;
                if (arg3)
                    result.suffix = arg3;
                result.entries.push(arg1);
                return result;
            }
        };
        return MemberName;
    }());
    TypeScript.MemberName = MemberName;
    var MemberNameString = (function (_super) {
        __extends(MemberNameString, _super);
        function MemberNameString(text) {
            var _this = _super.call(this) || this;
            _this.text = text;
            return _this;
        }
        MemberNameString.prototype.isString = function () { return true; };
        return MemberNameString;
    }(MemberName));
    TypeScript.MemberNameString = MemberNameString;
    var MemberNameArray = (function (_super) {
        __extends(MemberNameArray, _super);
        function MemberNameArray() {
            var _this = _super.call(this) || this;
            _this.delim = "";
            _this.entries = [];
            return _this;
        }
        MemberNameArray.prototype.isArray = function () { return true; };
        MemberNameArray.prototype.add = function (entry) {
            this.entries.push(entry);
        };
        MemberNameArray.prototype.addAll = function (entries) {
            for (var i = 0; i < entries.length; i++) {
                this.entries.push(entries[i]);
            }
        };
        return MemberNameArray;
    }(MemberName));
    TypeScript.MemberNameArray = MemberNameArray;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function stripStartAndEndQuotes(str) {
        var firstCharCode = str && str.charCodeAt(0);
        if (str && str.length >= 2 && firstCharCode === str.charCodeAt(str.length - 1) && (firstCharCode === TypeScript.CharacterCodes.singleQuote || firstCharCode === TypeScript.CharacterCodes.doubleQuote)) {
            return str.substring(1, str.length - 1);
        }
        return str;
    }
    TypeScript.stripStartAndEndQuotes = stripStartAndEndQuotes;
    function isSingleQuoted(str) {
        return str && str.length >= 2 && str.charCodeAt(0) === str.charCodeAt(str.length - 1) && str.charCodeAt(0) === TypeScript.CharacterCodes.singleQuote;
    }
    TypeScript.isSingleQuoted = isSingleQuoted;
    function isDoubleQuoted(str) {
        return str && str.length >= 2 && str.charCodeAt(0) === str.charCodeAt(str.length - 1) && str.charCodeAt(0) === TypeScript.CharacterCodes.doubleQuote;
    }
    TypeScript.isDoubleQuoted = isDoubleQuoted;
    function isQuoted(str) {
        return isDoubleQuoted(str) || isSingleQuoted(str);
    }
    TypeScript.isQuoted = isQuoted;
    function quoteStr(str) {
        return "\"" + str + "\"";
    }
    TypeScript.quoteStr = quoteStr;
    var switchToForwardSlashesRegEx = /\\/g;
    function switchToForwardSlashes(path) {
        return path.replace(switchToForwardSlashesRegEx, "/");
    }
    TypeScript.switchToForwardSlashes = switchToForwardSlashes;
    function trimModName(modName) {
        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) === ".d.ts") {
            return modName.substring(0, modName.length - 5);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".ts") {
            return modName.substring(0, modName.length - 3);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".js") {
            return modName.substring(0, modName.length - 3);
        }
        return modName;
    }
    TypeScript.trimModName = trimModName;
    function getDeclareFilePath(fname) {
        return isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);
    }
    TypeScript.getDeclareFilePath = getDeclareFilePath;
    function isFileOfExtension(fname, ext) {
        var invariantFname = fname.toLocaleUpperCase();
        var invariantExt = ext.toLocaleUpperCase();
        var extLength = invariantExt.length;
        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) === invariantExt;
    }
    function isTSFile(fname) {
        return isFileOfExtension(fname, ".ts");
    }
    TypeScript.isTSFile = isTSFile;
    function isDTSFile(fname) {
        return isFileOfExtension(fname, ".d.ts");
    }
    TypeScript.isDTSFile = isDTSFile;
    function getPrettyName(modPath, quote, treatAsFileName) {
        if (quote === void 0) { quote = true; }
        if (treatAsFileName === void 0) { treatAsFileName = false; }
        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripStartAndEndQuotes(modPath));
        var components = getPathComponents(modName);
        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;
    }
    TypeScript.getPrettyName = getPrettyName;
    function getPathComponents(path) {
        return path.split("/");
    }
    TypeScript.getPathComponents = getPathComponents;
    function getRelativePathToFixedPath(fixedModFilePath, absoluteModPath, isAbsoultePathURL) {
        if (isAbsoultePathURL === void 0) { isAbsoultePathURL = true; }
        absoluteModPath = switchToForwardSlashes(absoluteModPath);
        var modComponents = getPathComponents(absoluteModPath);
        var fixedModComponents = getPathComponents(fixedModFilePath);
        var joinStartIndex = 0;
        for (; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length; joinStartIndex++) {
            if (fixedModComponents[joinStartIndex] !== modComponents[joinStartIndex]) {
                break;
            }
        }
        if (joinStartIndex !== 0) {
            var relativePath = "";
            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);
            for (; joinStartIndex < fixedModComponents.length; joinStartIndex++) {
                if (fixedModComponents[joinStartIndex] !== "") {
                    relativePath = relativePath + "../";
                }
            }
            return relativePath + relativePathComponents.join("/");
        }
        if (isAbsoultePathURL && absoluteModPath.indexOf("://") === -1) {
            absoluteModPath = "file:///" + absoluteModPath;
        }
        return absoluteModPath;
    }
    TypeScript.getRelativePathToFixedPath = getRelativePathToFixedPath;
    function changePathToDTS(modPath) {
        return trimModName(stripStartAndEndQuotes(modPath)) + ".d.ts";
    }
    TypeScript.changePathToDTS = changePathToDTS;
    function isRelative(path) {
        return path.length > 0 && path.charAt(0) === ".";
    }
    TypeScript.isRelative = isRelative;
    function isRooted(path) {
        return path.length > 0 && (path.charAt(0) === "\\" || path.charAt(0) === "/" || (path.indexOf(":\\") !== -1) || (path.indexOf(":/") !== -1));
    }
    TypeScript.isRooted = isRooted;
    function getRootFilePath(outFname) {
        if (outFname === "") {
            return outFname;
        }
        else {
            var isPath = outFname.indexOf("/") !== -1;
            return isPath ? filePath(outFname) : "";
        }
    }
    TypeScript.getRootFilePath = getRootFilePath;
    function filePathComponents(fullPath) {
        fullPath = switchToForwardSlashes(fullPath);
        var components = getPathComponents(fullPath);
        return components.slice(0, components.length - 1);
    }
    TypeScript.filePathComponents = filePathComponents;
    function filePath(fullPath) {
        var path = filePathComponents(fullPath);
        return path.join("/") + "/";
    }
    TypeScript.filePath = filePath;
    function convertToDirectoryPath(dirPath) {
        if (dirPath && dirPath.charAt(dirPath.length - 1) !== "/") {
            dirPath += "/";
        }
        return dirPath;
    }
    TypeScript.convertToDirectoryPath = convertToDirectoryPath;
    var normalizePathRegEx = /^\\\\[^\\]/;
    function normalizePath(path) {
        if (normalizePathRegEx.test(path)) {
            path = "file:" + path;
        }
        var parts = getPathComponents(switchToForwardSlashes(path));
        var normalizedParts = [];
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part === ".") {
                continue;
            }
            if (normalizedParts.length > 0 && TypeScript.ArrayUtilities.last(normalizedParts) !== ".." && part === "..") {
                normalizedParts.pop();
                continue;
            }
            normalizedParts.push(part);
        }
        return normalizedParts.join("/");
    }
    TypeScript.normalizePath = normalizePath;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function isNoDefaultLibMatch(comment) {
        var isNoDefaultLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/gim;
        return isNoDefaultLibRegex.exec(comment);
    }
    TypeScript.tripleSlashReferenceRegExp = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/;
    function getFileReferenceFromReferencePath(fileName, lineMap, position, comment, diagnostics) {
        var simpleReferenceRegEx = /^\/\/\/\s*<reference\s+/gim;
        if (simpleReferenceRegEx.exec(comment)) {
            var isNoDefaultLib = isNoDefaultLibMatch(comment);
            if (!isNoDefaultLib) {
                var fullReferenceRegEx = TypeScript.tripleSlashReferenceRegExp;
                var fullReference = fullReferenceRegEx.exec(comment);
                if (!fullReference) {
                    diagnostics.push(new TypeScript.Diagnostic(fileName, lineMap, position, comment.length, TypeScript.DiagnosticCode.Invalid_reference_directive_syntax));
                }
                else {
                    var path = TypeScript.normalizePath(fullReference[3]);
                    var adjustedPath = TypeScript.normalizePath(path);
                    var isResident = fullReference.length >= 7 && fullReference[6] === "true";
                    if (isResident) {
                        TypeScript.CompilerDiagnostics.debugPrint(path + " is resident");
                    }
                    return {
                        line: 0,
                        character: 0,
                        position: 0,
                        length: 0,
                        path: TypeScript.switchToForwardSlashes(adjustedPath),
                        isResident: isResident
                    };
                }
            }
        }
        return null;
    }
    var scannerWindow = TypeScript.ArrayUtilities.createArray(2048, 0);
    var scannerDiagnostics = [];
    function processImports(lineMap, scanner, token, importedFiles) {
        var position = 0;
        var lineChar = { line: -1, character: -1 };
        var start = new Date().getTime();
        while (token.tokenKind !== TypeScript.SyntaxKind.EndOfFileToken) {
            if (token.tokenKind === TypeScript.SyntaxKind.ImportKeyword) {
                var importStart = position + token.leadingTriviaWidth();
                token = scanner.scan(scannerDiagnostics, false);
                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    token = scanner.scan(scannerDiagnostics, false);
                    if (token.tokenKind === TypeScript.SyntaxKind.EqualsToken) {
                        token = scanner.scan(scannerDiagnostics, false);
                        if (token.tokenKind === TypeScript.SyntaxKind.ModuleKeyword || token.tokenKind === TypeScript.SyntaxKind.RequireKeyword) {
                            token = scanner.scan(scannerDiagnostics, false);
                            if (token.tokenKind === TypeScript.SyntaxKind.OpenParenToken) {
                                var afterOpenParenPosition = scanner.absoluteIndex();
                                token = scanner.scan(scannerDiagnostics, false);
                                lineMap.fillLineAndCharacterFromPosition(importStart, lineChar);
                                if (token.tokenKind === TypeScript.SyntaxKind.StringLiteral) {
                                    var ref = {
                                        line: lineChar.line,
                                        character: lineChar.character,
                                        position: afterOpenParenPosition + token.leadingTriviaWidth(),
                                        length: token.width(),
                                        path: TypeScript.stripStartAndEndQuotes(TypeScript.switchToForwardSlashes(token.text())),
                                        isResident: false
                                    };
                                    importedFiles.push(ref);
                                }
                            }
                        }
                    }
                }
            }
            position = scanner.absoluteIndex();
            token = scanner.scan(scannerDiagnostics, false);
        }
        var totalTime = new Date().getTime() - start;
        TypeScript.fileResolutionScanImportsTime += totalTime;
    }
    function processTripleSlashDirectives(fileName, lineMap, firstToken) {
        var leadingTrivia = firstToken.leadingTrivia();
        var position = 0;
        var lineChar = { line: -1, character: -1 };
        var noDefaultLib = false;
        var diagnostics = [];
        var referencedFiles = [];
        for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
            var trivia = leadingTrivia.syntaxTriviaAt(i);
            if (trivia.kind() === TypeScript.SyntaxKind.SingleLineCommentTrivia) {
                var triviaText = trivia.fullText();
                var referencedCode = getFileReferenceFromReferencePath(fileName, lineMap, position, triviaText, diagnostics);
                if (referencedCode) {
                    lineMap.fillLineAndCharacterFromPosition(position, lineChar);
                    referencedCode.position = position;
                    referencedCode.length = trivia.fullWidth();
                    referencedCode.line = lineChar.line;
                    referencedCode.character = lineChar.character;
                    referencedFiles.push(referencedCode);
                }
                var isNoDefaultLib = isNoDefaultLibMatch(triviaText);
                if (isNoDefaultLib) {
                    noDefaultLib = isNoDefaultLib[3] === "true";
                }
            }
            position += trivia.fullWidth();
        }
        return { noDefaultLib: noDefaultLib, diagnostics: diagnostics, referencedFiles: referencedFiles };
    }
    function preProcessFile(fileName, sourceText, readImportFiles) {
        if (readImportFiles === void 0) { readImportFiles = true; }
        var text = TypeScript.SimpleText.fromScriptSnapshot(sourceText);
        var scanner = new Scanner(fileName, text, TypeScript.LanguageVersion.EcmaScript5, scannerWindow);
        var firstToken = scanner.scan(scannerDiagnostics, false);
        var importedFiles = [];
        if (readImportFiles) {
            processImports(text.lineMap(), scanner, firstToken, importedFiles);
        }
        var properties = processTripleSlashDirectives(fileName, text.lineMap(), firstToken);
        scannerDiagnostics.length = 0;
        return { referencedFiles: properties.referencedFiles, importedFiles: importedFiles, isLibFile: properties.noDefaultLib, diagnostics: properties.diagnostics };
    }
    TypeScript.preProcessFile = preProcessFile;
    function getParseOptions(settings) {
        return new TypeScript.ParseOptions(settings.codeGenTarget(), settings.allowAutomaticSemicolonInsertion());
    }
    TypeScript.getParseOptions = getParseOptions;
    function getReferencedFiles(fileName, sourceText) {
        return preProcessFile(fileName, sourceText, false).referencedFiles;
    }
    TypeScript.getReferencedFiles = getReferencedFiles;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ReferenceResolutionResult = (function () {
        function ReferenceResolutionResult() {
            this.resolvedFiles = [];
            this.diagnostics = [];
            this.seenNoDefaultLibTag = false;
        }
        return ReferenceResolutionResult;
    }());
    TypeScript.ReferenceResolutionResult = ReferenceResolutionResult;
    var ReferenceLocation = (function () {
        function ReferenceLocation(filePath, lineMap, position, length, isImported) {
            this.filePath = filePath;
            this.lineMap = lineMap;
            this.position = position;
            this.length = length;
            this.isImported = isImported;
        }
        return ReferenceLocation;
    }());
    var ReferenceResolver = (function () {
        function ReferenceResolver(inputFileNames, host, useCaseSensitiveFileResolution) {
            this.useCaseSensitiveFileResolution = useCaseSensitiveFileResolution;
            this.inputFileNames = inputFileNames;
            this.host = host;
            this.visited = {};
        }
        ReferenceResolver.resolve = function (inputFileNames, host, useCaseSensitiveFileResolution) {
            var resolver = new ReferenceResolver(inputFileNames, host, useCaseSensitiveFileResolution);
            return resolver.resolveInputFiles();
        };
        ReferenceResolver.prototype.resolveInputFiles = function () {
            var _this = this;
            var result = new ReferenceResolutionResult();
            if (!this.inputFileNames || this.inputFileNames.length <= 0) {
                return result;
            }
            var referenceLocation = new ReferenceLocation(null, null, 0, 0, false);
            this.inputFileNames.forEach(function (fileName) {
                _this.resolveIncludedFile(fileName, referenceLocation, result);
            });
            return result;
        };
        ReferenceResolver.prototype.resolveIncludedFile = function (path, referenceLocation, resolutionResult) {
            var normalizedPath = this.getNormalizedFilePath(path, referenceLocation.filePath);
            if (this.isSameFile(normalizedPath, referenceLocation.filePath)) {
                if (!referenceLocation.isImported) {
                    resolutionResult.diagnostics.push(new TypeScript.Diagnostic(referenceLocation.filePath, referenceLocation.lineMap, referenceLocation.position, referenceLocation.length, TypeScript.DiagnosticCode.A_file_cannot_have_a_reference_to_itself, null));
                }
                return normalizedPath;
            }
            if (!TypeScript.isTSFile(normalizedPath) && !TypeScript.isDTSFile(normalizedPath)) {
                var dtsFile = normalizedPath + ".d.ts";
                var tsFile = normalizedPath + ".ts";
                if (this.host.fileExists(dtsFile)) {
                    normalizedPath = dtsFile;
                }
                else {
                    normalizedPath = tsFile;
                }
            }
            if (!this.host.fileExists(normalizedPath)) {
                if (!referenceLocation.isImported) {
                    resolutionResult.diagnostics.push(new TypeScript.Diagnostic(referenceLocation.filePath, referenceLocation.lineMap, referenceLocation.position, referenceLocation.length, TypeScript.DiagnosticCode.Cannot_resolve_referenced_file_0, [path]));
                }
                return normalizedPath;
            }
            return this.resolveFile(normalizedPath, resolutionResult);
        };
        ReferenceResolver.prototype.resolveImportedFile = function (path, referenceLocation, resolutionResult) {
            var isRelativePath = TypeScript.isRelative(path);
            var isRootedPath = isRelativePath ? false : TypeScript.isRooted(path);
            if (isRelativePath || isRootedPath) {
                return this.resolveIncludedFile(path, referenceLocation, resolutionResult);
            }
            else {
                var parentDirectory = this.host.getParentDirectory(referenceLocation.filePath);
                var searchFilePath = null;
                var dtsFileName = path + ".d.ts";
                var tsFilePath = path + ".ts";
                var start = new Date().getTime();
                do {
                    var currentFilePath = this.host.resolveRelativePath(dtsFileName, parentDirectory);
                    if (this.host.fileExists(currentFilePath)) {
                        searchFilePath = currentFilePath;
                        break;
                    }
                    currentFilePath = this.host.resolveRelativePath(tsFilePath, parentDirectory);
                    if (this.host.fileExists(currentFilePath)) {
                        searchFilePath = currentFilePath;
                        break;
                    }
                    parentDirectory = this.host.getParentDirectory(parentDirectory);
                } while (parentDirectory);
                TypeScript.fileResolutionImportFileSearchTime += new Date().getTime() - start;
                if (!searchFilePath) {
                    return path;
                }
                return this.resolveFile(searchFilePath, resolutionResult);
            }
        };
        ReferenceResolver.prototype.resolveFile = function (normalizedPath, resolutionResult) {
            var _this = this;
            var visitedPath = this.isVisited(normalizedPath);
            if (!visitedPath) {
                this.recordVisitedFile(normalizedPath);
                var start = new Date().getTime();
                var scriptSnapshot = this.host.getScriptSnapshot(normalizedPath);
                var totalTime = new Date().getTime() - start;
                TypeScript.fileResolutionIOTime += totalTime;
                var lineMap = TypeScript.LineMap1.fromScriptSnapshot(scriptSnapshot);
                var preprocessedFileInformation = TypeScript.preProcessFile(normalizedPath, scriptSnapshot);
                RT.applyVariadic(resolutionResult.diagnostics, "push", preprocessedFileInformation.diagnostics);
                if (preprocessedFileInformation.isLibFile) {
                    resolutionResult.seenNoDefaultLibTag = true;
                }
                var normalizedReferencePaths = [];
                preprocessedFileInformation.referencedFiles.forEach(function (fileReference) {
                    var currentReferenceLocation = new ReferenceLocation(normalizedPath, lineMap, fileReference.position, fileReference.length, false);
                    var normalizedReferencePath = _this.resolveIncludedFile(fileReference.path, currentReferenceLocation, resolutionResult);
                    normalizedReferencePaths.push(normalizedReferencePath);
                });
                var normalizedImportPaths = [];
                for (var i = 0; i < preprocessedFileInformation.importedFiles.length; i++) {
                    var fileImport = preprocessedFileInformation.importedFiles[i];
                    var currentReferenceLocation = new ReferenceLocation(normalizedPath, lineMap, fileImport.position, fileImport.length, true);
                    var normalizedImportPath = this.resolveImportedFile(fileImport.path, currentReferenceLocation, resolutionResult);
                    normalizedImportPaths.push(normalizedImportPath);
                }
                resolutionResult.resolvedFiles.push({
                    path: normalizedPath,
                    referencedFiles: normalizedReferencePaths,
                    importedFiles: normalizedImportPaths
                });
            }
            else {
                normalizedPath = visitedPath;
            }
            return normalizedPath;
        };
        ReferenceResolver.prototype.getNormalizedFilePath = function (path, parentFilePath) {
            var parentFileDirectory = parentFilePath ? this.host.getParentDirectory(parentFilePath) : "";
            var normalizedPath = this.host.resolveRelativePath(path, parentFileDirectory);
            return normalizedPath;
        };
        ReferenceResolver.prototype.getUniqueFileId = function (filePath) {
            return this.useCaseSensitiveFileResolution ? filePath : filePath.toLocaleUpperCase();
        };
        ReferenceResolver.prototype.recordVisitedFile = function (filePath) {
            this.visited[this.getUniqueFileId(filePath)] = filePath;
        };
        ReferenceResolver.prototype.isVisited = function (filePath) {
            return this.visited[this.getUniqueFileId(filePath)];
        };
        ReferenceResolver.prototype.isSameFile = function (filePath1, filePath2) {
            if (!filePath1 || !filePath2) {
                return false;
            }
            if (this.useCaseSensitiveFileResolution) {
                return filePath1 === filePath2;
            }
            else {
                return filePath1.toLocaleUpperCase() === filePath2.toLocaleUpperCase();
            }
        };
        return ReferenceResolver;
    }());
    TypeScript.ReferenceResolver = ReferenceResolver;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var BloomFilter = (function () {
        function BloomFilter(expectedCount) {
            var m = Math.max(1, BloomFilter.computeM(expectedCount));
            var k = Math.max(1, BloomFilter.computeK(expectedCount));
            ;
            var sizeInEvenBytes = (m + 7) & ~7;
            this.bitArray = [];
            for (var i = 0, len = sizeInEvenBytes; i < len; i++) {
                this.bitArray[i] = false;
            }
            this.hashFunctionCount = k;
        }
        BloomFilter.computeM = function (expectedCount) {
            var p = BloomFilter.falsePositiveProbability;
            var n = expectedCount;
            var numerator = n * Math.log(p);
            var denominator = Math.log(1.0 / Math.pow(2.0, Math.log(2.0)));
            return Math.ceil(numerator / denominator);
        };
        BloomFilter.computeK = function (expectedCount) {
            var n = expectedCount;
            var m = BloomFilter.computeM(expectedCount);
            var temp = Math.log(2.0) * m / n;
            return Math.round(temp);
        };
        BloomFilter.prototype.computeHash = function (key, seed) {
            return TypeScript.Hash.computeMurmur2StringHashCode(key, seed);
        };
        BloomFilter.prototype.addKeys = function (keys) {
            for (var name in keys) {
                if (keys[name]) {
                    this.add(name);
                }
            }
        };
        BloomFilter.prototype.add = function (value) {
            for (var i = 0; i < this.hashFunctionCount; i++) {
                var hash = this.computeHash(value, i);
                hash = hash % this.bitArray.length;
                this.bitArray[Math.abs(hash)] = true;
            }
        };
        BloomFilter.prototype.probablyContains = function (value) {
            for (var i = 0; i < this.hashFunctionCount; i++) {
                var hash = this.computeHash(value, i);
                hash = hash % this.bitArray.length;
                if (!this.bitArray[Math.abs(hash)]) {
                    return false;
                }
            }
            return true;
        };
        BloomFilter.prototype.isEquivalent = function (filter) {
            return BloomFilter.isEquivalent(this.bitArray, filter.bitArray)
                && this.hashFunctionCount == filter.hashFunctionCount;
        };
        BloomFilter.isEquivalent = function (array1, array2) {
            if (array1.length != array2.length) {
                return false;
            }
            for (var i = 0; i < array1.length; i++) {
                if (array1[i] != array2[i]) {
                    return false;
                }
            }
            return true;
        };
        BloomFilter.falsePositiveProbability = 0.0001;
        return BloomFilter;
    }());
    TypeScript.BloomFilter = BloomFilter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var IdentifierWalker = (function (_super) {
        __extends(IdentifierWalker, _super);
        function IdentifierWalker(list) {
            var _this = _super.call(this) || this;
            _this.list = list;
            return _this;
        }
        IdentifierWalker.prototype.visitToken = function (token) {
            this.list[token.text()] = true;
        };
        return IdentifierWalker;
    }(TypeScript.SyntaxWalker));
    TypeScript.IdentifierWalker = IdentifierWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function kw2str(kw) {
        return kw.fileName + "(" + kw.line + "," + kw.column + "): warning TS" + kw.code + (kw.message ? ": TS*: " + kw.message : "");
    }
    TypeScript.kw2str = kw2str;
    var CompilationSettings = (function () {
        function CompilationSettings() {
            this.propagateEnumConstants = false;
            this.removeComments = false;
            this.watch = false;
            this.noResolve = false;
            this.allowAutomaticSemicolonInsertion = true;
            this.noImplicitAny = false;
            this.noLib = false;
            this.codeGenTarget = TypeScript.LanguageVersion.EcmaScript3;
            this.moduleGenTarget = TypeScript.ModuleGenTarget.Unspecified;
            this.outFileOption = "";
            this.outDirOption = "";
            this.mapSourceFiles = false;
            this.mapRoot = "";
            this.sourceRoot = "";
            this.generateDeclarationFiles = false;
            this.useCaseSensitiveFileResolution = false;
            this.gatherDiagnostics = false;
            this.codepage = null;
            this.safe = false;
            this.secure = CompilationSettings.SECURE ? true : false;
            this.serviceMode = true;
            this.noRuntimeChecks = false;
            this.generics = false;
            this.noWarns = [];
            this.noInstrs = [];
            this.knownWarnings = [];
            this.errorStats = false;
            this.relaxNullChecks = false;
            this.inlineCasts = false;
            this.tsstarTagging = false;
            this.noGetters = false;
            this.weakMaps = false;
            this.optimizePure = false;
        }
        CompilationSettings.prototype.addKnownWarnings = function (kws) {
            this.knownWarnings = this.knownWarnings.concat(kws);
        };
        return CompilationSettings;
    }());
    TypeScript.CompilationSettings = CompilationSettings;
    var ImmutableCompilationSettings = (function () {
        function ImmutableCompilationSettings(propagateEnumConstants, removeComments, watch, noResolve, allowAutomaticSemicolonInsertion, noImplicitAny, noLib, codeGenTarget, moduleGenTarget, outFileOption, outDirOption, mapSourceFiles, mapRoot, sourceRoot, generateDeclarationFiles, useCaseSensitiveFileResolution, gatherDiagnostics, codepage, safe, secure, serviceMode, noRuntimeChecks, generics, noWarns, noInstrs, knownWarnings, errorStats, relaxNullChecks, inlineCasts, tsstarTagging, noGetters, weakMaps, optimizePure) {
            this.matchedOrAlmost = [];
            this._propagateEnumConstants = propagateEnumConstants;
            this._removeComments = removeComments;
            this._watch = watch;
            this._noResolve = noResolve;
            this._allowAutomaticSemicolonInsertion = allowAutomaticSemicolonInsertion;
            this._noImplicitAny = noImplicitAny;
            this._noLib = noLib;
            this._codeGenTarget = codeGenTarget;
            this._moduleGenTarget = moduleGenTarget;
            this._outFileOption = outFileOption;
            this._outDirOption = outDirOption;
            this._mapSourceFiles = mapSourceFiles;
            this._mapRoot = mapRoot;
            this._sourceRoot = sourceRoot;
            this._generateDeclarationFiles = generateDeclarationFiles;
            this._useCaseSensitiveFileResolution = useCaseSensitiveFileResolution;
            this._gatherDiagnostics = gatherDiagnostics;
            this._codepage = codepage;
            this._safe = safe;
            this._secure = secure;
            this._serviceMode = serviceMode;
            this._noRuntimeChecks = noRuntimeChecks;
            this._generics = generics;
            this._noWarns = noWarns;
            this._noInstrs = noInstrs;
            this._knownWarnings = knownWarnings;
            this._errorStats = errorStats;
            this._relaxNullChecks = relaxNullChecks;
            this._inlineCasts = inlineCasts;
            this._tsstarTagging = tsstarTagging;
            this._noGetters = noGetters;
            this._weakMaps = weakMaps;
            this._optimizePure = optimizePure;
        }
        ImmutableCompilationSettings.prototype.propagateEnumConstants = function () { return this._propagateEnumConstants; };
        ImmutableCompilationSettings.prototype.removeComments = function () { return this._removeComments; };
        ImmutableCompilationSettings.prototype.watch = function () { return this._watch; };
        ImmutableCompilationSettings.prototype.noResolve = function () { return this._noResolve; };
        ImmutableCompilationSettings.prototype.allowAutomaticSemicolonInsertion = function () { return this._allowAutomaticSemicolonInsertion; };
        ImmutableCompilationSettings.prototype.noImplicitAny = function () { return this._noImplicitAny; };
        ImmutableCompilationSettings.prototype.noLib = function () { return this._noLib; };
        ImmutableCompilationSettings.prototype.codeGenTarget = function () { return this._codeGenTarget; };
        ImmutableCompilationSettings.prototype.moduleGenTarget = function () { return this._moduleGenTarget; };
        ImmutableCompilationSettings.prototype.outFileOption = function () { return this._outFileOption; };
        ImmutableCompilationSettings.prototype.outDirOption = function () { return this._outDirOption; };
        ImmutableCompilationSettings.prototype.mapSourceFiles = function () { return this._mapSourceFiles; };
        ImmutableCompilationSettings.prototype.mapRoot = function () { return this._mapRoot; };
        ImmutableCompilationSettings.prototype.sourceRoot = function () { return this._sourceRoot; };
        ImmutableCompilationSettings.prototype.generateDeclarationFiles = function () { return this._generateDeclarationFiles; };
        ImmutableCompilationSettings.prototype.useCaseSensitiveFileResolution = function () { return this._useCaseSensitiveFileResolution; };
        ImmutableCompilationSettings.prototype.gatherDiagnostics = function () { return this._gatherDiagnostics; };
        ImmutableCompilationSettings.prototype.codepage = function () { return this._codepage; };
        ImmutableCompilationSettings.prototype.safe = function () { return this._safe; };
        ImmutableCompilationSettings.prototype.secure = function () { return this._secure; };
        ImmutableCompilationSettings.prototype.weakMaps = function () { return this._weakMaps; };
        ImmutableCompilationSettings.prototype.optimizePure = function () { return this._optimizePure; };
        ImmutableCompilationSettings.prototype.shouldInstrument = function (fn) {
            var sn = fn.substring(fn.lastIndexOf("/") + 1);
            if (sn === "lib.d.ts" || sn === "rt.ts" || sn === "rtapi.ts" || sn === "core.ts") {
                return false;
            }
            return !this._noInstrs.some(function (f) { return fn.substr(fn.length - f.length) === f; });
        };
        ImmutableCompilationSettings.prototype.shouldWarn = function (diag, di) {
            var _this = this;
            var code = di.code.toString();
            if (this._noWarns.some(function (s) { return s === di.code.toString(); }))
                return false;
            var kw2 = {
                fileName: diag.fileName().toLowerCase(),
                line: diag.line() + 1,
                column: diag.character() + 1,
                code: di.code
            };
            var almostMatches = this._knownWarnings.filter(function (kw) {
                var endsWith = function (s1, s2) {
                    if (s1.length >= s2.length) {
                        return s1.substring(s1.length - s2.length) === s2.toLowerCase();
                    }
                    return false;
                };
                return endsWith(kw2.fileName, kw.fileName)
                    && kw.column === kw2.column
                    && kw.code == kw2.code;
            });
            if (almostMatches.some(function (kw) {
                if (kw.line === kw2.line) {
                    kw.matched = true;
                    _this.matchedOrAlmost.push({
                        category: kw.category,
                        fileName: kw.fileName,
                        column: kw.column,
                        code: kw.code,
                        line: kw.line,
                        message: diag.message()
                    });
                    return true;
                }
                else {
                    return false;
                }
            }))
                return false;
            if (almostMatches.length !== 0) {
                var am = almostMatches.sort(function (k, l) { return (Math.abs(k.line - kw2.line) - Math.abs(l.line - kw2.line)); });
                am = am.filter(function (kw) { return !kw.matched; });
                if (am && am.length !== 0) {
                    console.log("Warning at " + kw2str(kw2) + " almost matched known warnings: ");
                    console.log("\t" + kw2str(am[0]));
                    this.matchedOrAlmost.push({
                        category: am[0].category,
                        fileName: kw2.fileName,
                        column: kw2.column,
                        code: kw2.code,
                        line: kw2.line,
                        message: diag.message()
                    });
                    am[0].matched = true;
                }
            }
            return true;
        };
        ImmutableCompilationSettings.prototype.reportUnmatchedKnownWarnings = function (writeFile) {
            this._knownWarnings.forEach(function (f) {
                if (!f.matched) {
                    console.log("   ;;Unmatched known warning: " + kw2str(f));
                }
            });
            var sorted = this.matchedOrAlmost.sort(function (kw1, kw2) { return kw1.category.localeCompare(kw2.category); });
            var currentCategory = null;
            var contents = sorted.map(function (kw) {
                var out = "";
                if (currentCategory !== kw.category) {
                    out = out + kw.category + "\n";
                    currentCategory = kw.category;
                }
                out = out + "1>" + kw2str(kw);
                return out;
            }).join("\n");
            writeFile("knownWarnings.generated.txt", contents);
        };
        ImmutableCompilationSettings.prototype.serviceMode = function () {
            return this._serviceMode;
        };
        ImmutableCompilationSettings.prototype.noRuntimeChecks = function () {
            return this._noRuntimeChecks;
        };
        ImmutableCompilationSettings.prototype.generics = function () {
            return this._generics;
        };
        ImmutableCompilationSettings.prototype.knownWarnings = function () {
            return this._knownWarnings;
        };
        ImmutableCompilationSettings.prototype.errorStats = function () {
            return this._errorStats;
        };
        ImmutableCompilationSettings.prototype.relaxNullChecks = function () {
            return this._relaxNullChecks;
        };
        ImmutableCompilationSettings.prototype.inlineCasts = function () {
            return this._inlineCasts;
        };
        ImmutableCompilationSettings.prototype.tsstarTagging = function () {
            return this._tsstarTagging;
        };
        ImmutableCompilationSettings.prototype.noGetters = function () {
            return this._noGetters;
        };
        ImmutableCompilationSettings.defaultSettings = function () {
            if (!ImmutableCompilationSettings._defaultSettings) {
                ImmutableCompilationSettings._defaultSettings = ImmutableCompilationSettings.fromCompilationSettings(new CompilationSettings());
            }
            return ImmutableCompilationSettings._defaultSettings;
        };
        ImmutableCompilationSettings.fromCompilationSettings = function (settings) {
            return new ImmutableCompilationSettings(settings.propagateEnumConstants, settings.removeComments, settings.watch, settings.noResolve, settings.allowAutomaticSemicolonInsertion, settings.noImplicitAny, settings.noLib, settings.codeGenTarget, settings.moduleGenTarget, settings.outFileOption, settings.outDirOption, settings.mapSourceFiles, settings.mapRoot, settings.sourceRoot, settings.generateDeclarationFiles, settings.useCaseSensitiveFileResolution, settings.gatherDiagnostics, settings.codepage, settings.safe, settings.secure, settings.serviceMode, settings.noRuntimeChecks, settings.generics, settings.noWarns, settings.noInstrs, settings.knownWarnings, settings.errorStats, settings.relaxNullChecks, settings.inlineCasts, settings.tsstarTagging, settings.noGetters, settings.weakMaps, settings.optimizePure);
        };
        ImmutableCompilationSettings.prototype.toCompilationSettings = function () {
            var result = new CompilationSettings();
            for (var name in this) {
                if (this.hasOwnProperty(name) && TypeScript.StringUtilities.startsWith(name, "_")) {
                    result[name.substr(1)] = this[name];
                }
            }
            return result;
        };
        return ImmutableCompilationSettings;
    }());
    TypeScript.ImmutableCompilationSettings = ImmutableCompilationSettings;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullElementFlags;
    (function (PullElementFlags) {
        PullElementFlags[PullElementFlags["None"] = 0] = "None";
        PullElementFlags[PullElementFlags["Exported"] = 1] = "Exported";
        PullElementFlags[PullElementFlags["Private"] = 2] = "Private";
        PullElementFlags[PullElementFlags["Public"] = 4] = "Public";
        PullElementFlags[PullElementFlags["Ambient"] = 8] = "Ambient";
        PullElementFlags[PullElementFlags["Static"] = 16] = "Static";
        PullElementFlags[PullElementFlags["Optional"] = 128] = "Optional";
        PullElementFlags[PullElementFlags["Signature"] = 2048] = "Signature";
        PullElementFlags[PullElementFlags["Enum"] = 4096] = "Enum";
        PullElementFlags[PullElementFlags["ArrowFunction"] = 8192] = "ArrowFunction";
        PullElementFlags[PullElementFlags["ClassConstructorVariable"] = 16384] = "ClassConstructorVariable";
        PullElementFlags[PullElementFlags["InitializedModule"] = 32768] = "InitializedModule";
        PullElementFlags[PullElementFlags["InitializedDynamicModule"] = 65536] = "InitializedDynamicModule";
        PullElementFlags[PullElementFlags["MustCaptureThis"] = 262144] = "MustCaptureThis";
        PullElementFlags[PullElementFlags["DeclaredInAWithBlock"] = 2097152] = "DeclaredInAWithBlock";
        PullElementFlags[PullElementFlags["HasReturnStatement"] = 4194304] = "HasReturnStatement";
        PullElementFlags[PullElementFlags["PropertyParameter"] = 8388608] = "PropertyParameter";
        PullElementFlags[PullElementFlags["IsAnnotatedWithAny"] = 16777216] = "IsAnnotatedWithAny";
        PullElementFlags[PullElementFlags["HasDefaultArgs"] = 33554432] = "HasDefaultArgs";
        PullElementFlags[PullElementFlags["ConstructorParameter"] = 67108864] = "ConstructorParameter";
        PullElementFlags[PullElementFlags["ImplicitVariable"] = 118784] = "ImplicitVariable";
        PullElementFlags[PullElementFlags["SomeInitializedModule"] = 102400] = "SomeInitializedModule";
    })(PullElementFlags = TypeScript.PullElementFlags || (TypeScript.PullElementFlags = {}));
    function hasModifier(modifiers, flag) {
        for (var i = 0, n = modifiers.length; i < n; i++) {
            if (TypeScript.hasFlag(modifiers[i], flag)) {
                return true;
            }
        }
        return false;
    }
    TypeScript.hasModifier = hasModifier;
    var PullElementKind;
    (function (PullElementKind) {
        PullElementKind[PullElementKind["None"] = 0] = "None";
        PullElementKind[PullElementKind["Global"] = 0] = "Global";
        PullElementKind[PullElementKind["Script"] = 1] = "Script";
        PullElementKind[PullElementKind["Primitive"] = 2] = "Primitive";
        PullElementKind[PullElementKind["Container"] = 4] = "Container";
        PullElementKind[PullElementKind["Class"] = 8] = "Class";
        PullElementKind[PullElementKind["Interface"] = 16] = "Interface";
        PullElementKind[PullElementKind["DynamicModule"] = 32] = "DynamicModule";
        PullElementKind[PullElementKind["Enum"] = 64] = "Enum";
        PullElementKind[PullElementKind["TypeAlias"] = 128] = "TypeAlias";
        PullElementKind[PullElementKind["ObjectLiteral"] = 256] = "ObjectLiteral";
        PullElementKind[PullElementKind["Variable"] = 512] = "Variable";
        PullElementKind[PullElementKind["CatchVariable"] = 1024] = "CatchVariable";
        PullElementKind[PullElementKind["Parameter"] = 2048] = "Parameter";
        PullElementKind[PullElementKind["Property"] = 4096] = "Property";
        PullElementKind[PullElementKind["TypeParameter"] = 8192] = "TypeParameter";
        PullElementKind[PullElementKind["Function"] = 16384] = "Function";
        PullElementKind[PullElementKind["ConstructorMethod"] = 32768] = "ConstructorMethod";
        PullElementKind[PullElementKind["Method"] = 65536] = "Method";
        PullElementKind[PullElementKind["FunctionExpression"] = 131072] = "FunctionExpression";
        PullElementKind[PullElementKind["GetAccessor"] = 262144] = "GetAccessor";
        PullElementKind[PullElementKind["SetAccessor"] = 524288] = "SetAccessor";
        PullElementKind[PullElementKind["CallSignature"] = 1048576] = "CallSignature";
        PullElementKind[PullElementKind["ConstructSignature"] = 2097152] = "ConstructSignature";
        PullElementKind[PullElementKind["IndexSignature"] = 4194304] = "IndexSignature";
        PullElementKind[PullElementKind["ObjectType"] = 8388608] = "ObjectType";
        PullElementKind[PullElementKind["FunctionType"] = 16777216] = "FunctionType";
        PullElementKind[PullElementKind["ConstructorType"] = 33554432] = "ConstructorType";
        PullElementKind[PullElementKind["EnumMember"] = 67108864] = "EnumMember";
        PullElementKind[PullElementKind["WithBlock"] = 134217728] = "WithBlock";
        PullElementKind[PullElementKind["CatchBlock"] = 268435456] = "CatchBlock";
        PullElementKind[PullElementKind["All"] = 536869887] = "All";
        PullElementKind[PullElementKind["SomeFunction"] = 1032192] = "SomeFunction";
        PullElementKind[PullElementKind["SomeValue"] = 68147712] = "SomeValue";
        PullElementKind[PullElementKind["SomeType"] = 58728539] = "SomeType";
        PullElementKind[PullElementKind["AcceptableAlias"] = 59753052] = "AcceptableAlias";
        PullElementKind[PullElementKind["SomeContainer"] = 164] = "SomeContainer";
        PullElementKind[PullElementKind["SomeSignature"] = 7340032] = "SomeSignature";
        PullElementKind[PullElementKind["SomeTypeReference"] = 58720272] = "SomeTypeReference";
        PullElementKind[PullElementKind["SomeInstantiatableType"] = 8216] = "SomeInstantiatableType";
    })(PullElementKind = TypeScript.PullElementKind || (TypeScript.PullElementKind = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.pullDeclID = 0;
    var sentinelEmptyPullDeclArray = [];
    var PullDecl = (function () {
        function PullDecl(declName, displayName, kind, declFlags, span) {
            this.declID = TypeScript.pullDeclID++;
            this.flags = TypeScript.PullElementFlags.None;
            this.declGroups = null;
            this.childDecls = null;
            this.typeParameters = null;
            this.synthesizedValDecl = null;
            this.childDeclTypeCache = null;
            this.childDeclValueCache = null;
            this.childDeclNamespaceCache = null;
            this.childDeclTypeParameterCache = null;
            this.name = declName;
            this.kind = kind;
            this.flags = declFlags;
            this.span = span;
            if (displayName !== this.name) {
                this.declDisplayName = displayName;
            }
        }
        PullDecl.prototype.fileName = function () {
            throw TypeScript.Errors.abstract();
        };
        PullDecl.prototype.getParentPath = function () {
            throw TypeScript.Errors.abstract();
        };
        PullDecl.prototype.getParentDecl = function () {
            throw TypeScript.Errors.abstract();
        };
        PullDecl.prototype.semanticInfoChain = function () {
            throw TypeScript.Errors.abstract();
        };
        PullDecl.prototype.isExternalModule = function () {
            throw TypeScript.Errors.abstract();
        };
        PullDecl.prototype.getEnclosingDecl = function () {
            throw TypeScript.Errors.abstract();
        };
        PullDecl.prototype._getEnclosingDeclFromParentDecl = function () {
            var decl = this;
            while (decl) {
                switch (decl.kind) {
                    default:
                        return decl;
                    case TypeScript.PullElementKind.Variable:
                    case TypeScript.PullElementKind.TypeParameter:
                    case TypeScript.PullElementKind.Parameter:
                    case TypeScript.PullElementKind.TypeAlias:
                    case TypeScript.PullElementKind.EnumMember:
                }
                decl = decl.getParentDecl();
            }
            TypeScript.Debug.fail();
        };
        PullDecl.prototype.getDisplayName = function () {
            return this.declDisplayName === undefined ? this.name : this.declDisplayName;
        };
        PullDecl.prototype.setSymbol = function (symbol) {
            this.semanticInfoChain().setSymbolForDecl(this, symbol);
        };
        PullDecl.prototype.ensureSymbolIsBound = function (bindSignatureSymbol) {
            if (bindSignatureSymbol === void 0) { bindSignatureSymbol = false; }
            if (!((bindSignatureSymbol && this.hasSignatureSymbol()) || this.hasSymbol()) && this.kind != TypeScript.PullElementKind.Script) {
                var binder = this.semanticInfoChain().getBinder();
                binder.bindDeclToPullSymbol(this);
            }
        };
        PullDecl.prototype.getSymbol = function () {
            if (this.kind == TypeScript.PullElementKind.Script) {
                return null;
            }
            this.ensureSymbolIsBound();
            return this.semanticInfoChain().getSymbolForDecl(this);
        };
        PullDecl.prototype.hasSymbol = function () {
            var symbol = this.semanticInfoChain().getSymbolForDecl(this);
            return !!symbol;
        };
        PullDecl.prototype.setSignatureSymbol = function (signatureSymbol) {
            this.semanticInfoChain().setSignatureSymbolForDecl(this, signatureSymbol);
        };
        PullDecl.prototype.getSignatureSymbol = function () {
            this.ensureSymbolIsBound(true);
            return this.semanticInfoChain().getSignatureSymbolForDecl(this);
        };
        PullDecl.prototype.hasSignatureSymbol = function () {
            var signatureSymbol = this.semanticInfoChain().getSignatureSymbolForDecl(this);
            return !!signatureSymbol;
        };
        PullDecl.prototype.setFlags = function (flags) { this.flags = flags; };
        PullDecl.prototype.setFlag = function (flags) { this.flags |= flags; };
        PullDecl.prototype.getSpan = function () { return this.span; };
        PullDecl.prototype.setValueDecl = function (valDecl) { this.synthesizedValDecl = valDecl; };
        PullDecl.prototype.getValueDecl = function () { return this.synthesizedValDecl; };
        PullDecl.prototype.isEqual = function (other) {
            return (this.name === other.name) &&
                (this.kind === other.kind) &&
                (this.flags === other.flags) &&
                (this.fileName() === other.fileName()) &&
                (this.span.start() === other.span.start()) &&
                (this.span.end() === other.span.end());
        };
        PullDecl.prototype.getChildDeclCache = function (declKind) {
            if (declKind === TypeScript.PullElementKind.TypeParameter) {
                if (!this.childDeclTypeParameterCache) {
                    this.childDeclTypeParameterCache = TypeScript.createIntrinsicsObject();
                }
                return this.childDeclTypeParameterCache;
            }
            else if (TypeScript.hasFlag(declKind, TypeScript.PullElementKind.SomeContainer)) {
                if (!this.childDeclNamespaceCache) {
                    this.childDeclNamespaceCache = TypeScript.createIntrinsicsObject();
                }
                return this.childDeclNamespaceCache;
            }
            else if (TypeScript.hasFlag(declKind, TypeScript.PullElementKind.SomeType)) {
                if (!this.childDeclTypeCache) {
                    this.childDeclTypeCache = TypeScript.createIntrinsicsObject();
                }
                return this.childDeclTypeCache;
            }
            else {
                if (!this.childDeclValueCache) {
                    this.childDeclValueCache = TypeScript.createIntrinsicsObject();
                }
                return this.childDeclValueCache;
            }
        };
        PullDecl.prototype.addChildDecl = function (childDecl) {
            if (childDecl.kind === TypeScript.PullElementKind.TypeParameter) {
                if (!this.typeParameters) {
                    this.typeParameters = [];
                }
                this.typeParameters[this.typeParameters.length] = childDecl;
            }
            else {
                if (!this.childDecls) {
                    this.childDecls = [];
                }
                this.childDecls[this.childDecls.length] = childDecl;
            }
            var declName = childDecl.name;
            if (!(childDecl.kind & TypeScript.PullElementKind.SomeSignature)) {
                var cache = this.getChildDeclCache(childDecl.kind);
                var childrenOfName = cache[declName];
                if (!childrenOfName) {
                    childrenOfName = [];
                }
                childrenOfName.push(childDecl);
                cache[declName] = childrenOfName;
            }
        };
        PullDecl.prototype.searchChildDecls = function (declName, searchKind) {
            var cacheVal = null;
            if (searchKind & TypeScript.PullElementKind.SomeType) {
                cacheVal = this.childDeclTypeCache ? this.childDeclTypeCache[declName] : null;
            }
            else if (searchKind & TypeScript.PullElementKind.SomeContainer) {
                cacheVal = this.childDeclNamespaceCache ? this.childDeclNamespaceCache[declName] : null;
            }
            else {
                cacheVal = this.childDeclValueCache ? this.childDeclValueCache[declName] : null;
            }
            if (cacheVal) {
                return cacheVal;
            }
            else {
                if (searchKind & TypeScript.PullElementKind.SomeType) {
                    cacheVal = this.childDeclTypeParameterCache ? this.childDeclTypeParameterCache[declName] : null;
                    if (cacheVal) {
                        return cacheVal;
                    }
                }
                return [];
            }
        };
        PullDecl.prototype.getChildDecls = function () {
            return this.childDecls ? this.childDecls : [];
        };
        PullDecl.prototype.getTypeParameters = function () { return this.typeParameters ? this.typeParameters : []; };
        PullDecl.prototype.addVariableDeclToGroup = function (decl) {
            if (!this.declGroups) {
                this.declGroups = TypeScript.createIntrinsicsObject();
            }
            var declGroup = this.declGroups[decl.name];
            if (declGroup) {
                declGroup.addDecl(decl);
            }
            else {
                declGroup = new PullDeclGroup(decl.name);
                declGroup.addDecl(decl);
                this.declGroups[decl.name] = declGroup;
            }
        };
        PullDecl.prototype.getVariableDeclGroups = function () {
            var declGroups = null;
            if (this.declGroups) {
                for (var declName in this.declGroups) {
                    if (this.declGroups[declName]) {
                        if (declGroups === null) {
                            declGroups = [];
                        }
                        declGroups.push(this.declGroups[declName].getDecls());
                    }
                }
            }
            return declGroups ? declGroups : [];
        };
        PullDecl.prototype.hasBeenBound = function () {
            return this.hasSymbol() || this.hasSignatureSymbol();
        };
        PullDecl.prototype.isSynthesized = function () {
            return false;
        };
        PullDecl.prototype.ast = function () {
            var semanticInfoChain = this.semanticInfoChain();
            return semanticInfoChain ? semanticInfoChain.getASTForDecl(this) : null;
        };
        return PullDecl;
    }());
    TypeScript.PullDecl = PullDecl;
    var RootPullDecl = (function (_super) {
        __extends(RootPullDecl, _super);
        function RootPullDecl(name, fileName, kind, declFlags, span, semanticInfoChain, isExternalModule) {
            var _this = _super.call(this, name, name, kind, declFlags, span) || this;
            _this._semanticInfoChain = semanticInfoChain;
            _this._isExternalModule = isExternalModule;
            _this._fileName = fileName;
            return _this;
        }
        RootPullDecl.prototype.fileName = function () {
            return this._fileName;
        };
        RootPullDecl.prototype.getParentPath = function () {
            return [this];
        };
        RootPullDecl.prototype.getParentDecl = function () {
            return null;
        };
        RootPullDecl.prototype.semanticInfoChain = function () {
            return this._semanticInfoChain;
        };
        RootPullDecl.prototype.isExternalModule = function () {
            return this._isExternalModule;
        };
        RootPullDecl.prototype.getEnclosingDecl = function () {
            return this;
        };
        return RootPullDecl;
    }(PullDecl));
    TypeScript.RootPullDecl = RootPullDecl;
    var NormalPullDecl = (function (_super) {
        __extends(NormalPullDecl, _super);
        function NormalPullDecl(declName, displayName, kind, declFlags, parentDecl, span, addToParent) {
            if (addToParent === void 0) { addToParent = true; }
            var _this = _super.call(this, declName, displayName, kind, declFlags, span) || this;
            _this.parentDecl = null;
            _this.parentPath = null;
            _this.parentDecl = parentDecl;
            if (addToParent) {
                parentDecl.addChildDecl(_this);
            }
            return _this;
        }
        NormalPullDecl.prototype.fileName = function () {
            return this.parentDecl ? this.parentDecl.fileName() : "";
        };
        NormalPullDecl.prototype.getParentDecl = function () {
            return this.parentDecl;
        };
        NormalPullDecl.prototype.getParentPath = function () {
            if (!this.parentPath) {
                var path = [this];
                var parentDecl = this.parentDecl;
                while (parentDecl) {
                    if (parentDecl && path[path.length - 1] != parentDecl && !(parentDecl.kind & TypeScript.PullElementKind.ObjectLiteral)) {
                        path.unshift(parentDecl);
                    }
                    parentDecl = parentDecl.getParentDecl();
                }
                this.parentPath = path;
            }
            return this.parentPath;
        };
        NormalPullDecl.prototype.semanticInfoChain = function () {
            var parent = this.getParentDecl();
            return parent ? parent.semanticInfoChain() : null;
        };
        NormalPullDecl.prototype.isExternalModule = function () {
            return false;
        };
        NormalPullDecl.prototype.getEnclosingDecl = function () {
            return this.parentDecl && this.parentDecl._getEnclosingDeclFromParentDecl();
        };
        return NormalPullDecl;
    }(PullDecl));
    TypeScript.NormalPullDecl = NormalPullDecl;
    var PullEnumElementDecl = (function (_super) {
        __extends(PullEnumElementDecl, _super);
        function PullEnumElementDecl(declName, displayName, parentDecl, span) {
            var _this = _super.call(this, declName, displayName, TypeScript.PullElementKind.EnumMember, TypeScript.PullElementFlags.Public, parentDecl, span) || this;
            _this.constantValue = null;
            return _this;
        }
        return PullEnumElementDecl;
    }(NormalPullDecl));
    TypeScript.PullEnumElementDecl = PullEnumElementDecl;
    var PullFunctionExpressionDecl = (function (_super) {
        __extends(PullFunctionExpressionDecl, _super);
        function PullFunctionExpressionDecl(expressionName, declFlags, parentDecl, span, displayName) {
            if (displayName === void 0) { displayName = ""; }
            var _this = _super.call(this, "", displayName, TypeScript.PullElementKind.FunctionExpression, declFlags, parentDecl, span) || this;
            _this.functionExpressionName = expressionName;
            return _this;
        }
        PullFunctionExpressionDecl.prototype.getFunctionExpressionName = function () {
            return this.functionExpressionName;
        };
        return PullFunctionExpressionDecl;
    }(NormalPullDecl));
    TypeScript.PullFunctionExpressionDecl = PullFunctionExpressionDecl;
    var PullSynthesizedDecl = (function (_super) {
        __extends(PullSynthesizedDecl, _super);
        function PullSynthesizedDecl(declName, displayName, kind, declFlags, parentDecl, span, semanticInfoChain) {
            var _this = _super.call(this, declName, displayName, kind, declFlags, parentDecl, span, false) || this;
            _this._semanticInfoChain = semanticInfoChain;
            return _this;
        }
        PullSynthesizedDecl.prototype.semanticInfoChain = function () {
            return this._semanticInfoChain;
        };
        PullSynthesizedDecl.prototype.isSynthesized = function () {
            return true;
        };
        return PullSynthesizedDecl;
    }(NormalPullDecl));
    TypeScript.PullSynthesizedDecl = PullSynthesizedDecl;
    var PullDeclGroup = (function () {
        function PullDeclGroup(name) {
            this.name = name;
            this._decls = [];
        }
        PullDeclGroup.prototype.addDecl = function (decl) {
            if (decl.name === this.name) {
                this._decls[this._decls.length] = decl;
            }
        };
        PullDeclGroup.prototype.getDecls = function () {
            return this._decls;
        };
        return PullDeclGroup;
    }());
    TypeScript.PullDeclGroup = PullDeclGroup;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.pullSymbolID = 0;
    TypeScript.globalTyvarID = 0;
    TypeScript.sentinelEmptyArray = [];
    var PullSymbol = (function () {
        function PullSymbol(name, declKind) {
            this.pullSymbolID = TypeScript.pullSymbolID++;
            this._container = null;
            this.type = null;
            this._declarations = null;
            this.isResolved = false;
            this.isOptional = false;
            this.inResolution = false;
            this.isSynthesized = false;
            this.isVarArg = false;
            this.rootSymbol = null;
            this._enclosingSignature = null;
            this._docComments = null;
            this.isPrinting = false;
            this._translatedSymbol = null;
            this._fullName = null;
            this._fullQualifiedName = null;
            this.name = name;
            this.kind = declKind;
        }
        PullSymbol.prototype.isAny = function () {
            return false;
        };
        PullSymbol.prototype.isType = function () {
            return (this.kind & TypeScript.PullElementKind.SomeType) != 0;
        };
        PullSymbol.prototype.isTypeReference = function () { return false; };
        PullSymbol.prototype.isSignature = function () {
            return (this.kind & TypeScript.PullElementKind.SomeSignature) != 0;
        };
        PullSymbol.prototype.isArrayNamedTypeReference = function () {
            return false;
        };
        PullSymbol.prototype.isPrimitive = function () {
            return this.kind === TypeScript.PullElementKind.Primitive;
        };
        PullSymbol.prototype.isAccessor = function () {
            return false;
        };
        PullSymbol.prototype.isError = function () {
            return false;
        };
        PullSymbol.prototype.isInterface = function () {
            return this.kind === TypeScript.PullElementKind.Interface;
        };
        PullSymbol.prototype.isMethod = function () {
            return this.kind === TypeScript.PullElementKind.Method;
        };
        PullSymbol.prototype.isProperty = function () {
            return this.kind === TypeScript.PullElementKind.Property;
        };
        PullSymbol.prototype.isAlias = function () { return false; };
        PullSymbol.prototype.isContainer = function () { return false; };
        PullSymbol.prototype.findAliasedType = function (scopeSymbol, skipScopeSymbolAliasesLookIn, lookIntoOnlyExportedAlias, aliasSymbols, visitedScopeDeclarations) {
            if (aliasSymbols === void 0) { aliasSymbols = []; }
            if (visitedScopeDeclarations === void 0) { visitedScopeDeclarations = []; }
            var scopeDeclarations = scopeSymbol.getDeclarations();
            var scopeSymbolAliasesToLookIn = [];
            for (var i = 0; i < scopeDeclarations.length; i++) {
                var scopeDecl = scopeDeclarations[i];
                if (!TypeScript.ArrayUtilities.contains(visitedScopeDeclarations, scopeDecl)) {
                    visitedScopeDeclarations.push(scopeDecl);
                    var childDecls = scopeDecl.getChildDecls();
                    for (var j = 0; j < childDecls.length; j++) {
                        var childDecl = childDecls[j];
                        if (childDecl.kind === TypeScript.PullElementKind.TypeAlias &&
                            (!lookIntoOnlyExportedAlias || (childDecl.flags & TypeScript.PullElementFlags.Exported))) {
                            var symbol = childDecl.getSymbol();
                            if (PullContainerSymbol.usedAsSymbol(symbol, this) ||
                                (this.rootSymbol && PullContainerSymbol.usedAsSymbol(symbol, this.rootSymbol))) {
                                aliasSymbols.push(symbol);
                                return aliasSymbols;
                            }
                            if (!skipScopeSymbolAliasesLookIn && this.isExternalModuleReferenceAlias(symbol) &&
                                (!symbol.assignedContainer().hasExportAssignment() ||
                                    (symbol.assignedContainer().getExportAssignedContainerSymbol() && symbol.assignedContainer().getExportAssignedContainerSymbol().kind == TypeScript.PullElementKind.DynamicModule))) {
                                scopeSymbolAliasesToLookIn.push(symbol);
                            }
                        }
                    }
                }
            }
            for (var i = 0; i < scopeSymbolAliasesToLookIn.length; i++) {
                var scopeSymbolAlias = scopeSymbolAliasesToLookIn[i];
                aliasSymbols.push(scopeSymbolAlias);
                var result = this.findAliasedType(scopeSymbolAlias.assignedContainer().hasExportAssignment() ? scopeSymbolAlias.assignedContainer().getExportAssignedContainerSymbol() : scopeSymbolAlias.assignedContainer(), false, true, aliasSymbols, visitedScopeDeclarations);
                if (result) {
                    return result;
                }
                aliasSymbols.pop();
            }
            return null;
        };
        PullSymbol.prototype.getExternalAliasedSymbols = function (scopeSymbol) {
            if (!scopeSymbol) {
                return null;
            }
            var scopePath = scopeSymbol.pathToRoot();
            if (scopePath.length && scopePath[scopePath.length - 1].kind === TypeScript.PullElementKind.DynamicModule) {
                var symbols = this.findAliasedType(scopePath[scopePath.length - 1]);
                return symbols;
            }
            return null;
        };
        PullSymbol.prototype.isExternalModuleReferenceAlias = function (aliasSymbol) {
            if (aliasSymbol) {
                if (aliasSymbol.assignedValue()) {
                    return false;
                }
                if (aliasSymbol.assignedType() && aliasSymbol.assignedType() != aliasSymbol.assignedContainer()) {
                    return false;
                }
                if (aliasSymbol.assignedContainer() && aliasSymbol.assignedContainer().kind != TypeScript.PullElementKind.DynamicModule) {
                    return false;
                }
                return true;
            }
            return false;
        };
        PullSymbol.prototype.getExportedInternalAliasSymbol = function (scopeSymbol) {
            if (scopeSymbol) {
                if (this.kind != TypeScript.PullElementKind.TypeAlias) {
                    var scopePath = scopeSymbol.pathToRoot();
                    for (var i = 0; i < scopePath.length; i++) {
                        var internalAliases = this.findAliasedType(scopeSymbol, true, true);
                        if (internalAliases) {
                            TypeScript.Debug.assert(internalAliases.length == 1);
                            return internalAliases[0];
                        }
                    }
                }
            }
            return null;
        };
        PullSymbol.prototype.getAliasSymbolName = function (scopeSymbol, aliasNameGetter, aliasPartsNameGetter, skipInternalAlias) {
            if (!skipInternalAlias) {
                var internalAlias = this.getExportedInternalAliasSymbol(scopeSymbol);
                if (internalAlias) {
                    return aliasNameGetter(internalAlias);
                }
            }
            var externalAliases = this.getExternalAliasedSymbols(scopeSymbol);
            if (externalAliases && this.isExternalModuleReferenceAlias(externalAliases[externalAliases.length - 1])) {
                var aliasFullName = "";
                for (var i = 1, symbolsLen = externalAliases.length; i < symbolsLen; i++) {
                    aliasFullName = aliasFullName + "." + aliasPartsNameGetter(externalAliases[i]);
                }
                return aliasNameGetter(externalAliases[0]) + aliasFullName;
            }
            return null;
        };
        PullSymbol.prototype._getResolver = function () {
            TypeScript.Debug.assert(this._declarations && this._declarations.length > 0);
            return this._declarations[0].semanticInfoChain().getResolver();
        };
        PullSymbol.prototype._resolveDeclaredSymbol = function () {
            return this._getResolver().resolveDeclaredSymbol(this);
        };
        PullSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            var aliasName = this.getAliasSymbolName(scopeSymbol, function (symbol) { return symbol.getName(scopeSymbol, useConstraintInName); }, function (symbol) { return symbol.getName(); });
            if (aliasName != null) {
                return aliasName;
            }
            return this.name;
        };
        PullSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName, skipInternalAliasName) {
            var aliasDisplayName = this.getAliasSymbolName(scopeSymbol, function (symbol) { return symbol.getDisplayName(scopeSymbol, useConstraintInName); }, function (symbol) { return symbol.getDisplayName(); }, skipInternalAliasName);
            if (aliasDisplayName != null) {
                return aliasDisplayName;
            }
            var decls = this.getDeclarations();
            var name = decls.length && decls[0].getDisplayName();
            return (name && name.length) ? name : this.name;
        };
        PullSymbol.prototype.getIsSpecialized = function () { return false; };
        PullSymbol.prototype.getRootSymbol = function () {
            if (!this.rootSymbol) {
                return this;
            }
            return this.rootSymbol;
        };
        PullSymbol.prototype.setRootSymbol = function (symbol) { this.rootSymbol = symbol; };
        PullSymbol.prototype.setIsSynthesized = function (value) {
            if (value === void 0) { value = true; }
            this.isSynthesized = value;
        };
        PullSymbol.prototype.getIsSynthesized = function () { return this.isSynthesized; };
        PullSymbol.prototype.setEnclosingSignature = function (signature) {
            this._enclosingSignature = signature;
        };
        PullSymbol.prototype.getEnclosingSignature = function () {
            return this._enclosingSignature;
        };
        PullSymbol.prototype.addDeclaration = function (decl) {
            TypeScript.Debug.assert(!!decl);
            if (this.rootSymbol) {
                return;
            }
            if (!this._declarations) {
                this._declarations = [decl];
            }
            else {
                this._declarations[this._declarations.length] = decl;
            }
        };
        PullSymbol.prototype.getDeclarations = function () {
            if (this.rootSymbol) {
                return this.rootSymbol.getDeclarations();
            }
            if (!this._declarations) {
                this._declarations = [];
            }
            return this._declarations;
        };
        PullSymbol.prototype.hasDeclaration = function (decl) {
            if (!this._declarations) {
                return false;
            }
            return TypeScript.ArrayUtilities.any(this._declarations, function (eachDecl) { return eachDecl === decl; });
        };
        PullSymbol.prototype.setContainer = function (containerSymbol) {
            if (this.rootSymbol) {
                return;
            }
            this._container = containerSymbol;
        };
        PullSymbol.prototype.getContainer = function () {
            if (this.rootSymbol) {
                return this.rootSymbol.getContainer();
            }
            return this._container;
        };
        PullSymbol.prototype.setResolved = function () {
            this.isResolved = true;
            this.inResolution = false;
        };
        PullSymbol.prototype.startResolving = function () {
            this.inResolution = true;
        };
        PullSymbol.prototype.setUnresolved = function () {
            this.isResolved = false;
            this.inResolution = false;
        };
        PullSymbol.prototype.anyDeclHasFlag = function (flag) {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if (TypeScript.hasFlag(declarations[i].flags, flag)) {
                    return true;
                }
            }
            return false;
        };
        PullSymbol.prototype.allDeclsHaveFlag = function (flag) {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if (!TypeScript.hasFlag(declarations[i].flags, flag)) {
                    return false;
                }
            }
            return true;
        };
        PullSymbol.prototype.pathToRoot = function () {
            var path = [];
            var node = this;
            while (node) {
                if (node.isType()) {
                    var associatedContainerSymbol = node.getAssociatedContainerType();
                    if (associatedContainerSymbol) {
                        node = associatedContainerSymbol;
                    }
                }
                path[path.length] = node;
                var nodeKind = node.kind;
                if (nodeKind == TypeScript.PullElementKind.Parameter) {
                    break;
                }
                else {
                    node = node.getContainer();
                }
            }
            return path;
        };
        PullSymbol.prototype.findCommonAncestorPath = function (b) {
            var aPath = this.pathToRoot();
            if (aPath.length === 1) {
                return aPath;
            }
            var bPath;
            if (b) {
                bPath = b.pathToRoot();
            }
            else {
                return aPath;
            }
            var commonNodeIndex = -1;
            for (var i = 0, aLen = aPath.length; i < aLen; i++) {
                var aNode = aPath[i];
                for (var j = 0, bLen = bPath.length; j < bLen; j++) {
                    var bNode = bPath[j];
                    if (aNode === bNode) {
                        var aDecl = null;
                        if (i > 0) {
                            var decls = aPath[i - 1].getDeclarations();
                            if (decls.length) {
                                aDecl = decls[0].getParentDecl();
                            }
                        }
                        var bDecl = null;
                        if (j > 0) {
                            var decls = bPath[j - 1].getDeclarations();
                            if (decls.length) {
                                bDecl = decls[0].getParentDecl();
                            }
                        }
                        if (!aDecl || !bDecl || aDecl == bDecl) {
                            commonNodeIndex = i;
                            break;
                        }
                    }
                }
                if (commonNodeIndex >= 0) {
                    break;
                }
            }
            if (commonNodeIndex >= 0) {
                return aPath.slice(0, commonNodeIndex);
            }
            else {
                return aPath;
            }
        };
        PullSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            var str = this.getNameAndTypeName(scopeSymbol);
            return str;
        };
        PullSymbol.prototype.getNamePartForFullName = function () {
            return this.getDisplayName(null, true);
        };
        PullSymbol.prototype.fullQualifiedName = function () {
            if (this._fullQualifiedName)
                return this._fullQualifiedName;
            var fn = this.fullName();
            var ix = fn.indexOf("<");
            this._fullQualifiedName = ix >= 0 ? fn.substring(0, ix).split(".") : fn.split(".");
            return this._fullQualifiedName;
        };
        PullSymbol.prototype.fullName = function (scopeSymbol) {
            if (this._fullName)
                return this._fullName;
            this._fullName = this.fullNameAux(scopeSymbol);
            return this._fullName;
        };
        PullSymbol.prototype.fullNameAux = function (scopeSymbol) {
            var path = this.pathToRoot();
            var fullName = "";
            var aliasFullName = this.getAliasSymbolName(scopeSymbol, function (symbol) { return symbol.fullName(scopeSymbol); }, function (symbol) { return symbol.getNamePartForFullName(); });
            if (aliasFullName != null) {
                return aliasFullName;
            }
            for (var i = 1; i < path.length; i++) {
                var aliasFullName = path[i].getAliasSymbolName(scopeSymbol, function (symbol) { return symbol.fullName(scopeSymbol); }, function (symbol) { return symbol.getNamePartForFullName(); });
                if (aliasFullName != null) {
                    fullName = aliasFullName + "." + fullName;
                    break;
                }
                var scopedName = path[i].getNamePartForFullName();
                if (path[i].kind == TypeScript.PullElementKind.DynamicModule && !TypeScript.isQuoted(scopedName)) {
                    break;
                }
                if (scopedName === "") {
                    break;
                }
                fullName = scopedName + "." + fullName;
            }
            fullName = fullName + this.getNamePartForFullName();
            return fullName;
        };
        PullSymbol.prototype.getScopedName = function (scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName) {
            var path = this.findCommonAncestorPath(scopeSymbol);
            var fullName = "";
            var aliasFullName = this.getAliasSymbolName(scopeSymbol, function (symbol) { return symbol.getScopedName(scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName); }, function (symbol) { return symbol.getNamePartForFullName(); }, skipInternalAliasName);
            if (aliasFullName != null) {
                return aliasFullName;
            }
            for (var i = 1; i < path.length; i++) {
                var kind = path[i].kind;
                if (kind === TypeScript.PullElementKind.Container || kind === TypeScript.PullElementKind.DynamicModule) {
                    var aliasFullName = path[i].getAliasSymbolName(scopeSymbol, function (symbol) { return symbol.getScopedName(scopeSymbol, skipTypeParametersInName, false, skipInternalAliasName); }, function (symbol) { return symbol.getNamePartForFullName(); }, skipInternalAliasName);
                    if (aliasFullName != null) {
                        fullName = aliasFullName + "." + fullName;
                        break;
                    }
                    if (kind === TypeScript.PullElementKind.Container) {
                        fullName = path[i].getDisplayName() + "." + fullName;
                    }
                    else {
                        var displayName = path[i].getDisplayName();
                        if (TypeScript.isQuoted(displayName)) {
                            fullName = displayName + "." + fullName;
                        }
                        break;
                    }
                }
                else {
                    break;
                }
            }
            fullName = fullName + this.getDisplayName(scopeSymbol, useConstraintInName, skipInternalAliasName);
            return fullName;
        };
        PullSymbol.prototype.getScopedNameEx = function (scopeSymbol, skipTypeParametersInName, useConstraintInName, getPrettyTypeName, getTypeParamMarkerInfo, skipInternalAliasName) {
            var name = this.getScopedName(scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName);
            return TypeScript.MemberName.create(name);
        };
        PullSymbol.prototype.getTypeName = function (scopeSymbol, getPrettyTypeName) {
            var memberName = this.getTypeNameEx(scopeSymbol, getPrettyTypeName);
            return memberName.toString();
        };
        PullSymbol.prototype.getTypeNameEx = function (scopeSymbol, getPrettyTypeName) {
            var type = this.type;
            if (type) {
                var memberName = getPrettyTypeName ? this.getTypeNameForFunctionSignature("", scopeSymbol, getPrettyTypeName) : null;
                if (!memberName) {
                    memberName = type.getScopedNameEx(scopeSymbol, false, true, getPrettyTypeName);
                }
                return memberName;
            }
            return TypeScript.MemberName.create("");
        };
        PullSymbol.prototype.getTypeNameForFunctionSignature = function (prefix, scopeSymbol, getPrettyTypeName) {
            var type = this.type;
            if (type && !type.isNamedTypeSymbol() && this.kind != TypeScript.PullElementKind.Property && this.kind != TypeScript.PullElementKind.Variable && this.kind != TypeScript.PullElementKind.Parameter) {
                var signatures = type.getCallSignatures();
                if (signatures.length == 1 || (getPrettyTypeName && signatures.length)) {
                    var typeName = new TypeScript.MemberNameArray();
                    var signatureName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, prefix, false, false, scopeSymbol, getPrettyTypeName);
                    typeName.addAll(signatureName);
                    return typeName;
                }
            }
            return null;
        };
        PullSymbol.prototype.getNameAndTypeName = function (scopeSymbol) {
            var nameAndTypeName = this.getNameAndTypeNameEx(scopeSymbol);
            return nameAndTypeName.toString();
        };
        PullSymbol.prototype.getNameAndTypeNameEx = function (scopeSymbol) {
            var type = this.type;
            var nameStr = this.getDisplayName(scopeSymbol);
            if (type) {
                nameStr = nameStr + (this.isOptional ? "?" : "");
                var memberName = this.getTypeNameForFunctionSignature(nameStr, scopeSymbol);
                if (!memberName) {
                    var typeNameEx = type.getScopedNameEx(scopeSymbol);
                    memberName = TypeScript.MemberName.create(typeNameEx, nameStr + ": ", "");
                }
                return memberName;
            }
            return TypeScript.MemberName.create(nameStr);
        };
        PullSymbol.getTypeParameterString = function (typars, scopeSymbol, useContraintInName) {
            return PullSymbol.getTypeParameterStringEx(typars, scopeSymbol, undefined, useContraintInName).toString();
        };
        PullSymbol.getTypeParameterStringEx = function (typeParameters, scopeSymbol, getTypeParamMarkerInfo, useContraintInName) {
            var builder = new TypeScript.MemberNameArray();
            builder.prefix = "";
            if (typeParameters && typeParameters.length) {
                builder.add(TypeScript.MemberName.create("<"));
                for (var i = 0; i < typeParameters.length; i++) {
                    if (i) {
                        builder.add(TypeScript.MemberName.create(", "));
                    }
                    if (getTypeParamMarkerInfo) {
                        builder.add(new TypeScript.MemberName());
                    }
                    builder.add(typeParameters[i].getScopedNameEx(scopeSymbol, false, useContraintInName));
                    if (getTypeParamMarkerInfo) {
                        builder.add(new TypeScript.MemberName());
                    }
                }
                builder.add(TypeScript.MemberName.create(">"));
            }
            return builder;
        };
        PullSymbol.getIsExternallyVisible = function (symbol, fromIsExternallyVisibleSymbol, inIsExternallyVisibleSymbols) {
            if (inIsExternallyVisibleSymbols) {
                for (var i = 0; i < inIsExternallyVisibleSymbols.length; i++) {
                    if (inIsExternallyVisibleSymbols[i] === symbol) {
                        return true;
                    }
                }
            }
            else {
                inIsExternallyVisibleSymbols = [];
            }
            if (fromIsExternallyVisibleSymbol === symbol) {
                return true;
            }
            inIsExternallyVisibleSymbols.push(fromIsExternallyVisibleSymbol);
            var result = symbol.isExternallyVisible(inIsExternallyVisibleSymbols);
            TypeScript.Debug.assert(TypeScript.ArrayUtilities.last(inIsExternallyVisibleSymbols) === fromIsExternallyVisibleSymbol);
            inIsExternallyVisibleSymbols.pop();
            return result;
        };
        PullSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            var kind = this.kind;
            if (kind === TypeScript.PullElementKind.Primitive) {
                return true;
            }
            if (this.rootSymbol) {
                return PullSymbol.getIsExternallyVisible(this.rootSymbol, this, inIsExternallyVisibleSymbols);
            }
            if (this.isType()) {
                var associatedContainerSymbol = this.getAssociatedContainerType();
                if (associatedContainerSymbol) {
                    return PullSymbol.getIsExternallyVisible(associatedContainerSymbol, this, inIsExternallyVisibleSymbols);
                }
            }
            if (this.anyDeclHasFlag(TypeScript.PullElementFlags.Private)) {
                return false;
            }
            var container = this.getContainer();
            if (container === null) {
                var decls = this.getDeclarations();
                if (decls.length) {
                    var parentDecl = decls[0].getParentDecl();
                    if (parentDecl) {
                        var parentSymbol = parentDecl.getSymbol();
                        if (!parentSymbol || parentDecl.kind == TypeScript.PullElementKind.Script) {
                            return true;
                        }
                        return PullSymbol.getIsExternallyVisible(parentSymbol, this, inIsExternallyVisibleSymbols);
                    }
                }
                return true;
            }
            if (container.kind == TypeScript.PullElementKind.DynamicModule ||
                (container.getAssociatedContainerType() && container.getAssociatedContainerType().kind == TypeScript.PullElementKind.DynamicModule)) {
                var containerSymbol = container.kind == TypeScript.PullElementKind.DynamicModule
                    ? container
                    : container.getAssociatedContainerType();
                if (PullContainerSymbol.usedAsSymbol(containerSymbol, this)) {
                    return true;
                }
            }
            if (!this.anyDeclHasFlag(TypeScript.PullElementFlags.Exported) && kind != TypeScript.PullElementKind.Property && kind != TypeScript.PullElementKind.Method) {
                return false;
            }
            return PullSymbol.getIsExternallyVisible(container, this, inIsExternallyVisibleSymbols);
        };
        PullSymbol.prototype.getDocCommentsOfDecl = function (decl) {
            var ast = decl.ast();
            if (ast) {
                var enclosingModuleDeclaration = TypeScript.getEnclosingModuleDeclaration(ast);
                if (TypeScript.isLastNameOfModule(enclosingModuleDeclaration, ast)) {
                    return TypeScript.docComments(enclosingModuleDeclaration);
                }
                if (ast.kind() != TypeScript.SyntaxKind.ModuleDeclaration || decl.kind != TypeScript.PullElementKind.Variable) {
                    return TypeScript.docComments(ast);
                }
            }
            return [];
        };
        PullSymbol.prototype.getDocCommentArray = function (symbol) {
            var docComments = [];
            if (!symbol) {
                return docComments;
            }
            var isParameter = symbol.kind == TypeScript.PullElementKind.Parameter;
            var decls = symbol.getDeclarations();
            for (var i = 0; i < decls.length; i++) {
                if (isParameter && decls[i].kind == TypeScript.PullElementKind.Property) {
                    continue;
                }
                docComments = docComments.concat(this.getDocCommentsOfDecl(decls[i]));
            }
            return docComments;
        };
        PullSymbol.getDefaultConstructorSymbolForDocComments = function (classSymbol) {
            if (classSymbol.getHasDefaultConstructor()) {
                var extendedTypes = classSymbol.getExtendedTypes();
                if (extendedTypes.length) {
                    return PullSymbol.getDefaultConstructorSymbolForDocComments(extendedTypes[0]);
                }
            }
            return classSymbol.type.getConstructSignatures()[0];
        };
        PullSymbol.prototype.getDocCommentText = function (comments) {
            var docCommentText = new Array();
            for (var c = 0; c < comments.length; c++) {
                var commentText = this.getDocCommentTextValue(comments[c]);
                if (commentText !== "") {
                    docCommentText.push(commentText);
                }
            }
            return docCommentText.join("\n");
        };
        PullSymbol.prototype.getDocCommentTextValue = function (comment) {
            return this.cleanJSDocComment(comment.fullText());
        };
        PullSymbol.prototype.docComments = function (useConstructorAsClass) {
            var decls = this.getDeclarations();
            if (useConstructorAsClass && decls.length && decls[0].kind == TypeScript.PullElementKind.ConstructorMethod) {
                var classDecl = decls[0].getParentDecl();
                return this.getDocCommentText(this.getDocCommentsOfDecl(classDecl));
            }
            if (this._docComments === null) {
                var docComments = "";
                if (!useConstructorAsClass && this.kind == TypeScript.PullElementKind.ConstructSignature &&
                    decls.length && decls[0].kind == TypeScript.PullElementKind.Class) {
                    var classSymbol = this.returnType;
                    var extendedTypes = classSymbol.getExtendedTypes();
                    if (extendedTypes.length) {
                        docComments = extendedTypes[0].getConstructorMethod().docComments();
                    }
                    else {
                        docComments = "";
                    }
                }
                else if (this.kind == TypeScript.PullElementKind.Parameter) {
                    var parameterComments = [];
                    var funcContainer = this.getEnclosingSignature();
                    var funcDocComments = this.getDocCommentArray(funcContainer);
                    var paramComment = this.getParameterDocCommentText(this.getDisplayName(), funcDocComments);
                    if (paramComment != "") {
                        parameterComments.push(paramComment);
                    }
                    var paramSelfComment = this.getDocCommentText(this.getDocCommentArray(this));
                    if (paramSelfComment != "") {
                        parameterComments.push(paramSelfComment);
                    }
                    docComments = parameterComments.join("\n");
                }
                else {
                    var getSymbolComments = true;
                    if (this.kind == TypeScript.PullElementKind.FunctionType) {
                        var functionSymbol = this.getFunctionSymbol();
                        if (functionSymbol) {
                            docComments = functionSymbol._docComments || "";
                            getSymbolComments = false;
                        }
                        else {
                            var declarationList = this.getDeclarations();
                            if (declarationList.length > 0) {
                                docComments = declarationList[0].getSymbol()._docComments || "";
                                getSymbolComments = false;
                            }
                        }
                    }
                    if (getSymbolComments) {
                        docComments = this.getDocCommentText(this.getDocCommentArray(this));
                        if (docComments == "") {
                            if (this.kind == TypeScript.PullElementKind.CallSignature) {
                                var callTypeSymbol = this.functionType;
                                if (callTypeSymbol && callTypeSymbol.getCallSignatures().length == 1) {
                                    docComments = callTypeSymbol.docComments();
                                }
                            }
                        }
                    }
                }
                this._docComments = docComments;
            }
            return this._docComments;
        };
        PullSymbol.prototype.getParameterDocCommentText = function (param, fncDocComments) {
            if (fncDocComments.length === 0 || fncDocComments[0].kind() !== TypeScript.SyntaxKind.MultiLineCommentTrivia) {
                return "";
            }
            for (var i = 0; i < fncDocComments.length; i++) {
                var commentContents = fncDocComments[i].fullText();
                for (var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {
                    j += 6;
                    if (!this.isSpaceChar(commentContents, j)) {
                        continue;
                    }
                    j = this.consumeLeadingSpace(commentContents, j);
                    if (j === -1) {
                        break;
                    }
                    if (commentContents.charCodeAt(j) === TypeScript.CharacterCodes.openBrace) {
                        j++;
                        var charCode = 0;
                        for (var curlies = 1; j < commentContents.length; j++) {
                            charCode = commentContents.charCodeAt(j);
                            if (charCode === TypeScript.CharacterCodes.openBrace) {
                                curlies++;
                                continue;
                            }
                            if (charCode === TypeScript.CharacterCodes.closeBrace) {
                                curlies--;
                                if (curlies === 0) {
                                    break;
                                }
                                else {
                                    continue;
                                }
                            }
                            if (charCode === TypeScript.CharacterCodes.at) {
                                break;
                            }
                        }
                        if (j === commentContents.length) {
                            break;
                        }
                        if (charCode === TypeScript.CharacterCodes.at) {
                            continue;
                        }
                        j = this.consumeLeadingSpace(commentContents, j + 1);
                        if (j === -1) {
                            break;
                        }
                    }
                    if (param !== commentContents.substr(j, param.length) || !this.isSpaceChar(commentContents, j + param.length)) {
                        continue;
                    }
                    j = this.consumeLeadingSpace(commentContents, j + param.length);
                    if (j === -1) {
                        return "";
                    }
                    var endOfParam = commentContents.indexOf("@", j);
                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);
                    var paramSpacesToRemove = undefined;
                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\n") + 1;
                    if (paramLineIndex !== 0) {
                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) === "\r") {
                            paramLineIndex++;
                        }
                    }
                    var startSpaceRemovalIndex = this.consumeLeadingSpace(commentContents, paramLineIndex);
                    if (startSpaceRemovalIndex !== j && commentContents.charAt(startSpaceRemovalIndex) === "*") {
                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;
                    }
                    return this.cleanJSDocComment(paramHelpString, paramSpacesToRemove);
                }
            }
            return "";
        };
        PullSymbol.prototype.cleanJSDocComment = function (content, spacesToRemove) {
            var docCommentLines = new Array();
            content = content.replace("/**", "");
            if (content.length >= 2 && content.charAt(content.length - 1) === "/" && content.charAt(content.length - 2) === "*") {
                content = content.substring(0, content.length - 2);
            }
            var lines = content.split("\n");
            var inParamTag = false;
            for (var l = 0; l < lines.length; l++) {
                var line = lines[l];
                var cleanLinePos = this.cleanDocCommentLine(line, true, spacesToRemove);
                if (!cleanLinePos) {
                    continue;
                }
                var docCommentText = "";
                var prevPos = cleanLinePos.start;
                for (var i = line.indexOf("@", cleanLinePos.start); 0 <= i && i < cleanLinePos.end; i = line.indexOf("@", i + 1)) {
                    var wasInParamtag = inParamTag;
                    if (line.indexOf("param", i + 1) === i + 1 && this.isSpaceChar(line, i + 6)) {
                        if (!wasInParamtag) {
                            docCommentText += line.substring(prevPos, i);
                        }
                        prevPos = i;
                        inParamTag = true;
                    }
                    else if (wasInParamtag) {
                        prevPos = i;
                        inParamTag = false;
                    }
                }
                if (!inParamTag) {
                    docCommentText += line.substring(prevPos, cleanLinePos.end);
                }
                var newCleanPos = this.cleanDocCommentLine(docCommentText, false);
                if (newCleanPos) {
                    if (spacesToRemove === undefined) {
                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;
                    }
                    docCommentLines.push(docCommentText);
                }
            }
            return docCommentLines.join("\n");
        };
        PullSymbol.prototype.consumeLeadingSpace = function (line, startIndex, maxSpacesToRemove) {
            var endIndex = line.length;
            if (maxSpacesToRemove !== undefined) {
                endIndex = TypeScript.MathPrototype.min(startIndex + maxSpacesToRemove, endIndex);
            }
            for (; startIndex < endIndex; startIndex++) {
                var charCode = line.charCodeAt(startIndex);
                if (charCode !== TypeScript.CharacterCodes.space && charCode !== TypeScript.CharacterCodes.tab) {
                    return startIndex;
                }
            }
            if (endIndex !== line.length) {
                return endIndex;
            }
            return -1;
        };
        PullSymbol.prototype.isSpaceChar = function (line, index) {
            var length = line.length;
            if (index < length) {
                var charCode = line.charCodeAt(index);
                return charCode === TypeScript.CharacterCodes.space || charCode === TypeScript.CharacterCodes.tab;
            }
            return index === length;
        };
        PullSymbol.prototype.cleanDocCommentLine = function (line, jsDocStyleComment, jsDocLineSpaceToRemove) {
            var nonSpaceIndex = this.consumeLeadingSpace(line, 0);
            if (nonSpaceIndex !== -1) {
                var jsDocSpacesRemoved = nonSpaceIndex;
                if (jsDocStyleComment && line.charAt(nonSpaceIndex) === '*') {
                    var startIndex = nonSpaceIndex + 1;
                    nonSpaceIndex = this.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);
                    if (nonSpaceIndex !== -1) {
                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;
                    }
                    else {
                        return null;
                    }
                }
                return {
                    start: nonSpaceIndex,
                    end: line.charAt(line.length - 1) === "\r" ? line.length - 1 : line.length,
                    jsDocSpacesRemoved: jsDocSpacesRemoved
                };
            }
            return null;
        };
        return PullSymbol;
    }());
    TypeScript.PullSymbol = PullSymbol;
    var PullSignatureSymbol = (function (_super) {
        __extends(PullSignatureSymbol, _super);
        function PullSignatureSymbol(kind) {
            var _this = _super.call(this, "", kind) || this;
            _this._memberTypeParameterNameCache = null;
            _this._stringConstantOverload = undefined;
            _this.parameters = [];
            _this.typeParameters = null;
            _this.returnType = null;
            _this.functionType = null;
            _this.hasOptionalParam = false;
            _this.nonOptionalParamCount = 0;
            _this.hasVarArgs = false;
            _this.hasAGenericParameter = false;
            _this.hasBeenChecked = false;
            _this.inWrapCheck = false;
            return _this;
        }
        PullSignatureSymbol.prototype.isDefinition = function () { return false; };
        PullSignatureSymbol.prototype.isGeneric = function () { return this.hasAGenericParameter || (this.typeParameters && this.typeParameters.length != 0); };
        PullSignatureSymbol.prototype.addParameter = function (parameter, isOptional) {
            if (isOptional === void 0) { isOptional = false; }
            if (this.parameters == TypeScript.sentinelEmptyArray) {
                this.parameters = [];
            }
            this.parameters[this.parameters.length] = parameter;
            this.hasOptionalParam = isOptional;
            if (!parameter.getEnclosingSignature()) {
                parameter.setEnclosingSignature(this);
            }
            if (!isOptional) {
                this.nonOptionalParamCount++;
            }
        };
        PullSignatureSymbol.prototype.addTypeParameter = function (typeParameter) {
            if (!this.typeParameters) {
                this.typeParameters = [];
            }
            if (!this._memberTypeParameterNameCache) {
                this._memberTypeParameterNameCache = TypeScript.createIntrinsicsObject();
            }
            this.typeParameters[this.typeParameters.length] = typeParameter;
            this._memberTypeParameterNameCache[typeParameter.getName()] = typeParameter;
        };
        PullSignatureSymbol.prototype.getTypeParameters = function () {
            if (!this.typeParameters) {
                this.typeParameters = [];
            }
            return this.typeParameters;
        };
        PullSignatureSymbol.prototype.findTypeParameter = function (name) {
            var memberSymbol;
            if (!this._memberTypeParameterNameCache) {
                this._memberTypeParameterNameCache = TypeScript.createIntrinsicsObject();
                if (this.typeParameters) {
                    for (var i = 0; i < this.typeParameters.length; i++) {
                        this._memberTypeParameterNameCache[this.typeParameters[i].getName()] = this.typeParameters[i];
                    }
                }
            }
            memberSymbol = this._memberTypeParameterNameCache[name];
            return memberSymbol;
        };
        PullSignatureSymbol.prototype.isStringConstantOverloadSignature = function () {
            if (this._stringConstantOverload === undefined) {
                var params = this.parameters;
                this._stringConstantOverload = false;
                for (var i = 0; i < params.length; i++) {
                    var paramType = params[i].type;
                    if (paramType && paramType.isPrimitive() && paramType.isStringConstant()) {
                        this._stringConstantOverload = true;
                    }
                }
            }
            return this._stringConstantOverload;
        };
        PullSignatureSymbol.getSignatureTypeMemberName = function (candidateSignature, signatures, scopeSymbol) {
            var allMemberNames = new TypeScript.MemberNameArray();
            var signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, "", false, false, scopeSymbol, true, candidateSignature);
            allMemberNames.addAll(signatureMemberName);
            return allMemberNames;
        };
        PullSignatureSymbol.getSignaturesTypeNameEx = function (signatures, prefix, shortform, brackets, scopeSymbol, getPrettyTypeName, candidateSignature) {
            var result = [];
            if (!signatures) {
                return result;
            }
            var len = signatures.length;
            if (!getPrettyTypeName && len > 1) {
                shortform = false;
            }
            var foundDefinition = false;
            if (candidateSignature && candidateSignature.isDefinition() && len > 1) {
                candidateSignature = null;
            }
            for (var i = 0; i < len; i++) {
                if (len > 1 && signatures[i].isDefinition()) {
                    foundDefinition = true;
                    continue;
                }
                var signature = signatures[i];
                if (getPrettyTypeName && candidateSignature) {
                    signature = candidateSignature;
                }
                result.push(signature.getSignatureTypeNameEx(prefix, shortform, brackets, scopeSymbol));
                if (getPrettyTypeName) {
                    break;
                }
            }
            if (getPrettyTypeName && result.length && len > 1) {
                var lastMemberName = result[result.length - 1];
                for (var i = i + 1; i < len; i++) {
                    if (signatures[i].isDefinition()) {
                        foundDefinition = true;
                        break;
                    }
                }
                var overloadString = TypeScript.getLocalizedText(TypeScript.DiagnosticCode._0_overload_s, [(foundDefinition ? len - 2 : len - 1).toString()]);
                lastMemberName.add(TypeScript.MemberName.create(overloadString));
            }
            return result;
        };
        PullSignatureSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            var s = this.getSignatureTypeNameEx(this.getScopedNameEx().toString(), false, false, scopeSymbol, undefined, useConstraintInName).toString();
            return s;
        };
        PullSignatureSymbol.prototype.getSignatureTypeNameEx = function (prefix, shortform, brackets, scopeSymbol, getParamMarkerInfo, getTypeParamMarkerInfo) {
            var typeParamterBuilder = new TypeScript.MemberNameArray();
            typeParamterBuilder.add(PullSymbol.getTypeParameterStringEx(this.getTypeParameters(), scopeSymbol, getTypeParamMarkerInfo, true));
            if (brackets) {
                typeParamterBuilder.add(TypeScript.MemberName.create("["));
            }
            else {
                typeParamterBuilder.add(TypeScript.MemberName.create("("));
            }
            var builder = new TypeScript.MemberNameArray();
            builder.prefix = prefix;
            if (getTypeParamMarkerInfo) {
                builder.prefix = prefix;
                builder.addAll(typeParamterBuilder.entries);
            }
            else {
                builder.prefix = prefix + typeParamterBuilder.toString();
            }
            var params = this.parameters;
            var paramLen = params.length;
            for (var i = 0; i < paramLen; i++) {
                var paramType = params[i].type;
                var typeString = paramType ? ": " : "";
                var paramIsVarArg = params[i].isVarArg;
                var varArgPrefix = paramIsVarArg ? "..." : "";
                var optionalString = (!paramIsVarArg && params[i].isOptional) ? "?" : "";
                if (getParamMarkerInfo) {
                    builder.add(new TypeScript.MemberName());
                }
                builder.add(TypeScript.MemberName.create(varArgPrefix + params[i].getScopedNameEx(scopeSymbol).toString() + optionalString + typeString));
                if (paramType) {
                    builder.add(paramType.getScopedNameEx(scopeSymbol));
                }
                if (getParamMarkerInfo) {
                    builder.add(new TypeScript.MemberName());
                }
                if (i < paramLen - 1) {
                    builder.add(TypeScript.MemberName.create(", "));
                }
            }
            if (shortform) {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("] => "));
                }
                else {
                    builder.add(TypeScript.MemberName.create(") => "));
                }
            }
            else {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("]: "));
                }
                else {
                    builder.add(TypeScript.MemberName.create("): "));
                }
            }
            if (this.returnType) {
                builder.add(this.returnType.getScopedNameEx(scopeSymbol));
            }
            else {
                builder.add(TypeScript.MemberName.create("any"));
            }
            return builder;
        };
        PullSignatureSymbol.prototype.wrapsSomeTypeParameter = function (typeParameterArgumentMap) {
            var signature = this;
            if (signature.inWrapCheck) {
                return false;
            }
            signature.inWrapCheck = true;
            var wrapsSomeTypeParameter = false;
            if (signature.returnType && signature.returnType.wrapsSomeTypeParameter(typeParameterArgumentMap)) {
                wrapsSomeTypeParameter = true;
            }
            if (!wrapsSomeTypeParameter) {
                var parameters = signature.parameters;
                for (var i = 0; i < parameters.length; i++) {
                    if (!parameters[i].type) {
                        parameters[i]._resolveDeclaredSymbol();
                    }
                    if (parameters[i].type.wrapsSomeTypeParameter(typeParameterArgumentMap)) {
                        wrapsSomeTypeParameter = true;
                        break;
                    }
                }
            }
            signature.inWrapCheck = false;
            return wrapsSomeTypeParameter;
        };
        PullSignatureSymbol.prototype.wrapsSomeNestedTypeIntoInfiniteExpansion = function (typeBeingWrapped, isCheckingTypeArgumentList, knownWrapMap) {
            if (this.inWrapCheck) {
                return isCheckingTypeArgumentList;
            }
            if (knownWrapMap.valueAt(this.pullSymbolID, typeBeingWrapped.pullSymbolID) != undefined) {
                return knownWrapMap.valueAt(this.pullSymbolID, typeBeingWrapped.pullSymbolID);
            }
            knownWrapMap.setValueAt(this.pullSymbolID, typeBeingWrapped.pullSymbolID, isCheckingTypeArgumentList);
            this.inWrapCheck = true;
            var wrapsSomeWrappedTypeParameter = false;
            if (this.returnType && this.returnType._wrapsSomeNestedTypeIntoInfiniteExpansionRecurse(typeBeingWrapped, isCheckingTypeArgumentList, knownWrapMap)) {
                wrapsSomeWrappedTypeParameter = true;
            }
            if (!wrapsSomeWrappedTypeParameter) {
                var parameters = this.parameters;
                for (var i = 0; i < parameters.length; i++) {
                    if (parameters[i].type && parameters[i].type._wrapsSomeNestedTypeIntoInfiniteExpansionRecurse(typeBeingWrapped, isCheckingTypeArgumentList, knownWrapMap)) {
                        wrapsSomeWrappedTypeParameter = true;
                        break;
                    }
                }
            }
            knownWrapMap.setValueAt(this.pullSymbolID, typeBeingWrapped.pullSymbolID, wrapsSomeWrappedTypeParameter);
            this.inWrapCheck = false;
            return wrapsSomeWrappedTypeParameter;
        };
        return PullSignatureSymbol;
    }(PullSymbol));
    TypeScript.PullSignatureSymbol = PullSignatureSymbol;
    var PullTypeSymbol = (function (_super) {
        __extends(PullTypeSymbol, _super);
        function PullTypeSymbol(name, kind) {
            var _this = _super.call(this, name, kind) || this;
            _this._members = [];
            _this._enclosedMemberTypes = null;
            _this._enclosedMemberContainers = null;
            _this._typeParameters = null;
            _this._specializedVersionsOfThisType = null;
            _this._arrayVersionOfThisType = null;
            _this._implementedTypes = null;
            _this._extendedTypes = null;
            _this._typesThatExplicitlyImplementThisType = null;
            _this._typesThatExtendThisType = null;
            _this._callSignatures = null;
            _this._allCallSignatures = null;
            _this._constructSignatures = null;
            _this._indexSignatures = null;
            _this._allIndexSignatures = null;
            _this._memberNameCache = null;
            _this._enclosedTypeNameCache = null;
            _this._enclosedContainerCache = null;
            _this._typeParameterNameCache = null;
            _this._containedNonMemberNameCache = null;
            _this._containedNonMemberTypeNameCache = null;
            _this._containedNonMemberContainerCache = null;
            _this._simpleInstantiationCache = null;
            _this._complexInstantiationCache = null;
            _this._hasGenericSignature = false;
            _this._hasGenericMember = false;
            _this._hasBaseTypeConflict = false;
            _this._knownBaseTypeCount = 0;
            _this._associatedContainerTypeSymbol = null;
            _this._constructorMethod = null;
            _this._hasDefaultConstructor = false;
            _this._functionSymbol = null;
            _this._inMemberTypeNameEx = false;
            _this.inSymbolPrivacyCheck = false;
            _this.inWrapCheck = false;
            _this.typeReference = null;
            _this._isArrayNamedTypeReference = undefined;
            _this.type = _this;
            return _this;
        }
        PullTypeSymbol.prototype.isArrayNamedTypeReference = function () {
            if (this._isArrayNamedTypeReference === undefined) {
                this._isArrayNamedTypeReference = this.computeIsArrayNamedTypeReference();
            }
            return this._isArrayNamedTypeReference;
        };
        PullTypeSymbol.prototype.computeIsArrayNamedTypeReference = function () {
            var typeArgs = this.getTypeArguments();
            if (typeArgs && this.getTypeArguments().length === 1 &&
                this.name === "Array") {
                var container = this.getContainer();
                var declaration = this.getDeclarations()[0];
                if (declaration &&
                    declaration.getParentDecl() &&
                    declaration.getParentDecl().getParentDecl() === null) {
                    return true;
                }
            }
            return false;
        };
        PullTypeSymbol.prototype.isType = function () { return true; };
        PullTypeSymbol.prototype.isClass = function () {
            return this.kind == TypeScript.PullElementKind.Class || (this._constructorMethod != null);
        };
        PullTypeSymbol.prototype.isFunction = function () { return (this.kind & (TypeScript.PullElementKind.ConstructorType | TypeScript.PullElementKind.FunctionType)) != 0; };
        PullTypeSymbol.prototype.isConstructor = function () { return this.kind == TypeScript.PullElementKind.ConstructorType; };
        PullTypeSymbol.prototype.isTypeParameter = function () { return false; };
        PullTypeSymbol.prototype.isTypeVariable = function () { return false; };
        PullTypeSymbol.prototype.isError = function () { return false; };
        PullTypeSymbol.prototype.isEnum = function () { return this.kind == TypeScript.PullElementKind.Enum; };
        PullTypeSymbol.prototype.getTypeParameterArgumentMap = function () {
            return null;
        };
        PullTypeSymbol.prototype.isObject = function () {
            return TypeScript.hasFlag(this.kind, TypeScript.PullElementKind.Class | TypeScript.PullElementKind.ConstructorType | TypeScript.PullElementKind.Enum | TypeScript.PullElementKind.FunctionType | TypeScript.PullElementKind.Interface | TypeScript.PullElementKind.ObjectType);
        };
        PullTypeSymbol.prototype.getKnownBaseTypeCount = function () { return this._knownBaseTypeCount; };
        PullTypeSymbol.prototype.resetKnownBaseTypeCount = function () { this._knownBaseTypeCount = 0; };
        PullTypeSymbol.prototype.incrementKnownBaseCount = function () { this._knownBaseTypeCount++; };
        PullTypeSymbol.prototype.setHasBaseTypeConflict = function () {
            this._hasBaseTypeConflict = true;
        };
        PullTypeSymbol.prototype.hasBaseTypeConflict = function () {
            return this._hasBaseTypeConflict;
        };
        PullTypeSymbol.prototype.hasMembers = function () {
            if (this._members && this._members.length !== 0) {
                return true;
            }
            var parents = this.getExtendedTypes();
            for (var i = 0; i < parents.length; i++) {
                if (parents[i].hasMembers()) {
                    return true;
                }
            }
            return false;
        };
        PullTypeSymbol.prototype.setHasGenericSignature = function () { this._hasGenericSignature = true; };
        PullTypeSymbol.prototype.getHasGenericSignature = function () { return this._hasGenericSignature; };
        PullTypeSymbol.prototype.setHasGenericMember = function () { this._hasGenericMember = true; };
        PullTypeSymbol.prototype.getHasGenericMember = function () { return this._hasGenericMember; };
        PullTypeSymbol.prototype.setAssociatedContainerType = function (type) {
            this._associatedContainerTypeSymbol = type;
        };
        PullTypeSymbol.prototype.getAssociatedContainerType = function () {
            return this._associatedContainerTypeSymbol;
        };
        PullTypeSymbol.prototype.getArrayType = function () { return this._arrayVersionOfThisType; };
        PullTypeSymbol.prototype.getElementType = function () {
            return null;
        };
        PullTypeSymbol.prototype.setArrayType = function (arrayType) {
            this._arrayVersionOfThisType = arrayType;
        };
        PullTypeSymbol.prototype.getFunctionSymbol = function () {
            return this._functionSymbol;
        };
        PullTypeSymbol.prototype.setFunctionSymbol = function (symbol) {
            if (symbol) {
                this._functionSymbol = symbol;
            }
        };
        PullTypeSymbol.prototype.findContainedNonMember = function (name) {
            if (!this._containedNonMemberNameCache) {
                return null;
            }
            return this._containedNonMemberNameCache[name];
        };
        PullTypeSymbol.prototype.findContainedNonMemberType = function (typeName, kind) {
            if (kind === void 0) { kind = TypeScript.PullElementKind.None; }
            if (!this._containedNonMemberTypeNameCache) {
                return null;
            }
            var nonMemberSymbol = this._containedNonMemberTypeNameCache[typeName];
            if (nonMemberSymbol && kind != TypeScript.PullElementKind.None) {
                nonMemberSymbol = ((nonMemberSymbol.kind & kind) != 0) ? nonMemberSymbol : null;
            }
            return nonMemberSymbol;
        };
        PullTypeSymbol.prototype.findContainedNonMemberContainer = function (containerName, kind) {
            if (kind === void 0) { kind = TypeScript.PullElementKind.None; }
            if (!this._containedNonMemberContainerCache) {
                return null;
            }
            var nonMemberSymbol = this._containedNonMemberContainerCache[containerName];
            if (nonMemberSymbol && kind != TypeScript.PullElementKind.None) {
                nonMemberSymbol = ((nonMemberSymbol.kind & kind) != 0) ? nonMemberSymbol : null;
            }
            return nonMemberSymbol;
        };
        PullTypeSymbol.prototype.addMember = function (memberSymbol) {
            if (!memberSymbol) {
                return;
            }
            memberSymbol.setContainer(this);
            if (!this._memberNameCache) {
                this._memberNameCache = TypeScript.createIntrinsicsObject();
            }
            if (this._members === TypeScript.sentinelEmptyArray) {
                this._members = [];
            }
            this._members.push(memberSymbol);
            this._memberNameCache[memberSymbol.name] = memberSymbol;
        };
        PullTypeSymbol.prototype.addEnclosedMemberType = function (enclosedType) {
            if (!enclosedType) {
                return;
            }
            enclosedType.setContainer(this);
            if (!this._enclosedTypeNameCache) {
                this._enclosedTypeNameCache = TypeScript.createIntrinsicsObject();
            }
            if (!this._enclosedMemberTypes) {
                this._enclosedMemberTypes = [];
            }
            this._enclosedMemberTypes[this._enclosedMemberTypes.length] = enclosedType;
            this._enclosedTypeNameCache[enclosedType.name] = enclosedType;
        };
        PullTypeSymbol.prototype.addEnclosedMemberContainer = function (enclosedContainer) {
            if (!enclosedContainer) {
                return;
            }
            enclosedContainer.setContainer(this);
            if (!this._enclosedContainerCache) {
                this._enclosedContainerCache = TypeScript.createIntrinsicsObject();
            }
            if (!this._enclosedMemberContainers) {
                this._enclosedMemberContainers = [];
            }
            this._enclosedMemberContainers[this._enclosedMemberContainers.length] = enclosedContainer;
            this._enclosedContainerCache[enclosedContainer.name] = enclosedContainer;
        };
        PullTypeSymbol.prototype.addEnclosedNonMember = function (enclosedNonMember) {
            if (!enclosedNonMember) {
                return;
            }
            enclosedNonMember.setContainer(this);
            if (!this._containedNonMemberNameCache) {
                this._containedNonMemberNameCache = TypeScript.createIntrinsicsObject();
            }
            this._containedNonMemberNameCache[enclosedNonMember.name] = enclosedNonMember;
        };
        PullTypeSymbol.prototype.addEnclosedNonMemberType = function (enclosedNonMemberType) {
            if (!enclosedNonMemberType) {
                return;
            }
            enclosedNonMemberType.setContainer(this);
            if (!this._containedNonMemberTypeNameCache) {
                this._containedNonMemberTypeNameCache = TypeScript.createIntrinsicsObject();
            }
            this._containedNonMemberTypeNameCache[enclosedNonMemberType.name] = enclosedNonMemberType;
        };
        PullTypeSymbol.prototype.addEnclosedNonMemberContainer = function (enclosedNonMemberContainer) {
            if (!enclosedNonMemberContainer) {
                return;
            }
            enclosedNonMemberContainer.setContainer(this);
            if (!this._containedNonMemberContainerCache) {
                this._containedNonMemberContainerCache = TypeScript.createIntrinsicsObject();
            }
            this._containedNonMemberContainerCache[enclosedNonMemberContainer.name] = enclosedNonMemberContainer;
        };
        PullTypeSymbol.prototype.addTypeParameter = function (typeParameter) {
            if (!typeParameter) {
                return;
            }
            if (!typeParameter.getContainer()) {
                typeParameter.setContainer(this);
            }
            if (!this._typeParameterNameCache) {
                this._typeParameterNameCache = TypeScript.createIntrinsicsObject();
            }
            if (!this._typeParameters) {
                this._typeParameters = [];
            }
            this._typeParameters[this._typeParameters.length] = typeParameter;
            this._typeParameterNameCache[typeParameter.getName()] = typeParameter;
        };
        PullTypeSymbol.prototype.addConstructorTypeParameter = function (typeParameter) {
            this.addTypeParameter(typeParameter);
            var constructSignatures = this.getConstructSignatures();
            for (var i = 0; i < constructSignatures.length; i++) {
                constructSignatures[i].addTypeParameter(typeParameter);
            }
        };
        PullTypeSymbol.prototype.getMembers = function () {
            return this._members;
        };
        PullTypeSymbol.prototype.setHasDefaultConstructor = function (hasOne) {
            if (hasOne === void 0) { hasOne = true; }
            this._hasDefaultConstructor = hasOne;
        };
        PullTypeSymbol.prototype.getHasDefaultConstructor = function () {
            return this._hasDefaultConstructor;
        };
        PullTypeSymbol.prototype.getConstructorMethod = function () {
            return this._constructorMethod;
        };
        PullTypeSymbol.prototype.setConstructorMethod = function (constructorMethod) {
            this._constructorMethod = constructorMethod;
        };
        PullTypeSymbol.prototype.getTypeParameters = function () {
            if (!this._typeParameters) {
                return [];
            }
            return this._typeParameters;
        };
        PullTypeSymbol.prototype.isGeneric = function () {
            return (this._typeParameters && this._typeParameters.length > 0) ||
                this._hasGenericSignature ||
                this._hasGenericMember ||
                this.isArrayNamedTypeReference();
        };
        PullTypeSymbol.prototype.canUseSimpleInstantiationCache = function (substitutingTypes) {
            return substitutingTypes.length === 1 && substitutingTypes[0].kind !== TypeScript.PullElementKind.ObjectType;
        };
        PullTypeSymbol.prototype.addSpecialization = function (specializedVersionOfThisType, substitutingTypes) {
            if (!substitutingTypes || !substitutingTypes.length) {
                return;
            }
            if (this.canUseSimpleInstantiationCache(substitutingTypes)) {
                if (!this._simpleInstantiationCache) {
                    this._simpleInstantiationCache = [];
                }
                this._simpleInstantiationCache[substitutingTypes[0].pullSymbolID] = specializedVersionOfThisType;
            }
            else {
                if (!this._complexInstantiationCache) {
                    this._complexInstantiationCache = TypeScript.createIntrinsicsObject();
                }
                this._complexInstantiationCache[getIDForTypeSubstitutions(substitutingTypes)] = specializedVersionOfThisType;
            }
            if (!this._specializedVersionsOfThisType) {
                this._specializedVersionsOfThisType = [];
            }
            this._specializedVersionsOfThisType.push(specializedVersionOfThisType);
        };
        PullTypeSymbol.prototype.getSpecialization = function (substitutingTypes) {
            if (!substitutingTypes || !substitutingTypes.length) {
                return null;
            }
            if (this.canUseSimpleInstantiationCache(substitutingTypes)) {
                if (!this._simpleInstantiationCache) {
                    return null;
                }
                var result = this._simpleInstantiationCache[substitutingTypes[0].pullSymbolID];
                return result ? result : null;
            }
            else {
                if (!this._complexInstantiationCache) {
                    return null;
                }
                var result = this._complexInstantiationCache[getIDForTypeSubstitutions(substitutingTypes)];
                return result ? result : null;
            }
        };
        PullTypeSymbol.prototype.getKnownSpecializations = function () {
            if (!this._specializedVersionsOfThisType) {
                return [];
            }
            return this._specializedVersionsOfThisType;
        };
        PullTypeSymbol.prototype.getTypeArguments = function () {
            return null;
        };
        PullTypeSymbol.prototype.getTypeArgumentsOrTypeParameters = function () {
            return this.getTypeParameters();
        };
        PullTypeSymbol.prototype.addCallSignature = function (callSignature) {
            if (!this._callSignatures) {
                this._callSignatures = [];
            }
            this._callSignatures[this._callSignatures.length] = callSignature;
            if (callSignature.isGeneric()) {
                this._hasGenericSignature = true;
            }
            callSignature.functionType = this;
        };
        PullTypeSymbol.prototype.addConstructSignature = function (constructSignature) {
            if (!this._constructSignatures) {
                this._constructSignatures = [];
            }
            this._constructSignatures[this._constructSignatures.length] = constructSignature;
            if (constructSignature.isGeneric()) {
                this._hasGenericSignature = true;
            }
            constructSignature.functionType = this;
        };
        PullTypeSymbol.prototype.addIndexSignature = function (indexSignature) {
            if (!this._indexSignatures) {
                this._indexSignatures = [];
            }
            this._indexSignatures[this._indexSignatures.length] = indexSignature;
            if (indexSignature.isGeneric()) {
                this._hasGenericSignature = true;
            }
            indexSignature.functionType = this;
        };
        PullTypeSymbol.prototype.addUnhiddenSignaturesFromBaseType = function (derivedTypeSignatures, baseTypeSignatures, signaturesBeingAggregated) {
            if (!derivedTypeSignatures) {
                RT.applyVariadic(signaturesBeingAggregated, "push", baseTypeSignatures);
                return;
            }
            var resolver = this._getResolver();
            for (var i = 0; i < baseTypeSignatures.length; i++) {
                var baseSignature = baseTypeSignatures[i];
                var signatureIsHidden = TypeScript.ArrayUtilities.any(derivedTypeSignatures, function (sig) {
                    return resolver.signaturesAreIdentical(baseSignature, sig, false);
                });
                if (!signatureIsHidden) {
                    signaturesBeingAggregated.push(baseSignature);
                }
            }
        };
        PullTypeSymbol.prototype.hasOwnCallSignatures = function () {
            return this._callSignatures !== null;
        };
        PullTypeSymbol.prototype.getCallSignatures = function () {
            if (this._allCallSignatures) {
                return this._allCallSignatures;
            }
            var signatures = [];
            if (this._callSignatures) {
                signatures = signatures.concat(this._callSignatures);
            }
            if (this._extendedTypes && this.kind === TypeScript.PullElementKind.Interface) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }
                    this.addUnhiddenSignaturesFromBaseType(this._callSignatures, this._extendedTypes[i].getCallSignatures(), signatures);
                }
            }
            this._allCallSignatures = signatures;
            return signatures;
        };
        PullTypeSymbol.prototype.hasOwnConstructSignatures = function () {
            return this._constructSignatures !== null;
        };
        PullTypeSymbol.prototype.getConstructSignatures = function () {
            var signatures = [];
            if (this._constructSignatures) {
                signatures = signatures.concat(this._constructSignatures);
            }
            if (this._extendedTypes && this.kind === TypeScript.PullElementKind.Interface) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }
                    this.addUnhiddenSignaturesFromBaseType(this._constructSignatures, this._extendedTypes[i].getConstructSignatures(), signatures);
                }
            }
            return signatures;
        };
        PullTypeSymbol.prototype.hasOwnIndexSignatures = function () {
            return this._indexSignatures !== null;
        };
        PullTypeSymbol.prototype.getOwnIndexSignatures = function () {
            return this._indexSignatures || [];
        };
        PullTypeSymbol.prototype.getIndexSignatures = function () {
            if (this._allIndexSignatures) {
                return this._allIndexSignatures;
            }
            var signatures = [];
            if (this._indexSignatures) {
                signatures = signatures.concat(this._indexSignatures);
            }
            if (this._extendedTypes) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }
                    this.addUnhiddenSignaturesFromBaseType(this._indexSignatures, this._extendedTypes[i].getIndexSignatures(), signatures);
                }
            }
            this._allIndexSignatures = signatures;
            return signatures;
        };
        PullTypeSymbol.prototype.addImplementedType = function (implementedType) {
            if (!implementedType) {
                return;
            }
            if (!this._implementedTypes) {
                this._implementedTypes = [];
            }
            this._implementedTypes[this._implementedTypes.length] = implementedType;
            implementedType.addTypeThatExplicitlyImplementsThisType(this);
        };
        PullTypeSymbol.prototype.getImplementedTypes = function () {
            if (!this._implementedTypes) {
                return [];
            }
            return this._implementedTypes;
        };
        PullTypeSymbol.prototype.addExtendedType = function (extendedType) {
            if (!extendedType) {
                return;
            }
            if (!this._extendedTypes) {
                this._extendedTypes = [];
            }
            this._extendedTypes[this._extendedTypes.length] = extendedType;
            extendedType.addTypeThatExtendsThisType(this);
        };
        PullTypeSymbol.prototype.getExtendedTypes = function () {
            if (!this._extendedTypes) {
                return [];
            }
            return this._extendedTypes;
        };
        PullTypeSymbol.prototype.addTypeThatExtendsThisType = function (type) {
            if (!type) {
                return;
            }
            if (!this._typesThatExtendThisType) {
                this._typesThatExtendThisType = [];
            }
            this._typesThatExtendThisType[this._typesThatExtendThisType.length] = type;
        };
        PullTypeSymbol.prototype.getTypesThatExtendThisType = function () {
            if (!this._typesThatExtendThisType) {
                this._typesThatExtendThisType = [];
            }
            return this._typesThatExtendThisType;
        };
        PullTypeSymbol.prototype.addTypeThatExplicitlyImplementsThisType = function (type) {
            if (!type) {
                return;
            }
            if (!this._typesThatExplicitlyImplementThisType) {
                this._typesThatExplicitlyImplementThisType = [];
            }
            this._typesThatExplicitlyImplementThisType[this._typesThatExplicitlyImplementThisType.length] = type;
        };
        PullTypeSymbol.prototype.getTypesThatExplicitlyImplementThisType = function () {
            if (!this._typesThatExplicitlyImplementThisType) {
                this._typesThatExplicitlyImplementThisType = [];
            }
            return this._typesThatExplicitlyImplementThisType;
        };
        PullTypeSymbol.prototype.hasBase = function (potentialBase, visited) {
            if (visited === void 0) { visited = []; }
            if (this === potentialBase || this.getRootSymbol() === potentialBase || this === potentialBase.getRootSymbol()) {
                return true;
            }
            if (TypeScript.ArrayUtilities.contains(visited, this)) {
                return true;
            }
            visited.push(this);
            var extendedTypes = this.getExtendedTypes();
            for (var i = 0; i < extendedTypes.length; i++) {
                if (extendedTypes[i].hasBase(potentialBase, visited)) {
                    return true;
                }
            }
            var implementedTypes = this.getImplementedTypes();
            for (var i = 0; i < implementedTypes.length; i++) {
                if (implementedTypes[i].hasBase(potentialBase, visited)) {
                    return true;
                }
            }
            visited.pop();
            return false;
        };
        PullTypeSymbol.prototype.isValidBaseKind = function (baseType, isExtendedType) {
            if (baseType.isError()) {
                return false;
            }
            var thisIsClass = this.isClass();
            if (isExtendedType) {
                if (thisIsClass) {
                    return baseType.kind === TypeScript.PullElementKind.Class;
                }
            }
            else {
                if (!thisIsClass) {
                    return false;
                }
            }
            return !!(baseType.kind & (TypeScript.PullElementKind.Interface | TypeScript.PullElementKind.Class));
        };
        PullTypeSymbol.prototype.findMember = function (name, lookInParent) {
            var memberSymbol = null;
            if (this._memberNameCache) {
                memberSymbol = this._memberNameCache[name];
            }
            if (memberSymbol || !lookInParent) {
                return memberSymbol;
            }
            if (this._extendedTypes) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    memberSymbol = this._extendedTypes[i].findMember(name, lookInParent);
                    if (memberSymbol) {
                        return memberSymbol;
                    }
                }
            }
            return null;
        };
        PullTypeSymbol.prototype.findNestedType = function (name, kind) {
            if (kind === void 0) { kind = TypeScript.PullElementKind.None; }
            var memberSymbol;
            if (!this._enclosedTypeNameCache) {
                return null;
            }
            memberSymbol = this._enclosedTypeNameCache[name];
            if (memberSymbol && kind != TypeScript.PullElementKind.None) {
                memberSymbol = ((memberSymbol.kind & kind) != 0) ? memberSymbol : null;
            }
            return memberSymbol;
        };
        PullTypeSymbol.prototype.findNestedContainer = function (name, kind) {
            if (kind === void 0) { kind = TypeScript.PullElementKind.None; }
            var memberSymbol;
            if (!this._enclosedContainerCache) {
                return null;
            }
            memberSymbol = this._enclosedContainerCache[name];
            if (memberSymbol && kind != TypeScript.PullElementKind.None) {
                memberSymbol = ((memberSymbol.kind & kind) != 0) ? memberSymbol : null;
            }
            return memberSymbol;
        };
        PullTypeSymbol.prototype.getAllMembers = function (searchDeclKind, memberVisiblity) {
            var allMembers = [];
            if (this._members.length !== 0) {
                for (var i = 0, n = this._members.length; i < n; i++) {
                    var member = this._members[i];
                    if ((member.kind & searchDeclKind) && (memberVisiblity !== GetAllMembersVisiblity.externallyVisible || !member.anyDeclHasFlag(TypeScript.PullElementFlags.Private))) {
                        allMembers[allMembers.length] = member;
                    }
                }
            }
            if (this._extendedTypes) {
                var extenedMembersVisibility = memberVisiblity !== GetAllMembersVisiblity.all ? GetAllMembersVisiblity.externallyVisible : GetAllMembersVisiblity.all;
                for (var i = 0, n = this._extendedTypes.length; i < n; i++) {
                    var extendedMembers = this._extendedTypes[i].getAllMembers(searchDeclKind, extenedMembersVisibility);
                    for (var j = 0, m = extendedMembers.length; j < m; j++) {
                        var extendedMember = extendedMembers[j];
                        if (!(this._memberNameCache && this._memberNameCache[extendedMember.name])) {
                            allMembers[allMembers.length] = extendedMember;
                        }
                    }
                }
            }
            if (this.isContainer()) {
                if (this._enclosedMemberTypes) {
                    for (var i = 0; i < this._enclosedMemberTypes.length; i++) {
                        allMembers[allMembers.length] = this._enclosedMemberTypes[i];
                    }
                }
                if (this._enclosedMemberContainers) {
                    for (var i = 0; i < this._enclosedMemberContainers.length; i++) {
                        allMembers[allMembers.length] = this._enclosedMemberContainers[i];
                    }
                }
            }
            return allMembers;
        };
        PullTypeSymbol.prototype.findTypeParameter = function (name) {
            if (!this._typeParameterNameCache) {
                return null;
            }
            return this._typeParameterNameCache[name];
        };
        PullTypeSymbol.prototype.setResolved = function () {
            _super.prototype.setResolved.call(this);
        };
        PullTypeSymbol.prototype.getNamePartForFullName = function () {
            var name = _super.prototype.getNamePartForFullName.call(this);
            var typars = this.getTypeArgumentsOrTypeParameters();
            var typarString = PullSymbol.getTypeParameterString(typars, this, true);
            return name + typarString;
        };
        PullTypeSymbol.prototype.getScopedName = function (scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName) {
            return this.getScopedNameEx(scopeSymbol, skipTypeParametersInName, useConstraintInName, false, false, skipInternalAliasName).toString();
        };
        PullTypeSymbol.prototype.isNamedTypeSymbol = function () {
            var kind = this.kind;
            if (kind === TypeScript.PullElementKind.Primitive ||
                kind === TypeScript.PullElementKind.Class ||
                kind === TypeScript.PullElementKind.Container ||
                kind === TypeScript.PullElementKind.DynamicModule ||
                kind === TypeScript.PullElementKind.TypeAlias ||
                kind === TypeScript.PullElementKind.Enum ||
                kind === TypeScript.PullElementKind.TypeParameter ||
                ((kind === TypeScript.PullElementKind.Interface || kind === TypeScript.PullElementKind.ObjectType) && this.name != "")) {
                return true;
            }
            return false;
        };
        PullTypeSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            var s = this.getScopedNameEx(scopeSymbol, false, useConstraintInName).toString();
            return s;
        };
        PullTypeSymbol.prototype.getScopedNameEx = function (scopeSymbol, skipTypeParametersInName, useConstraintInName, getPrettyTypeName, getTypeParamMarkerInfo, skipInternalAliasName) {
            if (this.isArrayNamedTypeReference()) {
                var elementType = this.getElementType();
                var elementMemberName = elementType ?
                    (elementType.isArrayNamedTypeReference() || elementType.isNamedTypeSymbol() ?
                        elementType.getScopedNameEx(scopeSymbol, false, false, getPrettyTypeName, getTypeParamMarkerInfo, skipInternalAliasName) :
                        elementType.getMemberTypeNameEx(false, scopeSymbol, getPrettyTypeName)) :
                    TypeScript.MemberName.create("any");
                return TypeScript.MemberName.create(elementMemberName, "", "[]");
            }
            if (!this.isNamedTypeSymbol()) {
                return this.getMemberTypeNameEx(true, scopeSymbol, getPrettyTypeName);
            }
            if (skipTypeParametersInName) {
                return TypeScript.MemberName.create(_super.prototype.getScopedName.call(this, scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName));
            }
            else {
                var builder = new TypeScript.MemberNameArray();
                builder.prefix = _super.prototype.getScopedName.call(this, scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName);
                var typars = this.getTypeArgumentsOrTypeParameters();
                builder.add(PullSymbol.getTypeParameterStringEx(typars, scopeSymbol, getTypeParamMarkerInfo, useConstraintInName));
                return builder;
            }
        };
        PullTypeSymbol.prototype.hasOnlyOverloadCallSignatures = function () {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            return members.length === 0 && constructSignatures.length === 0 && callSignatures.length > 1;
        };
        PullTypeSymbol.prototype.getTypeOfSymbol = function () {
            var associatedContainerType = this.getAssociatedContainerType();
            if (associatedContainerType && associatedContainerType.isNamedTypeSymbol()) {
                return associatedContainerType;
            }
            var functionSymbol = this.getFunctionSymbol();
            if (functionSymbol && functionSymbol.kind == TypeScript.PullElementKind.Function && !TypeScript.PullHelpers.isSymbolLocal(functionSymbol)) {
                return functionSymbol;
            }
            return null;
        };
        PullTypeSymbol.prototype.getMemberTypeNameEx = function (topLevel, scopeSymbol, getPrettyTypeName) {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            var indexSignatures = this.getIndexSignatures();
            if (members.length > 0 || callSignatures.length > 0 || constructSignatures.length > 0 || indexSignatures.length > 0) {
                var typeOfSymbol = this.getTypeOfSymbol();
                if (typeOfSymbol) {
                    var nameForTypeOf = typeOfSymbol.getScopedNameEx(scopeSymbol, true);
                    return TypeScript.MemberName.create(nameForTypeOf, "typeof ", "");
                }
                if (this._inMemberTypeNameEx) {
                    return TypeScript.MemberName.create("any");
                }
                this._inMemberTypeNameEx = true;
                var allMemberNames = new TypeScript.MemberNameArray();
                var curlies = !topLevel || indexSignatures.length != 0;
                var delim = "; ";
                for (var i = 0; i < members.length; i++) {
                    if (members[i].kind == TypeScript.PullElementKind.Method && members[i].type.hasOnlyOverloadCallSignatures()) {
                        var methodCallSignatures = members[i].type.getCallSignatures();
                        var nameStr = members[i].getDisplayName(scopeSymbol) + (members[i].isOptional ? "?" : "");
                        ;
                        var methodMemberNames = PullSignatureSymbol.getSignaturesTypeNameEx(methodCallSignatures, nameStr, false, false, scopeSymbol);
                        allMemberNames.addAll(methodMemberNames);
                    }
                    else {
                        var memberTypeName = members[i].getNameAndTypeNameEx(scopeSymbol);
                        if (memberTypeName.isArray() && memberTypeName.delim === delim) {
                            allMemberNames.addAll(memberTypeName.entries);
                        }
                        else {
                            allMemberNames.add(memberTypeName);
                        }
                    }
                    curlies = true;
                }
                var getPrettyFunctionOverload = getPrettyTypeName && !curlies && this.hasOnlyOverloadCallSignatures();
                var signatureCount = callSignatures.length + constructSignatures.length + indexSignatures.length;
                var useShortFormSignature = !curlies && (signatureCount === 1);
                var signatureMemberName;
                if (callSignatures.length > 0) {
                    signatureMemberName =
                        PullSignatureSymbol.getSignaturesTypeNameEx(callSignatures, "", useShortFormSignature, false, scopeSymbol, getPrettyFunctionOverload);
                    allMemberNames.addAll(signatureMemberName);
                }
                if (constructSignatures.length > 0) {
                    signatureMemberName =
                        PullSignatureSymbol.getSignaturesTypeNameEx(constructSignatures, "new", useShortFormSignature, false, scopeSymbol);
                    allMemberNames.addAll(signatureMemberName);
                }
                if (indexSignatures.length > 0) {
                    signatureMemberName =
                        PullSignatureSymbol.getSignaturesTypeNameEx(indexSignatures, "", useShortFormSignature, true, scopeSymbol);
                    allMemberNames.addAll(signatureMemberName);
                }
                if ((curlies) || (!getPrettyFunctionOverload && (signatureCount > 1) && topLevel)) {
                    allMemberNames.prefix = "{ ";
                    allMemberNames.suffix = "}";
                    allMemberNames.delim = delim;
                }
                else if (allMemberNames.entries.length > 1) {
                    allMemberNames.delim = delim;
                }
                this._inMemberTypeNameEx = false;
                return allMemberNames;
            }
            return TypeScript.MemberName.create("{}");
        };
        PullTypeSymbol.prototype.getGenerativeTypeClassification = function (enclosingType) {
            return TypeScript.GenerativeTypeClassification.Closed;
        };
        PullTypeSymbol.prototype.wrapsSomeTypeParameter = function (typeParameterArgumentMap) {
            var type = this;
            var wrapsSomeTypeParameter = false;
            if (type.isTypeParameter()) {
                if (typeParameterArgumentMap[type.pullSymbolID]) {
                    return true;
                }
                var constraint = type.getConstraint();
                if (constraint && constraint.wrapsSomeTypeParameter(typeParameterArgumentMap)) {
                    return true;
                }
                return false;
            }
            if (type.inWrapCheck) {
                return wrapsSomeTypeParameter;
            }
            type.inWrapCheck = true;
            if (!wrapsSomeTypeParameter) {
                var typeArguments = type.getTypeArguments();
                if (type.isGeneric() && !typeArguments) {
                    typeArguments = type.getTypeParameters();
                }
                if (typeArguments) {
                    for (var i = 0; i < typeArguments.length; i++) {
                        if (typeArguments[i].wrapsSomeTypeParameter(typeParameterArgumentMap)) {
                            wrapsSomeTypeParameter = true;
                            break;
                        }
                    }
                }
            }
            if (!(type.kind & TypeScript.PullElementKind.SomeInstantiatableType) || !type.name) {
                if (!wrapsSomeTypeParameter) {
                    var members = type.getAllMembers(TypeScript.PullElementKind.SomeValue, GetAllMembersVisiblity.all);
                    for (var i = 0; i < members.length; i++) {
                        if (members[i].type.wrapsSomeTypeParameter(typeParameterArgumentMap)) {
                            wrapsSomeTypeParameter = true;
                            break;
                        }
                    }
                }
                var sigs;
                if (!wrapsSomeTypeParameter) {
                    sigs = type.getCallSignatures();
                    for (var i = 0; i < sigs.length; i++) {
                        if (sigs[i].wrapsSomeTypeParameter(typeParameterArgumentMap)) {
                            wrapsSomeTypeParameter = true;
                            break;
                        }
                    }
                }
                if (!wrapsSomeTypeParameter) {
                    sigs = type.getConstructSignatures();
                    for (var i = 0; i < sigs.length; i++) {
                        if (sigs[i].wrapsSomeTypeParameter(typeParameterArgumentMap)) {
                            wrapsSomeTypeParameter = true;
                            break;
                        }
                    }
                }
                if (!wrapsSomeTypeParameter) {
                    sigs = type.getIndexSignatures();
                    for (var i = 0; i < sigs.length; i++) {
                        if (sigs[i].wrapsSomeTypeParameter(typeParameterArgumentMap)) {
                            wrapsSomeTypeParameter = true;
                            break;
                        }
                    }
                }
            }
            type.inWrapCheck = false;
            return wrapsSomeTypeParameter;
        };
        PullTypeSymbol.prototype.wrapsSomeNestedTypeIntoInfiniteExpansion = function (typeBeingWrapped) {
            if (!this.isArrayNamedTypeReference() && this.isNamedTypeSymbol()) {
                var knownWrapMap = TypeScript.BitMatrix.getBitMatrix(true);
                var result = this._wrapsSomeNestedTypeIntoInfiniteExpansionRecurse(typeBeingWrapped, false, knownWrapMap);
                knownWrapMap.release();
                return result;
            }
            return false;
        };
        PullTypeSymbol.prototype.isTypeEquivalentToRootSymbol = function () {
            if (this.isTypeReference()) {
                if (this.getIsSpecialized()) {
                    var typeArguments = this.getTypeArguments();
                    var rootTypeArguments = this.getRootSymbol().getTypeArguments();
                    if (typeArguments) {
                        for (var i = 0; i < typeArguments.length; i++) {
                            if (!typeArguments[i].isTypeParameter() &&
                                !(rootTypeArguments && rootTypeArguments[i] == typeArguments[i].getRootSymbol())) {
                                return false;
                            }
                        }
                        return true;
                    }
                    return false;
                }
                else {
                    return true;
                }
            }
            return false;
        };
        PullTypeSymbol.prototype.isTypeBeingWrapped = function (typeBeingWrapped) {
            if (this.inWrapCheck || this == typeBeingWrapped) {
                return true;
            }
            if (typeBeingWrapped.isTypeEquivalentToRootSymbol()) {
                return this.isTypeBeingWrapped(typeBeingWrapped.getRootSymbol());
            }
            return false;
        };
        PullTypeSymbol.prototype.anyRootTypeBeingWrapped = function (typeBeingWrapped) {
            var prevRootType = this;
            var rootType = this.getRootSymbol();
            while (rootType != prevRootType) {
                if (rootType.isTypeBeingWrapped(typeBeingWrapped)) {
                    return true;
                }
                prevRootType = rootType;
                rootType = rootType.getRootSymbol();
            }
            return false;
        };
        PullTypeSymbol.prototype._wrapsSomeNestedTypeIntoInfiniteExpansionRecurse = function (typeBeingWrapped, isCheckingTypeArgumentList, knownWrapMap) {
            if (this.isArrayNamedTypeReference()) {
                return this.getElementType()._wrapsSomeNestedTypeIntoInfiniteExpansionRecurse(typeBeingWrapped, isCheckingTypeArgumentList, knownWrapMap);
            }
            if (this.isTypeBeingWrapped(typeBeingWrapped)) {
                return isCheckingTypeArgumentList;
            }
            if (knownWrapMap.valueAt(this.pullSymbolID, typeBeingWrapped.pullSymbolID) != undefined) {
                return knownWrapMap.valueAt(this.pullSymbolID, typeBeingWrapped.pullSymbolID);
            }
            if (this.isPrimitive() || this.isTypeParameter()) {
                return false;
            }
            this.inWrapCheck = true;
            var wrapsSomeWrappedTypeParameter = false;
            knownWrapMap.setValueAt(this.pullSymbolID, typeBeingWrapped.pullSymbolID, false);
            wrapsSomeWrappedTypeParameter = this._wrapsSomeNestedTypeIntoInfiniteExpansionWorker(typeBeingWrapped, isCheckingTypeArgumentList, knownWrapMap);
            knownWrapMap.setValueAt(this.pullSymbolID, typeBeingWrapped.pullSymbolID, wrapsSomeWrappedTypeParameter);
            this.inWrapCheck = false;
            return wrapsSomeWrappedTypeParameter;
        };
        PullTypeSymbol.prototype._wrapsSomeNestedTypeIntoInfiniteExpansionWorker = function (typeBeingWrapped, isCheckingTypeArgumentList, knownWrapMap) {
            var typeArguments = this.getTypeArguments();
            if (typeArguments) {
                for (var i = 0; i < typeArguments.length; i++) {
                    if (typeArguments[i]._wrapsSomeNestedTypeIntoInfiniteExpansionRecurse(typeBeingWrapped, true, knownWrapMap)) {
                        return true;
                    }
                }
            }
            if (this.anyRootTypeBeingWrapped(typeBeingWrapped)) {
                if (isCheckingTypeArgumentList && this.isTypeReference() && !this.getIsSpecialized()) {
                    return true;
                }
                return false;
            }
            else if (!this.isNamedTypeSymbol() || this.isGeneric()) {
                var isTypeEquivalentToRootSymbol = this.isTypeEquivalentToRootSymbol();
                var rootType = TypeScript.PullHelpers.getRootType(this);
                if (isTypeEquivalentToRootSymbol) {
                    rootType.inWrapCheck = true;
                }
                var members = this.getAllMembers(TypeScript.PullElementKind.SomeValue, GetAllMembersVisiblity.all);
                for (var i = 0; i < members.length; i++) {
                    if (members[i].type && members[i].type._wrapsSomeNestedTypeIntoInfiniteExpansionRecurse(typeBeingWrapped, isCheckingTypeArgumentList, knownWrapMap)) {
                        return true;
                    }
                }
                var sigs = this.getCallSignatures();
                for (var i = 0; i < sigs.length; i++) {
                    if (sigs[i].wrapsSomeNestedTypeIntoInfiniteExpansion(typeBeingWrapped, isCheckingTypeArgumentList, knownWrapMap)) {
                        return true;
                    }
                }
                sigs = this.getConstructSignatures();
                for (var i = 0; i < sigs.length; i++) {
                    if (sigs[i].wrapsSomeNestedTypeIntoInfiniteExpansion(typeBeingWrapped, isCheckingTypeArgumentList, knownWrapMap)) {
                        return true;
                    }
                }
                sigs = this.getIndexSignatures();
                for (var i = 0; i < sigs.length; i++) {
                    if (sigs[i].wrapsSomeNestedTypeIntoInfiniteExpansion(typeBeingWrapped, isCheckingTypeArgumentList, knownWrapMap)) {
                        return true;
                    }
                }
                if (isTypeEquivalentToRootSymbol) {
                    rootType.inWrapCheck = false;
                }
                return false;
            }
        };
        return PullTypeSymbol;
    }(PullSymbol));
    TypeScript.PullTypeSymbol = PullTypeSymbol;
    var PullPrimitiveTypeSymbol = (function (_super) {
        __extends(PullPrimitiveTypeSymbol, _super);
        function PullPrimitiveTypeSymbol(name) {
            var _this = _super.call(this, name, TypeScript.PullElementKind.Primitive) || this;
            _this.isResolved = true;
            return _this;
        }
        PullPrimitiveTypeSymbol.prototype.isAny = function () {
            return this.name === "any";
        };
        PullPrimitiveTypeSymbol.prototype.isStringConstant = function () { return false; };
        PullPrimitiveTypeSymbol.prototype.setUnresolved = function () {
        };
        return PullPrimitiveTypeSymbol;
    }(PullTypeSymbol));
    TypeScript.PullPrimitiveTypeSymbol = PullPrimitiveTypeSymbol;
    var PullStringConstantTypeSymbol = (function (_super) {
        __extends(PullStringConstantTypeSymbol, _super);
        function PullStringConstantTypeSymbol(name) {
            return _super.call(this, name) || this;
        }
        PullStringConstantTypeSymbol.prototype.isStringConstant = function () {
            return true;
        };
        return PullStringConstantTypeSymbol;
    }(PullPrimitiveTypeSymbol));
    TypeScript.PullStringConstantTypeSymbol = PullStringConstantTypeSymbol;
    var PullErrorTypeSymbol = (function (_super) {
        __extends(PullErrorTypeSymbol, _super);
        function PullErrorTypeSymbol(anyType, name) {
            var _this = _super.call(this, name) || this;
            _this.anyType = anyType;
            _this.isResolved = true;
            return _this;
        }
        PullErrorTypeSymbol.prototype.isError = function () {
            return true;
        };
        PullErrorTypeSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            return this.anyType.getName(scopeSymbol, useConstraintInName);
        };
        PullErrorTypeSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName, skipInternalAliasName) {
            return this.anyType.getName(scopeSymbol, useConstraintInName);
        };
        PullErrorTypeSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            return this.anyType.getName(scopeSymbol, useConstraintInName);
        };
        return PullErrorTypeSymbol;
    }(PullPrimitiveTypeSymbol));
    TypeScript.PullErrorTypeSymbol = PullErrorTypeSymbol;
    var PullContainerSymbol = (function (_super) {
        __extends(PullContainerSymbol, _super);
        function PullContainerSymbol(name, kind) {
            var _this = _super.call(this, name, kind) || this;
            _this.instanceSymbol = null;
            _this.assignedValue = null;
            _this.assignedType = null;
            _this.assignedContainer = null;
            return _this;
        }
        PullContainerSymbol.prototype.isContainer = function () { return true; };
        PullContainerSymbol.prototype.setInstanceSymbol = function (symbol) {
            this.instanceSymbol = symbol;
        };
        PullContainerSymbol.prototype.getInstanceSymbol = function () {
            return this.instanceSymbol;
        };
        PullContainerSymbol.prototype.setExportAssignedValueSymbol = function (symbol) {
            this.assignedValue = symbol;
        };
        PullContainerSymbol.prototype.getExportAssignedValueSymbol = function () {
            return this.assignedValue;
        };
        PullContainerSymbol.prototype.setExportAssignedTypeSymbol = function (type) {
            this.assignedType = type;
        };
        PullContainerSymbol.prototype.getExportAssignedTypeSymbol = function () {
            return this.assignedType;
        };
        PullContainerSymbol.prototype.setExportAssignedContainerSymbol = function (container) {
            this.assignedContainer = container;
        };
        PullContainerSymbol.prototype.getExportAssignedContainerSymbol = function () {
            return this.assignedContainer;
        };
        PullContainerSymbol.prototype.hasExportAssignment = function () {
            return !!this.assignedValue || !!this.assignedType || !!this.assignedContainer;
        };
        PullContainerSymbol.usedAsSymbol = function (containerSymbol, symbol) {
            if (!containerSymbol || !containerSymbol.isContainer()) {
                return false;
            }
            if (!containerSymbol.isAlias() && containerSymbol.type == symbol) {
                return true;
            }
            var moduleSymbol = containerSymbol;
            var valueExportSymbol = moduleSymbol.getExportAssignedValueSymbol();
            var typeExportSymbol = moduleSymbol.getExportAssignedTypeSymbol();
            var containerExportSymbol = moduleSymbol.getExportAssignedContainerSymbol();
            if (valueExportSymbol || typeExportSymbol || containerExportSymbol) {
                return valueExportSymbol == symbol || typeExportSymbol == symbol || containerExportSymbol == symbol || PullContainerSymbol.usedAsSymbol(containerExportSymbol, symbol);
            }
            return false;
        };
        PullContainerSymbol.prototype.getInstanceType = function () {
            return this.instanceSymbol ? this.instanceSymbol.type : null;
        };
        return PullContainerSymbol;
    }(PullTypeSymbol));
    TypeScript.PullContainerSymbol = PullContainerSymbol;
    var PullTypeAliasSymbol = (function (_super) {
        __extends(PullTypeAliasSymbol, _super);
        function PullTypeAliasSymbol(name) {
            var _this = _super.call(this, name, TypeScript.PullElementKind.TypeAlias) || this;
            _this._assignedValue = null;
            _this._assignedType = null;
            _this._assignedContainer = null;
            _this._isUsedAsValue = false;
            _this._typeUsedExternally = false;
            _this.retrievingExportAssignment = false;
            return _this;
        }
        PullTypeAliasSymbol.prototype.typeUsedExternally = function () {
            this._resolveDeclaredSymbol();
            return this._typeUsedExternally;
        };
        PullTypeAliasSymbol.prototype.isUsedAsValue = function () {
            this._resolveDeclaredSymbol();
            return this._isUsedAsValue;
        };
        PullTypeAliasSymbol.prototype.setTypeUsedExternally = function (value) {
            this._typeUsedExternally = value;
        };
        PullTypeAliasSymbol.prototype.setIsUsedAsValue = function (value) {
            this._isUsedAsValue = value;
            this._resolveDeclaredSymbol();
            var resolver = this._getResolver();
            var importDeclStatement = resolver.semanticInfoChain.getASTForDecl(this.getDeclarations()[0]);
            var aliasSymbol = resolver.semanticInfoChain.getAliasSymbolForAST(importDeclStatement.moduleReference);
            if (aliasSymbol) {
                aliasSymbol.setIsUsedAsValue(value);
            }
        };
        PullTypeAliasSymbol.prototype.assignedValue = function () {
            this._resolveDeclaredSymbol();
            return this._assignedValue;
        };
        PullTypeAliasSymbol.prototype.assignedType = function () {
            this._resolveDeclaredSymbol();
            return this._assignedType;
        };
        PullTypeAliasSymbol.prototype.assignedContainer = function () {
            this._resolveDeclaredSymbol();
            return this._assignedContainer;
        };
        PullTypeAliasSymbol.prototype.isAlias = function () { return true; };
        PullTypeAliasSymbol.prototype.isContainer = function () { return true; };
        PullTypeAliasSymbol.prototype.setAssignedValueSymbol = function (symbol) {
            this._assignedValue = symbol;
        };
        PullTypeAliasSymbol.prototype.getExportAssignedValueSymbol = function () {
            if (this._assignedValue) {
                return this._assignedValue;
            }
            if (this.retrievingExportAssignment) {
                return null;
            }
            if (this._assignedContainer) {
                this.retrievingExportAssignment = true;
                var sym = this._assignedContainer.getExportAssignedValueSymbol();
                this.retrievingExportAssignment = false;
                return sym;
            }
            return null;
        };
        PullTypeAliasSymbol.prototype.setAssignedTypeSymbol = function (type) {
            this._assignedType = type;
        };
        PullTypeAliasSymbol.prototype.getExportAssignedTypeSymbol = function () {
            if (this.retrievingExportAssignment) {
                return null;
            }
            if (this._assignedType) {
                if (this._assignedType.isAlias()) {
                    this.retrievingExportAssignment = true;
                    var sym = this._assignedType.getExportAssignedTypeSymbol();
                    this.retrievingExportAssignment = false;
                }
                else if (this._assignedType != this._assignedContainer) {
                    return this._assignedType;
                }
            }
            if (this._assignedContainer) {
                this.retrievingExportAssignment = true;
                var sym = this._assignedContainer.getExportAssignedTypeSymbol();
                this.retrievingExportAssignment = false;
                if (sym) {
                    return sym;
                }
            }
            return this._assignedContainer;
        };
        PullTypeAliasSymbol.prototype.setAssignedContainerSymbol = function (container) {
            this._assignedContainer = container;
        };
        PullTypeAliasSymbol.prototype.getExportAssignedContainerSymbol = function () {
            if (this.retrievingExportAssignment) {
                return null;
            }
            if (this._assignedContainer) {
                this.retrievingExportAssignment = true;
                var sym = this._assignedContainer.getExportAssignedContainerSymbol();
                this.retrievingExportAssignment = false;
                if (sym) {
                    return sym;
                }
            }
            return this._assignedContainer;
        };
        PullTypeAliasSymbol.prototype.getMembers = function () {
            if (this._assignedType) {
                return this._assignedType.getMembers();
            }
            return [];
        };
        PullTypeAliasSymbol.prototype.getCallSignatures = function () {
            if (this._assignedType) {
                return this._assignedType.getCallSignatures();
            }
            return [];
        };
        PullTypeAliasSymbol.prototype.getConstructSignatures = function () {
            if (this._assignedType) {
                return this._assignedType.getConstructSignatures();
            }
            return [];
        };
        PullTypeAliasSymbol.prototype.getIndexSignatures = function () {
            if (this._assignedType) {
                return this._assignedType.getIndexSignatures();
            }
            return [];
        };
        PullTypeAliasSymbol.prototype.findMember = function (name) {
            if (this._assignedType) {
                return this._assignedType.findMember(name, true);
            }
            return null;
        };
        PullTypeAliasSymbol.prototype.findNestedType = function (name) {
            if (this._assignedType) {
                return this._assignedType.findNestedType(name);
            }
            return null;
        };
        PullTypeAliasSymbol.prototype.findNestedContainer = function (name) {
            if (this._assignedType) {
                return this._assignedType.findNestedContainer(name);
            }
            return null;
        };
        PullTypeAliasSymbol.prototype.getAllMembers = function (searchDeclKind, memberVisibility) {
            if (this._assignedType) {
                return this._assignedType.getAllMembers(searchDeclKind, memberVisibility);
            }
            return [];
        };
        return PullTypeAliasSymbol;
    }(PullTypeSymbol));
    TypeScript.PullTypeAliasSymbol = PullTypeAliasSymbol;
    var PullDefinitionSignatureSymbol = (function (_super) {
        __extends(PullDefinitionSignatureSymbol, _super);
        function PullDefinitionSignatureSymbol() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PullDefinitionSignatureSymbol.prototype.isDefinition = function () { return true; };
        return PullDefinitionSignatureSymbol;
    }(PullSignatureSymbol));
    TypeScript.PullDefinitionSignatureSymbol = PullDefinitionSignatureSymbol;
    var PullTypeParameterSymbol = (function (_super) {
        __extends(PullTypeParameterSymbol, _super);
        function PullTypeParameterSymbol(name, _isFunctionTypeParameter) {
            var _this = _super.call(this, name, TypeScript.PullElementKind.TypeParameter) || this;
            _this._isFunctionTypeParameter = _isFunctionTypeParameter;
            _this._constraint = null;
            return _this;
        }
        PullTypeParameterSymbol.prototype.isTypeParameter = function () { return true; };
        PullTypeParameterSymbol.prototype.isFunctionTypeParameter = function () { return this._isFunctionTypeParameter; };
        PullTypeParameterSymbol.prototype.setConstraint = function (constraintType) {
            this._constraint = constraintType;
        };
        PullTypeParameterSymbol.prototype.getConstraint = function () {
            return this._constraint;
        };
        PullTypeParameterSymbol.prototype.getCallSignatures = function () {
            if (this._constraint) {
                return this._constraint.getCallSignatures();
            }
            return _super.prototype.getCallSignatures.call(this);
        };
        PullTypeParameterSymbol.prototype.getConstructSignatures = function () {
            if (this._constraint) {
                return this._constraint.getConstructSignatures();
            }
            return _super.prototype.getConstructSignatures.call(this);
        };
        PullTypeParameterSymbol.prototype.getIndexSignatures = function () {
            if (this._constraint) {
                return this._constraint.getIndexSignatures();
            }
            return _super.prototype.getIndexSignatures.call(this);
        };
        PullTypeParameterSymbol.prototype.isGeneric = function () { return true; };
        PullTypeParameterSymbol.prototype.fullName = function (scopeSymbol) {
            var name = this.getDisplayName(scopeSymbol);
            var container = this.getContainer();
            if (container) {
                var containerName = container.fullName(scopeSymbol);
                name = name + " in " + containerName;
            }
            return name;
        };
        PullTypeParameterSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            var name = _super.prototype.getName.call(this, scopeSymbol);
            if (this.isPrinting) {
                return name;
            }
            this.isPrinting = true;
            if (useConstraintInName && this._constraint) {
                name += " extends " + this._constraint.toString(scopeSymbol);
            }
            this.isPrinting = false;
            return name;
        };
        PullTypeParameterSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName, skipInternalAliasName) {
            var name = _super.prototype.getDisplayName.call(this, scopeSymbol, useConstraintInName, skipInternalAliasName);
            if (this.isPrinting) {
                return name;
            }
            this.isPrinting = true;
            if (useConstraintInName && this._constraint) {
                name += " extends " + this._constraint.toString(scopeSymbol);
            }
            this.isPrinting = false;
            return name;
        };
        PullTypeParameterSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            return true;
        };
        return PullTypeParameterSymbol;
    }(PullTypeSymbol));
    TypeScript.PullTypeParameterSymbol = PullTypeParameterSymbol;
    var PullAccessorSymbol = (function (_super) {
        __extends(PullAccessorSymbol, _super);
        function PullAccessorSymbol(name) {
            var _this = _super.call(this, name, TypeScript.PullElementKind.Property) || this;
            _this._getterSymbol = null;
            _this._setterSymbol = null;
            return _this;
        }
        PullAccessorSymbol.prototype.isAccessor = function () { return true; };
        PullAccessorSymbol.prototype.setSetter = function (setter) {
            if (!setter) {
                return;
            }
            this._setterSymbol = setter;
        };
        PullAccessorSymbol.prototype.getSetter = function () {
            return this._setterSymbol;
        };
        PullAccessorSymbol.prototype.setGetter = function (getter) {
            if (!getter) {
                return;
            }
            this._getterSymbol = getter;
        };
        PullAccessorSymbol.prototype.getGetter = function () {
            return this._getterSymbol;
        };
        return PullAccessorSymbol;
    }(PullSymbol));
    TypeScript.PullAccessorSymbol = PullAccessorSymbol;
    function getIDForTypeSubstitutions(types) {
        var substitution = "";
        var members = null;
        for (var i = 0; i < types.length; i++) {
            if (types[i].kind !== TypeScript.PullElementKind.ObjectType) {
                substitution += types[i].pullSymbolID + "#";
            }
            else {
                var structure = getIDForTypeSubstitutionsFromObjectType(types[i]);
                if (structure) {
                    substitution += structure;
                }
                else {
                    substitution += types[i].pullSymbolID + "#";
                }
            }
        }
        return substitution;
    }
    TypeScript.getIDForTypeSubstitutions = getIDForTypeSubstitutions;
    function getIDForTypeSubstitutionsFromObjectType(type) {
        var structure = "";
        if (type.isResolved) {
            var members = type.getMembers();
            if (members && members.length) {
                for (var j = 0; j < members.length; j++) {
                    structure += members[j].name + "@" + getIDForTypeSubstitutions([members[j].type]);
                }
            }
            var callSignatures = type.getCallSignatures();
            if (callSignatures && callSignatures.length) {
                for (var j = 0; j < callSignatures.length; j++) {
                    structure += getIDForTypeSubstitutionFromSignature(callSignatures[j]);
                }
            }
            var constructSignatures = type.getConstructSignatures();
            if (constructSignatures && constructSignatures.length) {
                for (var j = 0; j < constructSignatures.length; j++) {
                    structure += "new" + getIDForTypeSubstitutionFromSignature(constructSignatures[j]);
                }
            }
            var indexSignatures = type.getIndexSignatures();
            if (indexSignatures && indexSignatures.length) {
                for (var j = 0; j < indexSignatures.length; j++) {
                    structure += "[]" + getIDForTypeSubstitutionFromSignature(indexSignatures[j]);
                }
            }
        }
        if (structure !== "") {
            return "{" + structure + "}";
        }
        return null;
    }
    function getIDForTypeSubstitutionFromSignature(signature) {
        var structure = "(";
        var parameters = signature.parameters;
        if (parameters && parameters.length) {
            for (var k = 0; k < parameters.length; k++) {
                structure += parameters[k].name + "@" + getIDForTypeSubstitutions([parameters[k].type]);
            }
        }
        structure += ")" + getIDForTypeSubstitutions([signature.returnType]);
        return structure;
    }
    var GetAllMembersVisiblity;
    (function (GetAllMembersVisiblity) {
        GetAllMembersVisiblity[GetAllMembersVisiblity["all"] = 0] = "all";
        GetAllMembersVisiblity[GetAllMembersVisiblity["internallyVisible"] = 1] = "internallyVisible";
        GetAllMembersVisiblity[GetAllMembersVisiblity["externallyVisible"] = 2] = "externallyVisible";
    })(GetAllMembersVisiblity = TypeScript.GetAllMembersVisiblity || (TypeScript.GetAllMembersVisiblity = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CandidateInferenceInfo = (function () {
        function CandidateInferenceInfo() {
            this.typeParameter = null;
            this.isFixed = false;
            this.inferenceCandidates = [];
        }
        CandidateInferenceInfo.prototype.addCandidate = function (candidate) {
            if (!this.isFixed) {
                this.inferenceCandidates[this.inferenceCandidates.length] = candidate;
            }
        };
        return CandidateInferenceInfo;
    }());
    TypeScript.CandidateInferenceInfo = CandidateInferenceInfo;
    var ArgumentInferenceContext = (function () {
        function ArgumentInferenceContext(resolver, argumentsOrParameters) {
            this.inferenceCache = TypeScript.BitMatrix.getBitMatrix(false);
            this.candidateCache = [];
            this.fixedParameterTypes = null;
            this.resolver = null;
            this.argumentASTs = null;
            this.resolver = resolver;
            if (argumentsOrParameters instanceof TypeScript.ISeparatedSyntaxList2) {
                this.argumentASTs = argumentsOrParameters;
            }
            else {
                this.fixedParameterTypes = argumentsOrParameters;
            }
        }
        ArgumentInferenceContext.prototype.alreadyRelatingTypes = function (objectType, parameterType) {
            if (this.inferenceCache.valueAt(objectType.pullSymbolID, parameterType.pullSymbolID)) {
                return true;
            }
            else {
                this.inferenceCache.setValueAt(objectType.pullSymbolID, parameterType.pullSymbolID, true);
                return false;
            }
        };
        ArgumentInferenceContext.prototype.resetRelationshipCache = function () {
            this.inferenceCache.release();
            this.inferenceCache = TypeScript.BitMatrix.getBitMatrix(false);
        };
        ArgumentInferenceContext.prototype.addInferenceRoot = function (param) {
            var info = this.candidateCache[param.pullSymbolID];
            if (!info) {
                info = new CandidateInferenceInfo();
                info.typeParameter = param;
                this.candidateCache[param.pullSymbolID] = info;
            }
        };
        ArgumentInferenceContext.prototype.getInferenceInfo = function (param) {
            return this.candidateCache[param.pullSymbolID];
        };
        ArgumentInferenceContext.prototype.addCandidateForInference = function (param, candidate, fix) {
            var info = this.getInferenceInfo(param);
            if (info) {
                if (candidate) {
                    info.addCandidate(candidate);
                }
                if (!info.isFixed) {
                    info.isFixed = fix;
                }
            }
        };
        ArgumentInferenceContext.prototype.getInferenceArgumentCount = function () {
            if (this.fixedParameterTypes) {
                return this.fixedParameterTypes.length;
            }
            else {
                return this.argumentASTs.nonSeparatorCount();
            }
        };
        ArgumentInferenceContext.prototype.getArgumentTypeSymbolAtIndex = function (i, context) {
            TypeScript.Debug.assert(i >= 0, "invalid inference argument position");
            if (this.fixedParameterTypes && i < this.getInferenceArgumentCount()) {
                return this.fixedParameterTypes[i];
            }
            else if (i < this.getInferenceArgumentCount()) {
                return this.resolver.resolveAST(this.argumentASTs.nonSeparatorAt(i), true, context).type;
            }
            return null;
        };
        ArgumentInferenceContext.prototype.getInferenceCandidates = function () {
            var inferenceCandidates = [];
            for (var infoKey in this.candidateCache) {
                if (this.candidateCache.hasOwnProperty(infoKey)) {
                    var info = this.candidateCache[infoKey];
                    for (var i = 0; i < info.inferenceCandidates.length; i++) {
                        var val = [];
                        val[info.typeParameter.pullSymbolID] = info.inferenceCandidates[i];
                        inferenceCandidates.push(val);
                    }
                }
            }
            return inferenceCandidates;
        };
        ArgumentInferenceContext.prototype.inferArgumentTypes = function (resolver, context) {
            var collection;
            var bestCommonType;
            var results = [];
            var unfit = false;
            for (var infoKey in this.candidateCache) {
                if (this.candidateCache.hasOwnProperty(infoKey)) {
                    var info = this.candidateCache[infoKey];
                    if (!info.inferenceCandidates.length) {
                        results[results.length] = { param: info.typeParameter, type: null };
                        continue;
                    }
                    collection = {
                        getLength: function () { return info.inferenceCandidates.length; },
                        getTypeAtIndex: function (index) {
                            return info.inferenceCandidates[index].type;
                        }
                    };
                    bestCommonType = resolver.widenType(resolver.findBestCommonType(collection, context, new TypeScript.TypeComparisonInfo()));
                    if (!bestCommonType) {
                        unfit = true;
                    }
                    else {
                        for (var i = 0; i < results.length; i++) {
                            if (results[i].type == info.typeParameter) {
                                results[i].type = bestCommonType;
                            }
                        }
                    }
                    results[results.length] = { param: info.typeParameter, type: bestCommonType };
                }
            }
            return { results: results, unfit: unfit };
        };
        return ArgumentInferenceContext;
    }());
    TypeScript.ArgumentInferenceContext = ArgumentInferenceContext;
    var PullContextualTypeContext = (function () {
        function PullContextualTypeContext(contextualType, provisional, substitutions) {
            this.contextualType = contextualType;
            this.provisional = provisional;
            this.substitutions = substitutions;
            this.provisionallyTypedSymbols = [];
            this.hasProvisionalErrors = false;
            this.astSymbolMap = [];
        }
        PullContextualTypeContext.prototype.recordProvisionallyTypedSymbol = function (symbol) {
            this.provisionallyTypedSymbols[this.provisionallyTypedSymbols.length] = symbol;
        };
        PullContextualTypeContext.prototype.invalidateProvisionallyTypedSymbols = function () {
            for (var i = 0; i < this.provisionallyTypedSymbols.length; i++) {
                this.provisionallyTypedSymbols[i].setUnresolved();
            }
        };
        PullContextualTypeContext.prototype.setSymbolForAST = function (ast, symbol) {
            this.astSymbolMap[ast.syntaxID()] = symbol;
        };
        PullContextualTypeContext.prototype.getSymbolForAST = function (ast) {
            return this.astSymbolMap[ast.syntaxID()];
        };
        return PullContextualTypeContext;
    }());
    TypeScript.PullContextualTypeContext = PullContextualTypeContext;
    var PullTypeResolutionContext = (function () {
        function PullTypeResolutionContext(resolver, inTypeCheck, fileName) {
            if (inTypeCheck === void 0) { inTypeCheck = false; }
            if (fileName === void 0) { fileName = null; }
            this.resolver = resolver;
            this.inTypeCheck = inTypeCheck;
            this.fileName = fileName;
            this.contextStack = [];
            this.typeCheckedNodes = null;
            this.inBaseTypeResolution = false;
            if (inTypeCheck) {
                TypeScript.Debug.assert(fileName, "A file name must be provided if you are typechecking");
                this.typeCheckedNodes = TypeScript.BitVector.getBitVector(false);
            }
        }
        PullTypeResolutionContext.prototype.setTypeChecked = function (ast) {
            if (!this.inProvisionalResolution()) {
                this.typeCheckedNodes.setValueAt(ast.syntaxID(), true);
            }
        };
        PullTypeResolutionContext.prototype.canTypeCheckAST = function (ast) {
            return this.typeCheck() &&
                !this.typeCheckedNodes.valueAt(ast.syntaxID()) &&
                this.fileName === ast.fileName();
        };
        PullTypeResolutionContext.prototype.pushContextualType = function (type, provisional, substitutions) {
            this.contextStack.push(new PullContextualTypeContext(type, provisional, substitutions));
        };
        PullTypeResolutionContext.prototype.popContextualType = function () {
            var tc = this.contextStack.pop();
            tc.invalidateProvisionallyTypedSymbols();
            if (tc.hasProvisionalErrors && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].hasProvisionalErrors = true;
            }
            return tc;
        };
        PullTypeResolutionContext.prototype.hasProvisionalErrors = function () {
            return this.contextStack.length ? this.contextStack[this.contextStack.length - 1].hasProvisionalErrors : false;
        };
        PullTypeResolutionContext.prototype.findSubstitution = function (type) {
            var substitution = null;
            if (this.contextStack.length) {
                for (var i = this.contextStack.length - 1; i >= 0; i--) {
                    if (this.contextStack[i].substitutions) {
                        substitution = this.contextStack[i].substitutions[type.pullSymbolID];
                        if (substitution) {
                            break;
                        }
                    }
                }
            }
            return substitution;
        };
        PullTypeResolutionContext.prototype.getContextualType = function () {
            var context = !this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1];
            if (context) {
                var type = context.contextualType;
                if (!type) {
                    return null;
                }
                if (type.isTypeParameter() && type.getConstraint()) {
                    type = type.getConstraint();
                }
                var substitution = this.findSubstitution(type);
                return substitution ? substitution : type;
            }
            return null;
        };
        PullTypeResolutionContext.prototype.inProvisionalResolution = function () {
            return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional);
        };
        PullTypeResolutionContext.prototype.isInBaseTypeResolution = function () { return this.inBaseTypeResolution; };
        PullTypeResolutionContext.prototype.startBaseTypeResolution = function () {
            var wasInBaseTypeResoltion = this.inBaseTypeResolution;
            this.inBaseTypeResolution = true;
            return wasInBaseTypeResoltion;
        };
        PullTypeResolutionContext.prototype.doneBaseTypeResolution = function (wasInBaseTypeResolution) {
            this.inBaseTypeResolution = wasInBaseTypeResolution;
        };
        PullTypeResolutionContext.prototype.setTypeInContext = function (symbol, type) {
            var substitution = this.findSubstitution(type);
            symbol.type = substitution ? substitution : type;
            if (this.contextStack.length && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].recordProvisionallyTypedSymbol(symbol);
            }
        };
        PullTypeResolutionContext.prototype.postDiagnostic = function (diagnostic) {
            if (diagnostic) {
                if (this.inProvisionalResolution()) {
                    (this.contextStack[this.contextStack.length - 1]).hasProvisionalErrors = true;
                }
                else if (this.inTypeCheck && this.resolver) {
                    this.resolver.semanticInfoChain.addDiagnostic(diagnostic);
                }
            }
        };
        PullTypeResolutionContext.prototype.typeCheck = function () {
            return this.inTypeCheck && !this.inProvisionalResolution();
        };
        PullTypeResolutionContext.prototype.setSymbolForAST = function (ast, symbol) {
            this.contextStack[this.contextStack.length - 1].setSymbolForAST(ast, symbol);
        };
        PullTypeResolutionContext.prototype.getSymbolForAST = function (ast) {
            for (var i = this.contextStack.length - 1; i >= 0; i--) {
                var typeContext = this.contextStack[i];
                if (!typeContext.provisional) {
                    break;
                }
                var symbol = typeContext.getSymbolForAST(ast);
                if (symbol) {
                    return symbol;
                }
            }
            return null;
        };
        return PullTypeResolutionContext;
    }());
    TypeScript.PullTypeResolutionContext = PullTypeResolutionContext;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var OverloadApplicabilityStatus;
    (function (OverloadApplicabilityStatus) {
        OverloadApplicabilityStatus[OverloadApplicabilityStatus["NotAssignable"] = 0] = "NotAssignable";
        OverloadApplicabilityStatus[OverloadApplicabilityStatus["AssignableButWithProvisionalErrors"] = 1] = "AssignableButWithProvisionalErrors";
        OverloadApplicabilityStatus[OverloadApplicabilityStatus["AssignableWithNoProvisionalErrors"] = 2] = "AssignableWithNoProvisionalErrors";
        OverloadApplicabilityStatus[OverloadApplicabilityStatus["Subtype"] = 3] = "Subtype";
    })(OverloadApplicabilityStatus || (OverloadApplicabilityStatus = {}));
    var PullAdditionalCallResolutionData = (function () {
        function PullAdditionalCallResolutionData() {
            this.targetSymbol = null;
            this.resolvedSignatures = null;
            this.candidateSignature = null;
            this.actualParametersContextTypeSymbols = null;
            this.diagnosticsFromOverloadResolution = [];
        }
        return PullAdditionalCallResolutionData;
    }());
    TypeScript.PullAdditionalCallResolutionData = PullAdditionalCallResolutionData;
    var PullAdditionalObjectLiteralResolutionData = (function () {
        function PullAdditionalObjectLiteralResolutionData() {
            this.membersContextTypeSymbols = null;
        }
        return PullAdditionalObjectLiteralResolutionData;
    }());
    TypeScript.PullAdditionalObjectLiteralResolutionData = PullAdditionalObjectLiteralResolutionData;
    var MemberWithBaseOrigin = (function () {
        function MemberWithBaseOrigin(memberSymbol, baseOrigin) {
            this.memberSymbol = memberSymbol;
            this.baseOrigin = baseOrigin;
        }
        return MemberWithBaseOrigin;
    }());
    var SignatureWithBaseOrigin = (function () {
        function SignatureWithBaseOrigin(signature, baseOrigin) {
            this.signature = signature;
            this.baseOrigin = baseOrigin;
        }
        return SignatureWithBaseOrigin;
    }());
    var InheritedIndexSignatureInfo = (function () {
        function InheritedIndexSignatureInfo() {
        }
        return InheritedIndexSignatureInfo;
    }());
    var CompilerReservedNames;
    (function (CompilerReservedNames) {
        CompilerReservedNames[CompilerReservedNames["_this"] = 1] = "_this";
        CompilerReservedNames[CompilerReservedNames["_super"] = 2] = "_super";
        CompilerReservedNames[CompilerReservedNames["arguments"] = 3] = "arguments";
        CompilerReservedNames[CompilerReservedNames["_i"] = 4] = "_i";
        CompilerReservedNames[CompilerReservedNames["require"] = 5] = "require";
        CompilerReservedNames[CompilerReservedNames["exports"] = 6] = "exports";
    })(CompilerReservedNames || (CompilerReservedNames = {}));
    function getCompilerReservedName(name) {
        var nameText = name.valueText();
        var index = CompilerReservedNames[nameText];
        return CompilerReservedNames[index] ? index : undefined;
    }
    var PullTypeResolver = (function () {
        function PullTypeResolver(compilationSettings, semanticInfoChain) {
            this.compilationSettings = compilationSettings;
            this.semanticInfoChain = semanticInfoChain;
            this._cachedArrayInterfaceType = null;
            this._cachedNumberInterfaceType = null;
            this._cachedStringInterfaceType = null;
            this._cachedBooleanInterfaceType = null;
            this._cachedObjectInterfaceType = null;
            this._cachedFunctionInterfaceType = null;
            this._cachedIArgumentsInterfaceType = null;
            this._cachedRegExpInterfaceType = null;
            this._cachedAnyTypeArgs = null;
            this.typeCheckCallBacks = [];
            this.postTypeCheckWorkitems = [];
            this._cachedFunctionArgumentsSymbol = null;
            this.assignableCache = TypeScript.BitMatrix.getBitMatrix(true);
            this.subtypeCache = TypeScript.BitMatrix.getBitMatrix(true);
            this.identicalCache = TypeScript.BitMatrix.getBitMatrix(true);
        }
        PullTypeResolver.prototype.cachedArrayInterfaceType = function () {
            if (!this._cachedArrayInterfaceType) {
                this._cachedArrayInterfaceType = this.getSymbolFromDeclPath("Array", [], TypeScript.PullElementKind.Interface);
            }
            if (!this._cachedArrayInterfaceType) {
                this._cachedArrayInterfaceType = this.semanticInfoChain.anyTypeSymbol;
            }
            if (!this._cachedArrayInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedArrayInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }
            return this._cachedArrayInterfaceType;
        };
        PullTypeResolver.prototype.getArrayNamedType = function () {
            return this.cachedArrayInterfaceType();
        };
        PullTypeResolver.prototype.cachedNumberInterfaceType = function () {
            if (!this._cachedNumberInterfaceType) {
                this._cachedNumberInterfaceType = this.getSymbolFromDeclPath("Number", [], TypeScript.PullElementKind.Interface);
            }
            if (this._cachedNumberInterfaceType && !this._cachedNumberInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedNumberInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }
            return this._cachedNumberInterfaceType;
        };
        PullTypeResolver.prototype.cachedStringInterfaceType = function () {
            if (!this._cachedStringInterfaceType) {
                this._cachedStringInterfaceType = this.getSymbolFromDeclPath("String", [], TypeScript.PullElementKind.Interface);
            }
            if (this._cachedStringInterfaceType && !this._cachedStringInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedStringInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }
            return this._cachedStringInterfaceType;
        };
        PullTypeResolver.prototype.cachedBooleanInterfaceType = function () {
            if (!this._cachedBooleanInterfaceType) {
                this._cachedBooleanInterfaceType = this.getSymbolFromDeclPath("Boolean", [], TypeScript.PullElementKind.Interface);
            }
            if (this._cachedBooleanInterfaceType && !this._cachedBooleanInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedBooleanInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }
            return this._cachedBooleanInterfaceType;
        };
        PullTypeResolver.prototype.cachedObjectInterfaceType = function () {
            if (!this._cachedObjectInterfaceType) {
                this._cachedObjectInterfaceType = this.getSymbolFromDeclPath("Object", [], TypeScript.PullElementKind.Interface);
            }
            if (!this._cachedObjectInterfaceType) {
                this._cachedObjectInterfaceType = this.semanticInfoChain.anyTypeSymbol;
            }
            if (!this._cachedObjectInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedObjectInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }
            return this._cachedObjectInterfaceType;
        };
        PullTypeResolver.prototype.cachedFunctionInterfaceType = function () {
            if (!this._cachedFunctionInterfaceType) {
                this._cachedFunctionInterfaceType = this.getSymbolFromDeclPath("Function", [], TypeScript.PullElementKind.Interface);
            }
            if (this._cachedFunctionInterfaceType && !this._cachedFunctionInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedFunctionInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }
            return this._cachedFunctionInterfaceType;
        };
        PullTypeResolver.prototype.cachedIArgumentsInterfaceType = function () {
            if (!this._cachedIArgumentsInterfaceType) {
                this._cachedIArgumentsInterfaceType = this.getSymbolFromDeclPath("IArguments", [], TypeScript.PullElementKind.Interface);
            }
            if (this._cachedIArgumentsInterfaceType && !this._cachedIArgumentsInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedIArgumentsInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }
            return this._cachedIArgumentsInterfaceType;
        };
        PullTypeResolver.prototype.cachedRegExpInterfaceType = function () {
            if (!this._cachedRegExpInterfaceType) {
                this._cachedRegExpInterfaceType = this.getSymbolFromDeclPath("RegExp", [], TypeScript.PullElementKind.Interface);
            }
            if (this._cachedRegExpInterfaceType && !this._cachedRegExpInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedRegExpInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }
            return this._cachedRegExpInterfaceType;
        };
        PullTypeResolver.prototype.cachedFunctionArgumentsSymbol = function () {
            if (!this._cachedFunctionArgumentsSymbol) {
                this._cachedFunctionArgumentsSymbol = new TypeScript.PullSymbol("arguments", TypeScript.PullElementKind.Variable);
                this._cachedFunctionArgumentsSymbol.type = this.cachedIArgumentsInterfaceType() ? this.cachedIArgumentsInterfaceType() : this.semanticInfoChain.anyTypeSymbol;
                this._cachedFunctionArgumentsSymbol.setResolved();
                var functionArgumentsDecl = new TypeScript.PullSynthesizedDecl("arguments", "arguments", TypeScript.PullElementKind.Parameter, TypeScript.PullElementFlags.None, null, new TypeScript.TextSpan(0, 0), this.semanticInfoChain);
                functionArgumentsDecl.setSymbol(this._cachedFunctionArgumentsSymbol);
                this._cachedFunctionArgumentsSymbol.addDeclaration(functionArgumentsDecl);
            }
            return this._cachedFunctionArgumentsSymbol;
        };
        PullTypeResolver.prototype.setTypeChecked = function (ast, context) {
            context.setTypeChecked(ast);
        };
        PullTypeResolver.prototype.canTypeCheckAST = function (ast, context) {
            return context.canTypeCheckAST(ast);
        };
        PullTypeResolver.prototype.setSymbolForAST = function (ast, symbol, context) {
            if (context && context.inProvisionalResolution()) {
                context.setSymbolForAST(ast, symbol);
            }
            else {
                this.semanticInfoChain.setSymbolForAST(ast, symbol);
            }
        };
        PullTypeResolver.prototype.getSymbolForAST = function (ast, context) {
            var symbol = this.semanticInfoChain.getSymbolForAST(ast);
            if (!symbol) {
                if (context && context.inProvisionalResolution()) {
                    symbol = context.getSymbolForAST(ast);
                }
            }
            return symbol;
        };
        PullTypeResolver.prototype.getASTForDecl = function (decl) {
            return this.semanticInfoChain.getASTForDecl(decl);
        };
        PullTypeResolver.prototype.getNewErrorTypeSymbol = function (name) {
            if (name === void 0) { name = null; }
            return new TypeScript.PullErrorTypeSymbol(this.semanticInfoChain.anyTypeSymbol, name);
        };
        PullTypeResolver.prototype.getEnclosingDecl = function (decl) {
            var declPath = decl.getParentPath();
            if (declPath.length > 1 && declPath[declPath.length - 1] === decl) {
                return declPath[declPath.length - 2];
            }
            else {
                return declPath[declPath.length - 1];
            }
        };
        PullTypeResolver.prototype.getExportedMemberSymbol = function (symbol, parent) {
            if (!(symbol.kind & (TypeScript.PullElementKind.Method | TypeScript.PullElementKind.Property))) {
                var isContainer = (parent.kind & (TypeScript.PullElementKind.Container | TypeScript.PullElementKind.DynamicModule)) != 0;
                var containerType = !isContainer ? parent.getAssociatedContainerType() : parent;
                if (isContainer && containerType) {
                    if (symbol.anyDeclHasFlag(TypeScript.PullElementFlags.Exported)) {
                        return symbol;
                    }
                    return null;
                }
            }
            return symbol;
        };
        PullTypeResolver.prototype.getMemberSymbol = function (symbolName, declSearchKind, parent) {
            if (parent && parent.kind === TypeScript.PullElementKind.Interface && parent.name === "Just") {
                var repr = parent.getTypeArgumentsOrTypeParameters()[0];
                return this.getMemberSymbol(symbolName, declSearchKind, repr);
            }
            var member = null;
            if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                member = parent.findMember(symbolName, true);
            }
            else if (declSearchKind & TypeScript.PullElementKind.SomeType) {
                member = parent.findNestedType(symbolName);
            }
            else if (declSearchKind & TypeScript.PullElementKind.SomeContainer) {
                member = parent.findNestedContainer(symbolName);
            }
            if (member) {
                return this.getExportedMemberSymbol(member, parent);
            }
            var containerType = parent.getAssociatedContainerType();
            if (containerType) {
                if (containerType.isClass()) {
                    return null;
                }
                parent = containerType;
                if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                    member = parent.findMember(symbolName, true);
                }
                else if (declSearchKind & TypeScript.PullElementKind.SomeType) {
                    member = parent.findNestedType(symbolName);
                }
                else if (declSearchKind & TypeScript.PullElementKind.SomeContainer) {
                    member = parent.findNestedContainer(symbolName);
                }
                if (member) {
                    return this.getExportedMemberSymbol(member, parent);
                }
            }
            if (parent.kind & TypeScript.PullElementKind.SomeContainer) {
                var typeDeclarations = parent.getDeclarations();
                var childDecls = null;
                for (var j = 0; j < typeDeclarations.length; j++) {
                    childDecls = typeDeclarations[j].searchChildDecls(symbolName, declSearchKind);
                    if (childDecls.length) {
                        member = childDecls[0].getSymbol();
                        if (!member) {
                            member = childDecls[0].getSignatureSymbol();
                        }
                        return this.getExportedMemberSymbol(member, parent);
                    }
                    if ((declSearchKind & TypeScript.PullElementKind.SomeType) != 0 || (declSearchKind & TypeScript.PullElementKind.SomeValue) != 0) {
                        childDecls = typeDeclarations[j].searchChildDecls(symbolName, TypeScript.PullElementKind.TypeAlias);
                        if (childDecls.length && childDecls[0].kind == TypeScript.PullElementKind.TypeAlias) {
                            var aliasSymbol = this.getExportedMemberSymbol(childDecls[0].getSymbol(), parent);
                            if (aliasSymbol) {
                                if ((declSearchKind & TypeScript.PullElementKind.SomeType) != 0) {
                                    var typeSymbol = aliasSymbol.getExportAssignedTypeSymbol();
                                    if (typeSymbol) {
                                        return typeSymbol;
                                    }
                                }
                                else {
                                    var valueSymbol = aliasSymbol.getExportAssignedValueSymbol();
                                    if (valueSymbol) {
                                        return valueSymbol;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        PullTypeResolver.prototype.getSymbolFromDeclPath = function (symbolName, declPath, declSearchKind) {
            var symbol = null;
            var decl = null;
            var childDecls;
            var declSymbol = null;
            var declMembers;
            var pathDeclKind;
            var valDecl = null;
            var kind;
            var instanceSymbol = null;
            var instanceType = null;
            var childSymbol = null;
            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.kind;
                if (decl.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
                if (pathDeclKind & (TypeScript.PullElementKind.Container | TypeScript.PullElementKind.DynamicModule)) {
                    childDecls = decl.searchChildDecls(symbolName, declSearchKind);
                    if (childDecls.length) {
                        return childDecls[0].getSymbol();
                    }
                    if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                        instanceSymbol = decl.getSymbol().getInstanceSymbol();
                        childDecls = decl.searchChildDecls(symbolName, TypeScript.PullElementKind.TypeAlias);
                        if (childDecls.length) {
                            var sym = childDecls[0].getSymbol();
                            if (sym.isAlias()) {
                                return sym;
                            }
                        }
                        if (instanceSymbol) {
                            instanceType = instanceSymbol.type;
                            childSymbol = this.getMemberSymbol(symbolName, declSearchKind, instanceType);
                            if (childSymbol && (childSymbol.kind & declSearchKind) && !childSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.Static)) {
                                return childSymbol;
                            }
                        }
                        valDecl = decl.getValueDecl();
                        if (valDecl) {
                            decl = valDecl;
                        }
                    }
                    declSymbol = decl.getSymbol().type;
                    var childSymbol = this.getMemberSymbol(symbolName, declSearchKind, declSymbol);
                    if (childSymbol && (childSymbol.kind & declSearchKind) && !childSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.Static)) {
                        return childSymbol;
                    }
                }
                else if ((declSearchKind & (TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer)) || !(pathDeclKind & TypeScript.PullElementKind.Class)) {
                    var candidateSymbol = null;
                    if (pathDeclKind === TypeScript.PullElementKind.FunctionExpression && symbolName === decl.getFunctionExpressionName()) {
                        candidateSymbol = decl.getSymbol();
                    }
                    childDecls = decl.searchChildDecls(symbolName, declSearchKind);
                    if (childDecls.length) {
                        if (decl.kind & TypeScript.PullElementKind.SomeFunction) {
                            decl.ensureSymbolIsBound();
                        }
                        return childDecls[0].getSymbol();
                    }
                    if (candidateSymbol) {
                        return candidateSymbol;
                    }
                    if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                        childDecls = decl.searchChildDecls(symbolName, TypeScript.PullElementKind.TypeAlias);
                        if (childDecls.length) {
                            var sym = childDecls[0].getSymbol();
                            if (sym.isAlias()) {
                                return sym;
                            }
                        }
                    }
                }
            }
            symbol = this.semanticInfoChain.findSymbol([symbolName], declSearchKind);
            return symbol;
        };
        PullTypeResolver.prototype.getVisibleDeclsFromDeclPath = function (declPath, declSearchKind) {
            var result = [];
            var decl = null;
            var childDecls;
            var pathDeclKind;
            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.kind;
                var declKind = decl.kind;
                if (declKind !== TypeScript.PullElementKind.Class && declKind !== TypeScript.PullElementKind.Interface) {
                    this.addFilteredDecls(decl.getChildDecls(), declSearchKind, result);
                }
                switch (declKind) {
                    case TypeScript.PullElementKind.Container:
                    case TypeScript.PullElementKind.DynamicModule:
                        var otherDecls = this.semanticInfoChain.findDeclsFromPath(declPath.slice(0, i + 1), TypeScript.PullElementKind.SomeContainer);
                        for (var j = 0, m = otherDecls.length; j < m; j++) {
                            var otherDecl = otherDecls[j];
                            if (otherDecl === decl) {
                                continue;
                            }
                            var otherDeclChildren = otherDecl.getChildDecls();
                            for (var k = 0, s = otherDeclChildren.length; k < s; k++) {
                                var otherDeclChild = otherDeclChildren[k];
                                if ((otherDeclChild.flags & TypeScript.PullElementFlags.Exported) && (otherDeclChild.kind & declSearchKind)) {
                                    result.push(otherDeclChild);
                                }
                            }
                        }
                        break;
                    case TypeScript.PullElementKind.Class:
                    case TypeScript.PullElementKind.Interface:
                        var parameters = decl.getTypeParameters();
                        if (parameters && parameters.length) {
                            this.addFilteredDecls(parameters, declSearchKind, result);
                        }
                        break;
                    case TypeScript.PullElementKind.FunctionExpression:
                        var functionExpressionName = decl.getFunctionExpressionName();
                        if (functionExpressionName) {
                            result.push(decl);
                        }
                    case TypeScript.PullElementKind.Function:
                    case TypeScript.PullElementKind.ConstructorMethod:
                    case TypeScript.PullElementKind.Method:
                        var parameters = decl.getTypeParameters();
                        if (parameters && parameters.length) {
                            this.addFilteredDecls(parameters, declSearchKind, result);
                        }
                        break;
                }
            }
            var topLevelDecls = this.semanticInfoChain.topLevelDecls();
            for (var i = 0, n = topLevelDecls.length; i < n; i++) {
                var topLevelDecl = topLevelDecls[i];
                if (declPath.length > 0 && topLevelDecl.fileName() === declPath[0].fileName()) {
                    continue;
                }
                if (!topLevelDecl.isExternalModule()) {
                    this.addFilteredDecls(topLevelDecl.getChildDecls(), declSearchKind, result);
                }
            }
            return result;
        };
        PullTypeResolver.prototype.addFilteredDecls = function (decls, declSearchKind, result) {
            if (decls.length) {
                for (var i = 0, n = decls.length; i < n; i++) {
                    var decl = decls[i];
                    if (decl.kind & declSearchKind) {
                        result.push(decl);
                    }
                }
            }
        };
        PullTypeResolver.prototype.getVisibleDecls = function (enclosingDecl) {
            var declPath = enclosingDecl.getParentPath();
            var declSearchKind = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer | TypeScript.PullElementKind.SomeValue;
            return this.getVisibleDeclsFromDeclPath(declPath, declSearchKind);
        };
        PullTypeResolver.prototype.getVisibleContextSymbols = function (enclosingDecl, context) {
            var contextualTypeSymbol = context.getContextualType();
            if (!contextualTypeSymbol || this.isAnyOrEquivalent(contextualTypeSymbol)) {
                return null;
            }
            var declSearchKind = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer | TypeScript.PullElementKind.SomeValue;
            var members = contextualTypeSymbol.getAllMembers(declSearchKind, TypeScript.GetAllMembersVisiblity.externallyVisible);
            for (var i = 0; i < members.length; i++) {
                members[i].setUnresolved();
            }
            return members;
        };
        PullTypeResolver.prototype.getVisibleMembersFromExpression = function (expression, enclosingDecl, context) {
            var lhs = this.resolveAST(expression, false, context);
            if (isTypesOnlyLocation(expression) && (lhs.kind === TypeScript.PullElementKind.Class || lhs.kind === TypeScript.PullElementKind.Interface)) {
                return null;
            }
            var lhsType = lhs.type;
            if (!lhsType) {
                return null;
            }
            this.resolveDeclaredSymbol(lhsType, context);
            if (lhsType.isContainer() && lhsType.isAlias()) {
                lhsType = lhsType.getExportAssignedTypeSymbol();
            }
            while (lhsType.isTypeParameter()) {
                lhsType = lhsType.getConstraint();
                if (!lhsType) {
                    return null;
                }
            }
            if (this.isAnyOrEquivalent(lhsType)) {
                return null;
            }
            var memberVisibilty = TypeScript.GetAllMembersVisiblity.externallyVisible;
            var containerSymbol = lhsType;
            if (containerSymbol.kind === TypeScript.PullElementKind.ConstructorType) {
                containerSymbol = containerSymbol.getConstructSignatures()[0].returnType;
            }
            if (containerSymbol && containerSymbol.isClass()) {
                var declPath = enclosingDecl.getParentPath();
                if (declPath && declPath.length) {
                    var declarations = containerSymbol.getDeclarations();
                    for (var i = 0, n = declarations.length; i < n; i++) {
                        var declaration = declarations[i];
                        if (TypeScript.ArrayUtilities.contains(declPath, declaration)) {
                            memberVisibilty = TypeScript.GetAllMembersVisiblity.internallyVisible;
                            break;
                        }
                    }
                }
            }
            var declSearchKind = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer | TypeScript.PullElementKind.SomeValue;
            var members = [];
            if (lhsType.isContainer()) {
                var exportedAssignedContainerSymbol = lhsType.getExportAssignedContainerSymbol();
                if (exportedAssignedContainerSymbol) {
                    lhsType = exportedAssignedContainerSymbol;
                }
            }
            if (lhsType.isTypeParameter()) {
                var constraint = lhsType.getConstraint();
                if (constraint) {
                    lhsType = constraint;
                    members = lhsType.getAllMembers(declSearchKind, TypeScript.GetAllMembersVisiblity.externallyVisible);
                }
            }
            else {
                if (lhs.kind == TypeScript.PullElementKind.EnumMember) {
                    lhsType = this.semanticInfoChain.numberTypeSymbol;
                }
                if (lhsType === this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType()) {
                    lhsType = this.cachedNumberInterfaceType();
                }
                else if (lhsType === this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                    lhsType = this.cachedStringInterfaceType();
                }
                else if (lhsType === this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType()) {
                    lhsType = this.cachedBooleanInterfaceType();
                }
                if (!lhsType.isResolved) {
                    var potentiallySpecializedType = this.resolveDeclaredSymbol(lhsType, context);
                    if (potentiallySpecializedType != lhsType) {
                        if (!lhs.isType()) {
                            context.setTypeInContext(lhs, potentiallySpecializedType);
                        }
                        lhsType = potentiallySpecializedType;
                    }
                }
                members = lhsType.getAllMembers(declSearchKind, memberVisibilty);
                if (lhsType.isContainer()) {
                    var associatedInstance = lhsType.getInstanceSymbol();
                    if (associatedInstance) {
                        var instanceType = associatedInstance.type;
                        this.resolveDeclaredSymbol(instanceType, context);
                        var instanceMembers = instanceType.getAllMembers(declSearchKind, memberVisibilty);
                        members = members.concat(instanceMembers);
                    }
                    var exportedContainer = lhsType.getExportAssignedContainerSymbol();
                    if (exportedContainer) {
                        var exportedContainerMembers = exportedContainer.getAllMembers(declSearchKind, memberVisibilty);
                        members = members.concat(exportedContainerMembers);
                    }
                }
                else if (!lhsType.isConstructor()) {
                    var associatedContainerSymbol = lhsType.getAssociatedContainerType();
                    if (associatedContainerSymbol) {
                        var containerType = associatedContainerSymbol.type;
                        this.resolveDeclaredSymbol(containerType, context);
                        var containerMembers = containerType.getAllMembers(declSearchKind, memberVisibilty);
                        members = members.concat(containerMembers);
                    }
                }
            }
            if ((lhsType.getCallSignatures().length || lhsType.getConstructSignatures().length) && this.cachedFunctionInterfaceType()) {
                members = members.concat(this.cachedFunctionInterfaceType().getAllMembers(declSearchKind, TypeScript.GetAllMembersVisiblity.externallyVisible));
            }
            return members;
        };
        PullTypeResolver.prototype.isAnyOrEquivalent = function (type) {
            return (type === this.semanticInfoChain.anyTypeSymbol) || type.isError();
        };
        PullTypeResolver.prototype.resolveExternalModuleReference = function (idText, currentFileName) {
            var originalIdText = idText;
            var symbol = null;
            if (TypeScript.isRelative(originalIdText)) {
                var path = TypeScript.getRootFilePath(TypeScript.switchToForwardSlashes(currentFileName));
                symbol = this.semanticInfoChain.findExternalModule(path + idText);
            }
            else {
                idText = originalIdText;
                symbol = this.semanticInfoChain.findAmbientExternalModuleInGlobalContext(TypeScript.quoteStr(originalIdText));
                if (!symbol) {
                    var path = TypeScript.getRootFilePath(TypeScript.switchToForwardSlashes(currentFileName));
                    while (symbol === null && path != "") {
                        symbol = this.semanticInfoChain.findExternalModule(path + idText);
                        if (symbol === null) {
                            if (path === '/') {
                                path = '';
                            }
                            else {
                                path = TypeScript.normalizePath(path + "..");
                                path = path && path != '/' ? path + '/' : path;
                            }
                        }
                    }
                }
            }
            return symbol;
        };
        PullTypeResolver.prototype.resolveDeclaredSymbol = function (symbol, context) {
            if (!symbol || symbol.isResolved || symbol.isTypeReference()) {
                return symbol;
            }
            if (!context) {
                context = new TypeScript.PullTypeResolutionContext(this);
            }
            return this.resolveDeclaredSymbolWorker(symbol, context);
        };
        PullTypeResolver.prototype.resolveDeclaredSymbolWorker = function (symbol, context) {
            if (!symbol || symbol.isResolved) {
                return symbol;
            }
            if (symbol.inResolution) {
                if (!symbol.type && !symbol.isType()) {
                    symbol.type = this.semanticInfoChain.anyTypeSymbol;
                }
                return symbol;
            }
            var decls = symbol.getDeclarations();
            for (var i = 0; i < decls.length; i++) {
                var decl = decls[i];
                var ast = this.semanticInfoChain.getASTForDecl(decl);
                if (!ast ||
                    (ast.kind() === TypeScript.SyntaxKind.GetAccessor && ast.parent.parent.kind() === TypeScript.SyntaxKind.ObjectLiteralExpression) ||
                    (ast.kind() === TypeScript.SyntaxKind.SetAccessor && ast.parent.parent.kind() === TypeScript.SyntaxKind.ObjectLiteralExpression)) {
                    return symbol;
                }
                if (ast.kind() === TypeScript.SyntaxKind.IdentifierName && ast.parent && ast.parent.kind() === TypeScript.SyntaxKind.CatchClause) {
                    return symbol;
                }
                var enclosingModule = TypeScript.getEnclosingModuleDeclaration(ast);
                var resolvedSymbol;
                if (TypeScript.isAnyNameOfModule(enclosingModule, ast)) {
                    resolvedSymbol = this.resolveSingleModuleDeclaration(enclosingModule, ast, context);
                }
                else if (ast.kind() === TypeScript.SyntaxKind.SourceUnit && decl.kind === TypeScript.PullElementKind.DynamicModule) {
                    resolvedSymbol = this.resolveModuleSymbol(decl.getSymbol(), context, null, null, ast);
                }
                else {
                    TypeScript.Debug.assert(ast.kind() != TypeScript.SyntaxKind.IdentifierName && ast.kind() != TypeScript.SyntaxKind.MemberAccessExpression);
                    var resolvedSymbol = this.resolveAST(ast, false, context);
                }
                if (decl.kind == TypeScript.PullElementKind.Parameter &&
                    !symbol.isResolved &&
                    !symbol.type &&
                    resolvedSymbol &&
                    symbol.anyDeclHasFlag(TypeScript.PullElementFlags.PropertyParameter | TypeScript.PullElementFlags.ConstructorParameter)) {
                    symbol.type = resolvedSymbol.type;
                    symbol.setResolved();
                }
            }
            return symbol;
        };
        PullTypeResolver.prototype.resolveOtherDeclarations = function (astName, context) {
            var resolvedDecl = this.semanticInfoChain.getDeclForAST(astName);
            var symbol = resolvedDecl.getSymbol();
            var allDecls = symbol.getDeclarations();
            for (var i = 0; i < allDecls.length; i++) {
                var currentDecl = allDecls[i];
                var astForCurrentDecl = this.getASTForDecl(currentDecl);
                if (astForCurrentDecl != astName) {
                    var moduleDecl = TypeScript.getEnclosingModuleDeclaration(astForCurrentDecl);
                    if (TypeScript.isAnyNameOfModule(moduleDecl, astForCurrentDecl)) {
                        this.resolveSingleModuleDeclaration(moduleDecl, astForCurrentDecl, context);
                    }
                    else {
                        this.resolveAST(astForCurrentDecl, false, context);
                    }
                }
            }
        };
        PullTypeResolver.prototype.resolveSourceUnit = function (sourceUnit, context) {
            var enclosingDecl = this.getEnclosingDeclForAST(sourceUnit);
            var moduleSymbol = enclosingDecl.getSymbol();
            this.ensureAllSymbolsAreBound(moduleSymbol);
            this.resolveFirstExportAssignmentStatement(sourceUnit.moduleElements, context);
            this.resolveAST(sourceUnit.moduleElements, false, context);
            if (this.canTypeCheckAST(sourceUnit, context)) {
                this.typeCheckSourceUnit(sourceUnit, context);
            }
            return moduleSymbol;
        };
        PullTypeResolver.prototype.typeCheckSourceUnit = function (sourceUnit, context) {
            this.setTypeChecked(sourceUnit, context);
            this.resolveAST(sourceUnit.moduleElements, false, context);
        };
        PullTypeResolver.prototype.resolveEnumDeclaration = function (ast, context) {
            var containerDecl = this.semanticInfoChain.getDeclForAST(ast);
            var containerSymbol = containerDecl.getSymbol();
            if (containerSymbol.isResolved || containerSymbol.inResolution) {
                return containerSymbol;
            }
            containerSymbol.inResolution = true;
            var containerDecls = containerSymbol.getDeclarations();
            for (var i = 0; i < containerDecls.length; i++) {
                var childDecls = containerDecls[i].getChildDecls();
                for (var j = 0; j < childDecls.length; j++) {
                    childDecls[j].ensureSymbolIsBound();
                }
            }
            containerSymbol.setResolved();
            this.resolveOtherDeclarations(ast, context);
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckEnumDeclaration(ast, context);
            }
            return containerSymbol;
        };
        PullTypeResolver.prototype.typeCheckEnumDeclaration = function (ast, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.enumElements, false, context);
            var containerDecl = this.semanticInfoChain.getDeclForAST(ast);
            this.validateVariableDeclarationGroups(containerDecl, context);
            if (!TypeScript.enumIsElided(ast)) {
                this.checkNameForCompilerGeneratedDeclarationCollision(ast, true, ast.identifier, context);
            }
        };
        PullTypeResolver.prototype.postTypeCheckEnumDeclaration = function (ast, context) {
            this.checkThisCaptureVariableCollides(ast, true, context);
        };
        PullTypeResolver.prototype.resolveModuleDeclaration = function (ast, context) {
            var result;
            if (ast.stringLiteral) {
                result = this.resolveSingleModuleDeclaration(ast, ast.stringLiteral, context);
            }
            else {
                var moduleNames = TypeScript.getModuleNames(ast.name);
                for (var i = 0, n = moduleNames.length; i < n; i++) {
                    result = this.resolveSingleModuleDeclaration(ast, moduleNames[i], context);
                }
            }
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckModuleDeclaration(ast, context);
            }
            return result;
        };
        PullTypeResolver.prototype.ensureAllSymbolsAreBound = function (containerSymbol) {
            if (containerSymbol) {
                var containerDecls = containerSymbol.getDeclarations();
                for (var i = 0; i < containerDecls.length; i++) {
                    var childDecls = containerDecls[i].getChildDecls();
                    for (var j = 0; j < childDecls.length; j++) {
                        childDecls[j].ensureSymbolIsBound();
                    }
                }
            }
        };
        PullTypeResolver.prototype.resolveModuleSymbol = function (containerSymbol, context, moduleDeclAST, moduleDeclNameAST, sourceUnitAST) {
            if (containerSymbol.isResolved || containerSymbol.inResolution) {
                return containerSymbol;
            }
            containerSymbol.inResolution = true;
            this.ensureAllSymbolsAreBound(containerSymbol);
            var instanceSymbol = containerSymbol.getInstanceSymbol();
            if (instanceSymbol) {
                this.resolveDeclaredSymbol(instanceSymbol, context);
            }
            var isLastName = TypeScript.isLastNameOfModule(moduleDeclAST, moduleDeclNameAST);
            if (isLastName) {
                this.resolveFirstExportAssignmentStatement(moduleDeclAST.moduleElements, context);
            }
            else if (sourceUnitAST) {
                this.resolveFirstExportAssignmentStatement(sourceUnitAST.moduleElements, context);
            }
            containerSymbol.setResolved();
            if (moduleDeclNameAST) {
                this.resolveOtherDeclarations(moduleDeclNameAST, context);
            }
            return containerSymbol;
        };
        PullTypeResolver.prototype.resolveFirstExportAssignmentStatement = function (moduleElements, context) {
            for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                var moduleElement = moduleElements.childAt(i);
                if (moduleElement.kind() == TypeScript.SyntaxKind.ExportAssignment) {
                    this.resolveExportAssignmentStatement(moduleElement, context);
                    return;
                }
            }
        };
        PullTypeResolver.prototype.resolveSingleModuleDeclaration = function (ast, astName, context) {
            var containerDecl = this.semanticInfoChain.getDeclForAST(astName);
            var containerSymbol = containerDecl.getSymbol();
            return this.resolveModuleSymbol(containerSymbol, context, ast, astName, null);
        };
        PullTypeResolver.prototype.typeCheckModuleDeclaration = function (ast, context) {
            if (ast.stringLiteral) {
                this.typeCheckSingleModuleDeclaration(ast, ast.stringLiteral, context);
            }
            else {
                var moduleNames = TypeScript.getModuleNames(ast.name);
                for (var i = 0, n = moduleNames.length; i < n; i++) {
                    this.typeCheckSingleModuleDeclaration(ast, moduleNames[i], context);
                }
            }
        };
        PullTypeResolver.prototype.typeCheckSingleModuleDeclaration = function (ast, astName, context) {
            this.setTypeChecked(ast, context);
            if (TypeScript.isLastNameOfModule(ast, astName)) {
                this.resolveAST(ast.moduleElements, false, context);
            }
            var containerDecl = this.semanticInfoChain.getDeclForAST(astName);
            this.validateVariableDeclarationGroups(containerDecl, context);
            if (ast.stringLiteral) {
                if (TypeScript.isRelative(ast.stringLiteral.valueText())) {
                    this.semanticInfoChain.addDiagnosticFromAST(ast.stringLiteral, TypeScript.DiagnosticCode.Ambient_external_module_declaration_cannot_specify_relative_module_name);
                }
            }
            if (!TypeScript.moduleIsElided(ast) && !ast.stringLiteral) {
                this.checkNameForCompilerGeneratedDeclarationCollision(astName, true, astName, context);
            }
        };
        PullTypeResolver.prototype.postTypeCheckModuleDeclaration = function (ast, context) {
            this.checkThisCaptureVariableCollides(ast, true, context);
        };
        PullTypeResolver.prototype.isTypeRefWithoutTypeArgs = function (term) {
            if (term.kind() == TypeScript.SyntaxKind.IdentifierName) {
                return true;
            }
            else if (term.kind() == TypeScript.SyntaxKind.QualifiedName) {
                var binex = term;
                if (binex.right.kind() == TypeScript.SyntaxKind.IdentifierName) {
                    return true;
                }
            }
            return false;
        };
        PullTypeResolver.prototype.createInstantiatedType = function (type, typeArguments) {
            if (!type.isGeneric()) {
                return type;
            }
            var typeParameters = type.getTypeArgumentsOrTypeParameters();
            var typeParameterArgumentMap = [];
            for (var i = 0; i < typeParameters.length; i++) {
                typeParameterArgumentMap[typeParameters[i].pullSymbolID] = typeArguments[i] || new TypeScript.PullErrorTypeSymbol(this.semanticInfoChain.anyTypeSymbol, typeParameters[i].name);
            }
            return TypeScript.PullInstantiatedTypeReferenceSymbol.create(this, type, typeParameterArgumentMap);
        };
        PullTypeResolver.prototype.resolveReferenceTypeDeclaration = function (classOrInterface, name, heritageClauses, context) {
            var _this_1 = this;
            var typeDecl = this.semanticInfoChain.getDeclForAST(classOrInterface);
            var enclosingDecl = this.getEnclosingDecl(typeDecl);
            var typeDeclSymbol = typeDecl.getSymbol();
            var typeDeclIsClass = classOrInterface.kind() === TypeScript.SyntaxKind.ClassDeclaration;
            var hasVisited = this.getSymbolForAST(classOrInterface, context) != null;
            if ((typeDeclSymbol.isResolved && hasVisited) || (typeDeclSymbol.inResolution && !context.isInBaseTypeResolution())) {
                return typeDeclSymbol;
            }
            var wasResolving = typeDeclSymbol.inResolution;
            typeDeclSymbol.startResolving();
            if (!typeDeclSymbol.isResolved) {
                var typeDeclTypeParameters = typeDeclSymbol.getTypeParameters();
                for (var i = 0; i < typeDeclTypeParameters.length; i++) {
                    this.resolveDeclaredSymbol(typeDeclTypeParameters[i], context);
                }
            }
            var typeRefDecls = typeDeclSymbol.getDeclarations();
            for (var i = 0; i < typeRefDecls.length; i++) {
                var childDecls = typeRefDecls[i].getChildDecls();
                for (var j = 0; j < childDecls.length; j++) {
                    childDecls[j].ensureSymbolIsBound();
                }
            }
            var wasInBaseTypeResolution = context.startBaseTypeResolution();
            if (!typeDeclIsClass && !hasVisited) {
                typeDeclSymbol.resetKnownBaseTypeCount();
            }
            var extendsClause = TypeScript.getExtendsHeritageClause(heritageClauses);
            if (extendsClause) {
                for (var i = typeDeclSymbol.getKnownBaseTypeCount(); i < extendsClause.typeNames.nonSeparatorCount(); i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var parentType = this.resolveTypeReference(extendsClause.typeNames.nonSeparatorAt(i), context);
                    if (typeDeclSymbol.isValidBaseKind(parentType, true)) {
                        this.setSymbolForAST(extendsClause.typeNames.nonSeparatorAt(i), parentType, null);
                        if (!typeDeclSymbol.hasBase(parentType) && !parentType.hasBase(typeDeclSymbol)) {
                            typeDeclSymbol.addExtendedType(parentType);
                            var specializations = typeDeclSymbol.getKnownSpecializations();
                            for (var j = 0; j < specializations.length; j++) {
                                specializations[j].addExtendedType(parentType);
                            }
                        }
                    }
                    else if (parentType && !this.getSymbolForAST(extendsClause.typeNames.nonSeparatorAt(i), context)) {
                        this.setSymbolForAST(extendsClause.typeNames.nonSeparatorAt(i), parentType, null);
                    }
                }
            }
            var implementsClause = TypeScript.getImplementsHeritageClause(heritageClauses);
            if (implementsClause && typeDeclIsClass) {
                var extendsCount = extendsClause ? extendsClause.typeNames.nonSeparatorCount() : 0;
                for (var i = typeDeclSymbol.getKnownBaseTypeCount(); ((i - extendsCount) >= 0) && ((i - extendsCount) < implementsClause.typeNames.nonSeparatorCount()); i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var implementedTypeAST = implementsClause.typeNames.nonSeparatorAt(i - extendsCount);
                    var implementedType = this.resolveTypeReference(implementedTypeAST, context);
                    if (typeDeclSymbol.isValidBaseKind(implementedType, false)) {
                        this.setSymbolForAST(implementsClause.typeNames.nonSeparatorAt(i - extendsCount), implementedType, null);
                        if (!typeDeclSymbol.hasBase(implementedType) && !implementedType.hasBase(typeDeclSymbol)) {
                            typeDeclSymbol.addImplementedType(implementedType);
                        }
                    }
                    else if (implementedType && !this.getSymbolForAST(implementsClause.typeNames.nonSeparatorAt(i - extendsCount), context)) {
                        this.setSymbolForAST(implementsClause.typeNames.nonSeparatorAt(i - extendsCount), implementedType, null);
                    }
                }
            }
            context.doneBaseTypeResolution(wasInBaseTypeResolution);
            if (wasInBaseTypeResolution) {
                typeDeclSymbol.inResolution = false;
                this.typeCheckCallBacks.push(function (context) {
                    if (classOrInterface.kind() == TypeScript.SyntaxKind.ClassDeclaration) {
                        _this_1.resolveClassDeclaration(classOrInterface, context);
                    }
                    else {
                        _this_1.resolveInterfaceDeclaration(classOrInterface, context);
                    }
                });
                return typeDeclSymbol;
            }
            if (!typeDeclSymbol.isResolved) {
                if (!typeDeclIsClass) {
                    var callSignatures = typeDeclSymbol.getCallSignatures();
                    for (var i = 0; i < callSignatures.length; i++) {
                        this.resolveDeclaredSymbol(callSignatures[i], context);
                    }
                    var constructSignatures = typeDeclSymbol.getConstructSignatures();
                    for (var i = 0; i < constructSignatures.length; i++) {
                        this.resolveDeclaredSymbol(constructSignatures[i], context);
                    }
                    var indexSignatures = typeDeclSymbol.getIndexSignatures();
                    for (var i = 0; i < indexSignatures.length; i++) {
                        this.resolveDeclaredSymbol(indexSignatures[i], context);
                    }
                }
            }
            this.setSymbolForAST(name, typeDeclSymbol, context);
            this.setSymbolForAST(classOrInterface, typeDeclSymbol, context);
            typeDeclSymbol.setResolved();
            return typeDeclSymbol;
        };
        PullTypeResolver.prototype.resolveClassDeclaration = function (classDeclAST, context) {
            var classDecl = this.semanticInfoChain.getDeclForAST(classDeclAST);
            var classDeclSymbol = classDecl.getSymbol();
            if (!classDeclSymbol.isResolved) {
                this.resolveReferenceTypeDeclaration(classDeclAST, classDeclAST.identifier, classDeclAST.heritageClauses, context);
                var constructorMethod = classDeclSymbol.getConstructorMethod();
                var extendedTypes = classDeclSymbol.getExtendedTypes();
                var parentType = extendedTypes.length ? extendedTypes[0] : null;
                if (constructorMethod) {
                    var constructorTypeSymbol = constructorMethod.type;
                    var constructSignatures = constructorTypeSymbol.getConstructSignatures();
                    if (!constructSignatures.length) {
                        var constructorSignature;
                        var parentConstructor = parentType ? parentType.getConstructorMethod() : null;
                        if (parentConstructor) {
                            this.resolveDeclaredSymbol(parentConstructor, context);
                            var parentConstructorType = parentConstructor.type;
                            var parentConstructSignatures = parentConstructorType.getConstructSignatures();
                            var parentConstructSignature;
                            var parentParameters;
                            if (!parentConstructSignatures.length) {
                                parentConstructSignature = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.ConstructSignature);
                                parentConstructSignature.returnType = parentType;
                                parentConstructorType.addConstructSignature(parentConstructSignature);
                                parentConstructSignature.addDeclaration(parentType.getDeclarations()[0]);
                                var parentTypeParameters = parentConstructorType.getTypeParameters();
                                for (var i = 0; i < parentTypeParameters.length; i++) {
                                    parentConstructSignature.addTypeParameter(parentTypeParameters[i]);
                                }
                                parentConstructSignatures = [parentConstructSignature];
                            }
                            for (var i = 0; i < parentConstructSignatures.length; i++) {
                                parentConstructSignature = parentConstructSignatures[i];
                                parentParameters = parentConstructSignature.parameters;
                                constructorSignature = parentConstructSignature.isDefinition() ?
                                    new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.ConstructSignature) : new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.ConstructSignature);
                                constructorSignature.returnType = classDeclSymbol;
                                for (var j = 0; j < parentParameters.length; j++) {
                                    constructorSignature.addParameter(parentParameters[j], parentParameters[j].isOptional);
                                }
                                var typeParameters = constructorTypeSymbol.getTypeParameters();
                                for (var j = 0; j < typeParameters.length; j++) {
                                    constructorSignature.addTypeParameter(typeParameters[j]);
                                }
                                constructorTypeSymbol.addConstructSignature(constructorSignature);
                                constructorSignature.addDeclaration(classDecl);
                            }
                        }
                        else {
                            constructorSignature = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.ConstructSignature);
                            constructorSignature.returnType = classDeclSymbol;
                            constructorTypeSymbol.addConstructSignature(constructorSignature);
                            constructorSignature.addDeclaration(classDecl);
                            var typeParameters = constructorTypeSymbol.getTypeParameters();
                            for (var i = 0; i < typeParameters.length; i++) {
                                constructorSignature.addTypeParameter(typeParameters[i]);
                            }
                        }
                    }
                    if (!classDeclSymbol.isResolved) {
                        return classDeclSymbol;
                    }
                    if (parentType) {
                        var parentConstructorSymbol = parentType.getConstructorMethod();
                        if (parentConstructorSymbol) {
                            var parentConstructorTypeSymbol = parentConstructorSymbol.type;
                            if (!constructorTypeSymbol.hasBase(parentConstructorTypeSymbol)) {
                                constructorTypeSymbol.addExtendedType(parentConstructorTypeSymbol);
                            }
                        }
                    }
                }
                this.resolveOtherDeclarations(classDeclAST, context);
            }
            if (this.canTypeCheckAST(classDeclAST, context)) {
                this.typeCheckClassDeclaration(classDeclAST, context);
            }
            return classDeclSymbol;
        };
        PullTypeResolver.prototype.typeCheckTypeParametersOfTypeDeclaration = function (classOrInterface, context) {
            var _this_1 = this;
            var typeDecl = this.semanticInfoChain.getDeclForAST(classOrInterface);
            var typeDeclSymbol = typeDecl.getSymbol();
            var typeDeclTypeParameters = typeDeclSymbol.getTypeParameters();
            for (var i = 0; i < typeDeclTypeParameters.length; i++) {
                this.checkSymbolPrivacy(typeDeclSymbol, typeDeclTypeParameters[i], function (symbol) {
                    return _this_1.typeParameterOfTypeDeclarationPrivacyErrorReporter(classOrInterface, i, typeDeclTypeParameters[i], symbol, context);
                });
            }
        };
        PullTypeResolver.prototype.typeCheckClassDeclaration = function (classDeclAST, context) {
            this.setTypeChecked(classDeclAST, context);
            var classDecl = this.semanticInfoChain.getDeclForAST(classDeclAST);
            var classDeclSymbol = classDecl.getSymbol();
            this.checkNameForCompilerGeneratedDeclarationCollision(classDeclAST, true, classDeclAST.identifier, context);
            this.resolveAST(classDeclAST.classElements, false, context);
            this.typeCheckTypeParametersOfTypeDeclaration(classDeclAST, context);
            this.typeCheckBases(classDeclAST, classDeclAST.identifier, classDeclAST.heritageClauses, classDeclSymbol, this.getEnclosingDecl(classDecl), context);
            if (!classDeclSymbol.hasBaseTypeConflict()) {
                this.typeCheckMembersAgainstIndexer(classDeclSymbol, classDecl, context);
            }
        };
        PullTypeResolver.prototype.postTypeCheckClassDeclaration = function (classDeclAST, context) {
            this.checkThisCaptureVariableCollides(classDeclAST, true, context);
        };
        PullTypeResolver.prototype.resolveTypeSymbolSignatures = function (typeSymbol, context) {
            var callSignatures = typeSymbol.getCallSignatures();
            for (var i = 0; i < callSignatures.length; i++) {
                this.resolveDeclaredSymbol(callSignatures[i], context);
            }
            var constructSignatures = typeSymbol.getConstructSignatures();
            for (var i = 0; i < constructSignatures.length; i++) {
                this.resolveDeclaredSymbol(constructSignatures[i], context);
            }
            var indexSignatures = typeSymbol.getIndexSignatures();
            for (var i = 0; i < indexSignatures.length; i++) {
                this.resolveDeclaredSymbol(indexSignatures[i], context);
            }
        };
        PullTypeResolver.prototype.resolveInterfaceDeclaration = function (interfaceDeclAST, context) {
            this.resolveReferenceTypeDeclaration(interfaceDeclAST, interfaceDeclAST.identifier, interfaceDeclAST.heritageClauses, context);
            var interfaceDecl = this.semanticInfoChain.getDeclForAST(interfaceDeclAST);
            var interfaceDeclSymbol = interfaceDecl.getSymbol();
            this.resolveTypeSymbolSignatures(interfaceDeclSymbol, context);
            if (interfaceDeclSymbol.isResolved) {
                this.resolveOtherDeclarations(interfaceDeclAST, context);
                if (this.canTypeCheckAST(interfaceDeclAST, context)) {
                    this.typeCheckInterfaceDeclaration(interfaceDeclAST, context);
                }
            }
            return interfaceDeclSymbol;
        };
        PullTypeResolver.prototype.typeCheckInterfaceDeclaration = function (interfaceDeclAST, context) {
            this.setTypeChecked(interfaceDeclAST, context);
            var interfaceDecl = this.semanticInfoChain.getDeclForAST(interfaceDeclAST);
            var interfaceDeclSymbol = interfaceDecl.getSymbol();
            this.resolveAST(interfaceDeclAST.body.typeMembers, false, context);
            this.typeCheckTypeParametersOfTypeDeclaration(interfaceDeclAST, context);
            this.typeCheckBases(interfaceDeclAST, interfaceDeclAST.identifier, interfaceDeclAST.heritageClauses, interfaceDeclSymbol, this.getEnclosingDecl(interfaceDecl), context);
            if (!interfaceDeclSymbol.hasBaseTypeConflict()) {
                this.typeCheckMembersAgainstIndexer(interfaceDeclSymbol, interfaceDecl, context);
            }
        };
        PullTypeResolver.prototype.filterSymbol = function (symbol, kind, enclosingDecl, context) {
            if (symbol) {
                if (symbol.kind & kind) {
                    return symbol;
                }
                if (symbol.isAlias()) {
                    this.resolveDeclaredSymbol(symbol, context);
                    var alias = symbol;
                    if (kind & TypeScript.PullElementKind.SomeContainer) {
                        return alias.getExportAssignedContainerSymbol();
                    }
                    else if (kind & TypeScript.PullElementKind.SomeType) {
                        return alias.getExportAssignedTypeSymbol();
                    }
                    else if (kind & TypeScript.PullElementKind.SomeValue) {
                        return alias.getExportAssignedValueSymbol();
                    }
                }
            }
            return null;
        };
        PullTypeResolver.prototype.getMemberSymbolOfKind = function (symbolName, kind, pullTypeSymbol, enclosingDecl, context) {
            var memberSymbol = this.getMemberSymbol(symbolName, kind, pullTypeSymbol);
            return {
                symbol: this.filterSymbol(memberSymbol, kind, enclosingDecl, context),
                aliasSymbol: memberSymbol && memberSymbol.isAlias() ? memberSymbol : null
            };
        };
        PullTypeResolver.prototype.resolveIdentifierOfInternalModuleReference = function (importDecl, identifier, moduleSymbol, enclosingDecl, context) {
            var rhsName = identifier.valueText();
            if (rhsName.length === 0) {
                return null;
            }
            var moduleTypeSymbol = moduleSymbol.type;
            var memberSymbol = this.getMemberSymbolOfKind(rhsName, TypeScript.PullElementKind.SomeContainer, moduleTypeSymbol, enclosingDecl, context);
            var containerSymbol = memberSymbol.symbol;
            var valueSymbol = null;
            var typeSymbol = null;
            var aliasSymbol = null;
            var acceptableAlias = true;
            if (containerSymbol) {
                acceptableAlias = (containerSymbol.kind & TypeScript.PullElementKind.AcceptableAlias) != 0;
                aliasSymbol = memberSymbol.aliasSymbol;
            }
            if (!acceptableAlias && containerSymbol && containerSymbol.kind == TypeScript.PullElementKind.TypeAlias) {
                this.resolveDeclaredSymbol(containerSymbol, context);
                var aliasedAssignedValue = containerSymbol.getExportAssignedValueSymbol();
                var aliasedAssignedType = containerSymbol.getExportAssignedTypeSymbol();
                var aliasedAssignedContainer = containerSymbol.getExportAssignedContainerSymbol();
                if (aliasedAssignedValue || aliasedAssignedType || aliasedAssignedContainer) {
                    aliasSymbol = containerSymbol;
                    valueSymbol = aliasedAssignedValue;
                    typeSymbol = aliasedAssignedType;
                    containerSymbol = aliasedAssignedContainer;
                    acceptableAlias = true;
                }
            }
            if (!acceptableAlias) {
                this.semanticInfoChain.addDiagnosticFromAST(identifier, TypeScript.DiagnosticCode.Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules);
                return null;
            }
            if (!valueSymbol) {
                if (moduleTypeSymbol.getInstanceSymbol()) {
                    memberSymbol = this.getMemberSymbolOfKind(rhsName, TypeScript.PullElementKind.SomeValue, moduleTypeSymbol.getInstanceSymbol().type, enclosingDecl, context);
                    valueSymbol = memberSymbol.symbol;
                    if (valueSymbol && memberSymbol.aliasSymbol) {
                        aliasSymbol = memberSymbol.aliasSymbol;
                    }
                }
            }
            if (!typeSymbol) {
                memberSymbol = this.getMemberSymbolOfKind(rhsName, TypeScript.PullElementKind.SomeType, moduleTypeSymbol, enclosingDecl, context);
                typeSymbol = memberSymbol.symbol;
                if (typeSymbol && memberSymbol.aliasSymbol) {
                    aliasSymbol = memberSymbol.aliasSymbol;
                }
            }
            if (!valueSymbol && !typeSymbol && !containerSymbol) {
                this.semanticInfoChain.addDiagnosticFromAST(identifier, TypeScript.DiagnosticCode.Could_not_find_symbol_0_in_module_1, [rhsName, moduleSymbol.toString()]);
                return null;
            }
            if (!typeSymbol && containerSymbol) {
                typeSymbol = containerSymbol;
            }
            return {
                valueSymbol: valueSymbol,
                typeSymbol: typeSymbol,
                containerSymbol: containerSymbol,
                aliasSymbol: aliasSymbol
            };
        };
        PullTypeResolver.prototype.resolveModuleReference = function (importDecl, moduleNameExpr, enclosingDecl, context, declPath) {
            TypeScript.Debug.assert(moduleNameExpr.kind() == TypeScript.SyntaxKind.QualifiedName || moduleNameExpr.kind() == TypeScript.SyntaxKind.IdentifierName || moduleNameExpr.kind() === TypeScript.SyntaxKind.StringLiteral, "resolving module reference should always be either name or member reference");
            var moduleSymbol = null;
            var moduleName;
            if (moduleNameExpr.kind() == TypeScript.SyntaxKind.QualifiedName) {
                var dottedNameAST = moduleNameExpr;
                var moduleContainer = this.resolveModuleReference(importDecl, dottedNameAST.left, enclosingDecl, context, declPath);
                if (moduleContainer) {
                    moduleName = dottedNameAST.right.valueText();
                    moduleSymbol = this.getMemberSymbolOfKind(moduleName, TypeScript.PullElementKind.Container, moduleContainer.type, enclosingDecl, context).symbol;
                    if (!moduleSymbol) {
                        this.semanticInfoChain.addDiagnosticFromAST(dottedNameAST.right, TypeScript.DiagnosticCode.Could_not_find_module_0_in_module_1, [moduleName, moduleContainer.toString()]);
                    }
                }
            }
            else {
                var valueText = moduleNameExpr.kind() === TypeScript.SyntaxKind.IdentifierName ? moduleNameExpr.valueText() : moduleNameExpr.valueText();
                var text = moduleNameExpr.kind() === TypeScript.SyntaxKind.IdentifierName ? moduleNameExpr.text() : moduleNameExpr.text();
                if (text.length > 0) {
                    var resolvedModuleNameSymbol = this.getSymbolFromDeclPath(valueText, declPath, TypeScript.PullElementKind.Container);
                    moduleSymbol = this.filterSymbol(resolvedModuleNameSymbol, TypeScript.PullElementKind.Container, enclosingDecl, context);
                    if (moduleSymbol) {
                        this.semanticInfoChain.setSymbolForAST(moduleNameExpr, moduleSymbol);
                        if (resolvedModuleNameSymbol.isAlias()) {
                            this.semanticInfoChain.setAliasSymbolForAST(moduleNameExpr, resolvedModuleNameSymbol);
                        }
                    }
                    else {
                        this.semanticInfoChain.addDiagnosticFromAST(moduleNameExpr, TypeScript.DiagnosticCode.Unable_to_resolve_module_reference_0, [valueText]);
                    }
                }
            }
            return moduleSymbol;
        };
        PullTypeResolver.prototype.resolveInternalModuleReference = function (importStatementAST, context) {
            var importDecl = this.semanticInfoChain.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);
            var moduleReference = importStatementAST.moduleReference;
            var aliasExpr = moduleReference.kind() === TypeScript.SyntaxKind.ExternalModuleReference
                ? moduleReference.stringLiteral
                : moduleReference.moduleName;
            var declPath = enclosingDecl.getParentPath();
            var aliasedType = null;
            if (aliasExpr.kind() === TypeScript.SyntaxKind.IdentifierName || aliasExpr.kind() === TypeScript.SyntaxKind.StringLiteral) {
                var moduleSymbol = this.resolveModuleReference(importDecl, aliasExpr, enclosingDecl, context, declPath);
                if (moduleSymbol) {
                    aliasedType = moduleSymbol.type;
                    this.semanticInfoChain.setAliasSymbolForAST(moduleReference, this.semanticInfoChain.getAliasSymbolForAST(aliasExpr));
                    if (aliasedType.anyDeclHasFlag(TypeScript.PullElementFlags.InitializedModule)) {
                        var moduleName = aliasExpr.kind() === TypeScript.SyntaxKind.IdentifierName ? aliasExpr.valueText() : aliasExpr.valueText();
                        var valueSymbol = this.getSymbolFromDeclPath(moduleName, declPath, TypeScript.PullElementKind.SomeValue);
                        var instanceSymbol = aliasedType.getInstanceSymbol();
                        if (valueSymbol && (instanceSymbol != valueSymbol || valueSymbol.type == aliasedType)) {
                            var text = aliasExpr.kind() === TypeScript.SyntaxKind.IdentifierName ? aliasExpr.text() : aliasExpr.text();
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(aliasExpr, TypeScript.DiagnosticCode.Internal_module_reference_0_in_import_declaration_does_not_reference_module_instance_for_1, [text, moduleSymbol.type.toString(enclosingDecl ? enclosingDecl.getSymbol() : null)]));
                        }
                        else {
                            var importDeclSymbol = importDecl.getSymbol();
                            importDeclSymbol.setAssignedValueSymbol(valueSymbol);
                        }
                    }
                }
                else {
                    aliasedType = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            else if (aliasExpr.kind() == TypeScript.SyntaxKind.QualifiedName) {
                var importDeclSymbol = importDecl.getSymbol();
                var dottedNameAST = aliasExpr;
                var moduleSymbol = this.resolveModuleReference(importDecl, dottedNameAST.left, enclosingDecl, context, declPath);
                if (moduleSymbol) {
                    var identifierResolution = this.resolveIdentifierOfInternalModuleReference(importDecl, dottedNameAST.right, moduleSymbol, enclosingDecl, context);
                    if (identifierResolution) {
                        importDeclSymbol.setAssignedValueSymbol(identifierResolution.valueSymbol);
                        importDeclSymbol.setAssignedTypeSymbol(identifierResolution.typeSymbol);
                        importDeclSymbol.setAssignedContainerSymbol(identifierResolution.containerSymbol);
                        this.semanticInfoChain.setAliasSymbolForAST(moduleReference, identifierResolution.aliasSymbol);
                        if (identifierResolution.valueSymbol) {
                            importDeclSymbol.setIsUsedAsValue(true);
                        }
                        return null;
                    }
                }
                importDeclSymbol.setAssignedTypeSymbol(this.semanticInfoChain.anyTypeSymbol);
            }
            return aliasedType;
        };
        PullTypeResolver.prototype.resolveImportDeclaration = function (importStatementAST, context) {
            var importDecl = this.semanticInfoChain.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);
            var importDeclSymbol = importDecl.getSymbol();
            var aliasedType = null;
            if (importDeclSymbol.isResolved) {
                return importDeclSymbol;
            }
            importDeclSymbol.startResolving();
            if (importStatementAST.moduleReference.kind() === TypeScript.SyntaxKind.ExternalModuleReference) {
                var modPath = importStatementAST.moduleReference.stringLiteral.valueText();
                var declPath = enclosingDecl.getParentPath();
                aliasedType = this.resolveExternalModuleReference(modPath, importDecl.fileName());
                if (!aliasedType) {
                    var path = importStatementAST.moduleReference.stringLiteral.text();
                    this.semanticInfoChain.addDiagnosticFromAST(importStatementAST, TypeScript.DiagnosticCode.Unable_to_resolve_external_module_0, [path]);
                    aliasedType = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            else {
                aliasedType = this.resolveInternalModuleReference(importStatementAST, context);
            }
            if (aliasedType) {
                if (!aliasedType.isContainer()) {
                    this.semanticInfoChain.addDiagnosticFromAST(importStatementAST, TypeScript.DiagnosticCode.Module_cannot_be_aliased_to_a_non_module_type);
                    aliasedType = this.semanticInfoChain.anyTypeSymbol;
                }
                else if (aliasedType.getExportAssignedValueSymbol()) {
                    importDeclSymbol.setIsUsedAsValue(true);
                }
                if (aliasedType.isContainer()) {
                    importDeclSymbol.setAssignedContainerSymbol(aliasedType);
                }
                importDeclSymbol.setAssignedTypeSymbol(aliasedType);
                this.setSymbolForAST(importStatementAST.moduleReference, aliasedType, null);
            }
            importDeclSymbol.setResolved();
            this.resolveDeclaredSymbol(importDeclSymbol.assignedValue(), context);
            this.resolveDeclaredSymbol(importDeclSymbol.assignedType(), context);
            this.resolveDeclaredSymbol(importDeclSymbol.assignedContainer(), context);
            if (this.canTypeCheckAST(importStatementAST, context)) {
                this.typeCheckImportDeclaration(importStatementAST, context);
            }
            return importDeclSymbol;
        };
        PullTypeResolver.prototype.typeCheckImportDeclaration = function (importStatementAST, context) {
            var _this_1 = this;
            this.setTypeChecked(importStatementAST, context);
            var importDecl = this.semanticInfoChain.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);
            var importDeclSymbol = importDecl.getSymbol();
            if (importStatementAST.moduleReference.kind() === TypeScript.SyntaxKind.ExternalModuleReference) {
                if (this.compilationSettings.noResolve()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(importStatementAST, TypeScript.DiagnosticCode.Import_declaration_cannot_refer_to_external_module_reference_when_noResolve_option_is_set, null));
                }
                var modPath = importStatementAST.moduleReference.stringLiteral.valueText();
                if (enclosingDecl.kind === TypeScript.PullElementKind.DynamicModule) {
                    var ast = TypeScript.getEnclosingModuleDeclaration(this.getASTForDecl(enclosingDecl));
                    if (ast && ast.kind() === TypeScript.SyntaxKind.ModuleDeclaration) {
                        if (TypeScript.isRelative(modPath)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(importStatementAST, TypeScript.DiagnosticCode.Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name));
                        }
                    }
                }
            }
            var checkPrivacy;
            if (importStatementAST.moduleReference.kind() === TypeScript.SyntaxKind.ExternalModuleReference) {
                var containerSymbol = importDeclSymbol.getExportAssignedContainerSymbol();
                var container = containerSymbol ? containerSymbol.getContainer() : null;
                if (container && container.kind == TypeScript.PullElementKind.DynamicModule) {
                    checkPrivacy = true;
                }
            }
            else {
                checkPrivacy = true;
            }
            if (checkPrivacy) {
                var typeSymbol = importDeclSymbol.getExportAssignedTypeSymbol();
                var containerSymbol = importDeclSymbol.getExportAssignedContainerSymbol();
                var valueSymbol = importDeclSymbol.getExportAssignedValueSymbol();
                this.checkSymbolPrivacy(importDeclSymbol, containerSymbol, function (symbol) {
                    var messageCode = TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1;
                    var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null, false, false, true)];
                    context.postDiagnostic(_this_1.semanticInfoChain.diagnosticFromAST(importStatementAST, messageCode, messageArguments));
                });
                if (typeSymbol != containerSymbol) {
                    this.checkSymbolPrivacy(importDeclSymbol, typeSymbol, function (symbol) {
                        var messageCode = symbol.isContainer() && !symbol.isEnum() ?
                            TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1 :
                            TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1;
                        var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null, false, false, true)];
                        context.postDiagnostic(_this_1.semanticInfoChain.diagnosticFromAST(importStatementAST, messageCode, messageArguments));
                    });
                }
                if (valueSymbol) {
                    this.checkSymbolPrivacy(importDeclSymbol, valueSymbol.type, function (symbol) {
                        var messageCode = symbol.isContainer() && !symbol.isEnum() ?
                            TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1 :
                            TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1;
                        var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null, false, false, true)];
                        context.postDiagnostic(_this_1.semanticInfoChain.diagnosticFromAST(importStatementAST, messageCode, messageArguments));
                    });
                }
            }
            if (getCompilerReservedName(importStatementAST.identifier)) {
                this.postTypeCheckWorkitems.push(importStatementAST);
            }
        };
        PullTypeResolver.prototype.postTypeCheckImportDeclaration = function (importStatementAST, context) {
            if (TypeScript.importDeclarationIsElided(importStatementAST, this.semanticInfoChain)) {
                this.checkNameForCompilerGeneratedDeclarationCollision(importStatementAST, true, importStatementAST.identifier, context, true);
            }
        };
        PullTypeResolver.prototype.resolveExportAssignmentStatement = function (exportAssignmentAST, context) {
            var id = exportAssignmentAST.identifier.valueText();
            if (id.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var valueSymbol = null;
            var typeSymbol = null;
            var containerSymbol = null;
            var enclosingDecl = this.getEnclosingDeclForAST(exportAssignmentAST);
            var parentSymbol = enclosingDecl.getSymbol();
            if (!parentSymbol.isType() && parentSymbol.isContainer()) {
                this.semanticInfoChain.addDiagnosticFromAST(exportAssignmentAST, TypeScript.DiagnosticCode.Export_assignments_may_only_be_used_at_the_top_level_of_external_modules);
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var declPath = enclosingDecl !== null ? [enclosingDecl] : [];
            containerSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeContainer);
            var acceptableAlias = true;
            if (containerSymbol) {
                acceptableAlias = (containerSymbol.kind & TypeScript.PullElementKind.AcceptableAlias) != 0;
            }
            if (!acceptableAlias && containerSymbol && containerSymbol.kind == TypeScript.PullElementKind.TypeAlias) {
                this.resolveDeclaredSymbol(containerSymbol, context);
                var aliasSymbol = containerSymbol;
                var aliasedAssignedValue = aliasSymbol.getExportAssignedValueSymbol();
                var aliasedAssignedType = aliasSymbol.getExportAssignedTypeSymbol();
                var aliasedAssignedContainer = aliasSymbol.getExportAssignedContainerSymbol();
                if (aliasedAssignedValue || aliasedAssignedType || aliasedAssignedContainer) {
                    valueSymbol = aliasedAssignedValue;
                    typeSymbol = aliasedAssignedType;
                    containerSymbol = aliasedAssignedContainer;
                    aliasSymbol.setTypeUsedExternally(true);
                    acceptableAlias = true;
                }
            }
            if (!acceptableAlias) {
                this.semanticInfoChain.addDiagnosticFromAST(exportAssignmentAST, TypeScript.DiagnosticCode.Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules);
                return this.semanticInfoChain.voidTypeSymbol;
            }
            if (!valueSymbol) {
                valueSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeValue);
            }
            if (!typeSymbol) {
                typeSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeType);
            }
            if (!valueSymbol && !typeSymbol && !containerSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(exportAssignmentAST, TypeScript.DiagnosticCode.Could_not_find_symbol_0, [id]));
                return this.semanticInfoChain.voidTypeSymbol;
            }
            if (valueSymbol) {
                parentSymbol.setExportAssignedValueSymbol(valueSymbol);
            }
            if (typeSymbol) {
                parentSymbol.setExportAssignedTypeSymbol(typeSymbol);
            }
            if (containerSymbol) {
                parentSymbol.setExportAssignedContainerSymbol(containerSymbol);
            }
            this.resolveDeclaredSymbol(valueSymbol, context);
            this.resolveDeclaredSymbol(typeSymbol, context);
            this.resolveDeclaredSymbol(containerSymbol, context);
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.resolveAnyFunctionTypeSignature = function (funcDeclAST, typeParameters, parameterList, returnTypeAnnotation, context) {
            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            TypeScript.Debug.assert(functionDecl);
            var funcDeclSymbol = functionDecl.getSymbol();
            var signature = funcDeclSymbol.kind === TypeScript.PullElementKind.ConstructorType
                ? funcDeclSymbol.getConstructSignatures()[0] : funcDeclSymbol.getCallSignatures()[0];
            if (returnTypeAnnotation) {
                signature.returnType = this.resolveTypeReference(returnTypeAnnotation, context);
            }
            if (typeParameters) {
                for (var i = 0; i < typeParameters.typeParameters.nonSeparatorCount(); i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.typeParameters.nonSeparatorAt(i), context);
                }
            }
            if (parameterList) {
                for (var i = 0; i < parameterList.parameters.nonSeparatorCount(); i++) {
                    this.resolveFunctionTypeSignatureParameter(parameterList.parameters.nonSeparatorAt(i), signature, functionDecl, context);
                }
            }
            funcDeclSymbol.setResolved();
            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.setTypeChecked(funcDeclAST, context);
                this.typeCheckFunctionOverloads(funcDeclAST, context);
            }
            return funcDeclSymbol;
        };
        PullTypeResolver.prototype.resolveFunctionTypeSignatureParameter = function (argDeclAST, signature, enclosingDecl, context) {
            var paramDecl = this.semanticInfoChain.getDeclForAST(argDeclAST);
            var paramSymbol = paramDecl.getSymbol();
            if (argDeclAST.typeAnnotation) {
                var typeRef = this.resolveTypeReference(TypeScript.getType(argDeclAST), context);
                if (paramSymbol.isVarArg && !typeRef.isArrayNamedTypeReference()) {
                    var diagnostic = context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Rest_parameters_must_be_array_types));
                    typeRef = this.getNewErrorTypeSymbol();
                }
                context.setTypeInContext(paramSymbol, typeRef);
            }
            else {
                if (paramSymbol.isVarArg && paramSymbol.type) {
                    if (this.cachedArrayInterfaceType()) {
                        context.setTypeInContext(paramSymbol, this.createInstantiatedType(this.cachedArrayInterfaceType(), [paramSymbol.type]));
                    }
                    else {
                        context.setTypeInContext(paramSymbol, paramSymbol.type);
                    }
                }
                else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                    if (this.compilationSettings.noImplicitAny()) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Parameter_0_of_function_type_implicitly_has_an_any_type, [argDeclAST.identifier.text()]));
                    }
                }
            }
            paramSymbol.setResolved();
        };
        PullTypeResolver.prototype.resolveFunctionExpressionParameter = function (argDeclAST, id, typeExpr, equalsValueClause, contextParam, enclosingDecl, context) {
            var paramDecl = this.semanticInfoChain.getDeclForAST(argDeclAST);
            var paramSymbol = paramDecl.getSymbol();
            var contextualType = contextParam && contextParam.type;
            var isImplicitAny = false;
            if (typeExpr) {
                var typeRef = this.resolveTypeReference(typeExpr, context);
                if (paramSymbol.isVarArg && !typeRef.isArrayNamedTypeReference()) {
                    var diagnostic = context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Rest_parameters_must_be_array_types));
                    typeRef = this.getNewErrorTypeSymbol();
                }
                contextualType = typeRef || contextualType;
            }
            if (contextualType) {
                context.setTypeInContext(paramSymbol, contextualType);
            }
            else if (paramSymbol.isVarArg && this.cachedArrayInterfaceType()) {
                context.setTypeInContext(paramSymbol, this.createInstantiatedType(this.cachedArrayInterfaceType(), [this.semanticInfoChain.anyTypeSymbol]));
                isImplicitAny = true;
            }
            var canTypeCheckAST = this.canTypeCheckAST(argDeclAST, context);
            var initTypeSymbol;
            if (equalsValueClause && (canTypeCheckAST || !contextualType)) {
                if (contextualType) {
                    context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                }
                var initExprSymbol = this.resolveAST(equalsValueClause, contextualType != null, context);
                if (contextualType) {
                    context.popContextualType();
                }
                if (!initExprSymbol || !initExprSymbol.type) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Unable_to_resolve_type_of_0, [id.text()]));
                    if (!contextualType) {
                        context.setTypeInContext(paramSymbol, this.getNewErrorTypeSymbol(paramSymbol.name));
                    }
                }
                else {
                    initTypeSymbol = this.getInstanceTypeForAssignment(argDeclAST, initExprSymbol.type, context);
                    if (!contextualType) {
                        context.setTypeInContext(paramSymbol, this.widenType(initTypeSymbol, equalsValueClause, context));
                        isImplicitAny = initTypeSymbol !== paramSymbol.type;
                    }
                    else {
                        var comparisonInfo = new TypeComparisonInfo();
                        var isAssignable = this.sourceIsAssignableToTarget(initTypeSymbol, contextualType, argDeclAST, context, comparisonInfo);
                        if (!isAssignable) {
                            var enclosingSymbol = this.getEnclosingSymbolForAST(argDeclAST);
                            if (comparisonInfo.message) {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [initTypeSymbol.toString(enclosingSymbol), contextualType.toString(enclosingSymbol), comparisonInfo.message]));
                            }
                            else {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [initTypeSymbol.toString(enclosingSymbol), contextualType.toString(enclosingSymbol)]));
                            }
                        }
                    }
                }
            }
            if (!contextualType && !paramSymbol.isVarArg && !initTypeSymbol) {
                context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                isImplicitAny = true;
            }
            if (isImplicitAny && this.compilationSettings.noImplicitAny()) {
                var functionExpressionName = paramDecl.getParentDecl().getFunctionExpressionName();
                if (functionExpressionName) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [id.text(), functionExpressionName]));
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Parameter_0_of_lambda_function_implicitly_has_an_any_type, [id.text()]));
                }
            }
            if (canTypeCheckAST) {
                this.checkNameForCompilerGeneratedDeclarationCollision(argDeclAST, true, id, context);
            }
            paramSymbol.setResolved();
        };
        PullTypeResolver.prototype.checkNameForCompilerGeneratedDeclarationCollision = function (astWithName, isDeclaration, name, context, immediateThisCheck) {
            var compilerReservedName = getCompilerReservedName(name);
            if (compilerReservedName) {
                switch (compilerReservedName) {
                    case CompilerReservedNames._this:
                        if (immediateThisCheck) {
                            this.checkThisCaptureVariableCollides(astWithName, isDeclaration, context);
                        }
                        else {
                            this.postTypeCheckWorkitems.push(astWithName);
                        }
                        return;
                    case CompilerReservedNames._super:
                        this.checkSuperCaptureVariableCollides(astWithName, isDeclaration, context);
                        return;
                    case CompilerReservedNames.arguments:
                        this.checkArgumentsCollides(astWithName, context);
                        return;
                    case CompilerReservedNames._i:
                        if (isDeclaration) {
                            this.checkIndexOfRestArgumentInitializationCollides(astWithName, context);
                        }
                        return;
                    case CompilerReservedNames.require:
                    case CompilerReservedNames.exports:
                        if (isDeclaration) {
                            this.checkExternalModuleRequireExportsCollides(astWithName, name, context);
                        }
                        return;
                    default:
                        TypeScript.Debug.fail("Unknown compiler reserved name: " + name.text());
                }
            }
        };
        PullTypeResolver.prototype.hasRestParameterCodeGen = function (someFunctionDecl) {
            var enclosingAST = this.getASTForDecl(someFunctionDecl);
            var nodeType = enclosingAST.kind();
            if (nodeType == TypeScript.SyntaxKind.FunctionDeclaration) {
                var functionDeclaration = enclosingAST;
                return !TypeScript.hasFlag(someFunctionDecl.kind == TypeScript.PullElementKind.Method ? someFunctionDecl.getParentDecl().flags : someFunctionDecl.flags, TypeScript.PullElementFlags.Ambient)
                    && functionDeclaration.block
                    && TypeScript.lastParameterIsRest(functionDeclaration.callSignature.parameterList);
            }
            else if (nodeType === TypeScript.SyntaxKind.MemberFunctionDeclaration) {
                var memberFunction = enclosingAST;
                return !TypeScript.hasFlag(someFunctionDecl.kind == TypeScript.PullElementKind.Method ? someFunctionDecl.getParentDecl().flags : someFunctionDecl.flags, TypeScript.PullElementFlags.Ambient)
                    && memberFunction.block
                    && TypeScript.lastParameterIsRest(memberFunction.callSignature.parameterList);
            }
            else if (nodeType == TypeScript.SyntaxKind.ConstructorDeclaration) {
                var constructorDeclaration = enclosingAST;
                return !TypeScript.hasFlag(someFunctionDecl.getParentDecl().flags, TypeScript.PullElementFlags.Ambient)
                    && constructorDeclaration.block
                    && TypeScript.lastParameterIsRest(constructorDeclaration.parameterList);
            }
            else if (nodeType == TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression) {
                var arrowFunctionExpression = enclosingAST;
                return TypeScript.lastParameterIsRest(arrowFunctionExpression.callSignature.parameterList);
            }
            else if (nodeType === TypeScript.SyntaxKind.FunctionExpression) {
                var functionExpression = enclosingAST;
                return TypeScript.lastParameterIsRest(functionExpression.callSignature.parameterList);
            }
            return false;
        };
        PullTypeResolver.prototype.checkArgumentsCollides = function (ast, context) {
            if (ast.kind() == TypeScript.SyntaxKind.Parameter) {
                var enclosingDecl = this.getEnclosingDeclForAST(ast);
                if (TypeScript.hasFlag(enclosingDecl.kind, TypeScript.PullElementKind.SomeFunction)) {
                    if (this.hasRestParameterCodeGen(enclosingDecl)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters));
                    }
                }
            }
        };
        PullTypeResolver.prototype.checkIndexOfRestArgumentInitializationCollides = function (ast, context) {
            if (ast.kind() == TypeScript.SyntaxKind.Parameter) {
                var enclosingDecl = this.getEnclosingDeclForAST(ast);
                if (TypeScript.hasFlag(enclosingDecl.kind, TypeScript.PullElementKind.SomeFunction)) {
                    if (this.hasRestParameterCodeGen(enclosingDecl)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter));
                    }
                }
            }
        };
        PullTypeResolver.prototype.checkExternalModuleRequireExportsCollides = function (ast, name, context) {
            var enclosingDecl = this.getEnclosingDeclForAST(ast);
            var enclosingModule = TypeScript.getEnclosingModuleDeclaration(name);
            if (TypeScript.isAnyNameOfModule(enclosingModule, name)) {
                enclosingDecl = this.getEnclosingDeclForAST(enclosingModule);
            }
            if (enclosingDecl && enclosingDecl.kind == TypeScript.PullElementKind.DynamicModule) {
                var decl = this.semanticInfoChain.getDeclForAST(ast);
                if (!TypeScript.hasFlag(decl.flags, TypeScript.PullElementFlags.Ambient)) {
                    var nameText = name.valueText();
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module, [nameText, nameText]));
                }
            }
        };
        PullTypeResolver.prototype.resolveObjectTypeTypeReference = function (objectType, context) {
            var interfaceDecl = this.semanticInfoChain.getDeclForAST(objectType);
            TypeScript.Debug.assert(interfaceDecl);
            var interfaceSymbol = interfaceDecl.getSymbol();
            TypeScript.Debug.assert(interfaceSymbol);
            if (objectType.typeMembers) {
                var memberDecl = null;
                var memberSymbol = null;
                var memberType = null;
                var typeMembers = objectType.typeMembers;
                for (var i = 0; i < typeMembers.nonSeparatorCount(); i++) {
                    memberDecl = this.semanticInfoChain.getDeclForAST(typeMembers.nonSeparatorAt(i));
                    memberSymbol = (memberDecl.kind & TypeScript.PullElementKind.SomeSignature) ? memberDecl.getSignatureSymbol() : memberDecl.getSymbol();
                    this.resolveAST(typeMembers.nonSeparatorAt(i), false, context);
                    memberType = memberSymbol.type;
                    if ((memberType && memberType.isGeneric()) || (memberSymbol.isSignature() && memberSymbol.isGeneric())) {
                        interfaceSymbol.setHasGenericMember();
                    }
                }
            }
            interfaceSymbol.setResolved();
            if (this.canTypeCheckAST(objectType, context)) {
                this.typeCheckObjectTypeTypeReference(objectType, context);
            }
            return interfaceSymbol;
        };
        PullTypeResolver.prototype.typeCheckObjectTypeTypeReference = function (objectType, context) {
            this.setTypeChecked(objectType, context);
            var objectTypeDecl = this.semanticInfoChain.getDeclForAST(objectType);
            var objectTypeSymbol = objectTypeDecl.getSymbol();
            this.typeCheckMembersAgainstIndexer(objectTypeSymbol, objectTypeDecl, context);
        };
        PullTypeResolver.prototype.resolveTypeAnnotation = function (typeAnnotation, context) {
            return this.resolveTypeReference(typeAnnotation.type, context);
        };
        PullTypeResolver.prototype.resolveTypeReference = function (typeRef, context) {
            if (typeRef === null) {
                return null;
            }
            TypeScript.Debug.assert(typeRef.kind() !== TypeScript.SyntaxKind.TypeAnnotation);
            var aliasType = null;
            var type = this.computeTypeReferenceSymbol(typeRef, context);
            if (type.kind == TypeScript.PullElementKind.Container) {
                var container = type;
                var instanceSymbol = container.getInstanceSymbol();
                if (instanceSymbol &&
                    (instanceSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.ClassConstructorVariable) || instanceSymbol.kind == TypeScript.PullElementKind.ConstructorMethod)) {
                    type = instanceSymbol.type.getAssociatedContainerType();
                }
            }
            if (type && type.isAlias()) {
                aliasType = type;
                type = aliasType.getExportAssignedTypeSymbol();
            }
            if (type && !type.isGeneric()) {
                if (aliasType) {
                    this.semanticInfoChain.setAliasSymbolForAST(typeRef, aliasType);
                }
            }
            if (type && !type.isError()) {
                if ((type.kind & TypeScript.PullElementKind.SomeType) === 0) {
                    if (type.kind & TypeScript.PullElementKind.SomeContainer) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(typeRef, TypeScript.DiagnosticCode.Type_reference_cannot_refer_to_container_0, [aliasType ? aliasType.toString() : type.toString()]));
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(typeRef, TypeScript.DiagnosticCode.Type_reference_must_refer_to_type));
                    }
                }
            }
            if (this.canTypeCheckAST(typeRef, context)) {
                this.setTypeChecked(typeRef, context);
            }
            return type;
        };
        PullTypeResolver.prototype.computeTypeReferenceSymbol = function (term, context) {
            switch (term.kind()) {
                case TypeScript.SyntaxKind.AnyKeyword: return this.semanticInfoChain.anyTypeSymbol;
                case TypeScript.SyntaxKind.BooleanKeyword: return this.semanticInfoChain.booleanTypeSymbol;
                case TypeScript.SyntaxKind.NumberKeyword: return this.semanticInfoChain.numberTypeSymbol;
                case TypeScript.SyntaxKind.StringKeyword: return this.semanticInfoChain.stringTypeSymbol;
                case TypeScript.SyntaxKind.VoidKeyword: return this.semanticInfoChain.voidTypeSymbol;
            }
            var typeDeclSymbol = null;
            if (term.kind() === TypeScript.SyntaxKind.IdentifierName) {
                typeDeclSymbol = this.resolveTypeNameExpression(term, context);
            }
            else if (term.kind() === TypeScript.SyntaxKind.FunctionType) {
                var functionType = term;
                typeDeclSymbol = this.resolveAnyFunctionTypeSignature(functionType, functionType.typeParameterList, functionType.parameterList, functionType.type, context);
            }
            else if (term.kind() === TypeScript.SyntaxKind.ConstructorType) {
                var constructorType = term;
                typeDeclSymbol = this.resolveAnyFunctionTypeSignature(constructorType, constructorType.typeParameterList, constructorType.parameterList, constructorType.type, context);
            }
            else if (term.kind() === TypeScript.SyntaxKind.ObjectType) {
                typeDeclSymbol = this.resolveObjectTypeTypeReference(term, context);
            }
            else if (term.kind() === TypeScript.SyntaxKind.GenericType) {
                typeDeclSymbol = this.resolveGenericTypeReference(term, context);
            }
            else if (term.kind() === TypeScript.SyntaxKind.QualifiedName) {
                typeDeclSymbol = this.resolveQualifiedName(term, context);
            }
            else if (term.kind() === TypeScript.SyntaxKind.StringLiteral) {
                var stringConstantAST = term;
                var enclosingDecl = this.getEnclosingDeclForAST(term);
                typeDeclSymbol = new TypeScript.PullStringConstantTypeSymbol(stringConstantAST.text());
                var decl = new TypeScript.PullSynthesizedDecl(stringConstantAST.text(), stringConstantAST.text(), typeDeclSymbol.kind, null, enclosingDecl, new TypeScript.TextSpan(stringConstantAST.start(), stringConstantAST.width()), enclosingDecl.semanticInfoChain());
                typeDeclSymbol.addDeclaration(decl);
            }
            else if (term.kind() === TypeScript.SyntaxKind.TypeQuery) {
                var typeQuery = term;
                var typeQueryTerm = typeQuery.name;
                var valueSymbol = this.resolveAST(typeQueryTerm, false, context);
                if (valueSymbol && valueSymbol.isAlias()) {
                    if (valueSymbol.assignedValue()) {
                        valueSymbol = valueSymbol.assignedValue();
                    }
                    else {
                        var containerSymbol = valueSymbol.getExportAssignedContainerSymbol();
                        valueSymbol = (containerSymbol && containerSymbol.isContainer() && !containerSymbol.isEnum()) ? containerSymbol.getInstanceSymbol() : null;
                    }
                }
                if (valueSymbol) {
                    typeDeclSymbol = valueSymbol.type;
                }
                else {
                    typeDeclSymbol = this.getNewErrorTypeSymbol();
                }
            }
            else if (term.kind() === TypeScript.SyntaxKind.ArrayType) {
                var arrayType = term;
                var underlying = this.resolveTypeReference(arrayType.type, context);
                var arraySymbol = underlying.getArrayType();
                if (!arraySymbol) {
                    arraySymbol = this.createInstantiatedType(this.cachedArrayInterfaceType(), [underlying]);
                    if (!arraySymbol) {
                        arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
                typeDeclSymbol = arraySymbol;
            }
            else if (term.kind() === TypeScript.SyntaxKind.TupleType) {
                var tupleType = term;
                typeDeclSymbol = this.semanticInfoChain.anyTypeSymbol;
            }
            else {
                throw TypeScript.Errors.invalidOperation("unknown type");
            }
            if (!typeDeclSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(term, TypeScript.DiagnosticCode.Unable_to_resolve_type));
                return this.getNewErrorTypeSymbol();
            }
            if (typeDeclSymbol.isError()) {
                return typeDeclSymbol;
            }
            if (this.genericTypeIsUsedWithoutRequiredTypeArguments(typeDeclSymbol, term, context)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(term, TypeScript.DiagnosticCode.Generic_type_references_must_include_all_type_arguments));
                typeDeclSymbol = this.instantiateTypeToAny(typeDeclSymbol, context);
            }
            return typeDeclSymbol;
        };
        PullTypeResolver.prototype.genericTypeIsUsedWithoutRequiredTypeArguments = function (typeSymbol, term, context) {
            return typeSymbol.isNamedTypeSymbol() &&
                typeSymbol.isGeneric() &&
                !typeSymbol.isTypeParameter() &&
                (typeSymbol.isResolved || typeSymbol.inResolution) &&
                !typeSymbol.getIsSpecialized() &&
                typeSymbol.getTypeParameters().length &&
                typeSymbol.getTypeArguments() == null &&
                this.isTypeRefWithoutTypeArgs(term);
        };
        PullTypeResolver.prototype.resolveMemberVariableDeclaration = function (varDecl, context) {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(varDecl, varDecl.modifiers, varDecl.variableDeclarator.propertyName, TypeScript.getType(varDecl.variableDeclarator), varDecl.variableDeclarator.equalsValueClause, context);
        };
        PullTypeResolver.prototype.resolvePropertySignature = function (varDecl, context) {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(varDecl, [], varDecl.propertyName, TypeScript.getType(varDecl), null, context);
        };
        PullTypeResolver.prototype.resolveVariableDeclarator = function (varDecl, context) {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(varDecl, TypeScript.getVariableDeclaratorModifiers(varDecl), varDecl.propertyName, TypeScript.getType(varDecl), varDecl.equalsValueClause, context);
        };
        PullTypeResolver.prototype.resolveParameterList = function (list, context) {
            return this.resolveSeparatedList(list.parameters, context);
        };
        PullTypeResolver.prototype.resolveParameter = function (parameter, context) {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(parameter, parameter.modifiers, parameter.identifier, TypeScript.getType(parameter), parameter.equalsValueClause, context);
        };
        PullTypeResolver.prototype.getEnumTypeSymbol = function (enumElement, context) {
            var enumDeclaration = enumElement.parent.parent;
            var decl = this.semanticInfoChain.getDeclForAST(enumDeclaration);
            var symbol = decl.getSymbol();
            this.resolveDeclaredSymbol(symbol, context);
            return symbol;
        };
        PullTypeResolver.prototype.resolveEnumElement = function (enumElement, context) {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(enumElement, [], enumElement.propertyName, null, enumElement.equalsValueClause, context);
        };
        PullTypeResolver.prototype.typeCheckEnumElement = function (enumElement, context) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(enumElement, [], enumElement.propertyName, null, enumElement.equalsValueClause, context);
        };
        PullTypeResolver.prototype.resolveEqualsValueClause = function (clause, isContextuallyTyped, context) {
            if (this.canTypeCheckAST(clause, context)) {
                this.setTypeChecked(clause, context);
            }
            return this.resolveAST(clause.value, isContextuallyTyped, context);
        };
        PullTypeResolver.prototype.resolveVariableDeclaratorOrParameterOrEnumElement = function (varDeclOrParameter, modifiers, name, typeExpr, init, context) {
            var hasTypeExpr = typeExpr !== null || varDeclOrParameter.kind() === TypeScript.SyntaxKind.EnumElement;
            var enclosingDecl = this.getEnclosingDeclForAST(varDeclOrParameter);
            var decl = this.semanticInfoChain.getDeclForAST(varDeclOrParameter);
            if (enclosingDecl && decl.kind == TypeScript.PullElementKind.Parameter) {
                enclosingDecl.ensureSymbolIsBound();
            }
            var declSymbol = decl.getSymbol();
            var declParameterSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol() : null;
            if (declSymbol.isResolved) {
                var declType = declSymbol.type;
                var valDecl = decl.getValueDecl();
                if (valDecl) {
                    var valSymbol = valDecl.getSymbol();
                    if (valSymbol && !valSymbol.isResolved) {
                        valSymbol.type = declType;
                        valSymbol.setResolved();
                    }
                }
            }
            else {
                if (declSymbol.inResolution) {
                    declSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                    declSymbol.setResolved();
                    return declSymbol;
                }
                if (!declSymbol.type || !declSymbol.type.isError()) {
                    declSymbol.startResolving();
                    var typeExprSymbol = this.resolveAndTypeCheckVariableDeclarationTypeExpr(varDeclOrParameter, name, typeExpr, context);
                    if (!hasTypeExpr) {
                        this.resolveAndTypeCheckVariableDeclaratorOrParameterInitExpr(varDeclOrParameter, name, typeExpr, init, context, typeExprSymbol);
                    }
                    if (!(hasTypeExpr || init)) {
                        var defaultType = this.semanticInfoChain.anyTypeSymbol;
                        if (declSymbol.isVarArg) {
                            defaultType = this.createInstantiatedType(this.cachedArrayInterfaceType(), [defaultType]);
                        }
                        context.setTypeInContext(declSymbol, defaultType);
                        if (declParameterSymbol) {
                            declParameterSymbol.type = defaultType;
                        }
                    }
                    declSymbol.setResolved();
                    if (declParameterSymbol) {
                        declParameterSymbol.setResolved();
                    }
                }
            }
            if (this.canTypeCheckAST(varDeclOrParameter, context)) {
                this.typeCheckVariableDeclaratorOrParameterOrEnumElement(varDeclOrParameter, modifiers, name, typeExpr, init, context);
            }
            return declSymbol;
        };
        PullTypeResolver.prototype.resolveAndTypeCheckVariableDeclarationTypeExpr = function (varDeclOrParameter, name, typeExpr, context) {
            var enclosingDecl = this.getEnclosingDeclForAST(varDeclOrParameter);
            var decl = this.semanticInfoChain.getDeclForAST(varDeclOrParameter);
            var declSymbol = decl.getSymbol();
            var declParameterSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol() : null;
            if (varDeclOrParameter.kind() === TypeScript.SyntaxKind.EnumElement) {
                var result = this.getEnumTypeSymbol(varDeclOrParameter, context);
                declSymbol.type = result;
                return result;
            }
            if (!typeExpr) {
                return null;
            }
            var wrapperDecl = this.getEnclosingDecl(decl);
            wrapperDecl = wrapperDecl ? wrapperDecl : enclosingDecl;
            var typeExprSymbol = this.resolveTypeReference(typeExpr, context);
            if (!typeExprSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Unable_to_resolve_type_of_0, [name.text()]));
                declSymbol.type = this.getNewErrorTypeSymbol();
                if (declParameterSymbol) {
                    context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            }
            else if (typeExprSymbol.isError()) {
                context.setTypeInContext(declSymbol, typeExprSymbol);
                if (declParameterSymbol) {
                    context.setTypeInContext(declParameterSymbol, typeExprSymbol);
                }
            }
            else {
                if (typeExprSymbol == this.semanticInfoChain.anyTypeSymbol) {
                    decl.setFlag(TypeScript.PullElementFlags.IsAnnotatedWithAny);
                }
                if (typeExprSymbol.isContainer()) {
                    var exportedTypeSymbol = typeExprSymbol.getExportAssignedTypeSymbol();
                    if (exportedTypeSymbol) {
                        typeExprSymbol = exportedTypeSymbol;
                    }
                    else {
                        typeExprSymbol = typeExprSymbol.type;
                        if (typeExprSymbol.isAlias()) {
                            typeExprSymbol = typeExprSymbol.getExportAssignedTypeSymbol();
                        }
                        if (typeExprSymbol && typeExprSymbol.isContainer() && !typeExprSymbol.isEnum()) {
                            var instanceSymbol = typeExprSymbol.getInstanceSymbol();
                            if (!instanceSymbol || !TypeScript.PullHelpers.symbolIsEnum(instanceSymbol)) {
                                typeExprSymbol = this.getNewErrorTypeSymbol();
                            }
                            else {
                                typeExprSymbol = instanceSymbol.type;
                            }
                        }
                    }
                }
                else if (declSymbol.isVarArg && !(typeExprSymbol.isArrayNamedTypeReference() || typeExprSymbol == this.cachedArrayInterfaceType())) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Rest_parameters_must_be_array_types));
                    typeExprSymbol = this.getNewErrorTypeSymbol();
                }
                context.setTypeInContext(declSymbol, typeExprSymbol);
                if (declParameterSymbol) {
                    declParameterSymbol.type = typeExprSymbol;
                }
                if (typeExprSymbol.kind == TypeScript.PullElementKind.FunctionType && !typeExprSymbol.getFunctionSymbol()) {
                    typeExprSymbol.setFunctionSymbol(declSymbol);
                }
            }
            return typeExprSymbol;
        };
        PullTypeResolver.prototype.resolveAndTypeCheckVariableDeclaratorOrParameterInitExpr = function (varDeclOrParameter, name, typeExpr, init, context, typeExprSymbol) {
            if (!init) {
                return null;
            }
            var hasTypeExpr = typeExpr !== null || varDeclOrParameter.kind() === TypeScript.SyntaxKind.EnumElement;
            if (typeExprSymbol) {
                context.pushContextualType(typeExprSymbol, context.inProvisionalResolution(), null);
            }
            var enclosingDecl = this.getEnclosingDeclForAST(varDeclOrParameter);
            var decl = this.semanticInfoChain.getDeclForAST(varDeclOrParameter);
            var declSymbol = decl.getSymbol();
            var declParameterSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol() : null;
            var wrapperDecl = this.getEnclosingDecl(decl);
            wrapperDecl = wrapperDecl ? wrapperDecl : enclosingDecl;
            var initExprSymbol = this.resolveAST(init, typeExprSymbol != null, context);
            var widenedInitTypeSymbol;
            if (typeExprSymbol) {
                context.popContextualType();
            }
            if (!initExprSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Unable_to_resolve_type_of_0, [name.text()]));
                if (!hasTypeExpr) {
                    context.setTypeInContext(declSymbol, this.getNewErrorTypeSymbol());
                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                    }
                }
            }
            else {
                var initTypeSymbol = initExprSymbol.type;
                widenedInitTypeSymbol = this.widenType(initTypeSymbol, init.value, context);
                if (!hasTypeExpr) {
                    context.setTypeInContext(declSymbol, widenedInitTypeSymbol);
                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, widenedInitTypeSymbol);
                    }
                    if (this.compilationSettings.noImplicitAny()) {
                        if ((widenedInitTypeSymbol != initTypeSymbol) && (widenedInitTypeSymbol == this.semanticInfoChain.anyTypeSymbol)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Variable_0_implicitly_has_an_any_type, [name.text()]));
                        }
                    }
                }
            }
            return widenedInitTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckPropertySignature = function (varDecl, context) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(varDecl, [], varDecl.propertyName, TypeScript.getType(varDecl), null, context);
        };
        PullTypeResolver.prototype.typeCheckMemberVariableDeclaration = function (varDecl, context) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(varDecl, varDecl.modifiers, varDecl.variableDeclarator.propertyName, TypeScript.getType(varDecl), varDecl.variableDeclarator.equalsValueClause, context);
        };
        PullTypeResolver.prototype.typeCheckVariableDeclarator = function (varDecl, context) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(varDecl, TypeScript.getVariableDeclaratorModifiers(varDecl), varDecl.propertyName, TypeScript.getType(varDecl), varDecl.equalsValueClause, context);
        };
        PullTypeResolver.prototype.typeCheckParameter = function (parameter, context) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(parameter, parameter.modifiers, parameter.identifier, TypeScript.getType(parameter), parameter.equalsValueClause, context);
        };
        PullTypeResolver.prototype.typeCheckVariableDeclaratorOrParameterOrEnumElement = function (varDeclOrParameter, modifiers, name, typeExpr, init, context) {
            var _this_1 = this;
            this.setTypeChecked(varDeclOrParameter, context);
            var hasTypeExpr = typeExpr !== null || varDeclOrParameter.kind() === TypeScript.SyntaxKind.EnumElement;
            var enclosingDecl = this.getEnclosingDeclForAST(varDeclOrParameter);
            var decl = this.semanticInfoChain.getDeclForAST(varDeclOrParameter);
            var declSymbol = decl.getSymbol();
            var typeExprSymbol = this.resolveAndTypeCheckVariableDeclarationTypeExpr(varDeclOrParameter, name, typeExpr, context);
            var initTypeSymbol = this.resolveAndTypeCheckVariableDeclaratorOrParameterInitExpr(varDeclOrParameter, name, typeExpr, init, context, typeExprSymbol);
            if (hasTypeExpr || init) {
                if (typeExprSymbol && typeExprSymbol.isAlias()) {
                    typeExprSymbol = typeExprSymbol.getExportAssignedTypeSymbol();
                }
                if (typeExprSymbol && typeExprSymbol.kind === TypeScript.PullElementKind.DynamicModule) {
                    var exportedTypeSymbol = typeExprSymbol.getExportAssignedTypeSymbol();
                    if (exportedTypeSymbol) {
                        typeExprSymbol = exportedTypeSymbol;
                    }
                    else {
                        var instanceTypeSymbol = typeExprSymbol.getInstanceType();
                        if (!instanceTypeSymbol) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type_0, [typeExprSymbol.toString()]));
                            typeExprSymbol = null;
                        }
                        else {
                            typeExprSymbol = instanceTypeSymbol;
                        }
                    }
                }
                initTypeSymbol = this.getInstanceTypeForAssignment(varDeclOrParameter, initTypeSymbol, context);
                if (initTypeSymbol && typeExprSymbol) {
                    var comparisonInfo = new TypeComparisonInfo();
                    var isAssignable = this.sourceIsAssignableToTarget(initTypeSymbol, typeExprSymbol, varDeclOrParameter, context, comparisonInfo);
                    if (!isAssignable) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(varDeclOrParameter);
                        if (comparisonInfo.message) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [initTypeSymbol.toString(enclosingSymbol), typeExprSymbol.toString(enclosingSymbol), comparisonInfo.message]));
                        }
                        else {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [initTypeSymbol.toString(enclosingSymbol), typeExprSymbol.toString(enclosingSymbol)]));
                        }
                    }
                }
            }
            else if (varDeclOrParameter.kind() !== TypeScript.SyntaxKind.EnumElement && this.compilationSettings.noImplicitAny() && !this.isForInVariableDeclarator(varDeclOrParameter)) {
                var wrapperDecl = this.getEnclosingDecl(decl);
                wrapperDecl = wrapperDecl ? wrapperDecl : enclosingDecl;
                if ((wrapperDecl.kind === TypeScript.PullElementKind.Function ||
                    wrapperDecl.kind === TypeScript.PullElementKind.ConstructorMethod ||
                    wrapperDecl.kind === TypeScript.PullElementKind.ConstructSignature)) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [name.text(), enclosingDecl.name]));
                }
                else if (wrapperDecl.kind === TypeScript.PullElementKind.Method) {
                    var parentDecl = wrapperDecl.getParentDecl();
                    if (!TypeScript.hasFlag(parentDecl.flags, TypeScript.PullElementFlags.Ambient)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [name.text(), enclosingDecl.name]));
                    }
                    else if (TypeScript.hasFlag(parentDecl.flags, TypeScript.PullElementFlags.Ambient) &&
                        !TypeScript.hasFlag(wrapperDecl.flags, TypeScript.PullElementFlags.Private)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [name.text(), enclosingDecl.name]));
                    }
                }
                else if (wrapperDecl.kind === TypeScript.PullElementKind.ObjectType) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Member_0_of_object_type_implicitly_has_an_any_type, [name.text()]));
                }
                else if (wrapperDecl.kind !== TypeScript.PullElementKind.CatchBlock) {
                    if (!TypeScript.hasFlag(wrapperDecl.flags, TypeScript.PullElementFlags.Ambient)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Variable_0_implicitly_has_an_any_type, [name.text()]));
                    }
                    else if (TypeScript.hasFlag(wrapperDecl.flags, TypeScript.PullElementFlags.Ambient) &&
                        !TypeScript.hasModifier(modifiers, TypeScript.PullElementFlags.Private)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Variable_0_implicitly_has_an_any_type, [name.text()]));
                    }
                }
            }
            if (init && varDeclOrParameter.kind() === TypeScript.SyntaxKind.Parameter) {
                var containerSignature = enclosingDecl.getSignatureSymbol();
                if (containerSignature && !containerSignature.isDefinition()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Default_arguments_are_not_allowed_in_an_overload_parameter));
                }
            }
            if (declSymbol.kind != TypeScript.PullElementKind.Parameter &&
                (declSymbol.kind != TypeScript.PullElementKind.Property || declSymbol.getContainer().isNamedTypeSymbol())) {
                this.checkSymbolPrivacy(declSymbol, declSymbol.type, function (symbol) {
                    return _this_1.variablePrivacyErrorReporter(varDeclOrParameter, declSymbol, symbol, context);
                });
            }
            if ((declSymbol.kind != TypeScript.PullElementKind.Property && declSymbol.kind != TypeScript.PullElementKind.EnumMember) || declSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.PropertyParameter)) {
                this.checkNameForCompilerGeneratedDeclarationCollision(varDeclOrParameter, true, name, context);
            }
        };
        PullTypeResolver.prototype.isForInVariableDeclarator = function (ast) {
            return ast.kind() === TypeScript.SyntaxKind.VariableDeclarator &&
                ast.parent && ast.parent.parent && ast.parent.parent.parent &&
                ast.parent.kind() === TypeScript.SyntaxKind.SeparatedList &&
                ast.parent.parent.kind() === TypeScript.SyntaxKind.VariableDeclaration &&
                ast.parent.parent.parent.kind() === TypeScript.SyntaxKind.ForInStatement &&
                ast.parent.parent.parent.variableDeclaration === ast.parent.parent;
        };
        PullTypeResolver.prototype.checkSuperCaptureVariableCollides = function (superAST, isDeclaration, context) {
            var enclosingDecl = this.getEnclosingDeclForAST(superAST);
            var declPath = enclosingDecl.getParentPath();
            var classSymbol = this.getContextualClassSymbolForEnclosingDecl(superAST, enclosingDecl);
            if (classSymbol && !classSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.Ambient)) {
                if (superAST.kind() == TypeScript.SyntaxKind.Parameter) {
                    var enclosingAST = this.getASTForDecl(enclosingDecl);
                    if (enclosingAST.kind() !== TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression &&
                        enclosingAST.kind() !== TypeScript.SyntaxKind.SimpleArrowFunctionExpression) {
                        var block = enclosingDecl.kind == TypeScript.PullElementKind.Method ? enclosingAST.block : enclosingAST.block;
                        if (!block) {
                            return;
                        }
                    }
                }
                this.resolveDeclaredSymbol(classSymbol, context);
                var parents = classSymbol.getExtendedTypes();
                if (parents.length) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(superAST, isDeclaration
                        ? TypeScript.DiagnosticCode.Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference
                        : TypeScript.DiagnosticCode.Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference));
                }
            }
        };
        PullTypeResolver.prototype.checkThisCaptureVariableCollides = function (_thisAST, isDeclaration, context) {
            if (isDeclaration) {
                var decl = this.semanticInfoChain.getDeclForAST(_thisAST);
                if (TypeScript.hasFlag(decl.flags, TypeScript.PullElementFlags.Ambient)) {
                    return;
                }
            }
            var enclosingDecl = this.getEnclosingDeclForAST(_thisAST);
            var enclosingModule = TypeScript.getEnclosingModuleDeclaration(_thisAST);
            if (TypeScript.isAnyNameOfModule(enclosingModule, _thisAST)) {
                enclosingDecl = this.getEnclosingDeclForAST(enclosingModule);
            }
            var declPath = enclosingDecl.getParentPath();
            for (var i = declPath.length - 1; i >= 0; i--) {
                var decl = declPath[i];
                var declKind = decl.kind;
                if (declKind === TypeScript.PullElementKind.FunctionExpression && TypeScript.hasFlag(decl.flags, TypeScript.PullElementFlags.ArrowFunction)) {
                    continue;
                }
                if (declKind === TypeScript.PullElementKind.Function ||
                    declKind === TypeScript.PullElementKind.Method ||
                    declKind === TypeScript.PullElementKind.ConstructorMethod ||
                    declKind === TypeScript.PullElementKind.GetAccessor ||
                    declKind === TypeScript.PullElementKind.SetAccessor ||
                    declKind === TypeScript.PullElementKind.FunctionExpression ||
                    declKind === TypeScript.PullElementKind.Class ||
                    declKind === TypeScript.PullElementKind.Container ||
                    declKind === TypeScript.PullElementKind.DynamicModule ||
                    declKind === TypeScript.PullElementKind.Script) {
                    if (TypeScript.hasFlag(decl.flags, TypeScript.PullElementFlags.MustCaptureThis)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(_thisAST, isDeclaration
                            ? TypeScript.DiagnosticCode.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference
                            : TypeScript.DiagnosticCode.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference));
                    }
                    break;
                }
            }
        };
        PullTypeResolver.prototype.postTypeCheckVariableDeclaratorOrParameter = function (varDeclOrParameter, context) {
            this.checkThisCaptureVariableCollides(varDeclOrParameter, true, context);
        };
        PullTypeResolver.prototype.resolveTypeParameterDeclaration = function (typeParameterAST, context) {
            var typeParameterDecl = this.semanticInfoChain.getDeclForAST(typeParameterAST);
            var typeParameterSymbol = typeParameterDecl.getSymbol();
            if (typeParameterSymbol.isResolved || typeParameterSymbol.inResolution) {
                if (typeParameterSymbol.isResolved && this.canTypeCheckAST(typeParameterAST, context)) {
                    this.typeCheckTypeParameterDeclaration(typeParameterAST, context);
                }
                return typeParameterSymbol;
            }
            typeParameterSymbol.startResolving();
            if (typeParameterAST.constraint) {
                var constraintTypeSymbol = this.resolveTypeReference(typeParameterAST.constraint.type, context);
                if (constraintTypeSymbol) {
                    typeParameterSymbol.setConstraint(constraintTypeSymbol);
                }
            }
            typeParameterSymbol.setResolved();
            if (this.canTypeCheckAST(typeParameterAST, context)) {
                this.setTypeChecked(typeParameterAST, context);
            }
            return typeParameterSymbol;
        };
        PullTypeResolver.prototype.typeCheckTypeParameterDeclaration = function (typeParameterAST, context) {
            this.setTypeChecked(typeParameterAST, context);
            this.resolveAST(typeParameterAST.constraint, false, context);
        };
        PullTypeResolver.prototype.resolveConstraint = function (constraint, context) {
            if (this.canTypeCheckAST(constraint, context)) {
                this.setTypeChecked(constraint, context);
            }
            return this.resolveTypeReference(constraint.type, context);
        };
        PullTypeResolver.prototype.resolveFunctionBodyReturnTypes = function (funcDeclAST, block, bodyExpression, signature, useContextualType, enclosingDecl, context) {
            var _this_1 = this;
            var returnStatementsExpressions = [];
            var enclosingDeclStack = [enclosingDecl];
            var preFindReturnExpressionTypes = function (ast, walker) {
                var go = true;
                switch (ast.kind()) {
                    case TypeScript.SyntaxKind.FunctionDeclaration:
                    case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
                    case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                    case TypeScript.SyntaxKind.FunctionExpression:
                        go = false;
                        break;
                    case TypeScript.SyntaxKind.ReturnStatement:
                        var returnStatement = ast;
                        enclosingDecl.setFlag(TypeScript.PullElementFlags.HasReturnStatement);
                        returnStatementsExpressions.push({ expression: returnStatement.expression, enclosingDecl: enclosingDeclStack[enclosingDeclStack.length - 1] });
                        go = false;
                        break;
                    case TypeScript.SyntaxKind.CatchClause:
                    case TypeScript.SyntaxKind.WithStatement:
                        enclosingDeclStack[enclosingDeclStack.length] = _this_1.semanticInfoChain.getDeclForAST(ast);
                        break;
                    default:
                        break;
                }
                walker.options.goChildren = go;
                return ast;
            };
            var postFindReturnExpressionEnclosingDecls = function (ast, walker) {
                switch (ast.kind()) {
                    case TypeScript.SyntaxKind.CatchClause:
                    case TypeScript.SyntaxKind.WithStatement:
                        enclosingDeclStack.length--;
                        break;
                    default:
                        break;
                }
                walker.options.goChildren = true;
                return ast;
            };
            if (block) {
                TypeScript.getAstWalkerFactory().walk(block, function (ast, walker) { preFindReturnExpressionTypes(ast, walker); }, function (ast, walker) { postFindReturnExpressionEnclosingDecls(ast, walker); });
            }
            else {
                returnStatementsExpressions.push({ expression: bodyExpression, enclosingDecl: enclosingDecl });
                enclosingDecl.setFlag(TypeScript.PullElementFlags.HasReturnStatement);
            }
            if (!returnStatementsExpressions.length) {
                signature.returnType = this.semanticInfoChain.voidTypeSymbol;
            }
            else {
                var returnExpressionSymbols = [];
                var returnExpressions = [];
                for (var i = 0; i < returnStatementsExpressions.length; i++) {
                    var returnExpression = returnStatementsExpressions[i].expression;
                    if (returnExpression) {
                        var returnType = this.resolveAST(returnExpression, useContextualType, context).type;
                        if (returnType.isError()) {
                            signature.returnType = returnType;
                            return;
                        }
                        else {
                            if (returnExpression.parent.kind() === TypeScript.SyntaxKind.ReturnStatement) {
                                this.setSymbolForAST(returnExpression.parent, returnType, context);
                            }
                        }
                        returnExpressionSymbols.push(returnType);
                        returnExpressions.push(returnExpression);
                    }
                }
                if (!returnExpressionSymbols.length) {
                    signature.returnType = this.semanticInfoChain.voidTypeSymbol;
                }
                else {
                    var collection = {
                        getLength: function () {
                            return returnExpressionSymbols.length;
                        },
                        getTypeAtIndex: function (index) {
                            return returnExpressionSymbols[index].type;
                        }
                    };
                    var bestCommonReturnType = this.findBestCommonType(collection, context, new TypeComparisonInfo());
                    var returnType = bestCommonReturnType;
                    var returnExpression = returnExpressions[returnExpressionSymbols.indexOf(returnType)];
                    if (useContextualType && returnType == this.semanticInfoChain.anyTypeSymbol) {
                        var contextualType = context.getContextualType();
                        if (contextualType) {
                            returnType = contextualType;
                        }
                    }
                    var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
                    var functionSymbol = functionDecl.getSymbol();
                    if (returnType) {
                        var previousReturnType = returnType;
                        var newReturnType = this.widenType(returnType, returnExpression, context);
                        signature.returnType = newReturnType;
                        if (!TypeScript.ArrayUtilities.contains(returnExpressionSymbols, bestCommonReturnType)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Could_not_find_the_best_common_type_of_types_of_all_return_statement_expressions));
                        }
                        if (this.compilationSettings.noImplicitAny()) {
                            if (previousReturnType !== newReturnType && newReturnType === this.semanticInfoChain.anyTypeSymbol) {
                                var functionName = enclosingDecl.name;
                                if (functionName == "") {
                                    functionName = enclosingDecl.getFunctionExpressionName();
                                }
                                if (functionName != "") {
                                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [functionName]));
                                }
                                else {
                                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type));
                                }
                            }
                        }
                    }
                    if (!functionSymbol.type && functionSymbol.isAccessor()) {
                        functionSymbol.type = signature.returnType;
                    }
                }
            }
        };
        PullTypeResolver.prototype.typeCheckConstructorDeclaration = function (funcDeclAST, context) {
            var _this_1 = this;
            this.setTypeChecked(funcDeclAST, context);
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            if (funcDeclAST.parameterList) {
                for (var i = 0; i < funcDeclAST.parameterList.parameters.nonSeparatorCount(); i++) {
                    this.resolveAST(funcDeclAST.parameterList.parameters.nonSeparatorAt(i), false, context);
                }
            }
            this.resolveAST(funcDeclAST.block, false, context);
            if (funcDecl.getSignatureSymbol() && funcDecl.getSignatureSymbol().isDefinition() && this.enclosingClassIsDerived(funcDecl.getParentDecl())) {
                if (!this.constructorHasSuperCall(funcDeclAST)) {
                    context.postDiagnostic(new TypeScript.Diagnostic(funcDeclAST.fileName(), this.semanticInfoChain.lineMap(funcDeclAST.fileName()), funcDeclAST.start(), 11, TypeScript.DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call));
                }
                else if (this.superCallMustBeFirstStatementInConstructor(funcDecl)) {
                    var firstStatement = this.getFirstStatementOfBlockOrNull(funcDeclAST.block);
                    if (!firstStatement || !this.isSuperInvocationExpressionStatement(firstStatement)) {
                        context.postDiagnostic(new TypeScript.Diagnostic(funcDeclAST.fileName(), this.semanticInfoChain.lineMap(funcDeclAST.fileName()), funcDeclAST.start(), 11, TypeScript.DiagnosticCode.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties));
                    }
                }
            }
            this.validateVariableDeclarationGroups(funcDecl, context);
            this.checkFunctionTypePrivacy(funcDeclAST, false, null, TypeScript.Parameters.fromParameterList(funcDeclAST.parameterList), null, funcDeclAST.block, context);
            this.typeCheckCallBacks.push(function (context) {
                _this_1.typeCheckFunctionOverloads(funcDeclAST, context);
            });
        };
        PullTypeResolver.prototype.constructorHasSuperCall = function (constructorDecl) {
            var _this_1 = this;
            if (constructorDecl.block) {
                var foundSuperCall = false;
                var pre = function (ast, walker) {
                    if (_this_1.isSuperInvocationExpression(ast)) {
                        foundSuperCall = true;
                        walker.options.stopWalking = true;
                    }
                };
                TypeScript.getAstWalkerFactory().walk(constructorDecl.block, pre);
                return foundSuperCall;
            }
            return false;
        };
        PullTypeResolver.prototype.typeCheckFunctionExpression = function (funcDecl, context) {
            this.typeCheckAnyFunctionExpression(funcDecl, funcDecl.callSignature.typeParameterList, TypeScript.getType(funcDecl), funcDecl.block, null, context);
        };
        PullTypeResolver.prototype.typeCheckCallSignature = function (funcDecl, context) {
            this.typeCheckFunctionDeclaration(funcDecl, false, null, funcDecl.typeParameterList, funcDecl.parameterList, TypeScript.getType(funcDecl), null, context);
        };
        PullTypeResolver.prototype.typeCheckConstructSignature = function (funcDecl, context) {
            this.typeCheckFunctionDeclaration(funcDecl, false, null, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.getType(funcDecl), null, context);
        };
        PullTypeResolver.prototype.typeCheckFunctionDeclaration = function (funcDeclAST, isStatic, name, typeParameters, parameters, returnTypeAnnotation, block, context) {
            var _this_1 = this;
            this.setTypeChecked(funcDeclAST, context);
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            if (typeParameters) {
                for (var i = 0; i < typeParameters.typeParameters.nonSeparatorCount(); i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.typeParameters.nonSeparatorAt(i), context);
                }
            }
            this.resolveAST(parameters, false, context);
            this.resolveAST(block, false, context);
            var enclosingDecl = this.getEnclosingDecl(funcDecl);
            this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, returnTypeAnnotation, context);
            this.validateVariableDeclarationGroups(funcDecl, context);
            this.checkFunctionTypePrivacy(funcDeclAST, isStatic, typeParameters, TypeScript.Parameters.fromParameterList(parameters), returnTypeAnnotation, block, context);
            var signature = funcDecl.getSignatureSymbol();
            var hasReturn = (funcDecl.flags & (TypeScript.PullElementFlags.Signature | TypeScript.PullElementFlags.HasReturnStatement)) != 0;
            if (funcDeclAST.kind() !== TypeScript.SyntaxKind.ConstructSignature && block && returnTypeAnnotation != null && !hasReturn) {
                var isVoidOrAny = this.isAnyOrEquivalent(signature.returnType) || signature.returnType === this.semanticInfoChain.voidTypeSymbol;
                if (!isVoidOrAny && !(block.statements.childCount() > 0 && block.statements.childAt(0).kind() === TypeScript.SyntaxKind.ThrowStatement)) {
                    var funcName = funcDecl.getDisplayName();
                    funcName = funcName ? funcName : "expression";
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnTypeAnnotation, TypeScript.DiagnosticCode.Function_0_declared_a_non_void_return_type_but_has_no_return_expression, [funcName]));
                }
            }
            if (funcDecl.kind === TypeScript.PullElementKind.Function) {
                this.checkNameForCompilerGeneratedDeclarationCollision(funcDeclAST, true, name, context);
            }
            this.typeCheckCallBacks.push(function (context) {
                _this_1.typeCheckFunctionOverloads(funcDeclAST, context);
            });
        };
        PullTypeResolver.prototype.typeCheckIndexSignature = function (funcDeclAST, context) {
            var _this_1 = this;
            this.setTypeChecked(funcDeclAST, context);
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            this.resolveAST(funcDeclAST.parameter, false, context);
            var enclosingDecl = this.getEnclosingDecl(funcDecl);
            this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, TypeScript.getType(funcDeclAST), context);
            this.validateVariableDeclarationGroups(funcDecl, context);
            this.checkFunctionTypePrivacy(funcDeclAST, false, null, TypeScript.Parameters.fromParameter(funcDeclAST.parameter), TypeScript.getType(funcDeclAST), null, context);
            var signature = funcDecl.getSignatureSymbol();
            this.typeCheckCallBacks.push(function (context) {
                var parentSymbol = funcDecl.getSignatureSymbol().getContainer();
                var allIndexSignatures = _this_1.getBothKindsOfIndexSignatures(parentSymbol, context);
                var stringIndexSignature = allIndexSignatures.stringSignature;
                var numberIndexSignature = allIndexSignatures.numericSignature;
                var isNumericIndexer = numberIndexSignature === signature;
                if (numberIndexSignature && stringIndexSignature &&
                    (isNumericIndexer || stringIndexSignature.getDeclarations()[0].getParentDecl() !== numberIndexSignature.getDeclarations()[0].getParentDecl())) {
                    var comparisonInfo = new TypeComparisonInfo();
                    if (!_this_1.sourceIsSubtypeOfTarget(numberIndexSignature.returnType, stringIndexSignature.returnType, funcDeclAST, context, comparisonInfo)) {
                        var enclosingSymbol = _this_1.getEnclosingSymbolForAST(funcDeclAST);
                        if (comparisonInfo.message) {
                            context.postDiagnostic(_this_1.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1_NL_2, [numberIndexSignature.returnType.toString(enclosingSymbol), stringIndexSignature.returnType.toString(enclosingSymbol), comparisonInfo.message]));
                        }
                        else {
                            context.postDiagnostic(_this_1.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1, [numberIndexSignature.returnType.toString(enclosingSymbol), stringIndexSignature.returnType.toString(enclosingSymbol)]));
                        }
                    }
                }
                var allMembers = parentSymbol.type.getAllMembers(TypeScript.PullElementKind.All, TypeScript.GetAllMembersVisiblity.all);
                for (var i = 0; i < allMembers.length; i++) {
                    var member = allMembers[i];
                    var name = member.name;
                    if (name || (member.kind === TypeScript.PullElementKind.Property && name === "")) {
                        if (!allMembers[i].isResolved) {
                            _this_1.resolveDeclaredSymbol(allMembers[i], context);
                        }
                        if (parentSymbol !== allMembers[i].getContainer()) {
                            var isMemberNumeric = TypeScript.PullHelpers.isNameNumeric(name);
                            var indexerKindMatchesMemberNameKind = isNumericIndexer === isMemberNumeric;
                            var onlyStringIndexerIsPresent = !numberIndexSignature;
                            if (indexerKindMatchesMemberNameKind || onlyStringIndexerIsPresent) {
                                var comparisonInfo = new TypeComparisonInfo();
                                if (!_this_1.sourceIsSubtypeOfTarget(allMembers[i].type, signature.returnType, funcDeclAST, context, comparisonInfo, false)) {
                                    _this_1.reportErrorThatMemberIsNotSubtypeOfIndexer(allMembers[i], signature, funcDeclAST, context, comparisonInfo);
                                }
                            }
                        }
                    }
                }
            });
        };
        PullTypeResolver.prototype.postTypeCheckFunctionDeclaration = function (funcDeclAST, context) {
            this.checkThisCaptureVariableCollides(funcDeclAST, true, context);
        };
        PullTypeResolver.prototype.resolveReturnTypeAnnotationOfFunctionDeclaration = function (funcDeclAST, returnTypeAnnotation, context) {
            var returnTypeSymbol = null;
            if (returnTypeAnnotation) {
                var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
                returnTypeSymbol = this.resolveTypeReference(returnTypeAnnotation, context);
                if (!returnTypeSymbol) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnTypeAnnotation, TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference));
                }
                else {
                    var isConstructor = funcDeclAST.kind() === TypeScript.SyntaxKind.ConstructorDeclaration || funcDeclAST.kind() === TypeScript.SyntaxKind.ConstructSignature;
                    if (isConstructor && returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Constructors_cannot_have_a_return_type_of_void));
                    }
                }
            }
            return returnTypeSymbol;
        };
        PullTypeResolver.prototype.resolveMemberFunctionDeclaration = function (funcDecl, context) {
            return this.resolveFunctionDeclaration(funcDecl, TypeScript.hasModifier(funcDecl.modifiers, TypeScript.PullElementFlags.Static), funcDecl.propertyName, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.getType(funcDecl), funcDecl.block, context);
        };
        PullTypeResolver.prototype.resolveCallSignature = function (funcDecl, context) {
            return this.resolveFunctionDeclaration(funcDecl, false, null, funcDecl.typeParameterList, funcDecl.parameterList, TypeScript.getType(funcDecl), null, context);
        };
        PullTypeResolver.prototype.resolveConstructSignature = function (funcDecl, context) {
            return this.resolveFunctionDeclaration(funcDecl, false, null, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.getType(funcDecl), null, context);
        };
        PullTypeResolver.prototype.resolveMethodSignature = function (funcDecl, context) {
            return this.resolveFunctionDeclaration(funcDecl, false, funcDecl.propertyName, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.getType(funcDecl), null, context);
        };
        PullTypeResolver.prototype.resolveAnyFunctionDeclaration = function (funcDecl, context) {
            return this.resolveFunctionDeclaration(funcDecl, TypeScript.hasModifier(funcDecl.modifiers, TypeScript.PullElementFlags.Static), funcDecl.identifier, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.getType(funcDecl), funcDecl.block, context);
        };
        PullTypeResolver.prototype.resolveFunctionExpression = function (funcDecl, isContextuallyTyped, context) {
            return this.resolveAnyFunctionExpression(funcDecl, funcDecl.callSignature.typeParameterList, TypeScript.Parameters.fromParameterList(funcDecl.callSignature.parameterList), TypeScript.getType(funcDecl), funcDecl.block, null, isContextuallyTyped, context);
        };
        PullTypeResolver.prototype.resolveSimpleArrowFunctionExpression = function (funcDecl, isContextuallyTyped, context) {
            return this.resolveAnyFunctionExpression(funcDecl, null, TypeScript.Parameters.fromIdentifier(funcDecl.identifier), null, funcDecl.block, funcDecl.expression, isContextuallyTyped, context);
        };
        PullTypeResolver.prototype.resolveParenthesizedArrowFunctionExpression = function (funcDecl, isContextuallyTyped, context) {
            return this.resolveAnyFunctionExpression(funcDecl, funcDecl.callSignature.typeParameterList, TypeScript.Parameters.fromParameterList(funcDecl.callSignature.parameterList), TypeScript.getType(funcDecl), funcDecl.block, funcDecl.expression, isContextuallyTyped, context);
        };
        PullTypeResolver.prototype.getEnclosingClassDeclaration = function (ast) {
            while (ast) {
                if (ast.kind() === TypeScript.SyntaxKind.ClassDeclaration) {
                    return ast;
                }
                ast = ast.parent;
            }
            return null;
        };
        PullTypeResolver.prototype.resolveConstructorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var funcSymbol = funcDecl.getSymbol();
            var signature = funcDecl.getSignatureSymbol();
            var hadError = false;
            if (signature) {
                if (signature.isResolved) {
                    if (this.canTypeCheckAST(funcDeclAST, context)) {
                        this.typeCheckConstructorDeclaration(funcDeclAST, context);
                    }
                    return funcSymbol;
                }
                if (!signature.inResolution) {
                    var classAST = this.getEnclosingClassDeclaration(funcDeclAST);
                    if (classAST) {
                        var classDecl = this.semanticInfoChain.getDeclForAST(classAST);
                        var classSymbol = classDecl.getSymbol();
                        if (!classSymbol.isResolved && !classSymbol.inResolution) {
                            this.resolveDeclaredSymbol(classSymbol, context);
                        }
                    }
                }
                var functionTypeSymbol = funcSymbol && funcSymbol.type;
                if (signature.inResolution) {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                    return funcSymbol;
                }
                if (funcSymbol) {
                    funcSymbol.startResolving();
                }
                signature.startResolving();
                if (funcDeclAST.parameterList) {
                    var prevInTypeCheck = context.inTypeCheck;
                    context.inTypeCheck = false;
                    for (var i = 0; i < funcDeclAST.parameterList.parameters.nonSeparatorCount(); i++) {
                        this.resolveParameter(funcDeclAST.parameterList.parameters.nonSeparatorAt(i), context);
                    }
                    context.inTypeCheck = prevInTypeCheck;
                }
                if (signature.isGeneric()) {
                    if (funcSymbol) {
                        funcSymbol.type.setHasGenericSignature();
                    }
                }
                if (!hadError) {
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                }
            }
            if (funcSymbol) {
                this.resolveOtherDeclarations(funcDeclAST, context);
            }
            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckConstructorDeclaration(funcDeclAST, context);
            }
            return funcSymbol;
        };
        PullTypeResolver.prototype.resolveIndexMemberDeclaration = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
            }
            return this.resolveIndexSignature(ast.indexSignature, context);
        };
        PullTypeResolver.prototype.resolveIndexSignature = function (funcDeclAST, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var funcSymbol = funcDecl.getSymbol();
            var signature = funcDecl.getSignatureSymbol();
            var hadError = false;
            if (signature) {
                if (signature.isResolved) {
                    if (this.canTypeCheckAST(funcDeclAST, context)) {
                        this.typeCheckIndexSignature(funcDeclAST, context);
                    }
                    return funcSymbol;
                }
                var functionTypeSymbol = funcSymbol && funcSymbol.type;
                var returnTypeSymbol;
                if (signature.inResolution) {
                    if (funcDeclAST.typeAnnotation) {
                        returnTypeSymbol = this.resolveTypeReference(TypeScript.getType(funcDeclAST), context);
                        if (!returnTypeSymbol) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(TypeScript.getType(funcDeclAST), TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference));
                            signature.returnType = this.getNewErrorTypeSymbol();
                            hadError = true;
                        }
                        else {
                            signature.returnType = returnTypeSymbol;
                        }
                    }
                    else {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    }
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                    return funcSymbol;
                }
                if (funcSymbol) {
                    funcSymbol.startResolving();
                }
                signature.startResolving();
                if (funcDeclAST.parameter) {
                    var prevInTypeCheck = context.inTypeCheck;
                    context.inTypeCheck = false;
                    this.resolveParameter(funcDeclAST.parameter, context);
                    context.inTypeCheck = prevInTypeCheck;
                }
                if (funcDeclAST.typeAnnotation) {
                    returnTypeSymbol = this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, TypeScript.getType(funcDeclAST), context);
                    if (!returnTypeSymbol) {
                        signature.returnType = this.getNewErrorTypeSymbol();
                        hadError = true;
                    }
                    else {
                        signature.returnType = returnTypeSymbol;
                    }
                }
                else {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    var parentDeclFlags = TypeScript.PullElementFlags.None;
                    if (TypeScript.hasFlag(funcDecl.kind, TypeScript.PullElementKind.Method) ||
                        TypeScript.hasFlag(funcDecl.kind, TypeScript.PullElementKind.ConstructorMethod)) {
                        var parentDecl = funcDecl.getParentDecl();
                        parentDeclFlags = parentDecl.flags;
                    }
                    if (this.compilationSettings.noImplicitAny() &&
                        (!TypeScript.hasFlag(parentDeclFlags, TypeScript.PullElementFlags.Ambient) ||
                            (TypeScript.hasFlag(parentDeclFlags, TypeScript.PullElementFlags.Ambient) && !TypeScript.hasFlag(funcDecl.flags, TypeScript.PullElementFlags.Private)))) {
                        var funcDeclASTName = name;
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, ["Indexer"]));
                    }
                }
                if (!hadError) {
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                }
            }
            if (funcSymbol) {
                this.resolveOtherDeclarations(funcDeclAST, context);
            }
            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckIndexSignature(funcDeclAST, context);
            }
            return funcSymbol;
        };
        PullTypeResolver.prototype.resolveFunctionDeclaration = function (funcDeclAST, isStatic, name, typeParameters, parameterList, returnTypeAnnotation, block, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var funcSymbol = funcDecl.getSymbol();
            var signature = funcDecl.getSignatureSymbol();
            var hadError = false;
            var isConstructor = funcDeclAST.kind() === TypeScript.SyntaxKind.ConstructSignature;
            if (signature) {
                if (signature.isResolved) {
                    if (this.canTypeCheckAST(funcDeclAST, context)) {
                        this.typeCheckFunctionDeclaration(funcDeclAST, isStatic, name, typeParameters, parameterList, returnTypeAnnotation, block, context);
                    }
                    return funcSymbol;
                }
                if (isConstructor && !signature.inResolution) {
                    var classAST = this.getEnclosingClassDeclaration(funcDeclAST);
                    if (classAST) {
                        var classDecl = this.semanticInfoChain.getDeclForAST(classAST);
                        var classSymbol = classDecl.getSymbol();
                        if (!classSymbol.isResolved && !classSymbol.inResolution) {
                            this.resolveDeclaredSymbol(classSymbol, context);
                        }
                    }
                }
                var functionTypeSymbol = funcSymbol && funcSymbol.type;
                var returnTypeSymbol;
                if (signature.inResolution) {
                    if (returnTypeAnnotation) {
                        returnTypeSymbol = this.resolveTypeReference(returnTypeAnnotation, context);
                        if (!returnTypeSymbol) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnTypeAnnotation, TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference));
                            signature.returnType = this.getNewErrorTypeSymbol();
                            hadError = true;
                        }
                        else {
                            signature.returnType = returnTypeSymbol;
                            if (isConstructor && returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol) {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Constructors_cannot_have_a_return_type_of_void));
                            }
                        }
                    }
                    else {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    }
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                    return funcSymbol;
                }
                if (funcSymbol) {
                    funcSymbol.startResolving();
                }
                signature.startResolving();
                if (typeParameters) {
                    for (var i = 0; i < typeParameters.typeParameters.nonSeparatorCount(); i++) {
                        this.resolveTypeParameterDeclaration(typeParameters.typeParameters.nonSeparatorAt(i), context);
                    }
                }
                if (parameterList) {
                    var prevInTypeCheck = context.inTypeCheck;
                    context.inTypeCheck = false;
                    for (var i = 0; i < parameterList.parameters.nonSeparatorCount(); i++) {
                        this.resolveParameter(parameterList.parameters.nonSeparatorAt(i), context);
                    }
                    context.inTypeCheck = prevInTypeCheck;
                }
                if (returnTypeAnnotation) {
                    returnTypeSymbol = this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, returnTypeAnnotation, context);
                    if (!returnTypeSymbol) {
                        signature.returnType = this.getNewErrorTypeSymbol();
                        hadError = true;
                    }
                    else {
                        signature.returnType = returnTypeSymbol;
                    }
                }
                else if (funcDecl.kind !== TypeScript.PullElementKind.ConstructSignature) {
                    if (TypeScript.hasFlag(funcDecl.flags, TypeScript.PullElementFlags.Signature)) {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                        var parentDeclFlags = TypeScript.PullElementFlags.None;
                        if (TypeScript.hasFlag(funcDecl.kind, TypeScript.PullElementKind.Method) ||
                            TypeScript.hasFlag(funcDecl.kind, TypeScript.PullElementKind.ConstructorMethod)) {
                            var parentDecl = funcDecl.getParentDecl();
                            parentDeclFlags = parentDecl.flags;
                        }
                        if (this.compilationSettings.noImplicitAny() &&
                            (!TypeScript.hasFlag(parentDeclFlags, TypeScript.PullElementFlags.Ambient) ||
                                (TypeScript.hasFlag(parentDeclFlags, TypeScript.PullElementFlags.Ambient) && !TypeScript.hasFlag(funcDecl.flags, TypeScript.PullElementFlags.Private)))) {
                            var funcDeclASTName = name;
                            if (funcDeclASTName) {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [funcDeclASTName.text()]));
                            }
                            else {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type));
                            }
                        }
                    }
                    else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, block, null, signature, false, funcDecl, context);
                    }
                }
                else if (funcDecl.kind === TypeScript.PullElementKind.ConstructSignature) {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    if (this.compilationSettings.noImplicitAny()) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type));
                    }
                }
                if (!hadError) {
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                }
            }
            if (funcSymbol) {
                this.resolveOtherDeclarations(funcDeclAST, context);
            }
            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckFunctionDeclaration(funcDeclAST, isStatic, name, typeParameters, parameterList, returnTypeAnnotation, block, context);
            }
            return funcSymbol;
        };
        PullTypeResolver.prototype.resolveGetterReturnTypeAnnotation = function (getterFunctionDeclarationAst, enclosingDecl, context) {
            if (getterFunctionDeclarationAst && getterFunctionDeclarationAst.typeAnnotation) {
                return this.resolveTypeReference(TypeScript.getType(getterFunctionDeclarationAst), context);
            }
            return null;
        };
        PullTypeResolver.prototype.resolveSetterArgumentTypeAnnotation = function (setterFunctionDeclarationAst, enclosingDecl, context) {
            if (setterFunctionDeclarationAst &&
                setterFunctionDeclarationAst.parameterList &&
                setterFunctionDeclarationAst.parameterList.parameters.nonSeparatorCount() > 0) {
                var parameter = setterFunctionDeclarationAst.parameterList.parameters.nonSeparatorAt(0);
                return this.resolveTypeReference(TypeScript.getType(parameter), context);
            }
            return null;
        };
        PullTypeResolver.prototype.resolveAccessorDeclaration = function (funcDeclAst, context) {
            var functionDeclaration = this.semanticInfoChain.getDeclForAST(funcDeclAst);
            var accessorSymbol = functionDeclaration.getSymbol();
            if (accessorSymbol.inResolution) {
                accessorSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                accessorSymbol.setResolved();
                return accessorSymbol;
            }
            if (accessorSymbol.isResolved) {
                if (!accessorSymbol.type) {
                    accessorSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            else {
                var getterSymbol = accessorSymbol.getGetter();
                var getterFunctionDeclarationAst = getterSymbol ? getterSymbol.getDeclarations()[0].ast() : null;
                var hasGetter = getterSymbol !== null;
                var setterSymbol = accessorSymbol.getSetter();
                var setterFunctionDeclarationAst = setterSymbol ? setterSymbol.getDeclarations()[0].ast() : null;
                var hasSetter = setterSymbol !== null;
                var getterAnnotatedType = this.resolveGetterReturnTypeAnnotation(getterFunctionDeclarationAst, functionDeclaration, context);
                var getterHasTypeAnnotation = getterAnnotatedType !== null;
                var setterAnnotatedType = this.resolveSetterArgumentTypeAnnotation(setterFunctionDeclarationAst, functionDeclaration, context);
                var setterHasTypeAnnotation = setterAnnotatedType !== null;
                accessorSymbol.startResolving();
                if (hasGetter) {
                    getterSymbol =
                        this.resolveGetAccessorDeclaration(getterFunctionDeclarationAst, getterFunctionDeclarationAst.parameterList, TypeScript.getType(getterFunctionDeclarationAst), getterFunctionDeclarationAst.block, setterAnnotatedType, context);
                }
                if (hasSetter) {
                    setterSymbol = this.resolveSetAccessorDeclaration(setterFunctionDeclarationAst, setterFunctionDeclarationAst.parameterList, context);
                }
                if (hasGetter && hasSetter) {
                    var setterSig = setterSymbol.type.getCallSignatures()[0];
                    var setterParameters = setterSig.parameters;
                    var setterHasParameters = setterParameters.length > 0;
                    var getterSig = getterSymbol.type.getCallSignatures()[0];
                    var setterSuppliedTypeSymbol = setterHasParameters ? setterParameters[0].type : null;
                    var getterSuppliedTypeSymbol = getterSig.returnType;
                    if (setterHasTypeAnnotation && !getterHasTypeAnnotation) {
                        getterSuppliedTypeSymbol = setterSuppliedTypeSymbol;
                        getterSig.returnType = setterSuppliedTypeSymbol;
                    }
                    else if ((getterHasTypeAnnotation && !setterHasTypeAnnotation) ||
                        (!getterHasTypeAnnotation && !setterHasTypeAnnotation)) {
                        setterSuppliedTypeSymbol = getterSuppliedTypeSymbol;
                        if (setterHasParameters) {
                            setterParameters[0].type = getterSuppliedTypeSymbol;
                        }
                    }
                    if (!this.typesAreIdentical(setterSuppliedTypeSymbol, getterSuppliedTypeSymbol)) {
                        accessorSymbol.type = this.getNewErrorTypeSymbol();
                    }
                    else {
                        accessorSymbol.type = getterSuppliedTypeSymbol;
                    }
                }
                else if (hasSetter) {
                    var setterSig = setterSymbol.type.getCallSignatures()[0];
                    var setterParameters = setterSig.parameters;
                    var setterHasParameters = setterParameters.length > 0;
                    accessorSymbol.type = setterHasParameters ? setterParameters[0].type : this.semanticInfoChain.anyTypeSymbol;
                }
                else {
                    var getterSig = getterSymbol.type.getCallSignatures()[0];
                    accessorSymbol.type = getterSig.returnType;
                }
                accessorSymbol.setResolved();
            }
            if (this.canTypeCheckAST(funcDeclAst, context)) {
                this.typeCheckAccessorDeclaration(funcDeclAst, context);
            }
            return accessorSymbol;
        };
        PullTypeResolver.prototype.typeCheckAccessorDeclaration = function (funcDeclAst, context) {
            this.setTypeChecked(funcDeclAst, context);
            var functionDeclaration = this.semanticInfoChain.getDeclForAST(funcDeclAst);
            var accessorSymbol = functionDeclaration.getSymbol();
            var getterSymbol = accessorSymbol.getGetter();
            var setterSymbol = accessorSymbol.getSetter();
            var isGetter = funcDeclAst.kind() == TypeScript.SyntaxKind.GetAccessor;
            if (isGetter) {
                var getterFunctionDeclarationAst = funcDeclAst;
                context.pushContextualType(getterSymbol.type, context.inProvisionalResolution(), null);
                this.typeCheckGetAccessorDeclaration(getterFunctionDeclarationAst, context);
                context.popContextualType();
            }
            else {
                var setterFunctionDeclarationAst = funcDeclAst;
                this.typeCheckSetAccessorDeclaration(setterFunctionDeclarationAst, context);
            }
        };
        PullTypeResolver.prototype.resolveGetAccessorDeclaration = function (funcDeclAST, parameters, returnTypeAnnotation, block, setterAnnotatedType, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();
            var getterSymbol = accessorSymbol.getGetter();
            var getterTypeSymbol = getterSymbol.type;
            var signature = getterTypeSymbol.getCallSignatures()[0];
            var hadError = false;
            if (signature) {
                if (signature.isResolved) {
                    return getterSymbol;
                }
                if (signature.inResolution) {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    signature.setResolved();
                    return getterSymbol;
                }
                signature.startResolving();
                if (returnTypeAnnotation) {
                    var returnTypeSymbol = this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, returnTypeAnnotation, context);
                    if (!returnTypeSymbol) {
                        signature.returnType = this.getNewErrorTypeSymbol();
                        hadError = true;
                    }
                    else {
                        signature.returnType = returnTypeSymbol;
                    }
                }
                else {
                    if (!setterAnnotatedType) {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, block, null, signature, false, funcDecl, context);
                    }
                    else {
                        signature.returnType = setterAnnotatedType;
                    }
                }
                if (!hadError) {
                    signature.setResolved();
                }
            }
            funcDeclAST.inferredType = signature.returnType;
            return getterSymbol;
        };
        PullTypeResolver.prototype.checkIfGetterAndSetterTypeMatch = function (funcDeclAST, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();
            var getter = accessorSymbol.getGetter();
            var setter = accessorSymbol.getSetter();
            if (getter && setter) {
                var getterAST = getter.getDeclarations()[0].ast();
                var setterAST = setter.getDeclarations()[0].ast();
                if (getterAST.typeAnnotation && PullTypeResolver.hasSetAccessorParameterTypeAnnotation(setterAST)) {
                    var setterSig = setter.type.getCallSignatures()[0];
                    var setterParameters = setterSig.parameters;
                    var getter = accessorSymbol.getGetter();
                    var getterSig = getter.type.getCallSignatures()[0];
                    var setterSuppliedTypeSymbol = setterParameters[0].type;
                    var getterSuppliedTypeSymbol = getterSig.returnType;
                    if (!this.typesAreIdentical(setterSuppliedTypeSymbol, getterSuppliedTypeSymbol)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.get_and_set_accessor_must_have_the_same_type));
                    }
                }
            }
        };
        PullTypeResolver.prototype.typeCheckGetAccessorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();
            this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, TypeScript.getType(funcDeclAST), context);
            this.resolveAST(funcDeclAST.block, false, context);
            this.validateVariableDeclarationGroups(funcDecl, context);
            var enclosingDecl = this.getEnclosingDecl(funcDecl);
            var hasReturn = (funcDecl.flags & (TypeScript.PullElementFlags.Signature | TypeScript.PullElementFlags.HasReturnStatement)) != 0;
            var funcNameAST = funcDeclAST.propertyName;
            if (!hasReturn &&
                !(funcDeclAST.block.statements.childCount() > 0 && funcDeclAST.block.statements.childAt(0).kind() === TypeScript.SyntaxKind.ThrowStatement)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcNameAST, TypeScript.DiagnosticCode.Getters_must_return_a_value));
            }
            var setter = accessorSymbol.getSetter();
            if (setter) {
                var setterDecl = setter.getDeclarations()[0];
                var setterIsPrivate = TypeScript.hasFlag(setterDecl.flags, TypeScript.PullElementFlags.Private);
                var getterIsPrivate = TypeScript.hasModifier(funcDeclAST.modifiers, TypeScript.PullElementFlags.Private);
                if (getterIsPrivate != setterIsPrivate) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcNameAST, TypeScript.DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility));
                }
                this.checkIfGetterAndSetterTypeMatch(funcDeclAST, context);
            }
            this.checkFunctionTypePrivacy(funcDeclAST, TypeScript.hasModifier(funcDeclAST.modifiers, TypeScript.PullElementFlags.Static), null, TypeScript.Parameters.fromParameterList(funcDeclAST.parameterList), TypeScript.getType(funcDeclAST), funcDeclAST.block, context);
        };
        PullTypeResolver.hasSetAccessorParameterTypeAnnotation = function (setAccessor) {
            return setAccessor.parameterList && setAccessor.parameterList.parameters.nonSeparatorCount() > 0 && setAccessor.parameterList.parameters.nonSeparatorAt(0).typeAnnotation != null;
        };
        PullTypeResolver.prototype.resolveSetAccessorDeclaration = function (funcDeclAST, parameterList, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();
            var setterSymbol = accessorSymbol.getSetter();
            var setterTypeSymbol = setterSymbol.type;
            var signature = funcDecl.getSignatureSymbol();
            var hadError = false;
            if (signature) {
                if (signature.isResolved) {
                    return setterSymbol;
                }
                if (signature.inResolution) {
                    signature.returnType = this.semanticInfoChain.voidTypeSymbol;
                    signature.setResolved();
                    return setterSymbol;
                }
                signature.startResolving();
                if (parameterList) {
                    for (var i = 0; i < parameterList.parameters.nonSeparatorCount(); i++) {
                        this.resolveParameter(parameterList.parameters.nonSeparatorAt(i), context);
                    }
                }
                signature.returnType = this.semanticInfoChain.voidTypeSymbol;
                if (signature.hasAGenericParameter) {
                    setterTypeSymbol.setHasGenericSignature();
                }
                if (!hadError) {
                    signature.setResolved();
                }
            }
            funcDeclAST.inferredType = signature;
            return setterSymbol;
        };
        PullTypeResolver.prototype.typeCheckSetAccessorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();
            if (funcDeclAST.parameterList) {
                for (var i = 0; i < funcDeclAST.parameterList.parameters.nonSeparatorCount(); i++) {
                    this.resolveParameter(funcDeclAST.parameterList.parameters.nonSeparatorAt(i), context);
                }
            }
            this.resolveAST(funcDeclAST.block, false, context);
            this.validateVariableDeclarationGroups(funcDecl, context);
            var hasReturn = (funcDecl.flags & (TypeScript.PullElementFlags.Signature | TypeScript.PullElementFlags.HasReturnStatement)) != 0;
            var getter = accessorSymbol.getGetter();
            var funcNameAST = funcDeclAST.propertyName;
            if (getter) {
                var getterDecl = getter.getDeclarations()[0];
                var getterIsPrivate = TypeScript.hasFlag(getterDecl.flags, TypeScript.PullElementFlags.Private);
                var setterIsPrivate = TypeScript.hasModifier(funcDeclAST.modifiers, TypeScript.PullElementFlags.Private);
                if (getterIsPrivate != setterIsPrivate) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcNameAST, TypeScript.DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility));
                }
                this.checkIfGetterAndSetterTypeMatch(funcDeclAST, context);
            }
            else {
                if (this.compilationSettings.noImplicitAny()) {
                    var setterFunctionDeclarationAst = funcDeclAST;
                    if (!PullTypeResolver.hasSetAccessorParameterTypeAnnotation(setterFunctionDeclarationAst) && accessorSymbol.type == this.semanticInfoChain.anyTypeSymbol) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode._0_which_lacks_get_accessor_and_parameter_type_annotation_on_set_accessor_implicitly_has_an_any_type, [setterFunctionDeclarationAst.propertyName.text()]));
                    }
                }
            }
            this.checkFunctionTypePrivacy(funcDeclAST, TypeScript.hasModifier(funcDeclAST.modifiers, TypeScript.PullElementFlags.Static), null, TypeScript.Parameters.fromParameterList(funcDeclAST.parameterList), null, funcDeclAST.block, context);
        };
        PullTypeResolver.prototype.resolveList = function (list, context) {
            if (this.canTypeCheckAST(list, context)) {
                this.setTypeChecked(list, context);
                for (var i = 0, n = list.childCount(); i < n; i++) {
                    this.resolveAST(list.childAt(i), false, context);
                }
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.resolveSeparatedList = function (list, context) {
            if (this.canTypeCheckAST(list, context)) {
                this.setTypeChecked(list, context);
                for (var i = 0, n = list.nonSeparatorCount(); i < n; i++) {
                    this.resolveAST(list.nonSeparatorAt(i), false, context);
                }
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.resolveVoidExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.expression, false, context);
            }
            return this.semanticInfoChain.undefinedTypeSymbol;
        };
        PullTypeResolver.prototype.resolveLogicalOperation = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckLogicalOperation(ast, context);
            }
            return this.semanticInfoChain.booleanTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckLogicalOperation = function (binex, context) {
            this.setTypeChecked(binex, context);
            var leftType = this.resolveAST(binex.left, false, context).type;
            var rightType = this.resolveAST(binex.right, false, context).type;
            var comparisonInfo = new TypeComparisonInfo();
            if (!this.sourceIsAssignableToTarget(leftType, rightType, binex, context, comparisonInfo) &&
                !this.sourceIsAssignableToTarget(rightType, leftType, binex, context, comparisonInfo)) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(binex);
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binex, TypeScript.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, [TypeScript.SyntaxFacts.getText(TypeScript.SyntaxFacts.getOperatorTokenFromBinaryExpression(binex.kind())),
                    leftType.toString(enclosingSymbol), rightType.toString(enclosingSymbol)]));
            }
        };
        PullTypeResolver.prototype.resolveLogicalNotExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.operand, false, context);
            }
            return this.semanticInfoChain.booleanTypeSymbol;
        };
        PullTypeResolver.prototype.resolveUnaryArithmeticOperation = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckUnaryArithmeticOperation(ast, context);
            }
            return this.semanticInfoChain.numberTypeSymbol;
        };
        PullTypeResolver.prototype.resolvePostfixUnaryExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckPostfixUnaryExpression(ast, context);
            }
            return this.semanticInfoChain.numberTypeSymbol;
        };
        PullTypeResolver.prototype.isAnyOrNumberOrEnum = function (type) {
            return this.isAnyOrEquivalent(type) || type === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(type);
        };
        PullTypeResolver.prototype.typeCheckUnaryArithmeticOperation = function (unaryExpression, context) {
            this.setTypeChecked(unaryExpression, context);
            var nodeType = unaryExpression.kind();
            var expression = this.resolveAST(unaryExpression.operand, false, context);
            if (nodeType == TypeScript.SyntaxKind.PlusExpression || nodeType == TypeScript.SyntaxKind.NegateExpression || nodeType == TypeScript.SyntaxKind.BitwiseNotExpression) {
                return;
            }
            TypeScript.Debug.assert(nodeType === TypeScript.SyntaxKind.PreIncrementExpression ||
                nodeType === TypeScript.SyntaxKind.PreDecrementExpression);
            var operandType = expression.type;
            if (!this.isAnyOrNumberOrEnum(operandType)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(unaryExpression.operand, TypeScript.DiagnosticCode.The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type_any_number_or_an_enum_type));
            }
            if (!this.isReference(unaryExpression.operand, expression)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(unaryExpression.operand, TypeScript.DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer));
            }
        };
        PullTypeResolver.prototype.typeCheckPostfixUnaryExpression = function (unaryExpression, context) {
            this.setTypeChecked(unaryExpression, context);
            var nodeType = unaryExpression.kind();
            var expression = this.resolveAST(unaryExpression.operand, false, context);
            TypeScript.Debug.assert(nodeType === TypeScript.SyntaxKind.PostIncrementExpression ||
                nodeType === TypeScript.SyntaxKind.PostDecrementExpression);
            var operandType = expression.type;
            if (!this.isAnyOrNumberOrEnum(operandType)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(unaryExpression.operand, TypeScript.DiagnosticCode.The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type_any_number_or_an_enum_type));
            }
            if (!this.isReference(unaryExpression.operand, expression)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(unaryExpression.operand, TypeScript.DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer));
            }
        };
        PullTypeResolver.prototype.resolveBinaryArithmeticExpression = function (binaryExpression, context) {
            if (this.canTypeCheckAST(binaryExpression, context)) {
                this.typeCheckBinaryArithmeticExpression(binaryExpression, context);
            }
            return this.semanticInfoChain.numberTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckBinaryArithmeticExpression = function (binaryExpression, context) {
            this.setTypeChecked(binaryExpression, context);
            var lhsSymbol = this.resolveAST(binaryExpression.left, false, context);
            var lhsType = lhsSymbol.type;
            var rhsType = this.resolveAST(binaryExpression.right, false, context).type;
            if (lhsType === this.semanticInfoChain.nullTypeSymbol || lhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                lhsType = rhsType;
            }
            if (rhsType === this.semanticInfoChain.nullTypeSymbol || rhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                rhsType = lhsType;
            }
            var lhsIsFit = this.isAnyOrNumberOrEnum(lhsType);
            var rhsIsFit = this.isAnyOrNumberOrEnum(rhsType);
            if (!rhsIsFit) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.right, TypeScript.DiagnosticCode.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type));
            }
            if (!lhsIsFit) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type));
            }
            if (lhsIsFit && rhsIsFit) {
                switch (binaryExpression.kind()) {
                    case TypeScript.SyntaxKind.LeftShiftAssignmentExpression:
                    case TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression:
                    case TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression:
                    case TypeScript.SyntaxKind.SubtractAssignmentExpression:
                    case TypeScript.SyntaxKind.MultiplyAssignmentExpression:
                    case TypeScript.SyntaxKind.DivideAssignmentExpression:
                    case TypeScript.SyntaxKind.ModuloAssignmentExpression:
                    case TypeScript.SyntaxKind.OrAssignmentExpression:
                    case TypeScript.SyntaxKind.AndAssignmentExpression:
                    case TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression:
                        if (!this.isReference(binaryExpression.left, lhsSymbol)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression));
                        }
                        this.checkAssignability(binaryExpression.left, rhsType, lhsType, context);
                }
            }
        };
        PullTypeResolver.prototype.resolveTypeOfExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.expression, false, context);
            }
            return this.semanticInfoChain.stringTypeSymbol;
        };
        PullTypeResolver.prototype.resolveThrowStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.expression, false, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.resolveDeleteExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.expression, false, context);
            }
            return this.semanticInfoChain.booleanTypeSymbol;
        };
        PullTypeResolver.prototype.resolveInstanceOfExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckInstanceOfExpression(ast, context);
            }
            return this.semanticInfoChain.booleanTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckInstanceOfExpression = function (binaryExpression, context) {
            this.setTypeChecked(binaryExpression, context);
            var lhsType = this.resolveAST(binaryExpression.left, false, context).type;
            var rhsType = this.resolveAST(binaryExpression.right, false, context).type;
            var enclosingSymbol = this.getEnclosingSymbolForAST(binaryExpression);
            var isValidLHS = this.isAnyOrEquivalent(lhsType) || lhsType.isObject() || lhsType.isTypeParameter();
            var isValidRHS = this.isAnyOrEquivalent(rhsType) || this.typeIsSubtypeOfFunction(rhsType, binaryExpression, context);
            if (!isValidLHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter));
            }
            if (!isValidRHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.right, TypeScript.DiagnosticCode.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_a_subtype_of_the_Function_interface_type));
            }
        };
        PullTypeResolver.prototype.resolveCommaExpression = function (commaExpression, context) {
            if (this.canTypeCheckAST(commaExpression, context)) {
                this.setTypeChecked(commaExpression, context);
                this.resolveAST(commaExpression.left, false, context);
            }
            var rhsType = this.resolveAST(commaExpression.right, false, context).type;
            return this.resolveAST(commaExpression.right, false, context).type;
        };
        PullTypeResolver.prototype.resolveInExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckInExpression(ast, context);
            }
            return this.semanticInfoChain.booleanTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckInExpression = function (binaryExpression, context) {
            this.setTypeChecked(binaryExpression, context);
            var lhsType = this.resolveAST(binaryExpression.left, false, context).type;
            var rhsType = this.resolveAST(binaryExpression.right, false, context).type;
            var isValidLHS = this.isAnyOrEquivalent(lhsType.type) ||
                lhsType.type === this.semanticInfoChain.stringTypeSymbol ||
                lhsType.type === this.semanticInfoChain.numberTypeSymbol;
            var isValidRHS = this.isAnyOrEquivalent(rhsType) || rhsType.isObject() || rhsType.isTypeParameter();
            if (!isValidLHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number));
            }
            if (!isValidRHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter));
            }
        };
        PullTypeResolver.prototype.resolveForStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.variableDeclaration, false, context);
                this.resolveAST(ast.initializer, false, context);
                this.resolveAST(ast.condition, false, context);
                this.resolveAST(ast.incrementor, false, context);
                this.resolveAST(ast.statement, false, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.resolveForInStatement = function (forInStatement, context) {
            if (this.canTypeCheckAST(forInStatement, context)) {
                this.typeCheckForInStatement(forInStatement, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckForInStatement = function (forInStatement, context) {
            this.setTypeChecked(forInStatement, context);
            var rhsType = this.resolveAST(forInStatement.expression, false, context).type;
            var lval = forInStatement.variableDeclaration || forInStatement.left;
            var varSym = this.resolveAST(lval, false, context);
            if (forInStatement.variableDeclaration) {
                var declaration = forInStatement.variableDeclaration;
                var varDecl = declaration.declarators.nonSeparatorAt(0);
                if (varDecl.typeAnnotation) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(lval, TypeScript.DiagnosticCode.Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation));
                }
                var varSym = this.getSymbolForAST(varDecl, context);
            }
            var isStringOrNumber = varSym.type === this.semanticInfoChain.stringTypeSymbol || this.isAnyOrEquivalent(varSym.type);
            var isValidRHS = rhsType && (this.isAnyOrEquivalent(rhsType) || !rhsType.isPrimitive());
            if (!isStringOrNumber) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(lval, TypeScript.DiagnosticCode.Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any));
            }
            if (!isValidRHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(forInStatement.expression, TypeScript.DiagnosticCode.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter));
            }
            this.resolveAST(forInStatement.statement, false, context);
        };
        PullTypeResolver.prototype.resolveWhileStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckWhileStatement(ast, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckWhileStatement = function (ast, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.condition, false, context);
            this.resolveAST(ast.statement, false, context);
        };
        PullTypeResolver.prototype.resolveDoStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckDoStatement(ast, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckDoStatement = function (ast, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.condition, false, context);
            this.resolveAST(ast.statement, false, context);
        };
        PullTypeResolver.prototype.resolveIfStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckIfStatement(ast, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckIfStatement = function (ast, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.condition, false, context);
            this.resolveAST(ast.statement, false, context);
            this.resolveAST(ast.elseClause, false, context);
        };
        PullTypeResolver.prototype.resolveElseClause = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckElseClause(ast, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckElseClause = function (ast, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.statement, false, context);
        };
        PullTypeResolver.prototype.resolveBlock = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.statements, false, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.resolveVariableStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.declaration, false, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.resolveVariableDeclarationList = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.declarators, false, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.resolveWithStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckWithStatement(ast, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckWithStatement = function (ast, context) {
            this.setTypeChecked(ast, context);
            var withStatement = ast;
            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(withStatement.condition, TypeScript.DiagnosticCode.All_symbols_within_a_with_block_will_be_resolved_to_any));
        };
        PullTypeResolver.prototype.resolveTryStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckTryStatement(ast, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckTryStatement = function (ast, context) {
            this.setTypeChecked(ast, context);
            var tryStatement = ast;
            this.resolveAST(tryStatement.block, false, context);
            this.resolveAST(tryStatement.catchClause, false, context);
            this.resolveAST(tryStatement.finallyClause, false, context);
        };
        PullTypeResolver.prototype.resolveCatchClause = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckCatchClause(ast, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckCatchClause = function (ast, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.block, false, context);
            var catchDecl = this.semanticInfoChain.getDeclForAST(ast);
            this.validateVariableDeclarationGroups(catchDecl, context);
        };
        PullTypeResolver.prototype.resolveFinallyClause = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckFinallyClause(ast, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckFinallyClause = function (ast, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.block, false, context);
        };
        PullTypeResolver.prototype.getEnclosingFunctionDeclaration = function (ast) {
            var enclosingDecl = this.getEnclosingDeclForAST(ast);
            while (enclosingDecl) {
                if (enclosingDecl.kind & TypeScript.PullElementKind.SomeFunction) {
                    return enclosingDecl;
                }
                enclosingDecl = enclosingDecl.getParentDecl();
            }
            return null;
        };
        PullTypeResolver.prototype.resolveReturnExpression = function (expression, enclosingFunction, context) {
            if (enclosingFunction) {
                enclosingFunction.setFlag(TypeScript.PullElementFlags.HasReturnStatement);
            }
            var isContextuallyTyped = false;
            if (enclosingFunction) {
                var enclosingDeclAST = this.getASTForDecl(enclosingFunction);
                var typeAnnotation = TypeScript.getType(enclosingDeclAST);
                if (typeAnnotation) {
                    var returnTypeAnnotationSymbol = this.resolveTypeReference(typeAnnotation, context);
                    if (returnTypeAnnotationSymbol) {
                        isContextuallyTyped = true;
                        context.pushContextualType(returnTypeAnnotationSymbol, context.inProvisionalResolution(), null);
                    }
                }
                else {
                    var currentContextualType = context.getContextualType();
                    if (currentContextualType && currentContextualType.isFunction()) {
                        var currentContextTypeDecls = currentContextualType.getDeclarations();
                        var currentContextualTypeSignatureSymbol = currentContextTypeDecls && currentContextTypeDecls.length > 0
                            ? currentContextTypeDecls[0].getSignatureSymbol()
                            : currentContextualType.getCallSignatures()[0];
                        var currentContextualTypeReturnTypeSymbol = currentContextualTypeSignatureSymbol.returnType;
                        if (currentContextualTypeReturnTypeSymbol) {
                            isContextuallyTyped = true;
                            context.pushContextualType(currentContextualTypeReturnTypeSymbol, context.inProvisionalResolution(), null);
                        }
                    }
                }
            }
            var result = this.resolveAST(expression, isContextuallyTyped, context).type;
            if (isContextuallyTyped) {
                context.popContextualType();
            }
            return result;
        };
        PullTypeResolver.prototype.typeCheckReturnExpression = function (expression, expressionType, enclosingFunction, context) {
            if (enclosingFunction && enclosingFunction.kind === TypeScript.PullElementKind.ConstructorMethod) {
                var classDecl = enclosingFunction.getParentDecl();
                if (classDecl) {
                    var classSymbol = classDecl.getSymbol();
                    this.resolveDeclaredSymbol(classSymbol, context);
                    var comparisonInfo = new TypeComparisonInfo();
                    var isAssignable = this.sourceIsAssignableToTarget(expressionType, classSymbol.type, expression, context, comparisonInfo);
                    if (!isAssignable) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(expression, TypeScript.DiagnosticCode.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class));
                    }
                }
            }
            if (enclosingFunction && enclosingFunction.kind === TypeScript.PullElementKind.SetAccessor) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(expression, TypeScript.DiagnosticCode.Setters_cannot_return_a_value));
            }
            if (enclosingFunction) {
                var enclosingDeclAST = this.getASTForDecl(enclosingFunction);
                var typeAnnotation = TypeScript.getType(enclosingDeclAST);
                if (typeAnnotation || enclosingFunction.kind === TypeScript.PullElementKind.GetAccessor) {
                    var signatureSymbol = enclosingFunction.getSignatureSymbol();
                    var sigReturnType = signatureSymbol.returnType;
                    if (expressionType && sigReturnType) {
                        var comparisonInfo = new TypeComparisonInfo();
                        var upperBound = null;
                        if (expressionType.isTypeParameter()) {
                            upperBound = expressionType.getConstraint();
                            if (upperBound) {
                                expressionType = upperBound;
                            }
                        }
                        if (sigReturnType.isTypeParameter()) {
                            upperBound = sigReturnType.getConstraint();
                            if (upperBound) {
                                sigReturnType = upperBound;
                            }
                        }
                        this.resolveDeclaredSymbol(expressionType, context);
                        this.resolveDeclaredSymbol(sigReturnType, context);
                        var isAssignable = this.sourceIsAssignableToTarget(expressionType, sigReturnType, expression, context, comparisonInfo);
                        if (!isAssignable) {
                            var enclosingSymbol = this.getEnclosingSymbolForAST(expression);
                            if (comparisonInfo.message) {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(expression, TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [expressionType.toString(enclosingSymbol), sigReturnType.toString(enclosingSymbol), comparisonInfo.message]));
                            }
                            else {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(expression, TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [expressionType.toString(enclosingSymbol), sigReturnType.toString(enclosingSymbol)]));
                            }
                        }
                    }
                }
            }
        };
        PullTypeResolver.prototype.resolveReturnStatement = function (returnAST, context) {
            var enclosingFunction = this.getEnclosingFunctionDeclaration(returnAST);
            if (enclosingFunction) {
                enclosingFunction.setFlag(TypeScript.PullElementFlags.HasReturnStatement);
            }
            var returnType = this.getSymbolForAST(returnAST, context);
            var canTypeCheckAST = this.canTypeCheckAST(returnAST, context);
            if (!returnType || canTypeCheckAST) {
                var returnExpr = returnAST.expression;
                var resolvedReturnType = returnExpr === null
                    ? this.semanticInfoChain.voidTypeSymbol
                    : this.resolveReturnExpression(returnExpr, enclosingFunction, context);
                if (!returnType) {
                    returnType = resolvedReturnType;
                    this.setSymbolForAST(returnAST, resolvedReturnType, context);
                }
                if (returnExpr && canTypeCheckAST) {
                    this.setTypeChecked(returnExpr, context);
                    this.typeCheckReturnExpression(returnExpr, resolvedReturnType, enclosingFunction, context);
                }
            }
            return returnType;
        };
        PullTypeResolver.prototype.resolveSwitchStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckSwitchStatement(ast, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckSwitchStatement = function (ast, context) {
            this.setTypeChecked(ast, context);
            var expressionType = this.resolveAST(ast.expression, false, context).type;
            for (var i = 0, n = ast.switchClauses.childCount(); i < n; i++) {
                var switchClause = ast.switchClauses.childAt(i);
                if (switchClause.kind() === TypeScript.SyntaxKind.CaseSwitchClause) {
                    var caseSwitchClause = switchClause;
                    var caseClauseExpressionType = this.resolveAST(caseSwitchClause.expression, false, context).type;
                    this.resolveAST(caseSwitchClause.statements, false, context);
                    var comparisonInfo = new TypeComparisonInfo();
                    if (!this.sourceIsAssignableToTarget(expressionType, caseClauseExpressionType, caseSwitchClause.expression, context, comparisonInfo) &&
                        !this.sourceIsAssignableToTarget(caseClauseExpressionType, expressionType, caseSwitchClause.expression, context, comparisonInfo)) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(caseSwitchClause.expression);
                        if (comparisonInfo.message) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(caseSwitchClause.expression, TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [caseClauseExpressionType.toString(enclosingSymbol), expressionType.toString(enclosingSymbol), comparisonInfo.message]));
                        }
                        else {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(caseSwitchClause.expression, TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [caseClauseExpressionType.toString(enclosingSymbol), expressionType.toString(enclosingSymbol)]));
                        }
                    }
                }
                else {
                    var defaultSwitchClause = switchClause;
                    this.resolveAST(defaultSwitchClause.statements, false, context);
                }
            }
        };
        PullTypeResolver.prototype.resolveLabeledStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckLabeledStatement(ast, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckLabeledStatement = function (ast, context) {
            this.setTypeChecked(ast, context);
            var labelIdentifier = ast.identifier.valueText();
            var breakableLabels = this.getEnclosingLabels(ast, true, false);
            if (TypeScript.ArrayUtilities.contains(breakableLabels, labelIdentifier)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast.identifier, TypeScript.DiagnosticCode.Duplicate_identifier_0, [labelIdentifier]));
            }
            this.resolveAST(ast.statement, false, context);
        };
        PullTypeResolver.prototype.labelIsOnContinuableConstruct = function (statement) {
            switch (statement.kind()) {
                case TypeScript.SyntaxKind.LabeledStatement:
                    return this.labelIsOnContinuableConstruct(statement.statement);
                case TypeScript.SyntaxKind.WhileStatement:
                case TypeScript.SyntaxKind.ForStatement:
                case TypeScript.SyntaxKind.ForInStatement:
                case TypeScript.SyntaxKind.DoStatement:
                    return true;
                default:
                    return false;
            }
        };
        PullTypeResolver.prototype.resolveContinueStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckContinueStatement(ast, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.isIterationStatement = function (ast) {
            switch (ast.kind()) {
                case TypeScript.SyntaxKind.ForStatement:
                case TypeScript.SyntaxKind.ForInStatement:
                case TypeScript.SyntaxKind.WhileStatement:
                case TypeScript.SyntaxKind.DoStatement:
                    return true;
            }
            return false;
        };
        PullTypeResolver.prototype.isAnyFunctionExpressionOrDeclaration = function (ast) {
            switch (ast.kind()) {
                case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
                case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                case TypeScript.SyntaxKind.FunctionExpression:
                case TypeScript.SyntaxKind.FunctionDeclaration:
                case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                case TypeScript.SyntaxKind.FunctionPropertyAssignment:
                case TypeScript.SyntaxKind.ConstructorDeclaration:
                case TypeScript.SyntaxKind.GetAccessor:
                case TypeScript.SyntaxKind.SetAccessor:
                    return true;
            }
            return false;
        };
        PullTypeResolver.prototype.inSwitchStatement = function (ast) {
            while (ast) {
                if (ast.kind() === TypeScript.SyntaxKind.SwitchStatement) {
                    return true;
                }
                if (this.isAnyFunctionExpressionOrDeclaration(ast)) {
                    return false;
                }
                ast = ast.parent;
            }
            return false;
        };
        PullTypeResolver.prototype.inIterationStatement = function (ast) {
            while (ast) {
                if (this.isIterationStatement(ast)) {
                    return true;
                }
                if (this.isAnyFunctionExpressionOrDeclaration(ast)) {
                    return false;
                }
                ast = ast.parent;
            }
            return false;
        };
        PullTypeResolver.prototype.getEnclosingLabels = function (ast, breakable, crossFunctions) {
            var result = [];
            ast = ast.parent;
            while (ast) {
                if (ast.kind() === TypeScript.SyntaxKind.LabeledStatement) {
                    var labeledStatement = ast;
                    if (breakable) {
                        result.push(labeledStatement.identifier.valueText());
                    }
                    else {
                        if (this.labelIsOnContinuableConstruct(labeledStatement.statement)) {
                            result.push(labeledStatement.identifier.valueText());
                        }
                    }
                }
                if (!crossFunctions && this.isAnyFunctionExpressionOrDeclaration(ast)) {
                    break;
                }
                ast = ast.parent;
            }
            return result;
        };
        PullTypeResolver.prototype.typeCheckContinueStatement = function (ast, context) {
            this.setTypeChecked(ast, context);
            if (!this.inIterationStatement(ast)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.continue_statement_can_only_be_used_within_an_enclosing_iteration_statement));
            }
            else if (ast.identifier) {
                var continuableLabels = this.getEnclosingLabels(ast, false, false);
                if (!TypeScript.ArrayUtilities.contains(continuableLabels, ast.identifier.valueText())) {
                    var continuableLabels = this.getEnclosingLabels(ast, false, true);
                    if (TypeScript.ArrayUtilities.contains(continuableLabels, ast.identifier.valueText())) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary));
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Jump_target_not_found));
                    }
                }
            }
        };
        PullTypeResolver.prototype.resolveBreakStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckBreakStatement(ast, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckBreakStatement = function (ast, context) {
            this.setTypeChecked(ast, context);
            if (ast.identifier) {
                var breakableLabels = this.getEnclosingLabels(ast, true, false);
                if (!TypeScript.ArrayUtilities.contains(breakableLabels, ast.identifier.valueText())) {
                    var breakableLabels = this.getEnclosingLabels(ast, true, true);
                    if (TypeScript.ArrayUtilities.contains(breakableLabels, ast.identifier.valueText())) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary));
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Jump_target_not_found));
                    }
                }
            }
            else if (!this.inIterationStatement(ast) && !this.inSwitchStatement(ast)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement));
            }
        };
        PullTypeResolver.prototype.resolveAST = function (ast, isContextuallyTyped, context) {
            var ps = this.auxResolveAST(ast, isContextuallyTyped, context);
            if (ps && ps.type) {
                switch (ast.kind()) {
                    case TypeScript.SyntaxKind.MethodSignature:
                        ast.inferredType = ps.type.getCallSignatures()[0];
                        break;
                    case TypeScript.SyntaxKind.ConstructSignature:
                        ast.inferredType = ps.type.getConstructSignatures()[0];
                        break;
                    case TypeScript.SyntaxKind.IndexSignature:
                        ast.inferredType = ps.type.getIndexSignatures()[0];
                        break;
                    case TypeScript.SyntaxKind.ConstructorDeclaration:
                        ast.inferredType = ps.type.getConstructSignatures()[0];
                        break;
                    case TypeScript.SyntaxKind.ClassDeclaration:
                        ast.inferredType = ps.type.getConstructorMethod().type;
                        break;
                    case TypeScript.SyntaxKind.SuperKeyword:
                        ast.inferredType = ps.type.getConstructorMethod().type.getConstructSignatures()[0];
                        break;
                    default:
                        ast.inferredType = ps.type;
                }
            }
            return ps;
        };
        PullTypeResolver.prototype.auxResolveAST = function (ast, isContextuallyTyped, context) {
            if (!ast) {
                return;
            }
            var symbol = this.getSymbolForAST(ast, context);
            if (symbol && symbol.isResolved) {
                this.typeCheckAST(ast, isContextuallyTyped, context);
                return symbol;
            }
            var nodeType = ast.kind();
            switch (nodeType) {
                case TypeScript.SyntaxKind.ArrayType:
                case TypeScript.SyntaxKind.GenericType:
                case TypeScript.SyntaxKind.ObjectType:
                case TypeScript.SyntaxKind.TypeQuery:
                case TypeScript.SyntaxKind.ConstructorType:
                case TypeScript.SyntaxKind.FunctionType:
                    return this.resolveTypeReference(ast, context);
                case TypeScript.SyntaxKind.List:
                    return this.resolveList(ast, context);
                case TypeScript.SyntaxKind.SeparatedList:
                    return this.resolveSeparatedList(ast, context);
                case TypeScript.SyntaxKind.SourceUnit:
                    return this.resolveSourceUnit(ast, context);
                case TypeScript.SyntaxKind.EnumDeclaration:
                    return this.resolveEnumDeclaration(ast, context);
                case TypeScript.SyntaxKind.ModuleDeclaration:
                    return this.resolveModuleDeclaration(ast, context);
                case TypeScript.SyntaxKind.InterfaceDeclaration:
                    return this.resolveInterfaceDeclaration(ast, context);
                case TypeScript.SyntaxKind.ClassDeclaration:
                    return this.resolveClassDeclaration(ast, context);
                case TypeScript.SyntaxKind.VariableDeclaration:
                    return this.resolveVariableDeclarationList(ast, context);
                case TypeScript.SyntaxKind.MemberVariableDeclaration:
                    return this.resolveMemberVariableDeclaration(ast, context);
                case TypeScript.SyntaxKind.VariableDeclarator:
                    return this.resolveVariableDeclarator(ast, context);
                case TypeScript.SyntaxKind.PropertySignature:
                    return this.resolvePropertySignature(ast, context);
                case TypeScript.SyntaxKind.ParameterList:
                    return this.resolveParameterList(ast, context);
                case TypeScript.SyntaxKind.Parameter:
                    return this.resolveParameter(ast, context);
                case TypeScript.SyntaxKind.EnumElement:
                    return this.resolveEnumElement(ast, context);
                case TypeScript.SyntaxKind.EqualsValueClause:
                    return this.resolveEqualsValueClause(ast, isContextuallyTyped, context);
                case TypeScript.SyntaxKind.TypeParameter:
                    return this.resolveTypeParameterDeclaration(ast, context);
                case TypeScript.SyntaxKind.Constraint:
                    return this.resolveConstraint(ast, context);
                case TypeScript.SyntaxKind.ImportDeclaration:
                    return this.resolveImportDeclaration(ast, context);
                case TypeScript.SyntaxKind.ObjectLiteralExpression:
                    return this.resolveObjectLiteralExpression(ast, isContextuallyTyped, context);
                case TypeScript.SyntaxKind.SimplePropertyAssignment:
                    return this.resolveSimplePropertyAssignment(ast, isContextuallyTyped, context);
                case TypeScript.SyntaxKind.FunctionPropertyAssignment:
                    return this.resolveFunctionPropertyAssignment(ast, isContextuallyTyped, context);
                case TypeScript.SyntaxKind.IdentifierName:
                    if (isTypesOnlyLocation(ast)) {
                        return this.resolveTypeNameExpression(ast, context);
                    }
                    else {
                        return this.resolveNameExpression(ast, context);
                    }
                case TypeScript.SyntaxKind.MemberAccessExpression:
                    return this.resolveMemberAccessExpression(ast, context);
                case TypeScript.SyntaxKind.QualifiedName:
                    return this.resolveQualifiedName(ast, context);
                case TypeScript.SyntaxKind.ConstructorDeclaration:
                    return this.resolveConstructorDeclaration(ast, context);
                case TypeScript.SyntaxKind.GetAccessor:
                case TypeScript.SyntaxKind.SetAccessor:
                    return this.resolveAccessorDeclaration(ast, context);
                case TypeScript.SyntaxKind.IndexMemberDeclaration:
                    return this.resolveIndexMemberDeclaration(ast, context);
                case TypeScript.SyntaxKind.IndexSignature:
                    return this.resolveIndexSignature(ast, context);
                case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                    return this.resolveMemberFunctionDeclaration(ast, context);
                case TypeScript.SyntaxKind.CallSignature:
                    return this.resolveCallSignature(ast, context);
                case TypeScript.SyntaxKind.ConstructSignature:
                    return this.resolveConstructSignature(ast, context);
                case TypeScript.SyntaxKind.MethodSignature:
                    return this.resolveMethodSignature(ast, context);
                case TypeScript.SyntaxKind.FunctionDeclaration:
                    return this.resolveAnyFunctionDeclaration(ast, context);
                case TypeScript.SyntaxKind.FunctionExpression:
                    return this.resolveFunctionExpression(ast, isContextuallyTyped, context);
                case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
                    return this.resolveSimpleArrowFunctionExpression(ast, isContextuallyTyped, context);
                case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                    return this.resolveParenthesizedArrowFunctionExpression(ast, isContextuallyTyped, context);
                case TypeScript.SyntaxKind.ArrayLiteralExpression:
                    return this.resolveArrayLiteralExpression(ast, isContextuallyTyped, context);
                case TypeScript.SyntaxKind.ThisKeyword:
                    return this.resolveThisExpression(ast, context);
                case TypeScript.SyntaxKind.SuperKeyword:
                    return this.resolveSuperExpression(ast, context);
                case TypeScript.SyntaxKind.InvocationExpression:
                    return this.resolveInvocationExpression(ast, context);
                case TypeScript.SyntaxKind.ObjectCreationExpression:
                    return this.resolveObjectCreationExpression(ast, context);
                case TypeScript.SyntaxKind.CastExpression:
                    return this.resolveCastExpression(ast, context);
                case TypeScript.SyntaxKind.TypeAnnotation:
                    return this.resolveTypeAnnotation(ast, context);
                case TypeScript.SyntaxKind.ExportAssignment:
                    return this.resolveExportAssignmentStatement(ast, context);
                case TypeScript.SyntaxKind.NumericLiteral:
                    return this.semanticInfoChain.numberTypeSymbol;
                case TypeScript.SyntaxKind.StringLiteral:
                    return this.semanticInfoChain.stringTypeSymbol;
                case TypeScript.SyntaxKind.NullKeyword:
                    return this.semanticInfoChain.nullTypeSymbol;
                case TypeScript.SyntaxKind.TrueKeyword:
                case TypeScript.SyntaxKind.FalseKeyword:
                    return this.semanticInfoChain.booleanTypeSymbol;
                case TypeScript.SyntaxKind.VoidExpression:
                    return this.resolveVoidExpression(ast, context);
                case TypeScript.SyntaxKind.AssignmentExpression:
                    return this.resolveAssignmentExpression(ast, context);
                case TypeScript.SyntaxKind.LogicalNotExpression:
                    return this.resolveLogicalNotExpression(ast, context);
                case TypeScript.SyntaxKind.NotEqualsWithTypeConversionExpression:
                case TypeScript.SyntaxKind.EqualsWithTypeConversionExpression:
                case TypeScript.SyntaxKind.EqualsExpression:
                case TypeScript.SyntaxKind.NotEqualsExpression:
                case TypeScript.SyntaxKind.LessThanExpression:
                case TypeScript.SyntaxKind.LessThanOrEqualExpression:
                case TypeScript.SyntaxKind.GreaterThanOrEqualExpression:
                case TypeScript.SyntaxKind.GreaterThanExpression:
                    return this.resolveLogicalOperation(ast, context);
                case TypeScript.SyntaxKind.AddExpression:
                case TypeScript.SyntaxKind.AddAssignmentExpression:
                    return this.resolveBinaryAdditionOperation(ast, context);
                case TypeScript.SyntaxKind.PlusExpression:
                case TypeScript.SyntaxKind.NegateExpression:
                case TypeScript.SyntaxKind.BitwiseNotExpression:
                case TypeScript.SyntaxKind.PreIncrementExpression:
                case TypeScript.SyntaxKind.PreDecrementExpression:
                    return this.resolveUnaryArithmeticOperation(ast, context);
                case TypeScript.SyntaxKind.PostIncrementExpression:
                case TypeScript.SyntaxKind.PostDecrementExpression:
                    return this.resolvePostfixUnaryExpression(ast, context);
                case TypeScript.SyntaxKind.SubtractExpression:
                case TypeScript.SyntaxKind.MultiplyExpression:
                case TypeScript.SyntaxKind.DivideExpression:
                case TypeScript.SyntaxKind.ModuloExpression:
                case TypeScript.SyntaxKind.BitwiseOrExpression:
                case TypeScript.SyntaxKind.BitwiseAndExpression:
                case TypeScript.SyntaxKind.LeftShiftExpression:
                case TypeScript.SyntaxKind.SignedRightShiftExpression:
                case TypeScript.SyntaxKind.UnsignedRightShiftExpression:
                case TypeScript.SyntaxKind.BitwiseExclusiveOrExpression:
                case TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression:
                case TypeScript.SyntaxKind.LeftShiftAssignmentExpression:
                case TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression:
                case TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression:
                case TypeScript.SyntaxKind.SubtractAssignmentExpression:
                case TypeScript.SyntaxKind.MultiplyAssignmentExpression:
                case TypeScript.SyntaxKind.DivideAssignmentExpression:
                case TypeScript.SyntaxKind.ModuloAssignmentExpression:
                case TypeScript.SyntaxKind.OrAssignmentExpression:
                case TypeScript.SyntaxKind.AndAssignmentExpression:
                    return this.resolveBinaryArithmeticExpression(ast, context);
                case TypeScript.SyntaxKind.ElementAccessExpression:
                    return this.resolveElementAccessExpression(ast, context);
                case TypeScript.SyntaxKind.LogicalOrExpression:
                    return this.resolveLogicalOrExpression(ast, isContextuallyTyped, context);
                case TypeScript.SyntaxKind.LogicalAndExpression:
                    return this.resolveLogicalAndExpression(ast, context);
                case TypeScript.SyntaxKind.TypeOfExpression:
                    return this.resolveTypeOfExpression(ast, context);
                case TypeScript.SyntaxKind.ThrowStatement:
                    return this.resolveThrowStatement(ast, context);
                case TypeScript.SyntaxKind.DeleteExpression:
                    return this.resolveDeleteExpression(ast, context);
                case TypeScript.SyntaxKind.ConditionalExpression:
                    return this.resolveConditionalExpression(ast, isContextuallyTyped, context);
                case TypeScript.SyntaxKind.RegularExpressionLiteral:
                    return this.resolveRegularExpressionLiteral();
                case TypeScript.SyntaxKind.ParenthesizedExpression:
                    return this.resolveParenthesizedExpression(ast, context);
                case TypeScript.SyntaxKind.ExpressionStatement:
                    return this.resolveExpressionStatement(ast, context);
                case TypeScript.SyntaxKind.InstanceOfExpression:
                    return this.resolveInstanceOfExpression(ast, context);
                case TypeScript.SyntaxKind.CommaExpression:
                    return this.resolveCommaExpression(ast, context);
                case TypeScript.SyntaxKind.InExpression:
                    return this.resolveInExpression(ast, context);
                case TypeScript.SyntaxKind.ForStatement:
                    return this.resolveForStatement(ast, context);
                case TypeScript.SyntaxKind.ForInStatement:
                    return this.resolveForInStatement(ast, context);
                case TypeScript.SyntaxKind.WhileStatement:
                    return this.resolveWhileStatement(ast, context);
                case TypeScript.SyntaxKind.DoStatement:
                    return this.resolveDoStatement(ast, context);
                case TypeScript.SyntaxKind.IfStatement:
                    return this.resolveIfStatement(ast, context);
                case TypeScript.SyntaxKind.ElseClause:
                    return this.resolveElseClause(ast, context);
                case TypeScript.SyntaxKind.Block:
                    return this.resolveBlock(ast, context);
                case TypeScript.SyntaxKind.VariableStatement:
                    return this.resolveVariableStatement(ast, context);
                case TypeScript.SyntaxKind.WithStatement:
                    return this.resolveWithStatement(ast, context);
                case TypeScript.SyntaxKind.TryStatement:
                    return this.resolveTryStatement(ast, context);
                case TypeScript.SyntaxKind.CatchClause:
                    return this.resolveCatchClause(ast, context);
                case TypeScript.SyntaxKind.FinallyClause:
                    return this.resolveFinallyClause(ast, context);
                case TypeScript.SyntaxKind.ReturnStatement:
                    return this.resolveReturnStatement(ast, context);
                case TypeScript.SyntaxKind.SwitchStatement:
                    return this.resolveSwitchStatement(ast, context);
                case TypeScript.SyntaxKind.ContinueStatement:
                    return this.resolveContinueStatement(ast, context);
                case TypeScript.SyntaxKind.BreakStatement:
                    return this.resolveBreakStatement(ast, context);
                case TypeScript.SyntaxKind.LabeledStatement:
                    return this.resolveLabeledStatement(ast, context);
            }
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.typeCheckAST = function (ast, isContextuallyTyped, context) {
            if (!this.canTypeCheckAST(ast, context)) {
                return;
            }
            var nodeType = ast.kind();
            switch (nodeType) {
                case TypeScript.SyntaxKind.SourceUnit:
                    this.typeCheckSourceUnit(ast, context);
                    return;
                case TypeScript.SyntaxKind.EnumDeclaration:
                    this.typeCheckEnumDeclaration(ast, context);
                    return;
                case TypeScript.SyntaxKind.ModuleDeclaration:
                    this.typeCheckModuleDeclaration(ast, context);
                    return;
                case TypeScript.SyntaxKind.InterfaceDeclaration:
                    this.typeCheckInterfaceDeclaration(ast, context);
                    return;
                case TypeScript.SyntaxKind.ClassDeclaration:
                    this.typeCheckClassDeclaration(ast, context);
                    return;
                case TypeScript.SyntaxKind.EnumElement:
                    this.typeCheckEnumElement(ast, context);
                    return;
                case TypeScript.SyntaxKind.MemberVariableDeclaration:
                    this.typeCheckMemberVariableDeclaration(ast, context);
                    return;
                case TypeScript.SyntaxKind.VariableDeclarator:
                    this.typeCheckVariableDeclarator(ast, context);
                    return;
                case TypeScript.SyntaxKind.PropertySignature:
                    this.typeCheckPropertySignature(ast, context);
                    return;
                case TypeScript.SyntaxKind.Parameter:
                    this.typeCheckParameter(ast, context);
                    return;
                case TypeScript.SyntaxKind.ImportDeclaration:
                    this.typeCheckImportDeclaration(ast, context);
                    return;
                case TypeScript.SyntaxKind.ObjectLiteralExpression:
                    this.resolveObjectLiteralExpression(ast, isContextuallyTyped, context);
                    return;
                case TypeScript.SyntaxKind.FunctionPropertyAssignment:
                    this.typeCheckFunctionPropertyAssignment(ast, isContextuallyTyped, context);
                    return;
                case TypeScript.SyntaxKind.IdentifierName:
                    if (isTypesOnlyLocation(ast)) {
                        this.resolveTypeNameExpression(ast, context);
                    }
                    else {
                        this.resolveNameExpression(ast, context);
                    }
                    return;
                case TypeScript.SyntaxKind.MemberAccessExpression:
                    this.resolveMemberAccessExpression(ast, context);
                    return;
                case TypeScript.SyntaxKind.QualifiedName:
                    this.resolveQualifiedName(ast, context);
                    return;
                case TypeScript.SyntaxKind.FunctionExpression:
                    this.typeCheckFunctionExpression(ast, context);
                    break;
                case TypeScript.SyntaxKind.IndexSignature:
                    this.typeCheckIndexSignature(ast, context);
                    break;
                case TypeScript.SyntaxKind.CallSignature:
                    this.typeCheckCallSignature(ast, context);
                    break;
                case TypeScript.SyntaxKind.ConstructSignature:
                    this.typeCheckConstructSignature(ast, context);
                    break;
                case TypeScript.SyntaxKind.FunctionDeclaration:
                    {
                        var funcDecl = ast;
                        this.typeCheckFunctionDeclaration(funcDecl, TypeScript.hasModifier(funcDecl.modifiers, TypeScript.PullElementFlags.Static), funcDecl.identifier, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.getType(funcDecl), funcDecl.block, context);
                        return;
                    }
                case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
                    this.typeCheckSimpleArrowFunctionExpression(ast, context);
                    return;
                case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                    this.typeCheckParenthesizedArrowFunctionExpression(ast, context);
                    return;
                case TypeScript.SyntaxKind.ArrayLiteralExpression:
                    this.resolveArrayLiteralExpression(ast, isContextuallyTyped, context);
                    return;
                case TypeScript.SyntaxKind.InvocationExpression:
                    this.typeCheckInvocationExpression(ast, context);
                    return;
                case TypeScript.SyntaxKind.ObjectCreationExpression:
                    this.typeCheckObjectCreationExpression(ast, context);
                    return;
                case TypeScript.SyntaxKind.ReturnStatement:
                    this.resolveReturnStatement(ast, context);
                    return;
                default:
                    TypeScript.Debug.assert(false, "Failure nodeType: " + TypeScript.SyntaxKind[ast.kind()] + ". Implement typeCheck when symbol is set for the ast as part of resolution.");
            }
        };
        PullTypeResolver.prototype.processPostTypeCheckWorkItems = function (context) {
            while (this.postTypeCheckWorkitems.length) {
                var ast = this.postTypeCheckWorkitems.pop();
                this.postTypeCheck(ast, context);
            }
        };
        PullTypeResolver.prototype.postTypeCheck = function (ast, context) {
            var nodeType = ast.kind();
            switch (nodeType) {
                case TypeScript.SyntaxKind.Parameter:
                case TypeScript.SyntaxKind.VariableDeclarator:
                    this.postTypeCheckVariableDeclaratorOrParameter(ast, context);
                    return;
                case TypeScript.SyntaxKind.ClassDeclaration:
                    this.postTypeCheckClassDeclaration(ast, context);
                    return;
                case TypeScript.SyntaxKind.FunctionDeclaration:
                    this.postTypeCheckFunctionDeclaration(ast, context);
                    return;
                case TypeScript.SyntaxKind.ModuleDeclaration:
                    this.postTypeCheckModuleDeclaration(ast, context);
                    return;
                case TypeScript.SyntaxKind.EnumDeclaration:
                    this.postTypeCheckEnumDeclaration(ast, context);
                    return;
                case TypeScript.SyntaxKind.ImportDeclaration:
                    this.postTypeCheckImportDeclaration(ast, context);
                    return;
                case TypeScript.SyntaxKind.IdentifierName:
                    this.postTypeCheckNameExpression(ast, context);
                    return;
                default:
                    TypeScript.Debug.assert(false, "Implement postTypeCheck clause to handle the postTypeCheck work, nodeType: " + TypeScript.SyntaxKind[ast.kind()]);
            }
        };
        PullTypeResolver.prototype.resolveRegularExpressionLiteral = function () {
            if (this.cachedRegExpInterfaceType()) {
                return this.cachedRegExpInterfaceType();
            }
            else {
                return this.semanticInfoChain.anyTypeSymbol;
            }
        };
        PullTypeResolver.prototype.postTypeCheckNameExpression = function (nameAST, context) {
            this.checkThisCaptureVariableCollides(nameAST, false, context);
        };
        PullTypeResolver.prototype.typeCheckNameExpression = function (nameAST, context) {
            this.setTypeChecked(nameAST, context);
            this.checkNameForCompilerGeneratedDeclarationCollision(nameAST, false, nameAST, context);
        };
        PullTypeResolver.prototype.resolveNameExpression = function (nameAST, context) {
            var nameSymbol = this.getSymbolForAST(nameAST, context);
            var foundCached = nameSymbol != null;
            if (!foundCached || this.canTypeCheckAST(nameAST, context)) {
                if (this.canTypeCheckAST(nameAST, context)) {
                    this.typeCheckNameExpression(nameAST, context);
                }
                nameSymbol = this.computeNameExpression(nameAST, context, true);
            }
            this.resolveDeclaredSymbol(nameSymbol, context);
            if (nameSymbol &&
                (nameSymbol.type != this.semanticInfoChain.anyTypeSymbol ||
                    nameSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.IsAnnotatedWithAny | TypeScript.PullElementFlags.Exported))) {
                this.setSymbolForAST(nameAST, nameSymbol, context);
            }
            return nameSymbol;
        };
        PullTypeResolver.prototype.isSomeFunctionScope = function (declPath) {
            for (var i = declPath.length - 1; i >= 0; i--) {
                var decl = declPath[i];
                if (decl.kind & TypeScript.PullElementKind.SomeFunction) {
                    return true;
                }
            }
            return false;
        };
        PullTypeResolver.prototype.computeNameExpression = function (nameAST, context, reportDiagnostics) {
            var id = nameAST.valueText();
            if (id.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var nameSymbol = null;
            var enclosingDecl = this.getEnclosingDeclForAST(nameAST);
            if (TypeScript.isDeclarationASTOrDeclarationNameAST(nameAST)) {
                nameSymbol = this.semanticInfoChain.getDeclForAST(nameAST.parent).getSymbol();
            }
            var declPath = enclosingDecl.getParentPath();
            if (!nameSymbol) {
                var nameSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeValue);
            }
            if (!nameSymbol && id === "arguments" && this.isSomeFunctionScope(declPath)) {
                nameSymbol = this.cachedFunctionArgumentsSymbol();
                this.resolveDeclaredSymbol(this.cachedIArgumentsInterfaceType(), context);
            }
            if (!nameSymbol) {
                nameSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.TypeAlias);
                if (nameSymbol && !nameSymbol.isAlias()) {
                    nameSymbol = null;
                }
            }
            if (!nameSymbol) {
                if (!reportDiagnostics) {
                    return null;
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST, TypeScript.DiagnosticCode.Could_not_find_symbol_0, [nameAST.text()]));
                    return this.getNewErrorTypeSymbol(id);
                }
            }
            var nameDeclaration = nameSymbol.getDeclarations()[0];
            var nameParentDecl = nameDeclaration.getParentDecl();
            if (nameParentDecl &&
                (nameParentDecl.kind & TypeScript.PullElementKind.SomeFunction) &&
                (nameParentDecl.flags & TypeScript.PullElementFlags.HasDefaultArgs)) {
                var enclosingFunctionAST = this.semanticInfoChain.getASTForDecl(nameParentDecl);
                var currentParameterIndex = this.getCurrentParameterIndexForFunction(nameAST, enclosingFunctionAST);
                var parameterList = TypeScript.getParameterList(enclosingFunctionAST);
                if (currentParameterIndex >= 0) {
                    var foundMatchingParameter = false;
                    if (parameterList) {
                        for (var i = 0; i <= currentParameterIndex; i++) {
                            var candidateParameter = parameterList.parameters.nonSeparatorAt(i);
                            if (candidateParameter && candidateParameter.identifier.valueText() === id) {
                                foundMatchingParameter = true;
                            }
                        }
                    }
                    if (!foundMatchingParameter) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST, TypeScript.DiagnosticCode.Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it, [parameterList.parameters.nonSeparatorAt(currentParameterIndex).identifier.text(), nameAST.text()]));
                        return this.getNewErrorTypeSymbol(id);
                    }
                }
            }
            var aliasSymbol = null;
            if (nameSymbol.isType() && nameSymbol.isAlias()) {
                aliasSymbol = nameSymbol;
                if (!this.inTypeQuery(nameAST)) {
                    aliasSymbol.setIsUsedAsValue(true);
                }
                this.resolveDeclaredSymbol(nameSymbol, context);
                this.resolveDeclaredSymbol(aliasSymbol.assignedValue(), context);
                this.resolveDeclaredSymbol(aliasSymbol.assignedContainer(), context);
                var exportAssignmentSymbol = nameSymbol.getExportAssignedValueSymbol();
                if (exportAssignmentSymbol) {
                    nameSymbol = exportAssignmentSymbol;
                }
                else {
                    aliasSymbol = null;
                }
            }
            if (aliasSymbol) {
                this.semanticInfoChain.setAliasSymbolForAST(nameAST, aliasSymbol);
            }
            return nameSymbol;
        };
        PullTypeResolver.prototype.getCurrentParameterIndexForFunction = function (parameter, funcDecl) {
            var parameterList = TypeScript.getParameterList(funcDecl);
            if (parameterList) {
                while (parameter && parameter.parent) {
                    if (parameter.parent.parent === parameterList) {
                        return parameterList.parameters.nonSeparatorIndexOf(parameter);
                    }
                    parameter = parameter.parent;
                }
            }
            return -1;
        };
        PullTypeResolver.prototype.resolveMemberAccessExpression = function (dottedNameAST, context) {
            return this.resolveDottedNameExpression(dottedNameAST, dottedNameAST.expression, dottedNameAST.name, context);
        };
        PullTypeResolver.prototype.resolveDottedNameExpression = function (dottedNameAST, expression, name, context) {
            var symbol = this.getSymbolForAST(dottedNameAST, context);
            var foundCached = symbol != null;
            if (!foundCached || this.canTypeCheckAST(dottedNameAST, context)) {
                var canTypeCheckDottedNameAST = this.canTypeCheckAST(dottedNameAST, context);
                if (canTypeCheckDottedNameAST) {
                    this.setTypeChecked(dottedNameAST, context);
                }
                symbol = this.computeDottedNameExpression(expression, name, context, canTypeCheckDottedNameAST);
            }
            this.resolveDeclaredSymbol(symbol, context);
            if (symbol &&
                (symbol.type != this.semanticInfoChain.anyTypeSymbol ||
                    symbol.anyDeclHasFlag(TypeScript.PullElementFlags.IsAnnotatedWithAny | TypeScript.PullElementFlags.Exported))) {
                this.setSymbolForAST(dottedNameAST, symbol, context);
                this.setSymbolForAST(name, symbol, context);
            }
            return symbol;
        };
        PullTypeResolver.prototype.computeDottedNameExpression = function (expression, name, context, checkSuperPrivateAndStaticAccess) {
            var rhsName = name.valueText();
            if (rhsName.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var lhs = this.resolveAST(expression, false, context);
            var lhsType = lhs.type;
            if (lhs.isAlias()) {
                if (!this.inTypeQuery(expression)) {
                    lhs.setIsUsedAsValue(true);
                }
                lhsType = lhs.getExportAssignedTypeSymbol();
            }
            if (this.isAnyOrEquivalent(lhsType)) {
                return lhsType;
            }
            if (lhsType.isAlias()) {
                lhsType = lhsType.getExportAssignedTypeSymbol();
            }
            if (!lhsType) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, TypeScript.DiagnosticCode.Could_not_find_enclosing_symbol_for_dotted_name_0, [name.text()]));
                return this.getNewErrorTypeSymbol();
            }
            if (!lhsType.isResolved) {
                var potentiallySpecializedType = this.resolveDeclaredSymbol(lhsType, context);
                if (potentiallySpecializedType != lhsType) {
                    if (!lhs.isType()) {
                        context.setTypeInContext(lhs, potentiallySpecializedType);
                    }
                    lhsType = potentiallySpecializedType;
                }
            }
            if (lhsType.isContainer() && !lhsType.isAlias() && !lhsType.isEnum()) {
                var instanceSymbol = lhsType.getInstanceSymbol();
                if (instanceSymbol) {
                    lhsType = instanceSymbol.type;
                }
            }
            if (lhsType.isTypeParameter()) {
                lhsType = this.substituteUpperBoundForType(lhsType);
            }
            if ((lhsType === this.semanticInfoChain.numberTypeSymbol || lhsType.isEnum()) && this.cachedNumberInterfaceType()) {
                lhsType = this.cachedNumberInterfaceType();
            }
            else if (lhsType === this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                lhsType = this.cachedStringInterfaceType();
            }
            else if (lhsType === this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType()) {
                lhsType = this.cachedBooleanInterfaceType();
            }
            var nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, lhsType);
            if (!nameSymbol) {
                if ((lhsType.getCallSignatures().length || lhsType.getConstructSignatures().length) && this.cachedFunctionInterfaceType()) {
                    nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, this.cachedFunctionInterfaceType());
                }
                else if (lhsType.kind === TypeScript.PullElementKind.DynamicModule) {
                    var container = lhsType;
                    var associatedInstance = container.getInstanceSymbol();
                    if (associatedInstance) {
                        var instanceType = associatedInstance.type;
                        nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, instanceType);
                    }
                }
                else {
                    var associatedType = lhsType.getAssociatedContainerType();
                    if (associatedType && !associatedType.isClass()) {
                        nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, associatedType);
                    }
                }
                if (!nameSymbol && !lhsType.isPrimitive() && this.cachedObjectInterfaceType()) {
                    nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, this.cachedObjectInterfaceType());
                }
                if (!nameSymbol) {
                    var enclosingDecl = this.getEnclosingDeclForAST(expression);
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, TypeScript.DiagnosticCode.The_property_0_does_not_exist_on_value_of_type_1, [name.text(), lhsType.toString(enclosingDecl ? enclosingDecl.getSymbol() : null)]));
                    return this.getNewErrorTypeSymbol(rhsName);
                }
            }
            if (checkSuperPrivateAndStaticAccess) {
                this.checkForSuperMemberAccess(expression, name, nameSymbol, context) ||
                    this.checkForPrivateMemberAccess(name, lhsType, nameSymbol, context);
            }
            return nameSymbol;
        };
        PullTypeResolver.prototype.resolveTypeNameExpression = function (nameAST, context) {
            var typeNameSymbol = this.getSymbolForAST(nameAST, context);
            if (!typeNameSymbol || !typeNameSymbol.isType() || this.canTypeCheckAST(nameAST, context)) {
                if (this.canTypeCheckAST(nameAST, context)) {
                    this.setTypeChecked(nameAST, context);
                }
                typeNameSymbol = this.computeTypeNameExpression(nameAST, context);
                this.setSymbolForAST(nameAST, typeNameSymbol, context);
            }
            this.resolveDeclaredSymbol(typeNameSymbol, context);
            return typeNameSymbol;
        };
        PullTypeResolver.prototype.computeTypeNameExpression = function (nameAST, context) {
            var id = nameAST.valueText();
            if (id.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var enclosingDecl = this.getEnclosingDeclForAST(nameAST);
            var declPath = enclosingDecl.getParentPath();
            var onLeftOfDot = this.isLeftSideOfQualifiedName(nameAST);
            var kindToCheckFirst = onLeftOfDot ? TypeScript.PullElementKind.SomeContainer : TypeScript.PullElementKind.SomeType;
            var kindToCheckSecond = onLeftOfDot ? TypeScript.PullElementKind.SomeType : TypeScript.PullElementKind.SomeContainer;
            var typeNameSymbol = this.getSymbolFromDeclPath(id, declPath, kindToCheckFirst);
            if (!typeNameSymbol) {
                typeNameSymbol = this.getSymbolFromDeclPath(id, declPath, kindToCheckSecond);
            }
            if (!typeNameSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST, TypeScript.DiagnosticCode.Could_not_find_symbol_0, [nameAST.text()]));
                return this.getNewErrorTypeSymbol(id);
            }
            var typeNameSymbolAlias = null;
            if (typeNameSymbol.isAlias()) {
                typeNameSymbolAlias = typeNameSymbol;
                this.resolveDeclaredSymbol(typeNameSymbol, context);
                var aliasedType = typeNameSymbolAlias.getExportAssignedTypeSymbol();
                this.resolveDeclaredSymbol(aliasedType, context);
            }
            if (typeNameSymbol.isTypeParameter()) {
                if (enclosingDecl && (enclosingDecl.kind & TypeScript.PullElementKind.SomeFunction) && (enclosingDecl.flags & TypeScript.PullElementFlags.Static)) {
                    var parentDecl = typeNameSymbol.getDeclarations()[0].getParentDecl();
                    if (parentDecl.kind == TypeScript.PullElementKind.Class) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST, TypeScript.DiagnosticCode.Static_methods_cannot_reference_class_type_parameters));
                        return this.getNewErrorTypeSymbol();
                    }
                }
            }
            if (!typeNameSymbol.isGeneric() && (typeNameSymbol.isClass() || typeNameSymbol.isInterface())) {
                typeNameSymbol = TypeScript.PullTypeReferenceSymbol.createTypeReference(typeNameSymbol);
            }
            return typeNameSymbol;
        };
        PullTypeResolver.prototype.isLeftSideOfQualifiedName = function (ast) {
            return ast && ast.parent && ast.parent.kind() === TypeScript.SyntaxKind.QualifiedName && ast.parent.left === ast;
        };
        PullTypeResolver.prototype.resolveGenericTypeReference = function (genericTypeAST, context) {
            var genericTypeSymbol = this.resolveAST(genericTypeAST.name, false, context).type;
            if (genericTypeSymbol.isError()) {
                return genericTypeSymbol;
            }
            if (!genericTypeSymbol.inResolution && !genericTypeSymbol.isResolved) {
                this.resolveDeclaredSymbol(genericTypeSymbol, context);
            }
            if (genericTypeSymbol.isAlias()) {
                genericTypeSymbol = genericTypeSymbol.getExportAssignedTypeSymbol();
            }
            var typeArgs = [];
            if (genericTypeAST.typeArgumentList && genericTypeAST.typeArgumentList.typeArguments.nonSeparatorCount()) {
                for (var i = 0; i < genericTypeAST.typeArgumentList.typeArguments.nonSeparatorCount(); i++) {
                    typeArgs[i] = this.resolveTypeReference(genericTypeAST.typeArgumentList.typeArguments.nonSeparatorAt(i), context);
                    if (typeArgs[i].isError()) {
                        typeArgs[i] = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
            }
            var typeParameters = genericTypeSymbol.getTypeParameters();
            if (typeArgs.length && typeArgs.length != typeParameters.length) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(genericTypeAST, TypeScript.DiagnosticCode.Generic_type_0_requires_1_type_argument_s, [genericTypeSymbol.toString(), genericTypeSymbol.getTypeParameters().length.toString()]));
                return this.getNewErrorTypeSymbol();
            }
            if (!genericTypeSymbol.isResolved) {
                var typeDecls = genericTypeSymbol.getDeclarations();
                var childDecls = null;
                for (var i = 0; i < typeDecls.length; i++) {
                    childDecls = typeDecls[i].getChildDecls();
                    for (var j = 0; j < childDecls.length; j++) {
                        childDecls[j].ensureSymbolIsBound();
                    }
                }
            }
            var specializedSymbol = this.createInstantiatedType(genericTypeSymbol, typeArgs);
            var typeConstraint = null;
            var upperBound = null;
            typeParameters = specializedSymbol.getTypeParameters();
            var typeConstraintSubstitutionMap = [];
            var typeArg = null;
            var instantiatedSubstitutionMap = specializedSymbol.getTypeParameterArgumentMap();
            for (var i = 0; i < typeParameters.length; i++) {
                typeConstraintSubstitutionMap[typeParameters[i].pullSymbolID] = typeParameters[i];
            }
            for (var id in instantiatedSubstitutionMap) {
                typeConstraintSubstitutionMap[+id] = instantiatedSubstitutionMap[+id];
            }
            for (var iArg = 0; (iArg < typeArgs.length) && (iArg < typeParameters.length); iArg++) {
                typeArg = typeArgs[iArg];
                typeConstraint = typeParameters[iArg].getConstraint();
                typeConstraintSubstitutionMap[typeParameters[iArg].pullSymbolID] = typeArg;
                if (typeConstraint) {
                    if (typeConstraint.isTypeParameter()) {
                        for (var j = 0; j < typeParameters.length && j < typeArgs.length; j++) {
                            if (typeParameters[j] == typeConstraint) {
                                typeConstraint = typeArgs[j];
                            }
                        }
                    }
                    else if (typeConstraint.isGeneric()) {
                        typeConstraint = this.instantiateType(typeConstraint, typeConstraintSubstitutionMap);
                    }
                    if (typeArg.isTypeParameter()) {
                        upperBound = typeArg.getConstraint();
                        if (upperBound) {
                            typeArg = upperBound;
                        }
                    }
                    if (typeArg.inResolution || (typeArg.isTypeReference() && typeArg.referencedTypeSymbol.inResolution)) {
                        return specializedSymbol;
                    }
                    if (!this.sourceIsAssignableToTarget(typeArg, typeConstraint, genericTypeAST, context)) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(genericTypeAST);
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(genericTypeAST, TypeScript.DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2, [typeArg.toString(enclosingSymbol, true), typeConstraint.toString(enclosingSymbol, true), typeParameters[iArg].toString(enclosingSymbol, true)]));
                    }
                }
            }
            return specializedSymbol;
        };
        PullTypeResolver.prototype.resolveQualifiedName = function (dottedNameAST, context) {
            if (this.inTypeQuery(dottedNameAST)) {
                return this.resolveDottedNameExpression(dottedNameAST, dottedNameAST.left, dottedNameAST.right, context).type;
            }
            var symbol = this.getSymbolForAST(dottedNameAST, context);
            if (!symbol || this.canTypeCheckAST(dottedNameAST, context)) {
                var canTypeCheck = this.canTypeCheckAST(dottedNameAST, context);
                if (canTypeCheck) {
                    this.setTypeChecked(dottedNameAST, context);
                }
                symbol = this.computeQualifiedName(dottedNameAST, context);
                this.setSymbolForAST(dottedNameAST, symbol, context);
            }
            this.resolveDeclaredSymbol(symbol, context);
            return symbol;
        };
        PullTypeResolver.prototype.computeQualifiedName = function (dottedNameAST, context) {
            var rhsName = dottedNameAST.right.valueText();
            if (rhsName.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var enclosingDecl = this.getEnclosingDeclForAST(dottedNameAST);
            var lhs = this.resolveAST(dottedNameAST.left, false, context);
            var lhsType = lhs.isAlias() ? lhs.getExportAssignedContainerSymbol() : lhs.type;
            if (this.inClassExtendsHeritageClause(dottedNameAST) &&
                !this.inTypeArgumentList(dottedNameAST)) {
                if (lhs.isAlias()) {
                    lhs.setIsUsedAsValue(true);
                }
            }
            if (!lhsType) {
                return this.getNewErrorTypeSymbol();
            }
            if (this.isAnyOrEquivalent(lhsType)) {
                return lhsType;
            }
            var onLeftOfDot = this.isLeftSideOfQualifiedName(dottedNameAST);
            var isNameOfModule = dottedNameAST.parent.kind() === TypeScript.SyntaxKind.ModuleDeclaration && dottedNameAST.parent.name === dottedNameAST;
            var memberKind = (onLeftOfDot || isNameOfModule) ? TypeScript.PullElementKind.SomeContainer : TypeScript.PullElementKind.SomeType;
            var childTypeSymbol = this.getMemberSymbol(rhsName, memberKind, lhsType);
            if (!childTypeSymbol && lhsType.isContainer()) {
                var exportedContainer = lhsType.getExportAssignedContainerSymbol();
                if (exportedContainer) {
                    childTypeSymbol = this.getMemberSymbol(rhsName, memberKind, exportedContainer);
                }
            }
            if (!childTypeSymbol && enclosingDecl) {
                var parentDecl = enclosingDecl;
                while (parentDecl) {
                    if (parentDecl.kind & TypeScript.PullElementKind.SomeContainer) {
                        break;
                    }
                    parentDecl = parentDecl.getParentDecl();
                }
                if (parentDecl) {
                    var enclosingSymbolType = parentDecl.getSymbol().type;
                    if (enclosingSymbolType === lhsType) {
                        childTypeSymbol = this.getMemberSymbol(rhsName, memberKind, lhsType);
                    }
                }
            }
            if (!childTypeSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(dottedNameAST.right, TypeScript.DiagnosticCode.The_property_0_does_not_exist_on_value_of_type_1, [dottedNameAST.right.text(), lhsType.toString(enclosingDecl ? enclosingDecl.getSymbol() : null)]));
                return this.getNewErrorTypeSymbol(rhsName);
            }
            return childTypeSymbol;
        };
        PullTypeResolver.prototype.shouldContextuallyTypeAnyFunctionExpression = function (functionExpressionAST, typeParameters, parameters, returnTypeAnnotation, context) {
            if (typeParameters && typeParameters.typeParameters.nonSeparatorCount() > 0) {
                return false;
            }
            if (returnTypeAnnotation) {
                return false;
            }
            if (parameters) {
                for (var i = 0, n = parameters.length; i < n; i++) {
                    if (parameters.typeAt(i)) {
                        return false;
                    }
                }
            }
            var contextualFunctionTypeSymbol = context.getContextualType();
            if (contextualFunctionTypeSymbol) {
                this.resolveDeclaredSymbol(contextualFunctionTypeSymbol, context);
                var callSignatures = contextualFunctionTypeSymbol.getCallSignatures();
                var exactlyOneCallSignature = callSignatures && callSignatures.length == 1;
                if (!exactlyOneCallSignature) {
                    return false;
                }
                var callSignatureIsGeneric = callSignatures[0].typeParameters && callSignatures[0].typeParameters.length > 0;
                return !callSignatureIsGeneric;
            }
            return false;
        };
        PullTypeResolver.prototype.resolveAnyFunctionExpression = function (funcDeclAST, typeParameters, parameters, returnTypeAnnotation, block, bodyExpression, isContextuallyTyped, context) {
            var funcDeclSymbol = null;
            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            TypeScript.Debug.assert(functionDecl);
            if (functionDecl && functionDecl.hasSymbol()) {
                funcDeclSymbol = functionDecl.getSymbol();
                if (funcDeclSymbol.isResolved || funcDeclSymbol.inResolution) {
                    return funcDeclSymbol;
                }
            }
            funcDeclSymbol = functionDecl.getSymbol();
            TypeScript.Debug.assert(funcDeclSymbol);
            var funcDeclType = funcDeclSymbol.type;
            var signature = funcDeclType.getCallSignatures()[0];
            funcDeclSymbol.startResolving();
            if (typeParameters) {
                for (var i = 0; i < typeParameters.typeParameters.nonSeparatorCount(); i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.typeParameters.nonSeparatorAt(i), context);
                }
            }
            var assigningFunctionSignature = null;
            if (isContextuallyTyped &&
                this.shouldContextuallyTypeAnyFunctionExpression(funcDeclAST, typeParameters, parameters, returnTypeAnnotation, context)) {
                assigningFunctionSignature = context.getContextualType().getCallSignatures()[0];
            }
            if (parameters) {
                var contextParams = [];
                if (assigningFunctionSignature) {
                    contextParams = assigningFunctionSignature.parameters;
                }
                var contextualParametersCount = contextParams.length;
                for (var i = 0, n = parameters.length; i < n; i++) {
                    var actualParameterIsVarArgParameter = (i === (n - 1)) && parameters.lastParameterIsRest();
                    var correspondingContextualParameter = null;
                    var contextualParameterType = null;
                    if (i < contextualParametersCount) {
                        correspondingContextualParameter = contextParams[i];
                    }
                    else if (contextualParametersCount && contextParams[contextualParametersCount - 1].isVarArg) {
                        correspondingContextualParameter = contextParams[contextualParametersCount - 1];
                    }
                    if (correspondingContextualParameter) {
                        if (correspondingContextualParameter.isVarArg === actualParameterIsVarArgParameter) {
                            contextualParameterType = correspondingContextualParameter.type;
                        }
                        else if (correspondingContextualParameter.isVarArg) {
                            contextualParameterType = correspondingContextualParameter.type.getElementType();
                        }
                    }
                    this.resolveFunctionExpressionParameter(parameters.astAt(i), parameters.identifierAt(i), parameters.typeAt(i), parameters.initializerAt(i), contextualParameterType, functionDecl, context);
                }
            }
            if (returnTypeAnnotation) {
                signature.returnType = this.resolveTypeReference(returnTypeAnnotation, context);
            }
            else {
                if (assigningFunctionSignature) {
                    var returnType = assigningFunctionSignature.returnType;
                    if (returnType) {
                        context.pushContextualType(returnType, context.inProvisionalResolution(), null);
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, block, bodyExpression, signature, true, functionDecl, context);
                        context.popContextualType();
                    }
                    else {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                        if (this.compilationSettings.noImplicitAny()) {
                            var functionExpressionName = functionDecl.getFunctionExpressionName();
                            if (functionExpressionName != "") {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [functionExpressionName]));
                            }
                            else {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type));
                            }
                        }
                    }
                }
                else {
                    this.resolveFunctionBodyReturnTypes(funcDeclAST, block, bodyExpression, signature, false, functionDecl, context);
                }
            }
            context.setTypeInContext(funcDeclSymbol, funcDeclType);
            funcDeclSymbol.setResolved();
            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckAnyFunctionExpression(funcDeclAST, typeParameters, returnTypeAnnotation, block, bodyExpression, context);
            }
            return funcDeclSymbol;
        };
        PullTypeResolver.prototype.typeCheckSimpleArrowFunctionExpression = function (arrowFunction, context) {
            return this.typeCheckAnyFunctionExpression(arrowFunction, null, null, arrowFunction.block, arrowFunction.expression, context);
        };
        PullTypeResolver.prototype.typeCheckParenthesizedArrowFunctionExpression = function (arrowFunction, context) {
            return this.typeCheckAnyFunctionExpression(arrowFunction, arrowFunction.callSignature.typeParameterList, TypeScript.getType(arrowFunction), arrowFunction.block, arrowFunction.expression, context);
        };
        PullTypeResolver.prototype.typeCheckAnyFunctionExpression = function (funcDeclAST, typeParameters, returnTypeAnnotation, block, bodyExpression, context) {
            var _this_1 = this;
            this.setTypeChecked(funcDeclAST, context);
            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var funcDeclSymbol = functionDecl.getSymbol();
            var funcDeclType = funcDeclSymbol.type;
            var signature = funcDeclType.getCallSignatures()[0];
            var returnTypeSymbol = signature.returnType;
            if (typeParameters) {
                for (var i = 0; i < typeParameters.typeParameters.nonSeparatorCount(); i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.typeParameters.nonSeparatorAt(i), context);
                }
            }
            context.pushContextualType(null, context.inProvisionalResolution(), null);
            if (block) {
                this.resolveAST(block, false, context);
            }
            else {
                var bodyExpressionType = this.resolveReturnExpression(bodyExpression, functionDecl, context);
                this.typeCheckReturnExpression(bodyExpression, bodyExpressionType, functionDecl, context);
            }
            context.popContextualType();
            var hasReturn = (functionDecl.flags & (TypeScript.PullElementFlags.Signature | TypeScript.PullElementFlags.HasReturnStatement)) != 0;
            if (block && returnTypeAnnotation != null && !hasReturn) {
                var isVoidOrAny = this.isAnyOrEquivalent(returnTypeSymbol) || returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol;
                if (!isVoidOrAny && !(block.statements.childCount() > 0 && block.statements.childAt(0).kind() === TypeScript.SyntaxKind.ThrowStatement)) {
                    var funcName = functionDecl.getDisplayName();
                    funcName = funcName ? "'" + funcName + "'" : "expression";
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnTypeAnnotation, TypeScript.DiagnosticCode.Function_0_declared_a_non_void_return_type_but_has_no_return_expression, [funcName]));
                }
            }
            this.validateVariableDeclarationGroups(functionDecl, context);
            this.typeCheckCallBacks.push(function (context) {
                _this_1.typeCheckFunctionOverloads(funcDeclAST, context);
            });
        };
        PullTypeResolver.prototype.resolveThisExpression = function (thisExpression, context) {
            var enclosingDecl = this.getEnclosingDeclForAST(thisExpression);
            var thisTypeSymbol = this.getContextualClassSymbolForEnclosingDecl(thisExpression, enclosingDecl) || this.semanticInfoChain.anyTypeSymbol;
            if (this.canTypeCheckAST(thisExpression, context)) {
                this.typeCheckThisExpression(thisExpression, context, enclosingDecl);
            }
            return thisTypeSymbol;
        };
        PullTypeResolver.prototype.inTypeArgumentList = function (ast) {
            var previous = null;
            var current = ast;
            while (current) {
                switch (current.kind()) {
                    case TypeScript.SyntaxKind.GenericType:
                        var genericType = current;
                        if (genericType.typeArgumentList === previous) {
                            return true;
                        }
                        break;
                    case TypeScript.SyntaxKind.ArgumentList:
                        var argumentList = current;
                        return argumentList.typeArgumentList === previous;
                }
                previous = current;
                current = current.parent;
            }
            return false;
        };
        PullTypeResolver.prototype.inClassExtendsHeritageClause = function (ast) {
            while (ast) {
                switch (ast.kind()) {
                    case TypeScript.SyntaxKind.ExtendsHeritageClause:
                        var heritageClause = ast;
                        return heritageClause.parent.parent.kind() === TypeScript.SyntaxKind.ClassDeclaration;
                    case TypeScript.SyntaxKind.ConstructorDeclaration:
                    case TypeScript.SyntaxKind.ClassDeclaration:
                    case TypeScript.SyntaxKind.ModuleDeclaration:
                        return false;
                }
                ast = ast.parent;
            }
            return false;
        };
        PullTypeResolver.prototype.inTypeQuery = function (ast) {
            while (ast) {
                switch (ast.kind()) {
                    case TypeScript.SyntaxKind.TypeQuery:
                        return true;
                    case TypeScript.SyntaxKind.FunctionDeclaration:
                    case TypeScript.SyntaxKind.InvocationExpression:
                    case TypeScript.SyntaxKind.ConstructorDeclaration:
                    case TypeScript.SyntaxKind.ClassDeclaration:
                    case TypeScript.SyntaxKind.ModuleDeclaration:
                        return false;
                }
                ast = ast.parent;
            }
            return false;
        };
        PullTypeResolver.prototype.inArgumentListOfSuperInvocation = function (ast) {
            var previous = null;
            var current = ast;
            while (current) {
                switch (current.kind()) {
                    case TypeScript.SyntaxKind.InvocationExpression:
                        var invocationExpression = current;
                        if (previous === invocationExpression.argumentList &&
                            invocationExpression.expression.kind() === TypeScript.SyntaxKind.SuperKeyword) {
                            return true;
                        }
                        break;
                    case TypeScript.SyntaxKind.ConstructorDeclaration:
                    case TypeScript.SyntaxKind.ClassDeclaration:
                    case TypeScript.SyntaxKind.ModuleDeclaration:
                        return false;
                }
                previous = current;
                current = current.parent;
            }
            return false;
        };
        PullTypeResolver.prototype.inConstructorParameterList = function (ast) {
            var previous = null;
            var current = ast;
            while (current) {
                switch (current.kind()) {
                    case TypeScript.SyntaxKind.ConstructorDeclaration:
                        var constructorDecl = current;
                        return previous === constructorDecl.parameterList;
                    case TypeScript.SyntaxKind.ClassDeclaration:
                    case TypeScript.SyntaxKind.ModuleDeclaration:
                        return false;
                }
                previous = current;
                current = current.parent;
            }
            return false;
        };
        PullTypeResolver.prototype.isFunctionOrNonArrowFunctionExpression = function (decl) {
            if (decl.kind === TypeScript.PullElementKind.Function) {
                return true;
            }
            else if (decl.kind === TypeScript.PullElementKind.FunctionExpression && !TypeScript.hasFlag(decl.flags, TypeScript.PullElementFlags.ArrowFunction)) {
                return true;
            }
            return false;
        };
        PullTypeResolver.prototype.typeCheckThisExpression = function (thisExpression, context, enclosingDecl) {
            this.checkForThisCaptureInArrowFunction(thisExpression);
            if (this.inConstructorParameterList(thisExpression)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, TypeScript.DiagnosticCode.this_cannot_be_referenced_in_constructor_arguments));
                return;
            }
            for (var currentDecl = enclosingDecl; currentDecl !== null; currentDecl = currentDecl.getParentDecl()) {
                if (this.isFunctionOrNonArrowFunctionExpression(currentDecl)) {
                    return;
                }
                else if (currentDecl.kind === TypeScript.PullElementKind.Container || currentDecl.kind === TypeScript.PullElementKind.DynamicModule) {
                    if (currentDecl.getParentDecl() === null) {
                        return;
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, TypeScript.DiagnosticCode.this_cannot_be_referenced_within_module_bodies));
                        return;
                    }
                }
                else if (currentDecl.kind === TypeScript.PullElementKind.ConstructorMethod) {
                    if (this.inArgumentListOfSuperInvocation(thisExpression) &&
                        this.superCallMustBeFirstStatementInConstructor(currentDecl)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, TypeScript.DiagnosticCode.this_cannot_be_referenced_in_current_location));
                    }
                    return;
                }
                else if (currentDecl.kind === TypeScript.PullElementKind.Class) {
                    if (this.inStaticMemberVariableDeclaration(thisExpression)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, TypeScript.DiagnosticCode.this_cannot_be_referenced_in_static_initializers_in_a_class_body));
                    }
                    return;
                }
            }
        };
        PullTypeResolver.prototype.getContextualClassSymbolForEnclosingDecl = function (ast, enclosingDecl) {
            var declPath = enclosingDecl.getParentPath();
            if (declPath.length) {
                var isStaticContext = false;
                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declKind = decl.kind;
                    var declFlags = decl.flags;
                    if (declFlags & TypeScript.PullElementFlags.Static) {
                        isStaticContext = true;
                    }
                    else if (declKind === TypeScript.PullElementKind.FunctionExpression && !TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.ArrowFunction)) {
                        return null;
                    }
                    else if (declKind === TypeScript.PullElementKind.Function) {
                        return null;
                    }
                    else if (declKind === TypeScript.PullElementKind.Class) {
                        if (this.inStaticMemberVariableDeclaration(ast)) {
                            return this.getNewErrorTypeSymbol();
                        }
                        else {
                            var classSymbol = decl.getSymbol();
                            if (isStaticContext) {
                                var constructorSymbol = classSymbol.getConstructorMethod();
                                return constructorSymbol.type;
                            }
                            else {
                                return classSymbol;
                            }
                        }
                    }
                }
            }
            return null;
        };
        PullTypeResolver.prototype.inStaticMemberVariableDeclaration = function (ast) {
            while (ast) {
                if (ast.kind() === TypeScript.SyntaxKind.MemberVariableDeclaration && TypeScript.hasModifier(ast.modifiers, TypeScript.PullElementFlags.Static)) {
                    return true;
                }
                ast = ast.parent;
            }
            return false;
        };
        PullTypeResolver.prototype.resolveSuperExpression = function (ast, context) {
            var enclosingDecl = this.getEnclosingDeclForAST(ast);
            var superType = this.semanticInfoChain.anyTypeSymbol;
            var classSymbol = this.getContextualClassSymbolForEnclosingDecl(ast, enclosingDecl);
            if (classSymbol) {
                this.resolveDeclaredSymbol(classSymbol, context);
                var parents = classSymbol.getExtendedTypes();
                if (parents.length) {
                    superType = parents[0];
                }
            }
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckSuperExpression(ast, context, enclosingDecl);
            }
            return superType;
        };
        PullTypeResolver.prototype.typeCheckSuperExpression = function (ast, context, enclosingDecl) {
            this.setTypeChecked(ast, context);
            this.checkForThisCaptureInArrowFunction(ast);
            var isSuperCall = ast.parent.kind() === TypeScript.SyntaxKind.InvocationExpression;
            var isSuperPropertyAccess = ast.parent.kind() === TypeScript.SyntaxKind.MemberAccessExpression;
            TypeScript.Debug.assert(isSuperCall || isSuperPropertyAccess);
            if (isSuperPropertyAccess) {
                for (var currentDecl = enclosingDecl; currentDecl !== null; currentDecl = currentDecl.getParentDecl()) {
                    if (this.isFunctionOrNonArrowFunctionExpression(currentDecl)) {
                        break;
                    }
                    else if (currentDecl.kind === TypeScript.PullElementKind.Class) {
                        if (!this.enclosingClassIsDerived(currentDecl)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.super_cannot_be_referenced_in_non_derived_classes));
                            return;
                        }
                        else if (this.inConstructorParameterList(ast)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.super_cannot_be_referenced_in_constructor_arguments));
                            return;
                        }
                        else if (this.inStaticMemberVariableDeclaration(ast)) {
                            break;
                        }
                        return;
                    }
                }
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class));
                return;
            }
            else {
                for (var currentDecl = enclosingDecl; currentDecl !== null; currentDecl = currentDecl.getParentDecl()) {
                    if (this.isFunctionOrNonArrowFunctionExpression(currentDecl)) {
                        break;
                    }
                    else if (currentDecl.kind === TypeScript.PullElementKind.ConstructorMethod) {
                        var classDecl = currentDecl.getParentDecl();
                        if (!this.enclosingClassIsDerived(classDecl)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.super_cannot_be_referenced_in_non_derived_classes));
                            return;
                        }
                        else if (this.inConstructorParameterList(ast)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.super_cannot_be_referenced_in_constructor_arguments));
                            return;
                        }
                        return;
                    }
                }
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors));
            }
        };
        PullTypeResolver.prototype.resolveSimplePropertyAssignment = function (propertyAssignment, isContextuallyTyped, context) {
            return this.resolveAST(propertyAssignment.expression, isContextuallyTyped, context);
        };
        PullTypeResolver.prototype.resolveFunctionPropertyAssignment = function (funcProp, isContextuallyTyped, context) {
            return this.resolveAnyFunctionExpression(funcProp, funcProp.callSignature.typeParameterList, TypeScript.Parameters.fromParameterList(funcProp.callSignature.parameterList), TypeScript.getType(funcProp), funcProp.block, null, isContextuallyTyped, context);
        };
        PullTypeResolver.prototype.typeCheckFunctionPropertyAssignment = function (funcProp, isContextuallyTyped, context) {
            this.typeCheckAnyFunctionExpression(funcProp, funcProp.callSignature.typeParameterList, TypeScript.getType(funcProp), funcProp.block, null, context);
        };
        PullTypeResolver.prototype.resolveObjectLiteralExpression = function (expressionAST, isContextuallyTyped, context, additionalResults) {
            var symbol = this.getSymbolForAST(expressionAST, context);
            if (!symbol || additionalResults || this.canTypeCheckAST(expressionAST, context)) {
                if (this.canTypeCheckAST(expressionAST, context)) {
                    this.setTypeChecked(expressionAST, context);
                }
                symbol = this.computeObjectLiteralExpression(expressionAST, isContextuallyTyped, context, additionalResults);
                this.setSymbolForAST(expressionAST, symbol, context);
            }
            return symbol;
        };
        PullTypeResolver.prototype.bindObjectLiteralMembers = function (objectLiteralDeclaration, objectLiteralTypeSymbol, objectLiteralMembers, isUsingExistingSymbol, pullTypeContext) {
            var boundMemberSymbols = [];
            var memberSymbol;
            for (var i = 0, len = objectLiteralMembers.nonSeparatorCount(); i < len; i++) {
                var propertyAssignment = objectLiteralMembers.nonSeparatorAt(i);
                var id = this.getPropertyAssignmentName(propertyAssignment);
                var assignmentText = getPropertyAssignmentNameTextFromIdentifier(id);
                var isAccessor = propertyAssignment.kind() === TypeScript.SyntaxKind.GetAccessor || propertyAssignment.kind() === TypeScript.SyntaxKind.SetAccessor;
                var decl = this.semanticInfoChain.getDeclForAST(propertyAssignment);
                TypeScript.Debug.assert(decl);
                if (propertyAssignment.kind() == TypeScript.SyntaxKind.SimplePropertyAssignment) {
                    if (!isUsingExistingSymbol) {
                        memberSymbol = new TypeScript.PullSymbol(assignmentText.memberName, TypeScript.PullElementKind.Property);
                        memberSymbol.addDeclaration(decl);
                        decl.setSymbol(memberSymbol);
                    }
                    else {
                        memberSymbol = decl.getSymbol();
                    }
                }
                else if (propertyAssignment.kind() === TypeScript.SyntaxKind.FunctionPropertyAssignment) {
                    memberSymbol = decl.getSymbol();
                }
                else {
                    TypeScript.Debug.assert(isAccessor);
                    memberSymbol = decl.getSymbol();
                }
                if (!isUsingExistingSymbol && !isAccessor) {
                    if (objectLiteralTypeSymbol.findMember(memberSymbol.name, true)) {
                        pullTypeContext.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(propertyAssignment, TypeScript.DiagnosticCode.Duplicate_identifier_0, [assignmentText.actualText]));
                    }
                    objectLiteralTypeSymbol.addMember(memberSymbol);
                }
                boundMemberSymbols.push(memberSymbol);
            }
            return boundMemberSymbols;
        };
        PullTypeResolver.prototype.resolveObjectLiteralMembers = function (objectLiteralDeclaration, objectLiteralTypeSymbol, objectLiteralContextualType, objectLiteralMembers, stringIndexerSignature, numericIndexerSignature, allMemberTypes, allNumericMemberTypes, boundMemberSymbols, isUsingExistingSymbol, pullTypeContext, additionalResults) {
            for (var i = 0, len = objectLiteralMembers.nonSeparatorCount(); i < len; i++) {
                var propertyAssignment = objectLiteralMembers.nonSeparatorAt(i);
                var acceptedContextualType = false;
                var assigningSymbol = null;
                var id = this.getPropertyAssignmentName(propertyAssignment);
                var memberSymbol = boundMemberSymbols[i];
                var contextualMemberType;
                if (objectLiteralContextualType) {
                    assigningSymbol = this.getMemberSymbol(memberSymbol.name, TypeScript.PullElementKind.SomeValue, objectLiteralContextualType);
                    if (!assigningSymbol) {
                        if (numericIndexerSignature && TypeScript.PullHelpers.isNameNumeric(memberSymbol.name)) {
                            assigningSymbol = numericIndexerSignature;
                        }
                        else if (stringIndexerSignature) {
                            assigningSymbol = stringIndexerSignature;
                        }
                    }
                    if (assigningSymbol) {
                        this.resolveDeclaredSymbol(assigningSymbol, pullTypeContext);
                        contextualMemberType = assigningSymbol.kind === TypeScript.PullElementKind.IndexSignature ? assigningSymbol.returnType : assigningSymbol.type;
                        pullTypeContext.pushContextualType(contextualMemberType, pullTypeContext.inProvisionalResolution(), null);
                        acceptedContextualType = true;
                        if (additionalResults) {
                            additionalResults.membersContextTypeSymbols[i] = contextualMemberType;
                        }
                    }
                }
                var propertySymbol = this.resolveAST(propertyAssignment, contextualMemberType != null, pullTypeContext);
                var memberExpr = this.widenType(propertySymbol.type, propertyAssignment, pullTypeContext);
                if (memberExpr.type) {
                    if (memberExpr.type.isGeneric()) {
                        objectLiteralTypeSymbol.setHasGenericMember();
                    }
                    if (stringIndexerSignature) {
                        allMemberTypes.push(memberExpr.type);
                    }
                    if (numericIndexerSignature && TypeScript.PullHelpers.isNameNumeric(memberSymbol.name)) {
                        allNumericMemberTypes.push(memberExpr.type);
                    }
                }
                if (acceptedContextualType) {
                    pullTypeContext.popContextualType();
                }
                var isAccessor = propertyAssignment.kind() === TypeScript.SyntaxKind.SetAccessor || propertyAssignment.kind() === TypeScript.SyntaxKind.GetAccessor;
                if (!isUsingExistingSymbol) {
                    if (isAccessor) {
                        this.setSymbolForAST(id, memberExpr, pullTypeContext);
                    }
                    else {
                        pullTypeContext.setTypeInContext(memberSymbol, memberExpr.type);
                        memberSymbol.setResolved();
                        this.setSymbolForAST(id, memberSymbol, pullTypeContext);
                    }
                }
            }
        };
        PullTypeResolver.prototype.computeObjectLiteralExpression = function (objectLitAST, isContextuallyTyped, context, additionalResults) {
            var objectLitDecl = this.semanticInfoChain.getDeclForAST(objectLitAST);
            TypeScript.Debug.assert(objectLitDecl);
            var typeSymbol = this.getSymbolForAST(objectLitAST, context);
            var isUsingExistingSymbol = !!typeSymbol;
            if (!typeSymbol) {
                typeSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.Interface);
                typeSymbol.addDeclaration(objectLitDecl);
                this.setSymbolForAST(objectLitAST, typeSymbol, context);
                objectLitDecl.setSymbol(typeSymbol);
            }
            var propertyAssignments = objectLitAST.propertyAssignments;
            var contextualType = null;
            if (isContextuallyTyped) {
                contextualType = context.getContextualType();
                this.resolveDeclaredSymbol(contextualType, context);
            }
            var stringIndexerSignature = null;
            var numericIndexerSignature = null;
            var allMemberTypes = null;
            var allNumericMemberTypes = null;
            if (contextualType) {
                var indexSignatures = this.getBothKindsOfIndexSignatures(contextualType, context);
                stringIndexerSignature = indexSignatures.stringSignature;
                numericIndexerSignature = indexSignatures.numericSignature;
                if (stringIndexerSignature) {
                    allMemberTypes = [stringIndexerSignature.returnType];
                }
                if (numericIndexerSignature) {
                    allNumericMemberTypes = [numericIndexerSignature.returnType];
                }
            }
            if (propertyAssignments) {
                if (additionalResults) {
                    additionalResults.membersContextTypeSymbols = [];
                }
                var boundMemberSymbols = this.bindObjectLiteralMembers(objectLitDecl, typeSymbol, propertyAssignments, isUsingExistingSymbol, context);
                this.resolveObjectLiteralMembers(objectLitDecl, typeSymbol, contextualType, propertyAssignments, stringIndexerSignature, numericIndexerSignature, allMemberTypes, allNumericMemberTypes, boundMemberSymbols, isUsingExistingSymbol, context, additionalResults);
                if (!isUsingExistingSymbol) {
                    this.stampObjectLiteralWithIndexSignature(typeSymbol, allMemberTypes, stringIndexerSignature, context);
                    this.stampObjectLiteralWithIndexSignature(typeSymbol, allNumericMemberTypes, numericIndexerSignature, context);
                }
            }
            typeSymbol.setResolved();
            return typeSymbol;
        };
        PullTypeResolver.prototype.getPropertyAssignmentName = function (propertyAssignment) {
            if (propertyAssignment.kind() === TypeScript.SyntaxKind.SimplePropertyAssignment) {
                return propertyAssignment.propertyName;
            }
            else if (propertyAssignment.kind() === TypeScript.SyntaxKind.FunctionPropertyAssignment) {
                return propertyAssignment.propertyName;
            }
            else if (propertyAssignment.kind() === TypeScript.SyntaxKind.GetAccessor) {
                return propertyAssignment.propertyName;
            }
            else if (propertyAssignment.kind() === TypeScript.SyntaxKind.SetAccessor) {
                return propertyAssignment.propertyName;
            }
            else {
                TypeScript.Debug.assert(false);
            }
        };
        PullTypeResolver.prototype.stampObjectLiteralWithIndexSignature = function (objectLiteralSymbol, indexerTypeCandidates, contextualIndexSignature, context) {
            if (contextualIndexSignature) {
                var typeCollection = {
                    getLength: function () { return indexerTypeCandidates.length; },
                    getTypeAtIndex: function (index) {
                        return indexerTypeCandidates[index];
                    }
                };
                var decl = objectLiteralSymbol.getDeclarations()[0];
                var indexerReturnType = this.widenType(this.findBestCommonType(typeCollection, context));
                if (indexerReturnType == contextualIndexSignature.returnType) {
                    objectLiteralSymbol.addIndexSignature(contextualIndexSignature);
                }
                else {
                    this.semanticInfoChain.addSyntheticIndexSignature(decl, objectLiteralSymbol, this.getASTForDecl(decl), contextualIndexSignature.parameters[0].name, contextualIndexSignature.parameters[0].type, indexerReturnType);
                }
            }
        };
        PullTypeResolver.prototype.resolveArrayLiteralExpression = function (arrayLit, isContextuallyTyped, context) {
            var symbol = this.getSymbolForAST(arrayLit, context);
            if (!symbol || this.canTypeCheckAST(arrayLit, context)) {
                if (this.canTypeCheckAST(arrayLit, context)) {
                    this.setTypeChecked(arrayLit, context);
                }
                symbol = this.computeArrayLiteralExpressionSymbol(arrayLit, isContextuallyTyped, context);
                this.setSymbolForAST(arrayLit, symbol, context);
            }
            return symbol;
        };
        PullTypeResolver.prototype.computeArrayLiteralExpressionSymbol = function (arrayLit, isContextuallyTyped, context) {
            var elements = arrayLit.expressions;
            var elementType = null;
            var elementTypes = [];
            var comparisonInfo = new TypeComparisonInfo();
            var contextualElementType = null;
            comparisonInfo.onlyCaptureFirstError = true;
            if (isContextuallyTyped) {
                var contextualType = context.getContextualType();
                this.resolveDeclaredSymbol(contextualType, context);
                if (contextualType) {
                    var indexSignatures = this.getBothKindsOfIndexSignatures(contextualType, context);
                    if (indexSignatures.numericSignature) {
                        contextualElementType = indexSignatures.numericSignature.returnType;
                    }
                }
            }
            if (elements) {
                if (contextualElementType) {
                    context.pushContextualType(contextualElementType, context.inProvisionalResolution(), null);
                }
                for (var i = 0, n = elements.nonSeparatorCount(); i < n; i++) {
                    elementTypes.push(this.resolveAST(elements.nonSeparatorAt(i), contextualElementType !== null, context).type);
                }
                if (contextualElementType) {
                    context.popContextualType();
                }
            }
            if (elementTypes.length) {
                elementType = elementTypes[0];
            }
            var collection;
            if (contextualElementType) {
                if (!elementType) {
                    elementType = contextualElementType;
                }
                collection = {
                    getLength: function () { return elements.nonSeparatorCount() + 1; },
                    getTypeAtIndex: function (index) { return index === 0 ? contextualElementType : elementTypes[index - 1]; }
                };
            }
            else {
                collection = {
                    getLength: function () { return elements.nonSeparatorCount(); },
                    getTypeAtIndex: function (index) { return elementTypes[index]; }
                };
            }
            elementType = elementType ? this.findBestCommonType(collection, context, comparisonInfo) : elementType;
            if (!elementType) {
                elementType = this.semanticInfoChain.undefinedTypeSymbol;
            }
            var arraySymbol = elementType.getArrayType();
            if (!arraySymbol) {
                arraySymbol = this.createInstantiatedType(this.cachedArrayInterfaceType(), [elementType]);
                if (!arraySymbol) {
                    arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                }
                elementType.setArrayType(arraySymbol);
            }
            return arraySymbol;
        };
        PullTypeResolver.prototype.resolveElementAccessExpression = function (callEx, context) {
            var symbolAndDiagnostic = this.computeElementAccessExpressionSymbolAndDiagnostic(callEx, context);
            if (this.canTypeCheckAST(callEx, context)) {
                this.typeCheckElementAccessExpression(callEx, context, symbolAndDiagnostic);
            }
            return symbolAndDiagnostic.symbol;
        };
        PullTypeResolver.prototype.typeCheckElementAccessExpression = function (callEx, context, symbolAndDiagnostic) {
            this.setTypeChecked(callEx, context);
            context.postDiagnostic(symbolAndDiagnostic.diagnostic);
        };
        PullTypeResolver.prototype.computeElementAccessExpressionSymbolAndDiagnostic = function (callEx, context) {
            var targetSymbol = this.resolveAST(callEx.expression, false, context);
            var indexType = this.resolveAST(callEx.argumentExpression, false, context).type;
            var targetTypeSymbol = targetSymbol.type;
            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                return { symbol: targetTypeSymbol };
            }
            var elementType = targetTypeSymbol.getElementType();
            var isNumberIndex = indexType === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(indexType);
            if (elementType && isNumberIndex) {
                return { symbol: elementType };
            }
            if (callEx.argumentExpression.kind() === TypeScript.SyntaxKind.StringLiteral || callEx.argumentExpression.kind() === TypeScript.SyntaxKind.NumericLiteral) {
                var memberName = callEx.argumentExpression.kind() === TypeScript.SyntaxKind.StringLiteral
                    ? TypeScript.stripStartAndEndQuotes(callEx.argumentExpression.text())
                    : callEx.argumentExpression.valueText();
                var member = this.getMemberSymbol(memberName, TypeScript.PullElementKind.SomeValue, targetTypeSymbol);
                if (member) {
                    this.resolveDeclaredSymbol(member, context);
                    return { symbol: member.type };
                }
            }
            if (targetTypeSymbol == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                targetTypeSymbol = this.cachedStringInterfaceType();
            }
            var signatures = this.getBothKindsOfIndexSignatures(targetTypeSymbol, context);
            var stringSignature = signatures.stringSignature;
            var numberSignature = signatures.numericSignature;
            if (numberSignature && (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol)) {
                return { symbol: numberSignature.returnType || this.semanticInfoChain.anyTypeSymbol };
            }
            else if (stringSignature && (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol || indexType === this.semanticInfoChain.stringTypeSymbol)) {
                return { symbol: stringSignature.returnType || this.semanticInfoChain.anyTypeSymbol };
            }
            else if (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol || indexType === this.semanticInfoChain.stringTypeSymbol) {
                return { symbol: this.semanticInfoChain.anyTypeSymbol };
            }
            else {
                return {
                    symbol: this.getNewErrorTypeSymbol(),
                    diagnostic: this.semanticInfoChain.diagnosticFromAST(callEx, TypeScript.DiagnosticCode.Value_of_type_0_is_not_indexable_by_type_1, [targetTypeSymbol.toString(), indexType.toString()])
                };
            }
        };
        PullTypeResolver.prototype.getBothKindsOfIndexSignatures = function (enclosingType, context) {
            var signatures = enclosingType.getIndexSignatures();
            var stringSignature = null;
            var numberSignature = null;
            var signature = null;
            var paramSymbols;
            var paramType;
            for (var i = 0; i < signatures.length; i++) {
                if (stringSignature && numberSignature) {
                    break;
                }
                signature = signatures[i];
                if (!signature.isResolved) {
                    this.resolveDeclaredSymbol(signature, context);
                }
                paramSymbols = signature.parameters;
                if (paramSymbols.length) {
                    paramType = paramSymbols[0].type;
                    if (!stringSignature && paramType === this.semanticInfoChain.stringTypeSymbol) {
                        stringSignature = signature;
                        continue;
                    }
                    else if (!numberSignature && paramType === this.semanticInfoChain.numberTypeSymbol) {
                        numberSignature = signature;
                        continue;
                    }
                }
            }
            return {
                numericSignature: numberSignature,
                stringSignature: stringSignature
            };
        };
        PullTypeResolver.prototype.resolveBinaryAdditionOperation = function (binaryExpression, context) {
            var lhsExpression = this.resolveAST(binaryExpression.left, false, context);
            var lhsType = lhsExpression.type;
            var rhsType = this.resolveAST(binaryExpression.right, false, context).type;
            if (TypeScript.PullHelpers.symbolIsEnum(lhsType)) {
                lhsType = this.semanticInfoChain.numberTypeSymbol;
            }
            else if (lhsType === this.semanticInfoChain.nullTypeSymbol || lhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                if (rhsType != this.semanticInfoChain.nullTypeSymbol && rhsType != this.semanticInfoChain.undefinedTypeSymbol) {
                    lhsType = rhsType;
                }
                else {
                    lhsType = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            if (TypeScript.PullHelpers.symbolIsEnum(rhsType)) {
                rhsType = this.semanticInfoChain.numberTypeSymbol;
            }
            else if (rhsType === this.semanticInfoChain.nullTypeSymbol || rhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                if (lhsType != this.semanticInfoChain.nullTypeSymbol && lhsType != this.semanticInfoChain.undefinedTypeSymbol) {
                    rhsType = lhsType;
                }
                else {
                    rhsType = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            var exprType = null;
            if (lhsType === this.semanticInfoChain.stringTypeSymbol || rhsType === this.semanticInfoChain.stringTypeSymbol) {
                exprType = this.semanticInfoChain.stringTypeSymbol;
            }
            else if (this.isAnyOrEquivalent(lhsType) || this.isAnyOrEquivalent(rhsType)) {
                exprType = this.semanticInfoChain.anyTypeSymbol;
            }
            else if (rhsType === this.semanticInfoChain.numberTypeSymbol && lhsType === this.semanticInfoChain.numberTypeSymbol) {
                exprType = this.semanticInfoChain.numberTypeSymbol;
            }
            if (this.canTypeCheckAST(binaryExpression, context)) {
                this.setTypeChecked(binaryExpression, context);
                if (exprType) {
                    if (binaryExpression.kind() === TypeScript.SyntaxKind.AddAssignmentExpression) {
                        if (!this.isReference(binaryExpression.left, lhsExpression)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression));
                        }
                        this.checkAssignability(binaryExpression.left, exprType, lhsType, context);
                    }
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.Invalid_expression_types_not_known_to_support_the_addition_operator));
                }
            }
            if (!exprType) {
                exprType = this.semanticInfoChain.anyTypeSymbol;
            }
            return exprType;
        };
        PullTypeResolver.prototype.bestCommonTypeOfTwoTypes = function (type1, type2, context) {
            return this.findBestCommonType({
                getLength: function () {
                    return 2;
                },
                getTypeAtIndex: function (index) {
                    switch (index) {
                        case 0: return type1;
                        case 1: return type2;
                    }
                }
            }, context);
        };
        PullTypeResolver.prototype.bestCommonTypeOfThreeTypes = function (type1, type2, type3, context) {
            return this.findBestCommonType({
                getLength: function () {
                    return 3;
                },
                getTypeAtIndex: function (index) {
                    switch (index) {
                        case 0: return type1;
                        case 1: return type2;
                        case 2: return type3;
                    }
                }
            }, context);
        };
        PullTypeResolver.prototype.resolveLogicalOrExpression = function (binex, isContextuallyTyped, context) {
            if (this.canTypeCheckAST(binex, context)) {
                this.setTypeChecked(binex, context);
            }
            if (isContextuallyTyped) {
                var contextualType = context.getContextualType();
                var leftType = this.resolveAST(binex.left, isContextuallyTyped, context).type;
                var rightType = this.resolveAST(binex.right, isContextuallyTyped, context).type;
                return this.bestCommonTypeOfThreeTypes(contextualType, leftType, rightType, context);
            }
            else {
                var leftType = this.resolveAST(binex.left, false, context).type;
                context.pushContextualType(leftType, context.inProvisionalResolution(), null);
                var rightType = this.resolveAST(binex.right, true, context).type;
                context.popContextualType();
                return this.bestCommonTypeOfTwoTypes(leftType, rightType, context);
            }
        };
        PullTypeResolver.prototype.resolveLogicalAndExpression = function (binex, context) {
            if (this.canTypeCheckAST(binex, context)) {
                this.setTypeChecked(binex, context);
                this.resolveAST(binex.left, false, context);
            }
            return this.resolveAST(binex.right, false, context).type;
        };
        PullTypeResolver.prototype.computeTypeOfConditionalExpression = function (leftType, rightType, isContextuallyTyped, context) {
            if (isContextuallyTyped) {
                var contextualType = context.getContextualType();
                return this.bestCommonTypeOfThreeTypes(contextualType, leftType, rightType, context);
            }
            else {
                return this.bestCommonTypeOfTwoTypes(leftType, rightType, context);
            }
        };
        PullTypeResolver.prototype.resolveConditionalExpression = function (trinex, isContextuallyTyped, context) {
            var leftType = this.resolveAST(trinex.whenTrue, isContextuallyTyped, context).type;
            var rightType = this.resolveAST(trinex.whenFalse, isContextuallyTyped, context).type;
            var expressionType = this.computeTypeOfConditionalExpression(leftType, rightType, isContextuallyTyped, context);
            var conditionalTypesAreValid = this.conditionExpressionTypesAreValid(leftType, rightType, expressionType, isContextuallyTyped, context);
            if (this.canTypeCheckAST(trinex, context)) {
                this.setTypeChecked(trinex, context);
                this.resolveAST(trinex.condition, false, context);
                if (!this.conditionExpressionTypesAreValid(leftType, rightType, expressionType, isContextuallyTyped, context)) {
                    if (isContextuallyTyped) {
                        var contextualType = context.getContextualType();
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(trinex, TypeScript.DiagnosticCode.Type_of_conditional_0_must_be_identical_to_1_2_or_3, [expressionType.toString(), leftType.toString(), rightType.toString(), contextualType.toString()]));
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(trinex, TypeScript.DiagnosticCode.Type_of_conditional_0_must_be_identical_to_1_or_2, [expressionType.toString(), leftType.toString(), rightType.toString()]));
                    }
                }
            }
            if (!conditionalTypesAreValid) {
                return this.getNewErrorTypeSymbol();
            }
            return expressionType;
        };
        PullTypeResolver.prototype.conditionExpressionTypesAreValid = function (leftType, rightType, expressionType, isContextuallyTyped, context) {
            if (isContextuallyTyped) {
                var contextualType = context.getContextualType();
                if (this.typesAreIdentical(expressionType, leftType) ||
                    this.typesAreIdentical(expressionType, rightType) ||
                    this.typesAreIdentical(expressionType, contextualType)) {
                    return true;
                }
            }
            else {
                if (this.typesAreIdentical(expressionType, leftType) ||
                    this.typesAreIdentical(expressionType, rightType)) {
                    return true;
                }
            }
            return false;
        };
        PullTypeResolver.prototype.resolveParenthesizedExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
            }
            return this.resolveAST(ast.expression, false, context);
        };
        PullTypeResolver.prototype.resolveExpressionStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.expression, false, context);
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeResolver.prototype.resolveInvocationExpression = function (callEx, context, additionalResults) {
            var symbol = this.getSymbolForAST(callEx, context);
            if (!symbol || !symbol.isResolved) {
                if (!additionalResults) {
                    additionalResults = new PullAdditionalCallResolutionData();
                }
                symbol = this.computeInvocationExpressionSymbol(callEx, context, additionalResults);
                if (this.canTypeCheckAST(callEx, context)) {
                    this.setTypeChecked(callEx, context);
                }
                if (symbol != this.semanticInfoChain.anyTypeSymbol) {
                    this.setSymbolForAST(callEx, symbol, context);
                }
                this.semanticInfoChain.setCallResolutionDataForAST(callEx, additionalResults);
            }
            else {
                if (this.canTypeCheckAST(callEx, context)) {
                    this.typeCheckInvocationExpression(callEx, context);
                }
                var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);
                if (additionalResults && (callResolutionData != additionalResults)) {
                    additionalResults.actualParametersContextTypeSymbols = callResolutionData.actualParametersContextTypeSymbols;
                    additionalResults.candidateSignature = callResolutionData.candidateSignature;
                    additionalResults.resolvedSignatures = callResolutionData.resolvedSignatures;
                    additionalResults.targetSymbol = callResolutionData.targetSymbol;
                }
            }
            return symbol;
        };
        PullTypeResolver.prototype.typeCheckInvocationExpression = function (callEx, context) {
            this.setTypeChecked(callEx, context);
            var targetSymbol = this.resolveAST(callEx.expression, false, context);
            var callResolutionData;
            if (callEx.argumentList.args) {
                callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);
                var len = callEx.argumentList.args.nonSeparatorCount();
                for (var i = 0; i < len; i++) {
                    var contextualType = callResolutionData.actualParametersContextTypeSymbols ? callResolutionData.actualParametersContextTypeSymbols[i] : null;
                    if (contextualType) {
                        context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                    }
                    this.resolveAST(callEx.argumentList.args.nonSeparatorAt(i), contextualType != null, context);
                    if (contextualType) {
                        context.popContextualType();
                        contextualType = null;
                    }
                }
            }
            for (var i = 0; i < callResolutionData.diagnosticsFromOverloadResolution.length; i++) {
                context.postDiagnostic(callResolutionData.diagnosticsFromOverloadResolution[i]);
            }
        };
        PullTypeResolver.prototype.computeInvocationExpressionSymbol = function (callEx, context, additionalResults) {
            var targetSymbol = this.resolveAST(callEx.expression, false, context);
            var targetAST = this.getCallTargetErrorSpanAST(callEx);
            var targetTypeSymbol = targetSymbol.type;
            if (targetTypeSymbol && targetTypeSymbol.kind === TypeScript.PullElementKind.Interface && targetTypeSymbol.name === "Just") {
                targetTypeSymbol = targetTypeSymbol.getTypeArgumentsOrTypeParameters()[0];
            }
            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                this.resolveAST(callEx.argumentList.args, false, context);
                if (callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.nonSeparatorCount()) {
                    if (targetTypeSymbol === this.semanticInfoChain.anyTypeSymbol) {
                        this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Untyped_function_calls_may_not_accept_type_arguments), additionalResults, context);
                        return this.getNewErrorTypeSymbol();
                    }
                }
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var isSuperCall = false;
            if (callEx.expression.kind() === TypeScript.SyntaxKind.SuperKeyword) {
                isSuperCall = true;
                if (targetTypeSymbol.isClass()) {
                    targetSymbol = targetTypeSymbol.getConstructorMethod();
                    this.resolveDeclaredSymbol(targetSymbol, context);
                    targetTypeSymbol = targetSymbol.type;
                }
                else {
                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Calls_to_super_are_only_valid_inside_a_class), additionalResults, context);
                    this.resolveAST(callEx.argumentList.args, false, context);
                    return this.getNewErrorTypeSymbol();
                }
            }
            var signatures = isSuperCall ? targetTypeSymbol.getConstructSignatures() : targetTypeSymbol.getCallSignatures();
            if (!signatures.length && (targetTypeSymbol.kind == TypeScript.PullElementKind.ConstructorType)) {
                this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, [targetTypeSymbol.toString()]), additionalResults, context);
            }
            var typeArgs = null;
            var typeReplacementMap = null;
            var couldNotFindGenericOverload = false;
            var couldNotAssignToConstraint;
            var constraintDiagnostic = null;
            var typeArgumentCountDiagnostic = null;
            var diagnostics = [];
            if (callEx.argumentList.typeArgumentList) {
                typeArgs = [];
                if (callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.nonSeparatorCount()) {
                    for (var i = 0; i < callEx.argumentList.typeArgumentList.typeArguments.nonSeparatorCount(); i++) {
                        typeArgs[i] = this.resolveTypeReference(callEx.argumentList.typeArgumentList.typeArguments.nonSeparatorAt(i), context);
                    }
                }
            }
            else if (isSuperCall && targetTypeSymbol.isGeneric()) {
                typeArgs = targetTypeSymbol.getTypeArguments();
            }
            var triedToInferTypeArgs = false;
            var resolvedSigMap = [];
            var resolvedSignatures = [];
            var inferredTypeArgs;
            var specializedSignature;
            var typeParameters;
            var typeConstraint = null;
            var beforeResolutionSignatures = signatures;
            var targetTypeReplacementMap = targetTypeSymbol.getTypeParameterArgumentMap();
            for (var i = 0; i < signatures.length; i++) {
                typeParameters = signatures[i].getTypeParameters();
                couldNotAssignToConstraint = false;
                if (signatures[i].isGeneric() && typeParameters.length) {
                    if (typeArgs) {
                        if (typeArgs.length == typeParameters.length) {
                            inferredTypeArgs = typeArgs;
                        }
                        else {
                            typeArgumentCountDiagnostic = typeArgumentCountDiagnostic ||
                                this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Signature_expected_0_type_arguments_got_1_instead, [typeParameters.length.toString(), typeArgs.length.toString()]);
                            continue;
                        }
                    }
                    else if (!typeArgs && callEx.argumentList.args && callEx.argumentList.args.nonSeparatorCount()) {
                        inferredTypeArgs = this.inferArgumentTypesForSignature(signatures[i], new TypeScript.ArgumentInferenceContext(this, callEx.argumentList.args), new TypeComparisonInfo(), context);
                        triedToInferTypeArgs = true;
                    }
                    else {
                        inferredTypeArgs = [];
                    }
                    if (inferredTypeArgs) {
                        typeReplacementMap = [];
                        if (inferredTypeArgs.length) {
                            if (inferredTypeArgs.length != typeParameters.length) {
                                continue;
                            }
                            if (targetTypeReplacementMap) {
                                for (var _ix = 0; _ix < targetTypeReplacementMap.length; _ix++) {
                                    if (targetTypeReplacementMap[_ix]) {
                                        typeReplacementMap[_ix] = targetTypeReplacementMap[_ix];
                                    }
                                }
                            }
                            for (var j = 0; j < typeParameters.length; j++) {
                                typeReplacementMap[typeParameters[j].pullSymbolID] = inferredTypeArgs[j];
                            }
                            for (var j = 0; j < typeParameters.length; j++) {
                                typeConstraint = typeParameters[j].getConstraint();
                                if (typeConstraint) {
                                    if (typeConstraint.isTypeParameter()) {
                                        for (var k = 0; k < typeParameters.length && k < inferredTypeArgs.length; k++) {
                                            if (typeParameters[k] == typeConstraint) {
                                                typeConstraint = inferredTypeArgs[k];
                                            }
                                            else {
                                                typeConstraint = this.instantiateType(typeConstraint, typeReplacementMap);
                                            }
                                        }
                                    }
                                    else if (typeConstraint.isGeneric()) {
                                        typeConstraint = this.instantiateType(typeConstraint, typeReplacementMap);
                                    }
                                    if (!this.sourceIsAssignableToTarget(inferredTypeArgs[j], typeConstraint, targetAST, context, null, true)) {
                                        var enclosingSymbol = this.getEnclosingSymbolForAST(targetAST);
                                        constraintDiagnostic = this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2, [inferredTypeArgs[j].toString(enclosingSymbol, true), typeConstraint.toString(enclosingSymbol, true), typeParameters[j].toString(enclosingSymbol, true)]);
                                        couldNotAssignToConstraint = true;
                                    }
                                    if (couldNotAssignToConstraint) {
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            if (triedToInferTypeArgs) {
                                continue;
                            }
                            for (var j = 0; j < typeParameters.length; j++) {
                                typeReplacementMap[typeParameters[j].pullSymbolID] = this.semanticInfoChain.emptyTypeSymbol;
                            }
                        }
                        if (couldNotAssignToConstraint) {
                            continue;
                        }
                        specializedSignature = this.instantiateSignature(signatures[i], typeReplacementMap, true);
                        if (specializedSignature) {
                            resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                            resolvedSigMap.push({ sig: specializedSignature, index: i, inferredTypeArgs: inferredTypeArgs });
                        }
                    }
                }
                else {
                    if (!(callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.nonSeparatorCount())) {
                        resolvedSignatures[resolvedSignatures.length] = signatures[i];
                        resolvedSigMap.push({ sig: signatures[i], index: i, inferredTypeArgs: signatures[i].isGeneric() ? inferredTypeArgs : [] });
                    }
                }
            }
            if (signatures.length && !resolvedSignatures.length) {
                couldNotFindGenericOverload = true;
            }
            signatures = resolvedSignatures;
            var errorCondition = null;
            var actualParametersContextTypeSymbols;
            if (!signatures.length) {
                additionalResults.targetSymbol = targetSymbol;
                additionalResults.resolvedSignatures = beforeResolutionSignatures;
                additionalResults.candidateSignature = beforeResolutionSignatures && beforeResolutionSignatures.length ? beforeResolutionSignatures[0] : null;
                additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;
                this.resolveAST(callEx.argumentList.args, false, context);
                if (!couldNotFindGenericOverload) {
                    if (this.cachedFunctionInterfaceType() && this.sourceIsSubtypeOfTarget(targetTypeSymbol, this.cachedFunctionInterfaceType(), targetAST, context)) {
                        if (callEx.argumentList.typeArgumentList) {
                            this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Non_generic_functions_may_not_accept_type_arguments), additionalResults, context);
                        }
                        return this.semanticInfoChain.anyTypeSymbol;
                    }
                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(callEx, TypeScript.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature), additionalResults, context);
                }
                else if (constraintDiagnostic) {
                    this.postOverloadResolutionDiagnostics(constraintDiagnostic, additionalResults, context);
                }
                else if (typeArgumentCountDiagnostic) {
                    this.postOverloadResolutionDiagnostics(typeArgumentCountDiagnostic, additionalResults, context);
                }
                else {
                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(callEx, TypeScript.DiagnosticCode.Could_not_select_overload_for_call_expression), additionalResults, context);
                }
                return this.getNewErrorTypeSymbol();
            }
            var signature = this.resolveOverloads(callEx, signatures, callEx.argumentList.typeArgumentList != null, context, diagnostics);
            var useBeforeResolutionSignatures = signature == null;
            if (!signature) {
                for (var i = 0; i < diagnostics.length; i++) {
                    this.postOverloadResolutionDiagnostics(diagnostics[i], additionalResults, context);
                }
                this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Could_not_select_overload_for_call_expression), additionalResults, context);
                errorCondition = this.getNewErrorTypeSymbol();
                if (!signatures.length) {
                    return errorCondition;
                }
                signature = signatures[0];
            }
            resolvedSigMap.some(function (s) {
                if (s.sig === signature) {
                    callEx.resolvedSignatureIndex = s.index;
                    callEx.inferredTypeArgs = s.inferredTypeArgs;
                    return true;
                }
            });
            if (!signature.isGeneric() && callEx.argumentList.typeArgumentList) {
                this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Non_generic_functions_may_not_accept_type_arguments), additionalResults, context);
            }
            else if (signature.isGeneric() && callEx.argumentList.typeArgumentList && signature.getTypeParameters() && (callEx.argumentList.typeArgumentList.typeArguments.nonSeparatorCount() != signature.getTypeParameters().length)) {
                this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Signature_expected_0_type_arguments_got_1_instead, [signature.getTypeParameters().length.toString(), callEx.argumentList.typeArgumentList.typeArguments.nonSeparatorCount().toString()]), additionalResults, context);
            }
            var returnType = isSuperCall ? this.semanticInfoChain.voidTypeSymbol : signature.returnType;
            actualParametersContextTypeSymbols = [];
            if (callEx.argumentList.args) {
                var len = callEx.argumentList.args.nonSeparatorCount();
                var params = signature.parameters;
                var contextualType = null;
                var signatureDecl = signature.getDeclarations()[0];
                for (var i = 0; i < len; i++) {
                    if (params.length) {
                        if (i < params.length - 1 || (i < params.length && !signature.hasVarArgs)) {
                            this.resolveDeclaredSymbol(params[i], context);
                            contextualType = params[i].type;
                        }
                        else if (signature.hasVarArgs) {
                            contextualType = params[params.length - 1].type;
                            if (contextualType.isArrayNamedTypeReference()) {
                                contextualType = contextualType.getElementType();
                            }
                        }
                    }
                    if (contextualType) {
                        context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                        actualParametersContextTypeSymbols[i] = contextualType;
                    }
                    this.resolveAST(callEx.argumentList.args.nonSeparatorAt(i), contextualType != null, context);
                    if (contextualType) {
                        context.popContextualType();
                        contextualType = null;
                    }
                }
            }
            additionalResults.targetSymbol = targetSymbol;
            if (useBeforeResolutionSignatures && beforeResolutionSignatures) {
                additionalResults.resolvedSignatures = beforeResolutionSignatures;
                additionalResults.candidateSignature = beforeResolutionSignatures[0];
            }
            else {
                additionalResults.resolvedSignatures = signatures;
                additionalResults.candidateSignature = signature;
            }
            additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;
            if (errorCondition) {
                return errorCondition;
            }
            if (!returnType) {
                returnType = this.semanticInfoChain.anyTypeSymbol;
            }
            return returnType;
        };
        PullTypeResolver.prototype.resolveObjectCreationExpression = function (callEx, context, additionalResults) {
            var symbol = this.getSymbolForAST(callEx, context);
            if (!symbol || !symbol.isResolved) {
                if (!additionalResults) {
                    additionalResults = new PullAdditionalCallResolutionData();
                }
                symbol = this.computeObjectCreationExpressionSymbol(callEx, context, additionalResults);
                if (this.canTypeCheckAST(callEx, context)) {
                    this.setTypeChecked(callEx, context);
                }
                this.setSymbolForAST(callEx, symbol, context);
                this.semanticInfoChain.setCallResolutionDataForAST(callEx, additionalResults);
            }
            else {
                if (this.canTypeCheckAST(callEx, context)) {
                    this.typeCheckObjectCreationExpression(callEx, context);
                }
                var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);
                if (additionalResults && (callResolutionData != additionalResults)) {
                    additionalResults.actualParametersContextTypeSymbols = callResolutionData.actualParametersContextTypeSymbols;
                    additionalResults.candidateSignature = callResolutionData.candidateSignature;
                    additionalResults.resolvedSignatures = callResolutionData.resolvedSignatures;
                    additionalResults.targetSymbol = callResolutionData.targetSymbol;
                }
            }
            return symbol;
        };
        PullTypeResolver.prototype.typeCheckObjectCreationExpression = function (callEx, context) {
            this.setTypeChecked(callEx, context);
            this.resolveAST(callEx.expression, false, context);
            var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);
            if (callEx.argumentList) {
                var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);
                var len = callEx.argumentList.args.nonSeparatorCount();
                for (var i = 0; i < len; i++) {
                    var contextualType = callResolutionData.actualParametersContextTypeSymbols ? callResolutionData.actualParametersContextTypeSymbols[i] : null;
                    if (contextualType) {
                        context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                    }
                    this.resolveAST(callEx.argumentList.args.nonSeparatorAt(i), contextualType != null, context);
                    if (contextualType) {
                        context.popContextualType();
                        contextualType = null;
                    }
                }
            }
            for (var i = 0; i < callResolutionData.diagnosticsFromOverloadResolution.length; i++) {
                context.postDiagnostic(callResolutionData.diagnosticsFromOverloadResolution[i]);
            }
        };
        PullTypeResolver.prototype.postOverloadResolutionDiagnostics = function (diagnostic, additionalResults, context) {
            if (!context.inProvisionalResolution()) {
                additionalResults.diagnosticsFromOverloadResolution.push(diagnostic);
            }
            context.postDiagnostic(diagnostic);
        };
        PullTypeResolver.prototype.computeObjectCreationExpressionSymbol = function (callEx, context, additionalResults) {
            var returnType = null;
            var targetSymbol = this.resolveAST(callEx.expression, false, context);
            var targetTypeSymbol = targetSymbol.isType() ? targetSymbol : targetSymbol.type;
            var targetAST = this.getCallTargetErrorSpanAST(callEx);
            var constructSignatures = targetTypeSymbol.getConstructSignatures();
            var _constructSignatures = constructSignatures;
            var typeArgs = null;
            var typeReplacementMap = null;
            var usedCallSignaturesInstead = false;
            var couldNotAssignToConstraint;
            var constraintDiagnostic = null;
            var typeArgumentCountDiagnostic = null;
            var diagnostics = [];
            var resolvedSigMap = [];
            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                if (callEx.argumentList) {
                    this.resolveAST(callEx.argumentList.args, false, context);
                }
                return targetTypeSymbol;
            }
            if (!constructSignatures.length) {
                constructSignatures = targetTypeSymbol.getCallSignatures();
                usedCallSignaturesInstead = true;
                if (this.compilationSettings.noImplicitAny()) {
                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(callEx, TypeScript.DiagnosticCode.new_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type), additionalResults, context);
                }
            }
            if (constructSignatures.length) {
                if (callEx.argumentList && callEx.argumentList.typeArgumentList) {
                    typeArgs = [];
                    if (callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.nonSeparatorCount()) {
                        for (var i = 0; i < callEx.argumentList.typeArgumentList.typeArguments.nonSeparatorCount(); i++) {
                            typeArgs[i] = this.resolveTypeReference(callEx.argumentList.typeArgumentList.typeArguments.nonSeparatorAt(i), context);
                        }
                    }
                }
                if (targetTypeSymbol.isGeneric()) {
                    var resolvedSignatures = [];
                    var inferredTypeArgs;
                    var specializedSignature;
                    var typeParameters;
                    var typeConstraint = null;
                    var triedToInferTypeArgs;
                    var targetTypeReplacementMap = targetTypeSymbol.getTypeParameterArgumentMap();
                    for (var i = 0; i < constructSignatures.length; i++) {
                        couldNotAssignToConstraint = false;
                        if (constructSignatures[i].isGeneric()) {
                            typeParameters = constructSignatures[i].getTypeParameters();
                            if (typeArgs) {
                                if (typeArgs.length == typeParameters.length) {
                                    inferredTypeArgs = typeArgs;
                                }
                                else {
                                    typeArgumentCountDiagnostic = typeArgumentCountDiagnostic ||
                                        this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Signature_expected_0_type_arguments_got_1_instead, [typeParameters.length.toString(), typeArgs.length.toString()]);
                                    continue;
                                }
                            }
                            else if (!typeArgs && callEx.argumentList && callEx.argumentList.args && callEx.argumentList.args.nonSeparatorCount()) {
                                inferredTypeArgs = this.inferArgumentTypesForSignature(constructSignatures[i], new TypeScript.ArgumentInferenceContext(this, callEx.argumentList.args), new TypeComparisonInfo(), context);
                                triedToInferTypeArgs = true;
                            }
                            else {
                                inferredTypeArgs = [];
                            }
                            if (inferredTypeArgs) {
                                typeReplacementMap = [];
                                if (inferredTypeArgs.length) {
                                    if (inferredTypeArgs.length < typeParameters.length) {
                                        continue;
                                    }
                                    if (targetTypeReplacementMap) {
                                        for (var symbolID in targetTypeReplacementMap) {
                                            if (targetTypeReplacementMap.hasOwnProperty(symbolID)) {
                                                typeReplacementMap[+symbolID] = targetTypeReplacementMap[+symbolID];
                                            }
                                        }
                                    }
                                    for (var j = 0; j < typeParameters.length; j++) {
                                        typeReplacementMap[typeParameters[j].pullSymbolID] = inferredTypeArgs[j];
                                    }
                                    for (var j = 0; j < typeParameters.length; j++) {
                                        typeConstraint = typeParameters[j].getConstraint();
                                        if (typeConstraint) {
                                            if (typeConstraint.isTypeParameter()) {
                                                for (var k = 0; k < typeParameters.length && k < inferredTypeArgs.length; k++) {
                                                    if (typeParameters[k] == typeConstraint) {
                                                        typeConstraint = inferredTypeArgs[k];
                                                    }
                                                    else {
                                                        typeConstraint = this.instantiateType(typeConstraint, typeReplacementMap);
                                                    }
                                                }
                                            }
                                            else if (typeConstraint.isGeneric()) {
                                                typeConstraint = this.instantiateType(typeConstraint, typeReplacementMap);
                                            }
                                            if (!this.sourceIsAssignableToTarget(inferredTypeArgs[j], typeConstraint, targetAST, context, null, true)) {
                                                var enclosingSymbol = this.getEnclosingSymbolForAST(targetAST);
                                                constraintDiagnostic = this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2, [inferredTypeArgs[j].toString(enclosingSymbol, true), typeConstraint.toString(enclosingSymbol, true), typeParameters[j].toString(enclosingSymbol, true)]);
                                                couldNotAssignToConstraint = true;
                                            }
                                            if (couldNotAssignToConstraint) {
                                                break;
                                            }
                                        }
                                    }
                                }
                                else {
                                    if (triedToInferTypeArgs) {
                                        continue;
                                    }
                                    else {
                                        for (var j = 0; j < typeParameters.length; j++) {
                                            typeReplacementMap[typeParameters[j].pullSymbolID] = this.semanticInfoChain.emptyTypeSymbol;
                                        }
                                    }
                                }
                                if (couldNotAssignToConstraint) {
                                    continue;
                                }
                                specializedSignature = this.instantiateSignature(constructSignatures[i], typeReplacementMap, true);
                                if (specializedSignature) {
                                    resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                                    resolvedSigMap.push({ sig: specializedSignature, index: i, inferredTypeArgs: inferredTypeArgs });
                                }
                            }
                        }
                        else {
                            if (!(callEx.argumentList && callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.nonSeparatorCount())) {
                                resolvedSignatures[resolvedSignatures.length] = constructSignatures[i];
                                resolvedSigMap.push({ sig: constructSignatures[i], index: i, inferredTypeArgs: null });
                            }
                        }
                    }
                    constructSignatures = resolvedSignatures;
                }
                var signature = this.resolveOverloads(callEx, constructSignatures, callEx.argumentList && callEx.argumentList.typeArgumentList != null, context, diagnostics);
                additionalResults.targetSymbol = targetSymbol;
                additionalResults.resolvedSignatures = constructSignatures;
                additionalResults.candidateSignature = signature;
                additionalResults.actualParametersContextTypeSymbols = [];
                if (!constructSignatures.length) {
                    if (constraintDiagnostic) {
                        this.postOverloadResolutionDiagnostics(constraintDiagnostic, additionalResults, context);
                    }
                    else if (typeArgumentCountDiagnostic) {
                        this.postOverloadResolutionDiagnostics(typeArgumentCountDiagnostic, additionalResults, context);
                    }
                    return this.getNewErrorTypeSymbol();
                }
                var errorCondition = null;
                if (!signature) {
                    for (var i = 0; i < diagnostics.length; i++) {
                        this.postOverloadResolutionDiagnostics(diagnostics[i], additionalResults, context);
                    }
                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Could_not_select_overload_for_new_expression), additionalResults, context);
                    errorCondition = this.getNewErrorTypeSymbol();
                    if (!constructSignatures.length) {
                        return errorCondition;
                    }
                    signature = constructSignatures[0];
                }
                resolvedSigMap.some(function (s) {
                    if (s.sig === signature) {
                        callEx.resolvedSignatureIndex = s.index;
                        callEx.inferredTypeArgs = s.inferredTypeArgs;
                        return true;
                    }
                });
                returnType = signature.returnType;
                if (returnType && !signature.isGeneric() && returnType.isGeneric() && !returnType.getIsSpecialized()) {
                    if (typeArgs && typeArgs.length) {
                        returnType = this.createInstantiatedType(returnType, typeArgs);
                    }
                    else {
                        returnType = this.instantiateTypeToAny(returnType, context);
                    }
                }
                if (usedCallSignaturesInstead) {
                    if (returnType != this.semanticInfoChain.voidTypeSymbol) {
                        this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Call_signatures_used_in_a_new_expression_must_have_a_void_return_type), additionalResults, context);
                        return this.getNewErrorTypeSymbol();
                    }
                    else {
                        returnType = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
                if (!returnType) {
                    returnType = signature.returnType;
                    if (!returnType) {
                        returnType = targetTypeSymbol;
                    }
                }
                var actualParametersContextTypeSymbols = [];
                if (callEx.argumentList && callEx.argumentList.args) {
                    var len = callEx.argumentList.args.nonSeparatorCount();
                    var params = signature.parameters;
                    var contextualType = null;
                    var signatureDecl = signature.getDeclarations()[0];
                    for (var i = 0; i < len; i++) {
                        if (params.length) {
                            if (i < params.length - 1 || (i < params.length && !signature.hasVarArgs)) {
                                this.resolveDeclaredSymbol(params[i], context);
                                contextualType = params[i].type;
                            }
                            else if (signature.hasVarArgs) {
                                contextualType = params[params.length - 1].type;
                                if (contextualType.isArrayNamedTypeReference()) {
                                    contextualType = contextualType.getElementType();
                                }
                            }
                        }
                        if (contextualType) {
                            context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                            actualParametersContextTypeSymbols[i] = contextualType;
                        }
                        this.resolveAST(callEx.argumentList.args.nonSeparatorAt(i), contextualType != null, context);
                        if (contextualType) {
                            context.popContextualType();
                            contextualType = null;
                        }
                    }
                }
                additionalResults.targetSymbol = targetSymbol;
                additionalResults.resolvedSignatures = constructSignatures;
                additionalResults.candidateSignature = signature;
                additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;
                if (errorCondition) {
                    return errorCondition;
                }
                if (!returnType) {
                    returnType = this.semanticInfoChain.anyTypeSymbol;
                }
                return returnType;
            }
            else if (callEx.argumentList) {
                this.resolveAST(callEx.argumentList.args, false, context);
            }
            this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Invalid_new_expression), additionalResults, context);
            return this.getNewErrorTypeSymbol();
        };
        PullTypeResolver.prototype.instantiateSignatureInContext = function (signatureA, signatureB, context) {
            var typeReplacementMap = [];
            var inferredTypeArgs;
            var specializedSignature;
            var typeParameters = signatureA.getTypeParameters();
            var typeConstraint = null;
            var fixedParameterTypes = [];
            for (var i = 0; i < signatureB.parameters.length; i++) {
                fixedParameterTypes.push(signatureB.parameters[i].isVarArg ? signatureB.parameters[i].type.getElementType() : signatureB.parameters[i].type);
            }
            inferredTypeArgs = this.inferArgumentTypesForSignature(signatureA, new TypeScript.ArgumentInferenceContext(this, fixedParameterTypes), new TypeComparisonInfo(), context);
            var functionTypeA = signatureA.functionType;
            var functionTypeB = signatureB.functionType;
            var enclosingTypeParameterMap;
            if (functionTypeA) {
                enclosingTypeParameterMap = functionTypeA.getTypeParameterArgumentMap();
                if (enclosingTypeParameterMap) {
                    for (var _ix = 0; _ix < enclosingTypeParameterMap.length; _ix++) {
                        typeReplacementMap[_ix] = enclosingTypeParameterMap[_ix];
                    }
                }
            }
            if (functionTypeB) {
                enclosingTypeParameterMap = functionTypeB.getTypeParameterArgumentMap();
                if (enclosingTypeParameterMap) {
                    for (var _ix = 0; _ix < enclosingTypeParameterMap.length; _ix++) {
                        typeReplacementMap[_ix] = enclosingTypeParameterMap[_ix];
                    }
                }
            }
            for (var i = 0; i < typeParameters.length; i++) {
                typeReplacementMap[typeParameters[i].pullSymbolID] = inferredTypeArgs[i];
            }
            for (var i = 0; i < typeParameters.length; i++) {
                typeConstraint = typeParameters[i].getConstraint();
                if (typeConstraint) {
                    if (typeConstraint.isTypeParameter()) {
                        for (var j = 0; j < typeParameters.length && j < inferredTypeArgs.length; j++) {
                            if (typeParameters[j] == typeConstraint) {
                                typeConstraint = inferredTypeArgs[j];
                            }
                        }
                    }
                    else if (typeConstraint.isGeneric()) {
                        typeConstraint = TypeScript.PullInstantiatedTypeReferenceSymbol.create(this, typeConstraint, typeReplacementMap);
                    }
                    if (!this.sourceIsAssignableToTarget(inferredTypeArgs[i], typeConstraint, null, context, null, true)) {
                        if (this.signaturesAreIdentical(signatureA, signatureB, true)) {
                            return signatureA;
                        }
                        else {
                            return null;
                        }
                    }
                }
            }
            return this.instantiateSignature(signatureA, typeReplacementMap, true);
        };
        PullTypeResolver.prototype.resolveCastExpression = function (assertionExpression, context) {
            var typeAssertionType = this.resolveTypeReference(assertionExpression.type, context).type;
            if (this.canTypeCheckAST(assertionExpression, context)) {
                this.typeCheckCastExpression(assertionExpression, context, typeAssertionType);
            }
            return typeAssertionType;
        };
        PullTypeResolver.prototype.typeCheckCastExpression = function (assertionExpression, context, typeAssertionType) {
            this.setTypeChecked(assertionExpression, context);
            context.pushContextualType(typeAssertionType, context.inProvisionalResolution(), null);
            var exprType = this.resolveAST(assertionExpression.expression, true, context).type;
            context.popContextualType();
            this.resolveDeclaredSymbol(typeAssertionType, context);
            this.resolveDeclaredSymbol(exprType, context);
            var comparisonInfo = new TypeComparisonInfo();
            var isAssignable = this.sourceIsAssignableToTarget(typeAssertionType, exprType, assertionExpression, context, comparisonInfo) ||
                this.sourceIsAssignableToTarget(exprType, typeAssertionType, assertionExpression, context, comparisonInfo);
            if (!isAssignable) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(assertionExpression);
                if (comparisonInfo.message) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(assertionExpression, TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [exprType.toString(enclosingSymbol), typeAssertionType.toString(enclosingSymbol), comparisonInfo.message]));
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(assertionExpression, TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [exprType.toString(enclosingSymbol), typeAssertionType.toString(enclosingSymbol)]));
                }
            }
        };
        PullTypeResolver.prototype.resolveAssignmentExpression = function (binaryExpression, context) {
            var leftExpr = this.resolveAST(binaryExpression.left, false, context);
            var leftType = leftExpr.type;
            context.pushContextualType(leftType, context.inProvisionalResolution(), null);
            var rightType = this.resolveAST(binaryExpression.right, true, context).type;
            context.popContextualType();
            rightType = this.getInstanceTypeForAssignment(binaryExpression.left, rightType, context);
            if (this.canTypeCheckAST(binaryExpression, context)) {
                this.setTypeChecked(binaryExpression, context);
                if (!this.isReference(binaryExpression.left, leftExpr)) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression));
                }
                else {
                    this.checkAssignability(binaryExpression.left, rightType, leftExpr.type, context);
                }
            }
            return rightType;
        };
        PullTypeResolver.prototype.getInstanceTypeForAssignment = function (lhs, type, context) {
            var typeToReturn = type;
            if (typeToReturn && typeToReturn.isAlias()) {
                typeToReturn = typeToReturn.getExportAssignedTypeSymbol();
            }
            if (typeToReturn && typeToReturn.isContainer() && !typeToReturn.isEnum()) {
                var instanceTypeSymbol = typeToReturn.getInstanceType();
                if (!instanceTypeSymbol) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(lhs, TypeScript.DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type_0, [type.toString()]));
                    typeToReturn = null;
                }
                else {
                    typeToReturn = instanceTypeSymbol;
                }
            }
            return typeToReturn;
        };
        PullTypeResolver.prototype.widenType = function (type, ast, context) {
            if (type === this.semanticInfoChain.undefinedTypeSymbol ||
                type === this.semanticInfoChain.nullTypeSymbol ||
                type.isError()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            if (type.isArrayNamedTypeReference()) {
                var elementType = this.widenType(type.getElementType(), null, context);
                if (this.compilationSettings.noImplicitAny() && ast && ast.kind() === TypeScript.SyntaxKind.ArrayLiteralExpression) {
                    if (elementType === this.semanticInfoChain.anyTypeSymbol && type.getElementType() !== this.semanticInfoChain.anyTypeSymbol) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Array_Literal_implicitly_has_an_any_type_from_widening));
                    }
                }
                var arraySymbol = elementType.getArrayType();
                if (!arraySymbol) {
                    arraySymbol = this.createInstantiatedType(this.cachedArrayInterfaceType(), [elementType]);
                    if (!arraySymbol) {
                        arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
                return arraySymbol;
            }
            return type;
        };
        PullTypeResolver.prototype.findBestCommonType = function (collection, context, comparisonInfo) {
            var len = collection.getLength();
            for (var i = 0; i < len; i++) {
                var candidateType = collection.getTypeAtIndex(i);
                if (this.typeIsBestCommonTypeCandidate(candidateType, collection, context)) {
                    return candidateType;
                }
            }
            return this.semanticInfoChain.emptyTypeSymbol;
        };
        PullTypeResolver.prototype.typeIsBestCommonTypeCandidate = function (candidateType, collection, context) {
            for (var i = 0; i < collection.getLength(); i++) {
                var otherType = collection.getTypeAtIndex(i);
                if (candidateType == otherType) {
                    continue;
                }
                if (candidateType.isTypeParameter() && !otherType.isTypeParameter()) {
                    return false;
                }
                else if (!candidateType.isTypeParameter() && otherType.isTypeParameter()) {
                    continue;
                }
                else if (!this.sourceIsSubtypeOfTarget(otherType, candidateType, null, context)) {
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.typesAreIdenticalInEnclosingTypes = function (t1, t2, t1EnclosingType, t2EnclosingType, val) {
            t1 = this.getSymbolForRelationshipCheck(t1);
            t2 = this.getSymbolForRelationshipCheck(t2);
            if (t1 === t2) {
                return true;
            }
            if (t1 && t2) {
                var t1GenerativeTypeKind = t1EnclosingType ? t1.getGenerativeTypeClassification(t1EnclosingType) : TypeScript.GenerativeTypeClassification.Unknown;
                var t2GenerativeTypeKind = t2EnclosingType ? t2.getGenerativeTypeClassification(t2EnclosingType) : TypeScript.GenerativeTypeClassification.Unknown;
                if (t1GenerativeTypeKind == TypeScript.GenerativeTypeClassification.InfinitelyExpanding ||
                    t2GenerativeTypeKind == TypeScript.GenerativeTypeClassification.InfinitelyExpanding) {
                    return this.infinitelyExpandingTypesAreIdentical(t1, t2);
                }
            }
            return this.typesAreIdentical(t1, t2, val);
        };
        PullTypeResolver.prototype.typesAreIdentical = function (t1, t2, val) {
            t1 = this.getSymbolForRelationshipCheck(t1);
            t2 = this.getSymbolForRelationshipCheck(t2);
            if (t1 === t2) {
                return true;
            }
            if (!t1 || !t2) {
                return false;
            }
            if (val && t1.isPrimitive() && t1.isStringConstant() && t2 === this.semanticInfoChain.stringTypeSymbol) {
                return (val.kind() === TypeScript.SyntaxKind.StringLiteral) && (TypeScript.stripStartAndEndQuotes(val.text()) === TypeScript.stripStartAndEndQuotes(t1.name));
            }
            if (val && t2.isPrimitive() && t2.isStringConstant() && t2 === this.semanticInfoChain.stringTypeSymbol) {
                return (val.kind() === TypeScript.SyntaxKind.StringLiteral) && (TypeScript.stripStartAndEndQuotes(val.text()) === TypeScript.stripStartAndEndQuotes(t2.name));
            }
            if (t1.isPrimitive() && t1.isStringConstant() && t2.isPrimitive() && t2.isStringConstant()) {
                return TypeScript.stripStartAndEndQuotes(t1.name) === TypeScript.stripStartAndEndQuotes(t2.name);
            }
            if (t1.isPrimitive() || t2.isPrimitive()) {
                return false;
            }
            if (t1.isError() && t2.isError()) {
                return true;
            }
            if (t1.isTypeParameter() != t2.isTypeParameter()) {
                return false;
            }
            else if (t1.isTypeParameter()) {
                var t1ParentDeclaration = t1.getDeclarations()[0].getParentDecl();
                var t2ParentDeclaration = t2.getDeclarations()[0].getParentDecl();
                if (t1ParentDeclaration === t2ParentDeclaration) {
                    return this.symbolsShareDeclaration(t1, t2);
                }
                else {
                    return false;
                }
            }
            var isIdentical = this.identicalCache.valueAt(t1.pullSymbolID, t2.pullSymbolID);
            if (isIdentical != undefined) {
                return isIdentical;
            }
            if ((t1.kind & TypeScript.PullElementKind.Enum) || (t2.kind & TypeScript.PullElementKind.Enum)) {
                return t1.getAssociatedContainerType() === t2 || t2.getAssociatedContainerType() === t1;
            }
            if (t1.isPrimitive() != t2.isPrimitive()) {
                return false;
            }
            this.identicalCache.setValueAt(t1.pullSymbolID, t2.pullSymbolID, false);
            if (t1.hasMembers() && t2.hasMembers()) {
                var t1Members = t1.getAllMembers(TypeScript.PullElementKind.SomeValue, TypeScript.GetAllMembersVisiblity.all);
                var t2Members = t2.getAllMembers(TypeScript.PullElementKind.SomeValue, TypeScript.GetAllMembersVisiblity.all);
                if (t1Members.length != t2Members.length) {
                    this.identicalCache.setValueAt(t1.pullSymbolID, t2.pullSymbolID, undefined);
                    return false;
                }
                var t1MemberSymbol = null;
                var t2MemberSymbol = null;
                var t1MemberType = null;
                var t2MemberType = null;
                for (var iMember = 0; iMember < t1Members.length; iMember++) {
                    t1MemberSymbol = t1Members[iMember];
                    t2MemberSymbol = this.getMemberSymbol(t1MemberSymbol.name, TypeScript.PullElementKind.SomeValue, t2);
                    if (!t2MemberSymbol || (t1MemberSymbol.isOptional != t2MemberSymbol.isOptional)) {
                        this.identicalCache.setValueAt(t1.pullSymbolID, t2.pullSymbolID, undefined);
                        return false;
                    }
                    t1MemberType = t1MemberSymbol.type;
                    t2MemberType = t2MemberSymbol.type;
                    if (!this.typesAreIdenticalInEnclosingTypes(t1MemberType, t2MemberType, t1, t2)) {
                        return false;
                    }
                }
            }
            else if (t1.hasMembers() || t2.hasMembers()) {
                this.identicalCache.setValueAt(t1.pullSymbolID, t2.pullSymbolID, undefined);
                return false;
            }
            var t1CallSigs = t1.getCallSignatures();
            var t2CallSigs = t2.getCallSignatures();
            var t1ConstructSigs = t1.getConstructSignatures();
            var t2ConstructSigs = t2.getConstructSignatures();
            var t1IndexSigs = t1.getIndexSignatures();
            var t2IndexSigs = t2.getIndexSignatures();
            if (!this.signatureGroupsAreIdentical(t1CallSigs, t2CallSigs)) {
                this.identicalCache.setValueAt(t1.pullSymbolID, t2.pullSymbolID, undefined);
                return false;
            }
            if (!this.signatureGroupsAreIdentical(t1ConstructSigs, t2ConstructSigs)) {
                this.identicalCache.setValueAt(t1.pullSymbolID, t2.pullSymbolID, undefined);
                return false;
            }
            if (!this.signatureGroupsAreIdentical(t1IndexSigs, t2IndexSigs)) {
                this.identicalCache.setValueAt(t1.pullSymbolID, t2.pullSymbolID, undefined);
                return false;
            }
            this.identicalCache.setValueAt(t1.pullSymbolID, t2.pullSymbolID, true);
            return true;
        };
        PullTypeResolver.prototype.signatureGroupsAreIdentical = function (sg1, sg2) {
            if (sg1 === sg2) {
                return true;
            }
            if (!sg1 || !sg2) {
                return false;
            }
            if (sg1.length != sg2.length) {
                return false;
            }
            var sig1 = null;
            var sig2 = null;
            var sigsMatch = false;
            for (var iSig1 = 0; iSig1 < sg1.length; iSig1++) {
                sig1 = sg1[iSig1];
                for (var iSig2 = 0; iSig2 < sg2.length; iSig2++) {
                    sig2 = sg2[iSig2];
                    if (this.signaturesAreIdentical(sig1, sig2)) {
                        sigsMatch = true;
                        break;
                    }
                }
                if (sigsMatch) {
                    sigsMatch = false;
                    continue;
                }
                return false;
            }
            return true;
        };
        PullTypeResolver.prototype.signaturesAreIdentical = function (s1, s2, includingReturnType) {
            if (includingReturnType === void 0) { includingReturnType = true; }
            if (s1 === s2) {
                return true;
            }
            if (s1.hasVarArgs != s2.hasVarArgs) {
                return false;
            }
            if (s1.nonOptionalParamCount != s2.nonOptionalParamCount) {
                return false;
            }
            if (!!(s1.typeParameters && s1.typeParameters.length) != !!(s2.typeParameters && s2.typeParameters.length)) {
                return false;
            }
            if (s1.typeParameters && s2.typeParameters && (s1.typeParameters.length != s2.typeParameters.length)) {
                return false;
            }
            if (s1.parameters.length != s2.parameters.length) {
                return false;
            }
            this.resolveDeclaredSymbol(s1);
            this.resolveDeclaredSymbol(s2);
            var s1Params = s1.parameters;
            var s2Params = s2.parameters;
            if (includingReturnType && !this.typesAreIdenticalInEnclosingTypes(s1.returnType, s2.returnType, s1.functionType, s2.functionType)) {
                return false;
            }
            for (var iParam = 0; iParam < s1Params.length; iParam++) {
                if (!this.typesAreIdenticalInEnclosingTypes(s1Params[iParam].type, s2Params[iParam].type, s1.functionType, s2.functionType)) {
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.substituteUpperBoundForType = function (type) {
            if (!type || !type.isTypeParameter()) {
                return type;
            }
            var constraint = type.getConstraint();
            if (constraint && (constraint != type)) {
                return this.substituteUpperBoundForType(constraint);
            }
            return type;
        };
        PullTypeResolver.prototype.symbolsShareDeclaration = function (symbol1, symbol2) {
            var decls1 = symbol1.getDeclarations();
            var decls2 = symbol2.getDeclarations();
            if (decls1.length && decls2.length) {
                return decls1[0].isEqual(decls2[0]);
            }
            return false;
        };
        PullTypeResolver.prototype.sourceExtendsTarget = function (source, target, context) {
            if (source.isGeneric() != target.isGeneric()) {
                return false;
            }
            if (source.isTypeReference() && target.isTypeReference()) {
                if (source.referencedTypeSymbol.hasBase(target.referencedTypeSymbol)) {
                    var sourceTypeArguments = source.getTypeArguments();
                    var targetTypeArguments = target.getTypeArguments();
                    if (!(sourceTypeArguments && targetTypeArguments) || sourceTypeArguments.length != targetTypeArguments.length) {
                        return false;
                    }
                    for (var i = 0; i < targetTypeArguments.length; i++) {
                        if (!this.sourceExtendsTarget(sourceTypeArguments[i], targetTypeArguments[i], context)) {
                            return false;
                        }
                    }
                    return true;
                }
            }
            if (source.hasBase(target)) {
                return true;
            }
            if (context.isInBaseTypeResolution() &&
                (source.kind & (TypeScript.PullElementKind.Interface | TypeScript.PullElementKind.Class)) &&
                (target.kind & (TypeScript.PullElementKind.Interface | TypeScript.PullElementKind.Class))) {
                var sourceDecls = source.getDeclarations();
                var extendsSymbol = null;
                for (var i = 0; i < sourceDecls.length; i++) {
                    var sourceAST = this.semanticInfoChain.getASTForDecl(sourceDecls[i]);
                    var extendsClause = TypeScript.getExtendsHeritageClause(sourceAST.heritageClauses);
                    if (extendsClause) {
                        for (var j = 0; j < extendsClause.typeNames.nonSeparatorCount(); j++) {
                            extendsSymbol = this.semanticInfoChain.getSymbolForAST(extendsClause.typeNames.nonSeparatorAt(j));
                            if (extendsSymbol && (extendsSymbol == target || this.sourceExtendsTarget(extendsSymbol, target, context))) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        };
        PullTypeResolver.prototype.sourceIsSubtypeOfTarget = function (source, target, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };
        PullTypeResolver.prototype.sourceMembersAreSubtypeOfTargetMembers = function (source, target, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            return this.sourceMembersAreRelatableToTargetMembers(source, target, false, this.subtypeCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };
        PullTypeResolver.prototype.sourcePropertyIsSubtypeOfTargetProperty = function (source, target, sourceProp, targetProp, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            return this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, false, this.subtypeCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };
        PullTypeResolver.prototype.sourceCallSignaturesAreSubtypeOfTargetCallSignatures = function (source, target, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            return this.sourceCallSignaturesAreRelatableToTargetCallSignatures(source, target, false, this.subtypeCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };
        PullTypeResolver.prototype.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures = function (source, target, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            return this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(source, target, false, this.subtypeCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };
        PullTypeResolver.prototype.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures = function (source, target, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            return this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(source, target, false, this.subtypeCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };
        PullTypeResolver.prototype.typeIsSubtypeOfFunction = function (source, ast, context) {
            if (source.getCallSignatures().length || source.getConstructSignatures().length) {
                return true;
            }
            return this.cachedFunctionInterfaceType() &&
                this.sourceIsSubtypeOfTarget(source, this.cachedFunctionInterfaceType(), ast, context);
        };
        PullTypeResolver.prototype.signatureIsSubtypeOfTarget = function (s1, s2, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };
        PullTypeResolver.prototype.sourceIsAssignableToTarget = function (source, target, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };
        PullTypeResolver.prototype.signatureIsAssignableToTarget = function (s1, s2, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };
        PullTypeResolver.prototype.getSymbolForRelationshipCheck = function (symbol) {
            if (symbol && symbol.isTypeReference()) {
                return symbol.getReferencedTypeSymbol();
            }
            return symbol;
        };
        PullTypeResolver.prototype.sourceIsRelatableToTargetInEnclosingTypes = function (source, target, sourceEnclosingType, targetEnclosingType, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            source = this.getSymbolForRelationshipCheck(source);
            target = this.getSymbolForRelationshipCheck(target);
            if (source === target) {
                return true;
            }
            if (source && target) {
                var sourceGenerativeTypeKind = sourceEnclosingType ? source.getGenerativeTypeClassification(sourceEnclosingType) : TypeScript.GenerativeTypeClassification.Unknown;
                var targetGenerativeTypeKind = targetEnclosingType ? target.getGenerativeTypeClassification(targetEnclosingType) : TypeScript.GenerativeTypeClassification.Unknown;
                if (sourceGenerativeTypeKind == TypeScript.GenerativeTypeClassification.InfinitelyExpanding ||
                    targetGenerativeTypeKind == TypeScript.GenerativeTypeClassification.InfinitelyExpanding) {
                    return this.infinitelyExpandingSourceTypeIsRelatableToTargetType(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
                }
            }
            return this.sourceIsRelatableToTarget(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };
        PullTypeResolver.prototype.sourceIsRelatableToTarget = function (source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            source = this.getSymbolForRelationshipCheck(source);
            target = this.getSymbolForRelationshipCheck(target);
            if (source === target) {
                return true;
            }
            if (!(source && target)) {
                return true;
            }
            var sourceSubstitution = source;
            if (source == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                this.resolveDeclaredSymbol(this.cachedStringInterfaceType(), context);
                sourceSubstitution = this.cachedStringInterfaceType();
            }
            else if (source == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType()) {
                this.resolveDeclaredSymbol(this.cachedNumberInterfaceType(), context);
                sourceSubstitution = this.cachedNumberInterfaceType();
            }
            else if (source == this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType()) {
                this.resolveDeclaredSymbol(this.cachedBooleanInterfaceType(), context);
                sourceSubstitution = this.cachedBooleanInterfaceType();
            }
            else if (TypeScript.PullHelpers.symbolIsEnum(source) && this.cachedNumberInterfaceType()) {
                sourceSubstitution = this.cachedNumberInterfaceType();
            }
            else if (source.isTypeParameter()) {
                sourceSubstitution = this.substituteUpperBoundForType(source);
            }
            if (comparisonCache.valueAt(source.pullSymbolID, target.pullSymbolID) != undefined) {
                return true;
            }
            if (source === this.semanticInfoChain.stringTypeSymbol && target.isPrimitive() && target.isStringConstant()) {
                return comparisonInfo &&
                    comparisonInfo.stringConstantVal &&
                    (comparisonInfo.stringConstantVal.kind() === TypeScript.SyntaxKind.StringLiteral) &&
                    (TypeScript.stripStartAndEndQuotes(comparisonInfo.stringConstantVal.text()) === TypeScript.stripStartAndEndQuotes(target.name));
            }
            if (assignableTo) {
                if (this.isAnyOrEquivalent(source) || this.isAnyOrEquivalent(target)) {
                    return true;
                }
            }
            else {
                if (this.isAnyOrEquivalent(target)) {
                    return true;
                }
                if (target === this.semanticInfoChain.stringTypeSymbol && source.isPrimitive() && source.isStringConstant()) {
                    return true;
                }
            }
            if (source.isPrimitive() && source.isStringConstant() && target.isPrimitive() && target.isStringConstant()) {
                return TypeScript.stripStartAndEndQuotes(source.name) === TypeScript.stripStartAndEndQuotes(target.name);
            }
            if (source === this.semanticInfoChain.undefinedTypeSymbol) {
                return true;
            }
            if ((source === this.semanticInfoChain.nullTypeSymbol) && (target != this.semanticInfoChain.undefinedTypeSymbol && target != this.semanticInfoChain.voidTypeSymbol)) {
                return true;
            }
            if (target == this.semanticInfoChain.voidTypeSymbol) {
                if (source == this.semanticInfoChain.undefinedTypeSymbol || source == this.semanticInfoChain.nullTypeSymbol) {
                    return true;
                }
                return false;
            }
            else if (source == this.semanticInfoChain.voidTypeSymbol) {
                if (target == this.semanticInfoChain.anyTypeSymbol) {
                    return true;
                }
                return false;
            }
            if (target === this.semanticInfoChain.numberTypeSymbol && TypeScript.PullHelpers.symbolIsEnum(source)) {
                return true;
            }
            if (source === this.semanticInfoChain.numberTypeSymbol && TypeScript.PullHelpers.symbolIsEnum(target)) {
                return assignableTo;
            }
            if (TypeScript.PullHelpers.symbolIsEnum(target) && TypeScript.PullHelpers.symbolIsEnum(source)) {
                return this.symbolsShareDeclaration(target, source);
            }
            if ((source.kind & TypeScript.PullElementKind.Enum) || (target.kind & TypeScript.PullElementKind.Enum)) {
                return false;
            }
            if (source.getIsSpecialized() && target.getIsSpecialized()) {
                if (TypeScript.PullHelpers.getRootType(source) == TypeScript.PullHelpers.getRootType(target)) {
                    var sourceTypeArguments = source.getTypeArguments();
                    var targetTypeArguments = target.getTypeArguments();
                    if (sourceTypeArguments && targetTypeArguments) {
                        comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, false);
                        for (var i = 0; i < sourceTypeArguments.length; i++) {
                            if (!this.sourceIsRelatableToTarget(sourceTypeArguments[i], targetTypeArguments[i], assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                                break;
                            }
                        }
                        if (i == sourceTypeArguments.length) {
                            comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, true);
                            return true;
                        }
                        else {
                            comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, undefined);
                        }
                    }
                }
            }
            if (sourceSubstitution.isPrimitive() || target.isPrimitive()) {
                return false;
            }
            if (target.isTypeParameter()) {
                if (source.isTypeParameter() && (source === sourceSubstitution)) {
                    return this.typesAreIdentical(target, source);
                }
                else {
                    if (isComparingInstantiatedSignatures) {
                        target = this.substituteUpperBoundForType(target);
                    }
                    else {
                        return this.typesAreIdentical(target, sourceSubstitution);
                    }
                }
            }
            comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, false);
            if ((source.kind & TypeScript.PullElementKind.SomeInstantiatableType) && (target.kind & TypeScript.PullElementKind.SomeInstantiatableType) && this.sourceExtendsTarget(source, target, context)) {
                return true;
            }
            if (this.cachedObjectInterfaceType() && target === this.cachedObjectInterfaceType()) {
                return true;
            }
            if (this.cachedFunctionInterfaceType() &&
                (sourceSubstitution.getCallSignatures().length || sourceSubstitution.getConstructSignatures().length) &&
                target.hasBase(this.cachedFunctionInterfaceType())) {
                return true;
            }
            if (target.hasMembers() && !this.sourceMembersAreRelatableToTargetMembers(sourceSubstitution, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, undefined);
                return false;
            }
            if (!this.sourceCallSignaturesAreRelatableToTargetCallSignatures(sourceSubstitution, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, undefined);
                return false;
            }
            if (!this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(sourceSubstitution, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, undefined);
                return false;
            }
            if (!this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(sourceSubstitution, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, undefined);
                return false;
            }
            comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, true);
            return true;
        };
        PullTypeResolver.prototype.sourceMembersAreRelatableToTargetMembers = function (source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var targetProps = target.getAllMembers(TypeScript.PullElementKind.SomeValue, TypeScript.GetAllMembersVisiblity.all);
            for (var itargetProp = 0; itargetProp < targetProps.length; itargetProp++) {
                var targetProp = targetProps[itargetProp];
                var sourceProp = this.getMemberSymbol(targetProp.name, TypeScript.PullElementKind.SomeValue, source);
                this.resolveDeclaredSymbol(targetProp, context);
                var targetPropType = targetProp.type;
                if (sourceProp && sourceProp.anyDeclHasFlag(TypeScript.PullElementFlags.Static) && source.isClass()) {
                    sourceProp = null;
                }
                if (!sourceProp) {
                    if (this.cachedObjectInterfaceType()) {
                        sourceProp = this.getMemberSymbol(targetProp.name, TypeScript.PullElementKind.SomeValue, this.cachedObjectInterfaceType());
                    }
                    if (!sourceProp) {
                        if (this.cachedFunctionInterfaceType() && (targetPropType.getCallSignatures().length || targetPropType.getConstructSignatures().length)) {
                            sourceProp = this.getMemberSymbol(targetProp.name, TypeScript.PullElementKind.SomeValue, this.cachedFunctionInterfaceType());
                        }
                        if (!sourceProp) {
                            if (!(targetProp.isOptional)) {
                                if (comparisonInfo) {
                                    var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                                    comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.RequiredPropertyIsMissing;
                                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_0_is_missing_property_1_from_type_2, [source.toString(enclosingSymbol), targetProp.getScopedNameEx().toString(), target.toString(enclosingSymbol)]));
                                }
                                return false;
                            }
                            continue;
                        }
                    }
                }
                if (!this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.infinitelyExpandingSourceTypeIsRelatableToTargetType = function (sourceType, targetType, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var widenedTargetType = this.widenType(targetType);
            var widenedSourceType = this.widenType(sourceType);
            if ((widenedSourceType != this.semanticInfoChain.anyTypeSymbol) &&
                (widenedTargetType != this.semanticInfoChain.anyTypeSymbol)) {
                var sourceTypeNamedTypeReference = TypeScript.PullHelpers.getRootType(sourceType);
                var targetTypeNamedTypeReference = TypeScript.PullHelpers.getRootType(targetType);
                if (sourceTypeNamedTypeReference != targetTypeNamedTypeReference) {
                    comparisonCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                    if (comparisonInfo) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_0_and_1_originating_in_inifinitely_expanding_type_reference_do_not_refer_to_same_named_type, [sourceType.getScopedNameEx(enclosingSymbol).toString(), targetType.toString(enclosingSymbol)]));
                    }
                    return false;
                }
                var sourceTypeArguments = sourceType.getTypeArguments();
                var targetTypeArguments = targetType.getTypeArguments();
                if (!sourceTypeArguments && !targetTypeArguments) {
                    comparisonCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, true);
                    return true;
                }
                if (!(sourceTypeArguments && targetTypeArguments) ||
                    sourceTypeArguments.length != targetTypeArguments.length) {
                    comparisonCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                    if (comparisonInfo) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_0_and_1_originating_in_inifinitely_expanding_type_reference_have_incompatible_type_arguments, [sourceType.toString(enclosingSymbol), targetType.toString(enclosingSymbol)]));
                    }
                    return false;
                }
                var comparisonInfoTypeArgumentsCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoTypeArgumentsCheck = new TypeComparisonInfo(comparisonInfo);
                }
                for (var i = 0; i < sourceTypeArguments.length; i++) {
                    if (!this.sourceIsRelatableToTarget(sourceTypeArguments[i], targetTypeArguments[i], assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                        if (comparisonInfo) {
                            var message;
                            var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                            if (comparisonInfoTypeArgumentsCheck && comparisonInfoTypeArgumentsCheck.message) {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_0_and_1_originating_in_inifinitely_expanding_type_reference_have_incompatible_type_arguments_NL_2, [sourceType.toString(enclosingSymbol), targetType.toString(enclosingSymbol), comparisonInfoTypeArgumentsCheck.message]);
                            }
                            else {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_0_and_1_originating_in_inifinitely_expanding_type_reference_have_incompatible_type_arguments, [sourceType.toString(enclosingSymbol), targetType.toString(enclosingSymbol)]);
                            }
                            comparisonInfo.addMessage(message);
                        }
                    }
                }
            }
            comparisonCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, true);
            return true;
        };
        PullTypeResolver.prototype.infinitelyExpandingTypesAreIdentical = function (sourceType, targetType) {
            var widenedTargetType = this.widenType(targetType);
            var widenedSourceType = this.widenType(sourceType);
            if ((widenedSourceType != this.semanticInfoChain.anyTypeSymbol) &&
                (widenedTargetType != this.semanticInfoChain.anyTypeSymbol)) {
                var sourceTypeNamedTypeReference = TypeScript.PullHelpers.getRootType(sourceType);
                var targetTypeNamedTypeReference = TypeScript.PullHelpers.getRootType(targetType);
                if (sourceTypeNamedTypeReference != targetTypeNamedTypeReference) {
                    this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                    return false;
                }
                var sourceTypeArguments = sourceType.getTypeArguments();
                var targetTypeArguments = targetType.getTypeArguments();
                if (!sourceTypeArguments && !targetTypeArguments) {
                    this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, true);
                    return true;
                }
                if (!(sourceTypeArguments && targetTypeArguments) ||
                    sourceTypeArguments.length != targetTypeArguments.length) {
                    this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                    return false;
                }
                for (var i = 0; i < sourceTypeArguments.length; i++) {
                    if (!this.typesAreIdentical(sourceTypeArguments[i], targetTypeArguments[i])) {
                        this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                        return false;
                    }
                }
            }
            this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, true);
            return true;
        };
        PullTypeResolver.prototype.sourcePropertyIsRelatableToTargetProperty = function (source, target, sourceProp, targetProp, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var targetPropIsPrivate = targetProp.anyDeclHasFlag(TypeScript.PullElementFlags.Private);
            var sourcePropIsPrivate = sourceProp.anyDeclHasFlag(TypeScript.PullElementFlags.Private);
            if (targetPropIsPrivate != sourcePropIsPrivate) {
                if (comparisonInfo) {
                    var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                    if (targetPropIsPrivate) {
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2, [targetProp.getScopedNameEx().toString(), sourceProp.getContainer().toString(enclosingSymbol), targetProp.getContainer().toString(enclosingSymbol)]));
                    }
                    else {
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2, [targetProp.getScopedNameEx().toString(), sourceProp.getContainer().toString(enclosingSymbol), targetProp.getContainer().toString(enclosingSymbol)]));
                    }
                    comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.InconsistantPropertyAccesibility;
                }
                return false;
            }
            else if (sourcePropIsPrivate && targetPropIsPrivate) {
                var targetDecl = targetProp.getDeclarations()[0];
                var sourceDecl = sourceProp.getDeclarations()[0];
                if (!targetDecl.isEqual(sourceDecl)) {
                    if (comparisonInfo) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.InconsistantPropertyAccesibility;
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_0_and_1_define_property_2_as_private, [sourceProp.getContainer().toString(enclosingSymbol), targetProp.getContainer().toString(enclosingSymbol), targetProp.getScopedNameEx().toString()]));
                    }
                    return false;
                }
            }
            this.resolveDeclaredSymbol(sourceProp, context);
            var sourcePropType = sourceProp.type;
            var targetPropType = targetProp.type;
            if (comparisonCache.valueAt(sourcePropType.pullSymbolID, targetPropType.pullSymbolID)) {
                return true;
            }
            var comparisonInfoPropertyTypeCheck = null;
            if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                comparisonInfoPropertyTypeCheck = new TypeComparisonInfo(comparisonInfo);
            }
            if (this.sourceIsRelatableToTargetInEnclosingTypes(sourcePropType, targetPropType, source, target, assignableTo, comparisonCache, ast, context, comparisonInfoPropertyTypeCheck, isComparingInstantiatedSignatures)) {
                return true;
            }
            if (comparisonInfo) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatiblePropertyTypes;
                var message;
                if (comparisonInfoPropertyTypeCheck && comparisonInfoPropertyTypeCheck.message) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3, [targetProp.getScopedNameEx().toString(), source.toString(enclosingSymbol), target.toString(enclosingSymbol), comparisonInfoPropertyTypeCheck.message]);
                }
                else {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_property_0_of_types_1_and_2_are_incompatible, [targetProp.getScopedNameEx().toString(), source.toString(enclosingSymbol), target.toString(enclosingSymbol)]);
                }
                comparisonInfo.addMessage(message);
            }
            return false;
        };
        PullTypeResolver.prototype.sourceCallSignaturesAreRelatableToTargetCallSignatures = function (source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var targetCallSigs = target.getCallSignatures();
            if (targetCallSigs.length) {
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }
                var sourceCallSigs = source.getCallSignatures();
                if (!this.signatureGroupIsRelatableToTarget(sourceCallSigs, targetCallSigs, assignableTo, comparisonCache, ast, context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures)) {
                    if (comparisonInfo) {
                        var message;
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        if (sourceCallSigs.length && targetCallSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signatures_of_types_0_and_1_are_incompatible_NL_2, [source.toString(enclosingSymbol), target.toString(enclosingSymbol), comparisonInfoSignatuesTypeCheck.message]);
                            }
                            else {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signatures_of_types_0_and_1_are_incompatible, [source.toString(enclosingSymbol), target.toString(enclosingSymbol)]);
                            }
                        }
                        else {
                            var hasSig = targetCallSigs.length ? target.toString(enclosingSymbol) : source.toString(enclosingSymbol);
                            var lacksSig = !targetCallSigs.length ? target.toString(enclosingSymbol) : source.toString(enclosingSymbol);
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_0_requires_a_call_signature_but_type_1_lacks_one, [hasSig, lacksSig]);
                        }
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleSignatures;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.sourceConstructSignaturesAreRelatableToTargetConstructSignatures = function (source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var targetConstructSigs = target.getConstructSignatures();
            if (targetConstructSigs.length) {
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }
                var sourceConstructSigs = source.getConstructSignatures();
                if (!this.signatureGroupIsRelatableToTarget(sourceConstructSigs, targetConstructSigs, assignableTo, comparisonCache, ast, context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures)) {
                    if (comparisonInfo) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        var message;
                        if (sourceConstructSigs.length && targetConstructSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Construct_signatures_of_types_0_and_1_are_incompatible_NL_2, [source.toString(enclosingSymbol), target.toString(enclosingSymbol), comparisonInfoSignatuesTypeCheck.message]);
                            }
                            else {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Construct_signatures_of_types_0_and_1_are_incompatible, [source.toString(enclosingSymbol), target.toString(enclosingSymbol)]);
                            }
                        }
                        else {
                            var hasSig = targetConstructSigs.length ? target.toString(enclosingSymbol) : source.toString(enclosingSymbol);
                            var lacksSig = !targetConstructSigs.length ? target.toString(enclosingSymbol) : source.toString(enclosingSymbol);
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_0_requires_a_construct_signature_but_type_1_lacks_one, [hasSig, lacksSig]);
                        }
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleSignatures;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.sourceIndexSignaturesAreRelatableToTargetIndexSignatures = function (source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var targetIndexSigs = this.getBothKindsOfIndexSignatures(target, context);
            var targetStringSig = targetIndexSigs.stringSignature;
            var targetNumberSig = targetIndexSigs.numericSignature;
            if (targetStringSig || targetNumberSig) {
                var sourceIndexSigs = this.getBothKindsOfIndexSignatures(source, context);
                var sourceStringSig = sourceIndexSigs.stringSignature;
                var sourceNumberSig = sourceIndexSigs.numericSignature;
                var comparable = true;
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }
                if (targetStringSig) {
                    if (sourceStringSig) {
                        comparable = this.signatureIsAssignableToTarget(sourceStringSig, targetStringSig, ast, context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures);
                    }
                    else {
                        comparable = false;
                    }
                }
                if (comparable && targetNumberSig) {
                    if (sourceNumberSig) {
                        comparable = this.signatureIsAssignableToTarget(sourceNumberSig, targetNumberSig, ast, context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures);
                    }
                    else if (sourceStringSig) {
                        comparable = this.sourceIsAssignableToTarget(sourceStringSig.returnType, targetNumberSig.returnType, ast, context, comparisonInfoSignatuesTypeCheck);
                    }
                    else {
                        comparable = false;
                    }
                }
                if (!comparable) {
                    if (comparisonInfo) {
                        var message;
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Index_signatures_of_types_0_and_1_are_incompatible_NL_2, [source.toString(enclosingSymbol), target.toString(enclosingSymbol), comparisonInfoSignatuesTypeCheck.message]);
                        }
                        else {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Index_signatures_of_types_0_and_1_are_incompatible, [source.toString(enclosingSymbol), target.toString(enclosingSymbol)]);
                        }
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleSignatures;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.signatureGroupIsRelatableToTarget = function (sourceSG, targetSG, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            if (sourceSG === targetSG) {
                return true;
            }
            if (!(sourceSG.length && targetSG.length)) {
                return false;
            }
            var mSig = null;
            var nSig = null;
            var foundMatch = false;
            var targetExcludeDefinition = targetSG.length > 1;
            var sourceExcludeDefinition = sourceSG.length > 1;
            for (var iMSig = 0; iMSig < targetSG.length; iMSig++) {
                mSig = targetSG[iMSig];
                if (mSig.isStringConstantOverloadSignature() || (targetExcludeDefinition && mSig.isDefinition())) {
                    continue;
                }
                for (var iNSig = 0; iNSig < sourceSG.length; iNSig++) {
                    nSig = sourceSG[iNSig];
                    if (nSig.isStringConstantOverloadSignature() || (sourceExcludeDefinition && nSig.isDefinition())) {
                        continue;
                    }
                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                        foundMatch = true;
                        break;
                    }
                }
                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }
                return false;
            }
            return true;
        };
        PullTypeResolver.prototype.signatureIsRelatableToTarget = function (sourceSig, targetSig, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var sourceParameters = sourceSig.parameters;
            var targetParameters = targetSig.parameters;
            if (!sourceParameters || !targetParameters) {
                return false;
            }
            var targetVarArgCount = targetSig.nonOptionalParamCount;
            var sourceVarArgCount = sourceSig.nonOptionalParamCount;
            if (sourceVarArgCount > targetVarArgCount) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.SourceSignatureHasTooManyParameters;
                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signature_expects_0_or_fewer_parameters, [targetVarArgCount.toString()]));
                }
                return false;
            }
            if (sourceSig.isGeneric()) {
                sourceSig = this.instantiateSignatureInContext(sourceSig, targetSig, context);
                if (!sourceSig) {
                    return false;
                }
                else {
                    sourceParameters = sourceSig.parameters;
                }
            }
            comparisonCache.setValueAt(sourceSig.pullSymbolID, targetSig.pullSymbolID, false);
            var sourceReturnType = sourceSig.returnType;
            var targetReturnType = targetSig.returnType;
            if (targetReturnType != this.semanticInfoChain.voidTypeSymbol) {
                if (!this.sourceIsRelatableToTargetInEnclosingTypes(sourceReturnType, targetReturnType, sourceSig.functionType, targetSig.functionType, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleReturnTypes;
                    }
                    return false;
                }
            }
            var len = (sourceVarArgCount < targetVarArgCount && (sourceSig.hasVarArgs || (sourceParameters.length > sourceVarArgCount))) ? targetVarArgCount : sourceVarArgCount;
            if (!len) {
                len = (sourceParameters.length < targetParameters.length) ? sourceParameters.length : targetParameters.length;
            }
            var sourceParamType = null;
            var targetParamType = null;
            var sourceParamName = "";
            var targetParamName = "";
            for (var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {
                if (iSource < sourceParameters.length && (!sourceSig.hasVarArgs || iSource < sourceVarArgCount)) {
                    sourceParamType = sourceParameters[iSource].type;
                    sourceParamName = sourceParameters[iSource].name;
                }
                else if (iSource === sourceVarArgCount) {
                    sourceParamType = sourceParameters[iSource].type;
                    if (sourceParamType.isArrayNamedTypeReference()) {
                        sourceParamType = sourceParamType.getElementType();
                    }
                    sourceParamName = sourceParameters[iSource].name;
                }
                if (iTarget < targetParameters.length && !targetSig.hasVarArgs && (!targetVarArgCount || (iTarget < targetVarArgCount))) {
                    targetParamType = targetParameters[iTarget].type;
                    targetParamName = targetParameters[iTarget].name;
                }
                else if (targetSig.hasVarArgs && iTarget === targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].type;
                    if (targetParamType.isArrayNamedTypeReference()) {
                        targetParamType = targetParamType.getElementType();
                    }
                    targetParamName = targetParameters[iTarget].name;
                }
                if (!(this.sourceIsRelatableToTargetInEnclosingTypes(sourceParamType, targetParamType, sourceSig.functionType, targetSig.functionType, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) ||
                    this.sourceIsRelatableToTargetInEnclosingTypes(targetParamType, sourceParamType, targetSig.functionType, sourceSig.functionType, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures))) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleParameterTypes;
                    }
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.resolveOverloads = function (application, group, haveTypeArgumentsAtCallSite, context, diagnostics) {
            var _this_1 = this;
            var hasOverloads = group.length > 1;
            var comparisonInfo = new TypeComparisonInfo();
            var args = application.argumentList ? application.argumentList.args : null;
            var initialCandidates = TypeScript.ArrayUtilities.where(group, function (signature) {
                if (hasOverloads && signature.isDefinition()) {
                    return false;
                }
                if (haveTypeArgumentsAtCallSite && !signature.isGeneric()) {
                    return false;
                }
                return _this_1.overloadHasCorrectArity(signature, args);
            });
            var firstAssignableButNotSupertypeSignature = null;
            var firstAssignableWithProvisionalErrorsSignature = null;
            for (var i = 0; i < initialCandidates.length; i++) {
                var applicability = this.overloadIsApplicable(initialCandidates[i], args, context, comparisonInfo);
                if (applicability === OverloadApplicabilityStatus.Subtype) {
                    return initialCandidates[i];
                }
                else if (applicability === OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors &&
                    !firstAssignableButNotSupertypeSignature) {
                    firstAssignableButNotSupertypeSignature = initialCandidates[i];
                }
                else if (applicability === OverloadApplicabilityStatus.AssignableButWithProvisionalErrors &&
                    !firstAssignableWithProvisionalErrorsSignature) {
                    firstAssignableWithProvisionalErrorsSignature = initialCandidates[i];
                }
            }
            if (firstAssignableButNotSupertypeSignature || firstAssignableWithProvisionalErrorsSignature) {
                return firstAssignableButNotSupertypeSignature || firstAssignableWithProvisionalErrorsSignature;
            }
            else {
                var target = this.getCallTargetErrorSpanAST(application);
                if (comparisonInfo.message) {
                    diagnostics.push(this.semanticInfoChain.diagnosticFromAST(target, TypeScript.DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0, [comparisonInfo.message]));
                }
                else {
                    diagnostics.push(this.semanticInfoChain.diagnosticFromAST(target, TypeScript.DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target, null));
                }
            }
            return null;
        };
        PullTypeResolver.prototype.getCallTargetErrorSpanAST = function (callEx) {
            return (callEx.expression.kind() === TypeScript.SyntaxKind.MemberAccessExpression) ? callEx.expression.name : callEx.expression;
        };
        PullTypeResolver.prototype.overloadHasCorrectArity = function (signature, args) {
            if (args == null) {
                return signature.nonOptionalParamCount === 0;
            }
            var numberOfArgs = (args.nonSeparatorCount() && args.nonSeparatorCount() === args.separatorCount())
                ? args.separatorCount() + 1
                : args.nonSeparatorCount();
            if (numberOfArgs < signature.nonOptionalParamCount) {
                return false;
            }
            if (!signature.hasVarArgs && numberOfArgs > signature.parameters.length) {
                return false;
            }
            return true;
        };
        PullTypeResolver.prototype.overloadIsApplicable = function (signature, args, context, comparisonInfo) {
            if (args === null) {
                return OverloadApplicabilityStatus.Subtype;
            }
            var isInVarArg = false;
            var parameters = signature.parameters;
            var paramType = null;
            var overloadApplicability = OverloadApplicabilityStatus.Subtype;
            for (var i = 0; i < args.nonSeparatorCount(); i++) {
                if (!isInVarArg) {
                    this.resolveDeclaredSymbol(parameters[i], context);
                    if (parameters[i].isVarArg) {
                        paramType = parameters[i].type.getElementType() || this.getNewErrorTypeSymbol(parameters[i].type.getName());
                        isInVarArg = true;
                    }
                    else {
                        paramType = parameters[i].type;
                    }
                }
                var statusOfCurrentArgument = this.overloadIsApplicableForArgument(paramType, args.nonSeparatorAt(i), i, context, comparisonInfo);
                if (statusOfCurrentArgument === OverloadApplicabilityStatus.NotAssignable) {
                    return OverloadApplicabilityStatus.NotAssignable;
                }
                else if (statusOfCurrentArgument === OverloadApplicabilityStatus.AssignableButWithProvisionalErrors) {
                    overloadApplicability = OverloadApplicabilityStatus.AssignableButWithProvisionalErrors;
                }
                else if (overloadApplicability !== OverloadApplicabilityStatus.AssignableButWithProvisionalErrors &&
                    statusOfCurrentArgument === OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors) {
                    overloadApplicability = OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors;
                }
            }
            return overloadApplicability;
        };
        PullTypeResolver.prototype.overloadIsApplicableForArgument = function (paramType, arg, argIndex, context, comparisonInfo) {
            if (paramType.isAny()) {
                return OverloadApplicabilityStatus.Subtype;
            }
            else if (paramType.isError()) {
                return OverloadApplicabilityStatus.AssignableButWithProvisionalErrors;
            }
            else if (arg.kind() === TypeScript.SyntaxKind.SimpleArrowFunctionExpression) {
                var simpleArrowFunction = arg;
                return this.overloadIsApplicableForAnyFunctionExpressionArgument(paramType, arg, null, TypeScript.Parameters.fromIdentifier(simpleArrowFunction.identifier), null, simpleArrowFunction.block, simpleArrowFunction.expression, argIndex, context, comparisonInfo);
            }
            else if (arg.kind() === TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression) {
                var arrowFunction = arg;
                return this.overloadIsApplicableForAnyFunctionExpressionArgument(paramType, arg, arrowFunction.callSignature.typeParameterList, TypeScript.Parameters.fromParameterList(arrowFunction.callSignature.parameterList), TypeScript.getType(arrowFunction), arrowFunction.block, arrowFunction.expression, argIndex, context, comparisonInfo);
            }
            else if (arg.kind() === TypeScript.SyntaxKind.FunctionExpression) {
                var functionExpression = arg;
                return this.overloadIsApplicableForAnyFunctionExpressionArgument(paramType, arg, functionExpression.callSignature.typeParameterList, TypeScript.Parameters.fromParameterList(functionExpression.callSignature.parameterList), TypeScript.getType(functionExpression), functionExpression.block, null, argIndex, context, comparisonInfo);
            }
            else if (arg.kind() === TypeScript.SyntaxKind.ObjectLiteralExpression) {
                return this.overloadIsApplicableForObjectLiteralArgument(paramType, arg, argIndex, context, comparisonInfo);
            }
            else if (arg.kind() === TypeScript.SyntaxKind.ArrayLiteralExpression) {
                return this.overloadIsApplicableForArrayLiteralArgument(paramType, arg, argIndex, context, comparisonInfo);
            }
            else {
                return this.overloadIsApplicableForOtherArgument(paramType, arg, argIndex, context, comparisonInfo);
            }
        };
        PullTypeResolver.prototype.overloadIsApplicableForAnyFunctionExpressionArgument = function (paramType, arg, typeParameters, parameters, returnTypeAnnotation, block, bodyExpression, argIndex, context, comparisonInfo) {
            if (this.cachedFunctionInterfaceType() && paramType === this.cachedFunctionInterfaceType()) {
                return OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors;
            }
            context.pushContextualType(paramType, true, null);
            var argSym = this.resolveAnyFunctionExpression(arg, typeParameters, parameters, returnTypeAnnotation, block, bodyExpression, true, context);
            var applicabilityStatus = this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, arg, context);
            context.popContextualType();
            return applicabilityStatus;
        };
        PullTypeResolver.prototype.overloadIsApplicableForObjectLiteralArgument = function (paramType, arg, argIndex, context, comparisonInfo) {
            if (this.cachedObjectInterfaceType() && paramType === this.cachedObjectInterfaceType()) {
                return OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors;
            }
            context.pushContextualType(paramType, true, null);
            var argSym = this.resolveObjectLiteralExpression(arg, true, context);
            var applicabilityStatus = this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, arg, context);
            context.popContextualType();
            return applicabilityStatus;
        };
        PullTypeResolver.prototype.overloadIsApplicableForArrayLiteralArgument = function (paramType, arg, argIndex, context, comparisonInfo) {
            if (paramType === this.cachedArrayInterfaceType()) {
                return OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors;
            }
            context.pushContextualType(paramType, true, null);
            var argSym = this.resolveArrayLiteralExpression(arg, true, context);
            var applicabilityStatus = this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, arg, context);
            context.popContextualType();
            return applicabilityStatus;
        };
        PullTypeResolver.prototype.overloadIsApplicableForOtherArgument = function (paramType, arg, argIndex, context, comparisonInfo) {
            var argSym = this.resolveAST(arg, false, context);
            if (argSym.type.isAlias()) {
                var aliasSym = argSym.type;
                argSym = aliasSym.getExportAssignedTypeSymbol();
            }
            comparisonInfo.stringConstantVal = arg;
            return this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, arg, context);
        };
        PullTypeResolver.prototype.overloadIsApplicableForArgumentHelper = function (paramType, argSym, argumentIndex, comparisonInfo, arg, context) {
            var tempComparisonInfo = new TypeComparisonInfo();
            tempComparisonInfo.stringConstantVal = comparisonInfo.stringConstantVal;
            if (!context.hasProvisionalErrors() && this.sourceIsSubtypeOfTarget(argSym.type, paramType, arg, context, tempComparisonInfo)) {
                return OverloadApplicabilityStatus.Subtype;
            }
            if (this.sourceIsAssignableToTarget(argSym.type, paramType, arg, context, comparisonInfo.message ? tempComparisonInfo : comparisonInfo)) {
                return context.hasProvisionalErrors()
                    ? OverloadApplicabilityStatus.AssignableButWithProvisionalErrors
                    : OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors;
            }
            if (!comparisonInfo.message) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(arg);
                comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_apply_type_0_to_argument_1_which_is_of_type_2, [paramType.toString(enclosingSymbol), (argumentIndex + 1).toString(), argSym.getTypeName(enclosingSymbol)]));
            }
            return OverloadApplicabilityStatus.NotAssignable;
        };
        PullTypeResolver.prototype.inferArgumentTypesForSignature = function (signature, argContext, comparisonInfo, context) {
            var cxt = null;
            var parameters = signature.parameters;
            var typeParameters = signature.getTypeParameters();
            var parameterType = null;
            var argCount = argContext.getInferenceArgumentCount();
            for (var i = 0; i < typeParameters.length; i++) {
                argContext.addInferenceRoot(typeParameters[i]);
            }
            for (var i = 0; i < argCount; i++) {
                if (i >= parameters.length) {
                    break;
                }
                parameterType = parameters[i].type;
                if (signature.hasVarArgs && (i >= signature.nonOptionalParamCount - 1) && parameterType.isArrayNamedTypeReference()) {
                    parameterType = parameterType.getElementType();
                }
                var inferenceCandidates = argContext.getInferenceCandidates();
                if (inferenceCandidates.length) {
                    for (var j = 0; j < inferenceCandidates.length; j++) {
                        argContext.resetRelationshipCache();
                        var substitutions = inferenceCandidates[j];
                        context.pushContextualType(parameterType, true, substitutions);
                        this.relateTypeToTypeParameters(argContext.getArgumentTypeSymbolAtIndex(i, context), parameterType, false, argContext, context);
                        cxt = context.popContextualType();
                    }
                }
                else {
                    context.pushContextualType(parameterType, true, []);
                    this.relateTypeToTypeParameters(argContext.getArgumentTypeSymbolAtIndex(i, context), parameterType, false, argContext, context);
                    cxt = context.popContextualType();
                }
            }
            var inferenceResults = argContext.inferArgumentTypes(this, context);
            if (inferenceResults.unfit) {
                return null;
            }
            var resultTypes = [];
            for (var i = 0; i < typeParameters.length; i++) {
                for (var j = 0; j < inferenceResults.results.length; j++) {
                    if ((inferenceResults.results[j].param == typeParameters[i]) && inferenceResults.results[j].type) {
                        resultTypes[resultTypes.length] = inferenceResults.results[j].type;
                        break;
                    }
                }
            }
            if (!argCount && !resultTypes.length && typeParameters.length) {
                for (var i = 0; i < typeParameters.length; i++) {
                    resultTypes[resultTypes.length] = this.semanticInfoChain.emptyTypeSymbol;
                }
            }
            else if (resultTypes.length < typeParameters.length) {
                for (var i = resultTypes.length; i < typeParameters.length; i++) {
                    resultTypes[i] = this.semanticInfoChain.emptyTypeSymbol;
                }
            }
            var inferringAtCallExpression = argContext.argumentASTs && argContext.argumentASTs.parent && argContext.argumentASTs.parent.kind() === TypeScript.SyntaxKind.ArgumentList &&
                (argContext.argumentASTs.parent.parent.kind() === TypeScript.SyntaxKind.InvocationExpression || argContext.argumentASTs.parent.parent.kind() === TypeScript.SyntaxKind.ObjectCreationExpression);
            if (inferringAtCallExpression) {
                if (!this.typeParametersAreInScopeAtArgumentList(typeParameters, argContext.argumentASTs)) {
                    for (var i = 0; i < resultTypes.length; i++) {
                        if (resultTypes[i].wrapsSomeTypeParameter(argContext.candidateCache)) {
                            resultTypes[i] = this.semanticInfoChain.emptyTypeSymbol;
                        }
                    }
                }
            }
            return resultTypes;
        };
        PullTypeResolver.prototype.typeParametersAreInScopeAtArgumentList = function (typeParameters, args) {
            var enclosingDecl = this.getEnclosingDeclForAST(args);
            var typeParameterParentDecl = typeParameters[0].getDeclarations()[0].getParentDecl();
            return enclosingDecl.getParentPath().indexOf(typeParameterParentDecl) > -1;
        };
        PullTypeResolver.prototype.relateTypeToTypeParametersInEnclosingType = function (expressionType, parameterType, expressionTypeEnclosingType, parameterTypeEnclosingType, shouldFix, argContext, context) {
            if (expressionType && parameterType) {
                var expressionTypeGenerativeTypeClassification = expressionTypeEnclosingType ? expressionType.getGenerativeTypeClassification(expressionTypeEnclosingType) : TypeScript.GenerativeTypeClassification.Unknown;
                var parameterTypeGenerativeTypeClassification = parameterTypeEnclosingType ? parameterType.getGenerativeTypeClassification(parameterTypeEnclosingType) : TypeScript.GenerativeTypeClassification.Unknown;
                if (expressionTypeGenerativeTypeClassification == TypeScript.GenerativeTypeClassification.InfinitelyExpanding ||
                    parameterTypeGenerativeTypeClassification == TypeScript.GenerativeTypeClassification.InfinitelyExpanding) {
                    this.relateInifinitelyExpandingTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, context);
                    return;
                }
            }
            this.relateTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, context);
        };
        PullTypeResolver.prototype.relateTypeToTypeParameters = function (expressionType, parameterType, shouldFix, argContext, context) {
            if (!expressionType || !parameterType) {
                return;
            }
            if (expressionType.isError()) {
                expressionType = this.semanticInfoChain.anyTypeSymbol;
            }
            if (parameterType.isTypeParameter()) {
                argContext.addCandidateForInference(parameterType, expressionType, shouldFix);
                return;
            }
            var parameterDeclarations = parameterType.getDeclarations();
            var expressionDeclarations = expressionType.getDeclarations();
            if (!parameterType.isArrayNamedTypeReference() &&
                parameterDeclarations.length &&
                expressionDeclarations.length &&
                !(parameterType.isTypeParameter() || expressionType.isTypeParameter()) &&
                (parameterDeclarations[0].isEqual(expressionDeclarations[0]) || (expressionType.isGeneric() && parameterType.isGeneric() &&
                    this.sourceIsSubtypeOfTarget(this.instantiateTypeToAny(expressionType, context), this.instantiateTypeToAny(parameterType, context), null, context, null))) &&
                expressionType.isGeneric()) {
                this.relateTypeArgumentsOfTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, context);
            }
            if (expressionType.isArrayNamedTypeReference() && parameterType.isArrayNamedTypeReference()) {
                this.relateArrayTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, context);
                return;
            }
            this.relateObjectTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, context);
        };
        PullTypeResolver.prototype.relateTypeArgumentsOfTypeToTypeParameters = function (expressionType, parameterType, shouldFix, argContext, context) {
            var typeParameters = parameterType.getTypeArgumentsOrTypeParameters();
            var typeArguments = expressionType.getTypeArguments();
            if (!typeArguments) {
                typeParameters = parameterType.getTypeArguments();
                typeArguments = expressionType.getTypeArgumentsOrTypeParameters();
            }
            if (typeParameters && typeArguments && typeParameters.length === typeArguments.length) {
                for (var i = 0; i < typeParameters.length; i++) {
                    if (typeArguments[i] != typeParameters[i]) {
                        this.relateTypeToTypeParameters(typeArguments[i], typeParameters[i], true, argContext, context);
                    }
                }
            }
        };
        PullTypeResolver.prototype.relateInifinitelyExpandingTypeToTypeParameters = function (expressionType, parameterType, shouldFix, argContext, context) {
            if (!expressionType || !parameterType) {
                return;
            }
            var expressionTypeNamedTypeReference = TypeScript.PullHelpers.getRootType(expressionType);
            var parameterTypeNamedTypeReference = TypeScript.PullHelpers.getRootType(parameterType);
            if (expressionTypeNamedTypeReference != parameterTypeNamedTypeReference) {
                return;
            }
            var expressionTypeTypeArguments = expressionType.getTypeArguments();
            var parameterTypeParameters = parameterType.getTypeParameters();
            if (expressionTypeTypeArguments && parameterTypeParameters && expressionTypeTypeArguments.length === parameterTypeParameters.length) {
                for (var i = 0; i < expressionTypeTypeArguments.length; i++) {
                    this.relateTypeArgumentsOfTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, context);
                }
            }
        };
        PullTypeResolver.prototype.relateFunctionSignatureToTypeParameters = function (expressionSignature, parameterSignature, argContext, context) {
            var expressionParams = expressionSignature.parameters;
            var expressionReturnType = expressionSignature.returnType;
            var parameterParams = parameterSignature.parameters;
            var parameterReturnType = parameterSignature.returnType;
            var len = parameterParams.length < expressionParams.length ? parameterParams.length : expressionParams.length;
            for (var i = 0; i < len; i++) {
                this.relateTypeToTypeParametersInEnclosingType(expressionParams[i].type, parameterParams[i].type, expressionSignature.functionType, parameterSignature.functionType, true, argContext, context);
            }
            this.relateTypeToTypeParametersInEnclosingType(expressionReturnType, parameterReturnType, expressionSignature.functionType, parameterSignature.functionType, false, argContext, context);
        };
        PullTypeResolver.prototype.relateObjectTypeToTypeParameters = function (objectType, parameterType, shouldFix, argContext, context) {
            var parameterTypeMembers = parameterType.getMembers();
            var parameterSignatures;
            var objectMember;
            var objectSignatures;
            if (argContext.alreadyRelatingTypes(objectType, parameterType)) {
                return;
            }
            var objectTypeArguments = objectType.getTypeArguments();
            var parameterTypeParameters = parameterType.getTypeParameters();
            if (objectTypeArguments) {
                if (objectTypeArguments.length === parameterTypeParameters.length) {
                    for (var i = 0; i < objectTypeArguments.length; i++) {
                        argContext.addCandidateForInference(parameterTypeParameters[i], objectTypeArguments[i], shouldFix);
                    }
                }
                else if (parameterType == this.semanticInfoChain.anyTypeSymbol) {
                    for (var i = 0; i < objectTypeArguments.length; i++) {
                        this.relateTypeToTypeParameters(parameterType, objectTypeArguments[i], shouldFix, argContext, context);
                    }
                }
            }
            for (var i = 0; i < parameterTypeMembers.length; i++) {
                objectMember = this.getMemberSymbol(parameterTypeMembers[i].name, TypeScript.PullElementKind.SomeValue, objectType);
                if (objectMember) {
                    this.relateTypeToTypeParametersInEnclosingType(objectMember.type, parameterTypeMembers[i].type, objectType, parameterType, shouldFix, argContext, context);
                }
            }
            parameterSignatures = parameterType.getCallSignatures();
            objectSignatures = objectType.getCallSignatures();
            if ((parameterSignatures.length == 1) &&
                (objectSignatures.length == 1) &&
                !objectSignatures[0].isGeneric() &&
                (parameterSignatures[0].nonOptionalParamCount >= objectSignatures[0].nonOptionalParamCount)) {
                this.relateFunctionSignatureToTypeParameters(objectSignatures[0], parameterSignatures[0], argContext, context);
            }
            parameterSignatures = parameterType.getConstructSignatures();
            objectSignatures = objectType.getConstructSignatures();
            if ((parameterSignatures.length == 1) &&
                (objectSignatures.length == 1) &&
                !objectSignatures[0].isGeneric() &&
                (parameterSignatures[0].nonOptionalParamCount >= objectSignatures[0].nonOptionalParamCount)) {
                this.relateFunctionSignatureToTypeParameters(objectSignatures[0], parameterSignatures[0], argContext, context);
            }
            var parameterIndexSignatures = this.getBothKindsOfIndexSignatures(parameterType, context);
            var objectIndexSignatures = this.getBothKindsOfIndexSignatures(objectType, context);
            if (parameterIndexSignatures.stringSignature && objectIndexSignatures.stringSignature) {
                this.relateFunctionSignatureToTypeParameters(objectIndexSignatures.stringSignature, parameterIndexSignatures.stringSignature, argContext, context);
            }
            if (parameterIndexSignatures.numericSignature && objectIndexSignatures.numericSignature) {
                this.relateFunctionSignatureToTypeParameters(objectIndexSignatures.numericSignature, parameterIndexSignatures.numericSignature, argContext, context);
            }
        };
        PullTypeResolver.prototype.relateArrayTypeToTypeParameters = function (argArrayType, parameterArrayType, shouldFix, argContext, context) {
            var argElement = argArrayType.getElementType();
            var paramElement = parameterArrayType.getElementType();
            this.relateTypeToTypeParameters(argElement, paramElement, shouldFix, argContext, context);
        };
        PullTypeResolver.prototype.instantiateTypeToAny = function (typeToSpecialize, context) {
            var typeParameters = typeToSpecialize.getTypeParameters();
            if (!typeParameters.length) {
                return typeToSpecialize;
            }
            var typeArguments = null;
            if (!this._cachedAnyTypeArgs) {
                this._cachedAnyTypeArgs = [
                    [this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol]
                ];
            }
            if (typeParameters.length < this._cachedAnyTypeArgs.length) {
                typeArguments = this._cachedAnyTypeArgs[typeParameters.length - 1];
            }
            else {
                typeArguments = [];
                for (var i = 0; i < typeParameters.length; i++) {
                    typeArguments[typeArguments.length] = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            var type = this.createInstantiatedType(typeToSpecialize, typeArguments);
            return type;
        };
        PullTypeResolver.typeCheck = function (compilationSettings, semanticInfoChain, document) {
            var sourceUnit = document.sourceUnit();
            var resolver = semanticInfoChain.getResolver();
            var context = new TypeScript.PullTypeResolutionContext(resolver, true, sourceUnit.fileName());
            if (resolver.canTypeCheckAST(sourceUnit, context)) {
                resolver.resolveAST(sourceUnit, false, context);
                resolver.validateVariableDeclarationGroups(semanticInfoChain.getDeclForAST(sourceUnit), context);
                while (resolver.typeCheckCallBacks.length) {
                    var callBack = resolver.typeCheckCallBacks.pop();
                    callBack(context);
                }
                resolver.processPostTypeCheckWorkItems(context);
            }
        };
        PullTypeResolver.prototype.validateVariableDeclarationGroups = function (enclosingDecl, context) {
            var importDeclarationNames = null;
            if (enclosingDecl.kind & (TypeScript.PullElementKind.Container | TypeScript.PullElementKind.DynamicModule | TypeScript.PullElementKind.Script)) {
                var childDecls = enclosingDecl.getChildDecls();
                for (var i = 0, n = childDecls.length; i < n; i++) {
                    var childDecl = childDecls[i];
                    if (childDecl.kind === TypeScript.PullElementKind.TypeAlias) {
                        importDeclarationNames = importDeclarationNames || TypeScript.createIntrinsicsObject();
                        importDeclarationNames[childDecl.name] = true;
                    }
                }
            }
            var declGroups = enclosingDecl.getVariableDeclGroups();
            for (var i = 0, i_max = declGroups.length; i < i_max; i++) {
                var firstSymbol = null;
                var firstSymbolType = null;
                if (enclosingDecl.kind === TypeScript.PullElementKind.Script && declGroups[i].length) {
                    var name = declGroups[i][0].name;
                    var candidateSymbol = this.semanticInfoChain.findTopLevelSymbol(name, TypeScript.PullElementKind.Variable, enclosingDecl);
                    if (candidateSymbol && candidateSymbol.isResolved) {
                        if (!candidateSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.ImplicitVariable)) {
                            firstSymbol = candidateSymbol;
                            firstSymbolType = candidateSymbol.type;
                        }
                    }
                    var importSymbol = this.semanticInfoChain.findTopLevelSymbol(name, TypeScript.PullElementKind.TypeAlias, null);
                    if (importSymbol && importSymbol.isAlias()) {
                        importDeclarationNames = importDeclarationNames || TypeScript.createIntrinsicsObject();
                    }
                }
                for (var j = 0, j_max = declGroups[i].length; j < j_max; j++) {
                    var decl = declGroups[i][j];
                    var boundDeclAST = this.semanticInfoChain.getASTForDecl(decl);
                    var name = decl.name;
                    if (importDeclarationNames && importDeclarationNames[name]) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(boundDeclAST, TypeScript.DiagnosticCode.Variable_declaration_cannot_have_the_same_name_as_an_import_declaration));
                        continue;
                    }
                    var symbol = decl.getSymbol();
                    var symbolType = symbol.type;
                    if (j === 0 && !firstSymbol) {
                        firstSymbol = symbol;
                        firstSymbolType = symbolType;
                        continue;
                    }
                    if (symbolType && firstSymbolType && symbolType !== firstSymbolType && !this.typesAreIdentical(symbolType, firstSymbolType)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(boundDeclAST, TypeScript.DiagnosticCode.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, [symbol.getScopedName(), firstSymbolType.toString(), symbolType.toString()]));
                        continue;
                    }
                }
            }
        };
        PullTypeResolver.prototype.typeCheckFunctionOverloads = function (funcDecl, context, signature, allSignatures) {
            if (!signature) {
                var functionSignatureInfo = TypeScript.PullHelpers.getSignatureForFuncDecl(this.semanticInfoChain.getDeclForAST(funcDecl));
                signature = functionSignatureInfo.signature;
                allSignatures = functionSignatureInfo.allSignatures;
            }
            var functionDeclaration = this.semanticInfoChain.getDeclForAST(funcDecl);
            var funcSymbol = functionDeclaration.getSymbol();
            var definitionSignature = null;
            for (var i = allSignatures.length - 1; i >= 0; i--) {
                if (allSignatures[i].isDefinition()) {
                    definitionSignature = allSignatures[i];
                    break;
                }
            }
            if (!signature.isDefinition()) {
                for (var i = 0; i < allSignatures.length; i++) {
                    if (allSignatures[i] === signature) {
                        break;
                    }
                    if (this.signaturesAreIdentical(allSignatures[i], signature, false)) {
                        if (!this.typesAreIdentical(allSignatures[i].returnType, signature.returnType)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, TypeScript.DiagnosticCode.Overloads_cannot_differ_only_by_return_type));
                        }
                        else if (funcDecl.kind() === TypeScript.SyntaxKind.ConstructorDeclaration) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, TypeScript.DiagnosticCode.Duplicate_constructor_overload_signature));
                        }
                        else if (functionDeclaration.kind === TypeScript.PullElementKind.ConstructSignature) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, TypeScript.DiagnosticCode.Duplicate_overload_construct_signature));
                        }
                        else if (functionDeclaration.kind === TypeScript.PullElementKind.CallSignature) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, TypeScript.DiagnosticCode.Duplicate_overload_call_signature));
                        }
                        else {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, TypeScript.DiagnosticCode.Duplicate_overload_signature_for_0, [funcSymbol.getScopedNameEx().toString()]));
                        }
                        break;
                    }
                }
            }
            var isConstantOverloadSignature = signature.isStringConstantOverloadSignature();
            if (isConstantOverloadSignature) {
                if (signature.isDefinition()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, TypeScript.DiagnosticCode.Overload_signature_implementation_cannot_use_specialized_type));
                }
                else {
                    var foundSubtypeSignature = false;
                    for (var i = 0; i < allSignatures.length; i++) {
                        if (allSignatures[i].isDefinition() || allSignatures[i] === signature) {
                            continue;
                        }
                        if (!allSignatures[i].isResolved) {
                            this.resolveDeclaredSymbol(allSignatures[i], context);
                        }
                        if (allSignatures[i].isStringConstantOverloadSignature()) {
                            continue;
                        }
                        if (this.signatureIsSubtypeOfTarget(signature, allSignatures[i], null, context)) {
                            foundSubtypeSignature = true;
                            break;
                        }
                    }
                    if (!foundSubtypeSignature) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, TypeScript.DiagnosticCode.Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature));
                    }
                }
            }
            else if (definitionSignature && definitionSignature != signature) {
                var comparisonInfo = new TypeComparisonInfo();
                if (!definitionSignature.isResolved) {
                    this.resolveDeclaredSymbol(definitionSignature, context);
                }
                if (!this.signatureIsAssignableToTarget(definitionSignature, signature, funcDecl, context, comparisonInfo)) {
                    if (comparisonInfo.message) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, TypeScript.DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition_NL_0, [comparisonInfo.message]));
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, TypeScript.DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition));
                    }
                }
            }
            var signatureForVisibilityCheck = definitionSignature;
            if (!definitionSignature) {
                if (allSignatures[0] === signature) {
                    return;
                }
                signatureForVisibilityCheck = allSignatures[0];
            }
            if (funcDecl.kind() !== TypeScript.SyntaxKind.ConstructorDeclaration && functionDeclaration.kind !== TypeScript.PullElementKind.ConstructSignature && signatureForVisibilityCheck && signature != signatureForVisibilityCheck) {
                var errorCode;
                if (signatureForVisibilityCheck.anyDeclHasFlag(TypeScript.PullElementFlags.Private) != signature.anyDeclHasFlag(TypeScript.PullElementFlags.Private)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_public_or_private;
                }
                else if (signatureForVisibilityCheck.anyDeclHasFlag(TypeScript.PullElementFlags.Exported) != signature.anyDeclHasFlag(TypeScript.PullElementFlags.Exported)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_exported_or_not_exported;
                }
                else if (signatureForVisibilityCheck.anyDeclHasFlag(TypeScript.PullElementFlags.Ambient) != signature.anyDeclHasFlag(TypeScript.PullElementFlags.Ambient)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_ambient_or_non_ambient;
                }
                else if (signatureForVisibilityCheck.anyDeclHasFlag(TypeScript.PullElementFlags.Optional) != signature.anyDeclHasFlag(TypeScript.PullElementFlags.Optional)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_optional_or_required;
                }
                if (errorCode) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, errorCode));
                }
            }
        };
        PullTypeResolver.prototype.checkSymbolPrivacy = function (declSymbol, symbol, privacyErrorReporter) {
            if (!symbol || symbol.kind === TypeScript.PullElementKind.Primitive) {
                return;
            }
            if (symbol.isType()) {
                var typeSymbol = symbol;
                var isNamedType = typeSymbol.isNamedTypeSymbol();
                if (typeSymbol.isArrayNamedTypeReference()) {
                    this.checkSymbolPrivacy(declSymbol, typeSymbol.getElementType(), privacyErrorReporter);
                    return;
                }
                if (!isNamedType) {
                    var typeOfSymbol = typeSymbol.getTypeOfSymbol();
                    if (typeOfSymbol) {
                        this.checkSymbolPrivacy(declSymbol, typeOfSymbol, privacyErrorReporter);
                        return;
                    }
                }
                if (typeSymbol.inSymbolPrivacyCheck) {
                    return;
                }
                typeSymbol.inSymbolPrivacyCheck = true;
                var typars = typeSymbol.getTypeArgumentsOrTypeParameters();
                if (typars) {
                    for (var i = 0; i < typars.length; i++) {
                        this.checkSymbolPrivacy(declSymbol, typars[i], privacyErrorReporter);
                    }
                }
                if (!isNamedType) {
                    var members = typeSymbol.getMembers();
                    for (var i = 0; i < members.length; i++) {
                        this.checkSymbolPrivacy(declSymbol, members[i].type, privacyErrorReporter);
                    }
                    this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getCallSignatures(), privacyErrorReporter);
                    this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getConstructSignatures(), privacyErrorReporter);
                    this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getIndexSignatures(), privacyErrorReporter);
                }
                else if (typeSymbol.kind == TypeScript.PullElementKind.TypeParameter) {
                    this.checkSymbolPrivacy(declSymbol, typeSymbol.getConstraint(), privacyErrorReporter);
                }
                typeSymbol.inSymbolPrivacyCheck = false;
                if (!isNamedType) {
                    return;
                }
            }
            if (declSymbol.isExternallyVisible()) {
                var symbolIsVisible = symbol.isExternallyVisible();
                if (symbolIsVisible && symbol.kind != TypeScript.PullElementKind.TypeParameter) {
                    var symbolPath = symbol.pathToRoot();
                    var declSymbolPath = declSymbol.pathToRoot();
                    if (symbolPath[symbolPath.length - 1].kind === TypeScript.PullElementKind.DynamicModule &&
                        declSymbolPath[declSymbolPath.length - 1].kind == TypeScript.PullElementKind.DynamicModule &&
                        declSymbolPath[declSymbolPath.length - 1] != symbolPath[symbolPath.length - 1]) {
                        symbolIsVisible = false;
                        var declSymbolScope = declSymbolPath[declSymbolPath.length - 1];
                        for (var i = symbolPath.length - 1; i >= 0; i--) {
                            var aliasSymbols = symbolPath[i].getExternalAliasedSymbols(declSymbolScope);
                            if (aliasSymbols) {
                                symbolIsVisible = true;
                                aliasSymbols[0].setTypeUsedExternally(true);
                                break;
                            }
                        }
                        symbol = symbolPath[symbolPath.length - 1];
                    }
                }
                else if (symbol.kind == TypeScript.PullElementKind.TypeAlias) {
                    var aliasSymbol = symbol;
                    symbolIsVisible = true;
                    aliasSymbol.setTypeUsedExternally(true);
                }
                if (!symbolIsVisible) {
                    privacyErrorReporter(symbol);
                }
            }
        };
        PullTypeResolver.prototype.checkTypePrivacyOfSignatures = function (declSymbol, signatures, privacyErrorReporter) {
            for (var i = 0; i < signatures.length; i++) {
                var signature = signatures[i];
                if (signatures.length > 1 && signature.isDefinition()) {
                    continue;
                }
                var typeParams = signature.getTypeParameters();
                for (var j = 0; j < typeParams.length; j++) {
                    this.checkSymbolPrivacy(declSymbol, typeParams[j], privacyErrorReporter);
                }
                var params = signature.parameters;
                for (var j = 0; j < params.length; j++) {
                    var paramType = params[j].type;
                    this.checkSymbolPrivacy(declSymbol, paramType, privacyErrorReporter);
                }
                var returnType = signature.returnType;
                this.checkSymbolPrivacy(declSymbol, returnType, privacyErrorReporter);
            }
        };
        PullTypeResolver.prototype.typeParameterOfTypeDeclarationPrivacyErrorReporter = function (classOrInterface, indexOfTypeParameter, typeParameter, symbol, context) {
            var decl = this.semanticInfoChain.getDeclForAST(classOrInterface);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol() : null;
            var messageCode;
            var typeParameters = classOrInterface.kind() === TypeScript.SyntaxKind.ClassDeclaration
                ? classOrInterface.typeParameterList
                : classOrInterface.typeParameterList;
            var typeParameterAST = typeParameters.typeParameters.nonSeparatorAt(indexOfTypeParameter);
            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (classOrInterface.kind() === TypeScript.SyntaxKind.ClassDeclaration) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_class_is_using_inaccessible_module_1;
                }
                else {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_interface_is_using_inaccessible_module_1;
                }
            }
            else {
                if (classOrInterface.kind() === TypeScript.SyntaxKind.ClassDeclaration) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_class_has_or_is_using_private_type_1;
                }
                else {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_interface_has_or_is_using_private_type_1;
                }
            }
            var messageArguments = [typeParameter.getScopedName(enclosingSymbol, false, true), typeSymbolName];
            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(typeParameterAST, messageCode, messageArguments));
        };
        PullTypeResolver.prototype.baseListPrivacyErrorReporter = function (classOrInterface, declSymbol, baseAst, isExtendedType, symbol, context) {
            var decl = this.semanticInfoChain.getDeclForAST(classOrInterface);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol() : null;
            var messageCode;
            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (classOrInterface.kind() === TypeScript.SyntaxKind.ClassDeclaration) {
                    if (isExtendedType) {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_extends_class_from_inaccessible_module_1;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_implements_interface_from_inaccessible_module_1;
                    }
                }
                else {
                    messageCode = TypeScript.DiagnosticCode.Exported_interface_0_extends_interface_from_inaccessible_module_1;
                }
            }
            else {
                if (classOrInterface.kind() === TypeScript.SyntaxKind.ClassDeclaration) {
                    if (isExtendedType) {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_extends_private_class_1;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_implements_private_interface_1;
                    }
                }
                else {
                    messageCode = TypeScript.DiagnosticCode.Exported_interface_0_extends_private_interface_1;
                }
            }
            var messageArguments = [declSymbol.getScopedName(enclosingSymbol), typeSymbolName];
            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseAst, messageCode, messageArguments));
        };
        PullTypeResolver.prototype.variablePrivacyErrorReporter = function (declAST, declSymbol, symbol, context) {
            var typeSymbol = symbol;
            var enclosingDecl = this.getEnclosingDecl(declSymbol.getDeclarations()[0]);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol() : null;
            var isProperty = declSymbol.kind === TypeScript.PullElementKind.Property;
            var isPropertyOfClass = false;
            var declParent = declSymbol.getContainer();
            if (declParent && (declParent.kind === TypeScript.PullElementKind.Class || declParent.kind === TypeScript.PullElementKind.ConstructorMethod)) {
                isPropertyOfClass = true;
            }
            var messageCode;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (declSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.Static)) {
                    messageCode = TypeScript.DiagnosticCode.Public_static_property_0_of_exported_class_is_using_inaccessible_module_1;
                }
                else if (isProperty) {
                    if (isPropertyOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Public_property_0_of_exported_class_is_using_inaccessible_module_1;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.Property_0_of_exported_interface_is_using_inaccessible_module_1;
                    }
                }
                else {
                    messageCode = TypeScript.DiagnosticCode.Exported_variable_0_is_using_inaccessible_module_1;
                }
            }
            else {
                if (declSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.Static)) {
                    messageCode = TypeScript.DiagnosticCode.Public_static_property_0_of_exported_class_has_or_is_using_private_type_1;
                }
                else if (isProperty) {
                    if (isPropertyOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Public_property_0_of_exported_class_has_or_is_using_private_type_1;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.Property_0_of_exported_interface_has_or_is_using_private_type_1;
                    }
                }
                else {
                    messageCode = TypeScript.DiagnosticCode.Exported_variable_0_has_or_is_using_private_type_1;
                }
            }
            var messageArguments = [declSymbol.getScopedName(enclosingSymbol), typeSymbolName];
            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(declAST, messageCode, messageArguments));
        };
        PullTypeResolver.prototype.checkFunctionTypePrivacy = function (funcDeclAST, isStatic, typeParameters, parameters, returnTypeAnnotation, block, context) {
            var _this_1 = this;
            if (funcDeclAST.kind() === TypeScript.SyntaxKind.FunctionExpression ||
                funcDeclAST.kind() === TypeScript.SyntaxKind.FunctionPropertyAssignment ||
                (funcDeclAST.kind() === TypeScript.SyntaxKind.GetAccessor && funcDeclAST.parent.parent.kind() === TypeScript.SyntaxKind.ObjectLiteralExpression) ||
                (funcDeclAST.kind() === TypeScript.SyntaxKind.SetAccessor && funcDeclAST.parent.parent.kind() === TypeScript.SyntaxKind.ObjectLiteralExpression)) {
                return;
            }
            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var functionSymbol = functionDecl.getSymbol();
            ;
            var functionSignature;
            var isGetter = funcDeclAST.kind() === TypeScript.SyntaxKind.GetAccessor;
            var isSetter = funcDeclAST.kind() === TypeScript.SyntaxKind.SetAccessor;
            var isIndexSignature = functionDecl.kind === TypeScript.PullElementKind.IndexSignature;
            if (isGetter || isSetter) {
                var accessorSymbol = functionSymbol;
                functionSignature = (isGetter ? accessorSymbol.getGetter() : accessorSymbol.getSetter()).type.getCallSignatures()[0];
            }
            else {
                if (!functionSymbol) {
                    var parentDecl = functionDecl.getParentDecl();
                    functionSymbol = parentDecl.getSymbol();
                    if (functionSymbol && functionSymbol.isType() && !functionSymbol.isNamedTypeSymbol()) {
                        return;
                    }
                }
                else if (functionSymbol.kind == TypeScript.PullElementKind.Method &&
                    !isStatic &&
                    !functionSymbol.getContainer().isNamedTypeSymbol()) {
                    return;
                }
                functionSignature = functionDecl.getSignatureSymbol();
            }
            if (typeParameters && !isGetter && !isSetter && !isIndexSignature && funcDeclAST.kind() !== TypeScript.SyntaxKind.ConstructorDeclaration) {
                for (var i = 0; i < typeParameters.typeParameters.nonSeparatorCount(); i++) {
                    var typeParameterAST = typeParameters.typeParameters.nonSeparatorAt(i);
                    var typeParameter = this.resolveTypeParameterDeclaration(typeParameterAST, context);
                    this.checkSymbolPrivacy(functionSymbol, typeParameter, function (symbol) {
                        return _this_1.functionTypeArgumentArgumentTypePrivacyErrorReporter(funcDeclAST, isStatic, typeParameterAST, typeParameter, symbol, context);
                    });
                }
            }
            if (!isGetter && !isIndexSignature) {
                var funcParams = functionSignature.parameters;
                for (var i = 0; i < funcParams.length; i++) {
                    this.checkSymbolPrivacy(functionSymbol, funcParams[i].type, function (symbol) {
                        return _this_1.functionArgumentTypePrivacyErrorReporter(funcDeclAST, isStatic, parameters, i, funcParams[i], symbol, context);
                    });
                }
            }
            if (!isSetter) {
                this.checkSymbolPrivacy(functionSymbol, functionSignature.returnType, function (symbol) {
                    return _this_1.functionReturnTypePrivacyErrorReporter(funcDeclAST, isStatic, returnTypeAnnotation, block, functionSignature.returnType, symbol, context);
                });
            }
        };
        PullTypeResolver.prototype.functionTypeArgumentArgumentTypePrivacyErrorReporter = function (declAST, isStatic, typeParameterAST, typeParameter, symbol, context) {
            var decl = this.semanticInfoChain.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol() : null;
            var isMethod = decl.kind === TypeScript.PullElementKind.Method;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === TypeScript.PullElementKind.Class || isStatic)) {
                isMethodOfClass = true;
            }
            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            var messageCode;
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (decl.kind === TypeScript.PullElementKind.ConstructSignature) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1;
                }
                else if (decl.kind === TypeScript.PullElementKind.CallSignature) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1;
                }
                else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1;
                    }
                    else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1;
                    }
                }
                else {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_function_is_using_inaccessible_module_1;
                }
            }
            else {
                if (decl.kind === TypeScript.PullElementKind.ConstructSignature) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1;
                }
                else if (decl.kind === TypeScript.PullElementKind.CallSignature) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1;
                }
                else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1;
                    }
                    else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1;
                    }
                }
                else {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_function_has_or_is_using_private_type_1;
                }
            }
            if (messageCode) {
                var messageArgs = [typeParameter.getScopedName(enclosingSymbol, false, true), typeSymbolName];
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(typeParameterAST, messageCode, messageArgs));
            }
        };
        PullTypeResolver.prototype.functionArgumentTypePrivacyErrorReporter = function (declAST, isStatic, parameters, argIndex, paramSymbol, symbol, context) {
            var decl = this.semanticInfoChain.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol() : null;
            var isGetter = declAST.kind() === TypeScript.SyntaxKind.GetAccessor;
            var isSetter = declAST.kind() === TypeScript.SyntaxKind.SetAccessor;
            var isMethod = decl.kind === TypeScript.PullElementKind.Method;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === TypeScript.PullElementKind.Class || isStatic)) {
                isMethodOfClass = true;
            }
            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            var messageCode;
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (declAST.kind() === TypeScript.SyntaxKind.ConstructorDeclaration) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1;
                }
                else if (isSetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1;
                    }
                }
                else if (decl.kind === TypeScript.PullElementKind.ConstructSignature) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1;
                }
                else if (decl.kind === TypeScript.PullElementKind.CallSignature) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1;
                }
                else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1;
                    }
                    else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1;
                    }
                }
                else if (!isGetter) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_exported_function_is_using_inaccessible_module_1;
                }
            }
            else {
                if (declAST.kind() === TypeScript.SyntaxKind.ConstructorDeclaration) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1;
                }
                else if (isSetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1;
                    }
                }
                else if (decl.kind === TypeScript.PullElementKind.ConstructSignature) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1;
                }
                else if (decl.kind === TypeScript.PullElementKind.CallSignature) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1;
                }
                else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1;
                    }
                    else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1;
                    }
                }
                else if (!isGetter && decl.kind !== TypeScript.PullElementKind.IndexSignature) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_exported_function_has_or_is_using_private_type_1;
                }
            }
            if (messageCode) {
                var parameter = parameters.astAt(argIndex);
                var messageArgs = [paramSymbol.getScopedName(enclosingSymbol), typeSymbolName];
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(parameter, messageCode, messageArgs));
            }
        };
        PullTypeResolver.prototype.functionReturnTypePrivacyErrorReporter = function (declAST, isStatic, returnTypeAnnotation, block, funcReturnType, symbol, context) {
            var _this_1 = this;
            var decl = this.semanticInfoChain.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var isGetter = declAST.kind() === TypeScript.SyntaxKind.GetAccessor;
            var isSetter = declAST.kind() === TypeScript.SyntaxKind.SetAccessor;
            var isMethod = decl.kind === TypeScript.PullElementKind.Method;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === TypeScript.PullElementKind.Class || isStatic)) {
                isMethodOfClass = true;
            }
            var messageCode = null;
            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (isGetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0;
                    }
                }
                else if (decl.kind === TypeScript.PullElementKind.ConstructSignature) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0;
                }
                else if (decl.kind === TypeScript.PullElementKind.CallSignature) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0;
                }
                else if (decl.kind === TypeScript.PullElementKind.IndexSignature) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0;
                }
                else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0;
                    }
                    else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0;
                    }
                }
                else if (!isSetter && declAST.kind() !== TypeScript.SyntaxKind.ConstructorDeclaration) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_exported_function_is_using_inaccessible_module_0;
                }
            }
            else {
                if (isGetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0;
                    }
                }
                else if (decl.kind === TypeScript.PullElementKind.ConstructSignature) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0;
                }
                else if (decl.kind === TypeScript.PullElementKind.CallSignature) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0;
                }
                else if (decl.kind === TypeScript.PullElementKind.IndexSignature) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0;
                }
                else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0;
                    }
                    else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0;
                    }
                    else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0;
                    }
                }
                else if (!isSetter && declAST.kind() !== TypeScript.SyntaxKind.ConstructorDeclaration) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_exported_function_has_or_is_using_private_type_0;
                }
            }
            if (messageCode) {
                var messageArguments = [typeSymbolName];
                var reportOnFuncDecl = false;
                if (returnTypeAnnotation) {
                    var returnExpressionSymbol = this.resolveTypeReference(returnTypeAnnotation, context);
                    if (TypeScript.PullHelpers.typeSymbolsAreIdentical(returnExpressionSymbol, funcReturnType)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnTypeAnnotation, messageCode, messageArguments));
                    }
                }
                if (block) {
                    var reportErrorOnReturnExpressions = function (ast, walker) {
                        var go = true;
                        switch (ast.kind()) {
                            case TypeScript.SyntaxKind.FunctionDeclaration:
                            case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
                            case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                            case TypeScript.SyntaxKind.FunctionExpression:
                                go = false;
                                break;
                            case TypeScript.SyntaxKind.ReturnStatement:
                                var returnStatement = ast;
                                var returnExpressionSymbol = _this_1.resolveAST(returnStatement.expression, false, context).type;
                                if (TypeScript.PullHelpers.typeSymbolsAreIdentical(returnExpressionSymbol, funcReturnType)) {
                                    context.postDiagnostic(_this_1.semanticInfoChain.diagnosticFromAST(returnStatement, messageCode, messageArguments));
                                }
                                else {
                                    reportOnFuncDecl = true;
                                }
                                go = false;
                                break;
                            default:
                                break;
                        }
                        walker.options.goChildren = go;
                        return ast;
                    };
                    TypeScript.getAstWalkerFactory().walk(block, function (ast, walker) { reportErrorOnReturnExpressions(ast, walker); });
                }
                if (reportOnFuncDecl) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(declAST, messageCode, messageArguments));
                }
            }
        };
        PullTypeResolver.prototype.enclosingClassIsDerived = function (classDecl) {
            TypeScript.Debug.assert(classDecl.kind === TypeScript.PullElementKind.Class);
            var classSymbol = classDecl.getSymbol();
            return classSymbol.getExtendedTypes().length > 0;
        };
        PullTypeResolver.prototype.isSuperInvocationExpression = function (ast) {
            if (ast.kind() === TypeScript.SyntaxKind.InvocationExpression) {
                var invocationExpression = ast;
                if (invocationExpression.expression.kind() === TypeScript.SyntaxKind.SuperKeyword) {
                    return true;
                }
            }
            return false;
        };
        PullTypeResolver.prototype.isSuperInvocationExpressionStatement = function (node) {
            if (node && node.kind() === TypeScript.SyntaxKind.ExpressionStatement) {
                var expressionStatement = node;
                if (this.isSuperInvocationExpression(expressionStatement.expression)) {
                    return true;
                }
            }
            return false;
        };
        PullTypeResolver.prototype.getFirstStatementOfBlockOrNull = function (block) {
            if (block && block.statements && block.statements.childCount() > 0) {
                return block.statements.childAt(0);
            }
            return null;
        };
        PullTypeResolver.prototype.superCallMustBeFirstStatementInConstructor = function (constructorDecl) {
            TypeScript.Debug.assert(constructorDecl.kind === TypeScript.PullElementKind.ConstructorMethod);
            if (constructorDecl) {
                var enclosingClass = constructorDecl.getParentDecl();
                var classSymbol = enclosingClass.getSymbol();
                if (classSymbol.getExtendedTypes().length === 0) {
                    return false;
                }
                var classMembers = classSymbol.getMembers();
                for (var i = 0, n1 = classMembers.length; i < n1; i++) {
                    var member = classMembers[i];
                    if (member.kind === TypeScript.PullElementKind.Property) {
                        var declarations = member.getDeclarations();
                        for (var j = 0, n2 = declarations.length; j < n2; j++) {
                            var declaration = declarations[j];
                            var ast = this.semanticInfoChain.getASTForDecl(declaration);
                            if (ast.kind() === TypeScript.SyntaxKind.Parameter) {
                                return true;
                            }
                            if (ast.kind() === TypeScript.SyntaxKind.MemberVariableDeclaration) {
                                var variableDeclarator = ast;
                                if (variableDeclarator.variableDeclarator.equalsValueClause) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        };
        PullTypeResolver.prototype.checkForThisCaptureInArrowFunction = function (expression) {
            var enclosingDecl = this.getEnclosingDeclForAST(expression);
            var declPath = enclosingDecl.getParentPath();
            if (declPath.length) {
                var inArrowFunction = false;
                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declKind = decl.kind;
                    var declFlags = decl.flags;
                    if (declKind === TypeScript.PullElementKind.FunctionExpression &&
                        TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.ArrowFunction)) {
                        inArrowFunction = true;
                        continue;
                    }
                    if (inArrowFunction) {
                        if (declKind === TypeScript.PullElementKind.Function ||
                            declKind === TypeScript.PullElementKind.Method ||
                            declKind === TypeScript.PullElementKind.ConstructorMethod ||
                            declKind === TypeScript.PullElementKind.GetAccessor ||
                            declKind === TypeScript.PullElementKind.SetAccessor ||
                            declKind === TypeScript.PullElementKind.FunctionExpression ||
                            declKind === TypeScript.PullElementKind.Class ||
                            declKind === TypeScript.PullElementKind.Container ||
                            declKind === TypeScript.PullElementKind.DynamicModule ||
                            declKind === TypeScript.PullElementKind.Script) {
                            decl.setFlags(decl.flags | TypeScript.PullElementFlags.MustCaptureThis);
                            if (declKind === TypeScript.PullElementKind.Class) {
                                var constructorSymbol = decl.getSymbol().getConstructorMethod();
                                var constructorDecls = constructorSymbol.getDeclarations();
                                for (var i = 0; i < constructorDecls.length; i++) {
                                    constructorDecls[i].flags = constructorDecls[i].flags | TypeScript.PullElementFlags.MustCaptureThis;
                                }
                            }
                            break;
                        }
                    }
                    else if (declKind === TypeScript.PullElementKind.Function || declKind === TypeScript.PullElementKind.FunctionExpression) {
                        break;
                    }
                }
            }
        };
        PullTypeResolver.prototype.typeCheckMembersAgainstIndexer = function (containerType, containerTypeDecl, context) {
            var indexSignatures = this.getBothKindsOfIndexSignatures(containerType, context);
            var stringSignature = indexSignatures.stringSignature;
            var numberSignature = indexSignatures.numericSignature;
            if (stringSignature || numberSignature) {
                var members = containerTypeDecl.getChildDecls();
                for (var i = 0; i < members.length; i++) {
                    var member = members[i];
                    if ((member.name || (member.kind === TypeScript.PullElementKind.Property && member.name === "")) &&
                        member.kind !== TypeScript.PullElementKind.ConstructorMethod &&
                        !TypeScript.hasFlag(member.flags, TypeScript.PullElementFlags.Static)) {
                        var memberSymbol = member.getSymbol();
                        var relevantSignature = this.determineRelevantIndexerForMember(memberSymbol, numberSignature, stringSignature);
                        if (relevantSignature) {
                            var comparisonInfo = new TypeComparisonInfo();
                            if (!this.sourceIsSubtypeOfTarget(memberSymbol.type, relevantSignature.returnType, member.ast(), context, comparisonInfo)) {
                                this.reportErrorThatMemberIsNotSubtypeOfIndexer(memberSymbol, relevantSignature, member.ast(), context, comparisonInfo);
                            }
                        }
                    }
                }
            }
        };
        PullTypeResolver.prototype.determineRelevantIndexerForMember = function (member, numberIndexSignature, stringIndexSignature) {
            if (numberIndexSignature && TypeScript.PullHelpers.isNameNumeric(member.name)) {
                return numberIndexSignature;
            }
            else if (stringIndexSignature) {
                return stringIndexSignature;
            }
            return null;
        };
        PullTypeResolver.prototype.reportErrorThatMemberIsNotSubtypeOfIndexer = function (member, indexSignature, astForError, context, comparisonInfo) {
            var enclosingSymbol = this.getEnclosingSymbolForAST(astForError);
            if (indexSignature.parameters[0].type === this.semanticInfoChain.numberTypeSymbol) {
                if (comparisonInfo.message) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(astForError, TypeScript.DiagnosticCode.All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0_NL_1, [indexSignature.returnType.toString(enclosingSymbol), comparisonInfo.message]));
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(astForError, TypeScript.DiagnosticCode.All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0, [indexSignature.returnType.toString(enclosingSymbol)]));
                }
            }
            else {
                if (comparisonInfo.message) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(astForError, TypeScript.DiagnosticCode.All_named_properties_must_be_subtypes_of_string_indexer_type_0_NL_1, [indexSignature.returnType.toString(enclosingSymbol), comparisonInfo.message]));
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(astForError, TypeScript.DiagnosticCode.All_named_properties_must_be_subtypes_of_string_indexer_type_0, [indexSignature.returnType.toString(enclosingSymbol)]));
                }
            }
        };
        PullTypeResolver.prototype.typeCheckIfTypeMemberPropertyOkToOverride = function (typeSymbol, extendedType, typeMember, extendedTypeMember, enclosingDecl, comparisonInfo) {
            if (!typeSymbol.isClass()) {
                return true;
            }
            var typeMemberKind = typeMember.kind;
            var extendedMemberKind = extendedTypeMember.kind;
            if (typeMemberKind === extendedMemberKind) {
                return true;
            }
            var errorCode;
            if (typeMemberKind === TypeScript.PullElementKind.Property) {
                if (typeMember.isAccessor()) {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                }
                else {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                }
            }
            else if (typeMemberKind === TypeScript.PullElementKind.Method) {
                if (extendedTypeMember.isAccessor()) {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                }
                else {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property;
                }
            }
            var message = TypeScript.getDiagnosticMessage(errorCode, [typeSymbol.toString(), typeMember.getScopedNameEx().toString(), extendedType.toString()]);
            comparisonInfo.addMessage(message);
            return false;
        };
        PullTypeResolver.prototype.typeCheckIfTypeExtendsType = function (classOrInterface, name, typeSymbol, extendedType, enclosingDecl, context) {
            var typeMembers = typeSymbol.getMembers();
            var comparisonInfo = new TypeComparisonInfo();
            var foundError = false;
            var foundError1 = false;
            var foundError2 = false;
            for (var i = 0; i < typeMembers.length; i++) {
                var propName = typeMembers[i].name;
                var extendedTypeProp = extendedType.findMember(propName, true);
                if (extendedTypeProp) {
                    this.resolveDeclaredSymbol(extendedTypeProp, context);
                    foundError1 = !this.typeCheckIfTypeMemberPropertyOkToOverride(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, enclosingDecl, comparisonInfo);
                    if (!foundError1) {
                        foundError2 = !this.sourcePropertyIsSubtypeOfTargetProperty(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, classOrInterface, context, comparisonInfo);
                    }
                    if (foundError1 || foundError2) {
                        foundError = true;
                        break;
                    }
                }
            }
            if (!foundError && typeSymbol.hasOwnCallSignatures()) {
                foundError = !this.sourceCallSignaturesAreSubtypeOfTargetCallSignatures(typeSymbol, extendedType, classOrInterface, context, comparisonInfo);
            }
            if (!foundError && typeSymbol.hasOwnConstructSignatures()) {
                foundError = !this.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures(typeSymbol, extendedType, classOrInterface, context, comparisonInfo);
            }
            if (!foundError && typeSymbol.hasOwnIndexSignatures()) {
                foundError = !this.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures(typeSymbol, extendedType, classOrInterface, context, comparisonInfo);
            }
            if (!foundError && typeSymbol.isClass()) {
                var typeConstructorType = typeSymbol.getConstructorMethod().type;
                var typeConstructorTypeMembers = typeConstructorType.getMembers();
                if (typeConstructorTypeMembers.length) {
                    var extendedConstructorType = extendedType.getConstructorMethod().type;
                    var comparisonInfoForPropTypeCheck = new TypeComparisonInfo(comparisonInfo);
                    for (var i = 0; i < typeConstructorTypeMembers.length; i++) {
                        var propName = typeConstructorTypeMembers[i].name;
                        var extendedConstructorTypeProp = extendedConstructorType.findMember(propName, true);
                        if (extendedConstructorTypeProp) {
                            if (!extendedConstructorTypeProp.isResolved) {
                                this.resolveDeclaredSymbol(extendedConstructorTypeProp, context);
                            }
                            var typeConstructorTypePropType = typeConstructorTypeMembers[i].type;
                            var extendedConstructorTypePropType = extendedConstructorTypeProp.type;
                            if (!this.sourceIsSubtypeOfTarget(typeConstructorTypePropType, extendedConstructorTypePropType, classOrInterface, context, comparisonInfoForPropTypeCheck)) {
                                var propMessage;
                                var enclosingSymbol = this.getEnclosingSymbolForAST(classOrInterface);
                                if (comparisonInfoForPropTypeCheck.message) {
                                    propMessage = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3, [extendedConstructorTypeProp.getScopedNameEx().toString(), typeSymbol.toString(enclosingSymbol), extendedType.toString(enclosingSymbol), comparisonInfoForPropTypeCheck.message]);
                                }
                                else {
                                    propMessage = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_static_property_0_of_class_1_and_class_2_are_incompatible, [extendedConstructorTypeProp.getScopedNameEx().toString(), typeSymbol.toString(enclosingSymbol), extendedType.toString(enclosingSymbol)]);
                                }
                                comparisonInfo.addMessage(propMessage);
                                foundError = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (foundError) {
                var errorCode;
                if (typeSymbol.isClass()) {
                    errorCode = TypeScript.DiagnosticCode.Class_0_cannot_extend_class_1_NL_2;
                }
                else {
                    if (extendedType.isClass()) {
                        errorCode = TypeScript.DiagnosticCode.Interface_0_cannot_extend_class_1_NL_2;
                    }
                    else {
                        errorCode = TypeScript.DiagnosticCode.Interface_0_cannot_extend_interface_1_NL_2;
                    }
                }
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, errorCode, [typeSymbol.getScopedName(), extendedType.getScopedName(), comparisonInfo.message]));
            }
        };
        PullTypeResolver.prototype.typeCheckIfClassImplementsType = function (classDecl, classSymbol, implementedType, enclosingDecl, context) {
            var comparisonInfo = new TypeComparisonInfo();
            var foundError = !this.sourceMembersAreSubtypeOfTargetMembers(classSymbol, implementedType, classDecl, context, comparisonInfo);
            if (!foundError) {
                foundError = !this.sourceCallSignaturesAreSubtypeOfTargetCallSignatures(classSymbol, implementedType, classDecl, context, comparisonInfo);
                if (!foundError) {
                    foundError = !this.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures(classSymbol, implementedType, classDecl, context, comparisonInfo);
                    if (!foundError) {
                        foundError = !this.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures(classSymbol, implementedType, classDecl, context, comparisonInfo);
                    }
                }
            }
            if (foundError) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(classDecl);
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(classDecl.identifier, TypeScript.DiagnosticCode.Class_0_declares_interface_1_but_does_not_implement_it_NL_2, [classSymbol.getScopedName(enclosingSymbol), implementedType.getScopedName(enclosingSymbol), comparisonInfo.message]));
            }
        };
        PullTypeResolver.prototype.hasClassTypeSymbolConflictAsValue = function (valueDeclAST, typeSymbol, enclosingDecl, context) {
            var typeSymbolAlias = this.semanticInfoChain.getAliasSymbolForAST(valueDeclAST);
            var valueSymbol = this.computeNameExpression(valueDeclAST, context, false);
            var valueSymbolAlias = this.semanticInfoChain.getAliasSymbolForAST(valueDeclAST);
            this.semanticInfoChain.setAliasSymbolForAST(valueDeclAST, typeSymbolAlias);
            if (typeSymbolAlias && valueSymbolAlias) {
                return typeSymbolAlias != valueSymbolAlias;
            }
            if (!valueSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.ClassConstructorVariable)) {
                return true;
            }
            var associatedContainerType = valueSymbol.type ? valueSymbol.type.getAssociatedContainerType() : null;
            if (associatedContainerType) {
                return associatedContainerType != typeSymbol.getRootSymbol();
            }
            return true;
        };
        PullTypeResolver.prototype.typeCheckBase = function (classOrInterface, name, typeSymbol, baseDeclAST, isExtendedType, enclosingDecl, context) {
            var _this_1 = this;
            var typeDecl = this.semanticInfoChain.getDeclForAST(classOrInterface);
            var baseType = this.resolveTypeReference(baseDeclAST, context).type;
            if (!baseType) {
                return;
            }
            var typeDeclIsClass = typeSymbol.isClass();
            if (!typeSymbol.isValidBaseKind(baseType, isExtendedType)) {
                if (!baseType.isError()) {
                    if (isExtendedType) {
                        if (typeDeclIsClass) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseDeclAST, TypeScript.DiagnosticCode.A_class_may_only_extend_another_class));
                        }
                        else {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseDeclAST, TypeScript.DiagnosticCode.An_interface_may_only_extend_another_class_or_interface));
                        }
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseDeclAST, TypeScript.DiagnosticCode.A_class_may_only_implement_another_class_or_interface));
                    }
                }
                return;
            }
            else if (typeDeclIsClass && isExtendedType && baseDeclAST.kind() == TypeScript.SyntaxKind.IdentifierName) {
                if (this.hasClassTypeSymbolConflictAsValue(baseDeclAST, baseType, enclosingDecl, context)) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseDeclAST, TypeScript.DiagnosticCode.Type_reference_0_in_extends_clause_does_not_reference_constructor_function_for_1, [baseDeclAST.text(), baseType.toString(enclosingDecl ? enclosingDecl.getSymbol() : null)]));
                }
            }
            if (baseType.hasBase(typeSymbol)) {
                typeSymbol.setHasBaseTypeConflict();
                baseType.setHasBaseTypeConflict();
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, typeDeclIsClass ? TypeScript.DiagnosticCode.Class_0_is_recursively_referenced_as_a_base_type_of_itself : TypeScript.DiagnosticCode.Interface_0_is_recursively_referenced_as_a_base_type_of_itself, [typeSymbol.getScopedName()]));
                return;
            }
            if (isExtendedType) {
                this.typeCheckIfTypeExtendsType(classOrInterface, name, typeSymbol, baseType, enclosingDecl, context);
            }
            else {
                TypeScript.Debug.assert(classOrInterface.kind() === TypeScript.SyntaxKind.ClassDeclaration);
                this.typeCheckIfClassImplementsType(classOrInterface, typeSymbol, baseType, enclosingDecl, context);
            }
            this.checkSymbolPrivacy(typeSymbol, baseType, function (errorSymbol) {
                return _this_1.baseListPrivacyErrorReporter(classOrInterface, typeSymbol, baseDeclAST, isExtendedType, errorSymbol, context);
            });
        };
        PullTypeResolver.prototype.typeCheckBases = function (classOrInterface, name, heritageClauses, typeSymbol, enclosingDecl, context) {
            var _this_1 = this;
            var extendsClause = TypeScript.getExtendsHeritageClause(heritageClauses);
            var implementsClause = TypeScript.getImplementsHeritageClause(heritageClauses);
            if (!extendsClause && !implementsClause) {
                return;
            }
            var typeDeclIsClass = classOrInterface.kind() === TypeScript.SyntaxKind.ClassDeclaration;
            if (extendsClause) {
                for (var i = 0; i < extendsClause.typeNames.nonSeparatorCount(); i++) {
                    this.typeCheckBase(classOrInterface, name, typeSymbol, extendsClause.typeNames.nonSeparatorAt(i), true, enclosingDecl, context);
                }
            }
            if (typeSymbol.isClass()) {
                if (implementsClause) {
                    for (var i = 0; i < implementsClause.typeNames.nonSeparatorCount(); i++) {
                        this.typeCheckBase(classOrInterface, name, typeSymbol, implementsClause.typeNames.nonSeparatorAt(i), false, enclosingDecl, context);
                    }
                }
            }
            else if (extendsClause && !typeSymbol.hasBaseTypeConflict() && typeSymbol.getExtendedTypes().length > 1) {
                var firstInterfaceASTWithExtendsClause = TypeScript.ArrayUtilities.firstOrDefault(typeSymbol.getDeclarations(), function (decl) {
                    return decl.ast().heritageClauses !== null;
                }).ast();
                if (classOrInterface === firstInterfaceASTWithExtendsClause) {
                    this.typeCheckCallBacks.push(function (context) {
                        _this_1.checkTypeCompatibilityBetweenBases(classOrInterface.identifier, typeSymbol, context);
                    });
                }
            }
        };
        PullTypeResolver.prototype.checkTypeCompatibilityBetweenBases = function (name, typeSymbol, context) {
            var derivedIndexSignatures = typeSymbol.getOwnIndexSignatures();
            var inheritedMembersMap = TypeScript.createIntrinsicsObject();
            var inheritedIndexSignatures = new InheritedIndexSignatureInfo();
            var typeHasOwnNumberIndexer = false;
            var typeHasOwnStringIndexer = false;
            if (typeSymbol.hasOwnIndexSignatures()) {
                var ownIndexSignatures = typeSymbol.getOwnIndexSignatures();
                for (var i = 0; i < ownIndexSignatures.length; i++) {
                    if (ownIndexSignatures[i].parameters[0].type === this.semanticInfoChain.numberTypeSymbol) {
                        typeHasOwnNumberIndexer = true;
                    }
                    else {
                        typeHasOwnStringIndexer = true;
                    }
                }
            }
            var baseTypes = typeSymbol.getExtendedTypes();
            for (var i = 0; i < baseTypes.length; i++) {
                if (this.checkNamedPropertyTypeIdentityBetweenBases(name, typeSymbol, baseTypes[i], inheritedMembersMap, context) ||
                    this.checkIndexSignatureIdentityBetweenBases(name, typeSymbol, baseTypes[i], inheritedIndexSignatures, typeHasOwnNumberIndexer, typeHasOwnStringIndexer, context)) {
                    return;
                }
            }
            if (this.checkThatInheritedNumberSignatureIsSubtypeOfInheritedStringSignature(name, typeSymbol, inheritedIndexSignatures, context)) {
                return;
            }
            this.checkInheritedMembersAgainstInheritedIndexSignatures(name, typeSymbol, inheritedIndexSignatures, inheritedMembersMap, context);
        };
        PullTypeResolver.prototype.checkNamedPropertyTypeIdentityBetweenBases = function (interfaceName, interfaceSymbol, baseTypeSymbol, inheritedMembersMap, context) {
            var baseMembers = baseTypeSymbol.getAllMembers(TypeScript.PullElementKind.Property | TypeScript.PullElementKind.Method, TypeScript.GetAllMembersVisiblity.all);
            for (var i = 0; i < baseMembers.length; i++) {
                var member = baseMembers[i];
                var memberName = member.name;
                if (interfaceSymbol.findMember(memberName, false)) {
                    continue;
                }
                if (inheritedMembersMap[memberName]) {
                    var prevMember = inheritedMembersMap[memberName];
                    if (prevMember.baseOrigin !== baseTypeSymbol && !this.typesAreIdentical(member.type, prevMember.memberSymbol.type)) {
                        var innerDiagnostic = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_property_0_of_types_1_and_2_are_not_identical, [memberName, prevMember.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName()]);
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, TypeScript.DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3, [interfaceSymbol.getDisplayName(), prevMember.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName(), innerDiagnostic]));
                        return true;
                    }
                }
                else {
                    inheritedMembersMap[memberName] = new MemberWithBaseOrigin(member, baseTypeSymbol);
                }
            }
            return false;
        };
        PullTypeResolver.prototype.checkIndexSignatureIdentityBetweenBases = function (interfaceName, interfaceSymbol, baseTypeSymbol, allInheritedSignatures, derivedTypeHasOwnNumberSignature, derivedTypeHasOwnStringSignature, context) {
            if (derivedTypeHasOwnNumberSignature && derivedTypeHasOwnStringSignature) {
                return false;
            }
            var indexSignaturesFromThisBaseType = baseTypeSymbol.getIndexSignatures();
            for (var i = 0; i < indexSignaturesFromThisBaseType.length; i++) {
                var currentInheritedSignature = indexSignaturesFromThisBaseType[i];
                var parameterTypeIsString = currentInheritedSignature.parameters[0].type === this.semanticInfoChain.stringTypeSymbol;
                var parameterTypeIsNumber = !parameterTypeIsString;
                if (parameterTypeIsString && derivedTypeHasOwnStringSignature ||
                    parameterTypeIsNumber && derivedTypeHasOwnNumberSignature) {
                    continue;
                }
                if (parameterTypeIsString) {
                    if (allInheritedSignatures.stringSignatureWithBaseOrigin) {
                        if (allInheritedSignatures.stringSignatureWithBaseOrigin.baseOrigin !== baseTypeSymbol &&
                            !this.typesAreIdentical(allInheritedSignatures.stringSignatureWithBaseOrigin.signature.returnType, currentInheritedSignature.returnType)) {
                            var innerDiagnostic = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_string_indexer_of_types_0_and_1_are_not_identical, [allInheritedSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName()]);
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, TypeScript.DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3, [interfaceSymbol.getDisplayName(), allInheritedSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName(), innerDiagnostic]));
                            return true;
                        }
                    }
                    else {
                        allInheritedSignatures.stringSignatureWithBaseOrigin = new SignatureWithBaseOrigin(currentInheritedSignature, baseTypeSymbol);
                    }
                }
                else if (parameterTypeIsNumber) {
                    if (allInheritedSignatures.numberSignatureWithBaseOrigin) {
                        if (allInheritedSignatures.numberSignatureWithBaseOrigin.baseOrigin !== baseTypeSymbol &&
                            !this.typesAreIdentical(allInheritedSignatures.numberSignatureWithBaseOrigin.signature.returnType, currentInheritedSignature.returnType)) {
                            var innerDiagnostic = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_number_indexer_of_types_0_and_1_are_not_identical, [allInheritedSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName()]);
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, TypeScript.DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3, [interfaceSymbol.getDisplayName(), allInheritedSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName(), innerDiagnostic]));
                            return true;
                        }
                    }
                    else {
                        allInheritedSignatures.numberSignatureWithBaseOrigin = new SignatureWithBaseOrigin(currentInheritedSignature, baseTypeSymbol);
                    }
                }
            }
            return false;
        };
        PullTypeResolver.prototype.checkInheritedMembersAgainstInheritedIndexSignatures = function (interfaceName, interfaceSymbol, inheritedIndexSignatures, inheritedMembers, context) {
            if (!inheritedIndexSignatures.stringSignatureWithBaseOrigin && !inheritedIndexSignatures.numberSignatureWithBaseOrigin) {
                return false;
            }
            var comparisonInfo = new TypeComparisonInfo();
            var stringSignature = inheritedIndexSignatures.stringSignatureWithBaseOrigin && inheritedIndexSignatures.stringSignatureWithBaseOrigin.signature;
            var numberSignature = inheritedIndexSignatures.numberSignatureWithBaseOrigin && inheritedIndexSignatures.numberSignatureWithBaseOrigin.signature;
            for (var memberName in inheritedMembers) {
                var memberWithBaseOrigin = inheritedMembers[memberName];
                if (!memberWithBaseOrigin) {
                    continue;
                }
                var relevantSignature = this.determineRelevantIndexerForMember(memberWithBaseOrigin.memberSymbol, numberSignature, stringSignature);
                if (!relevantSignature) {
                    continue;
                }
                var relevantSignatureIsNumberSignature = relevantSignature.parameters[0].type === this.semanticInfoChain.numberTypeSymbol;
                var signatureBaseOrigin = relevantSignatureIsNumberSignature ? inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin :
                    inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin;
                if (signatureBaseOrigin === memberWithBaseOrigin.baseOrigin) {
                    continue;
                }
                var memberIsSubtype = this.sourceIsSubtypeOfTarget(memberWithBaseOrigin.memberSymbol.type, relevantSignature.returnType, interfaceName, context, comparisonInfo);
                if (!memberIsSubtype) {
                    var enclosingSymbol = this.getEnclosingSymbolForAST(interfaceName);
                    if (relevantSignatureIsNumberSignature) {
                        var innerDiagnostic = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_of_property_0_in_type_1_is_not_a_subtype_of_number_indexer_type_in_type_2_NL_3, [("" + memberName), memberWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), comparisonInfo.message]);
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, TypeScript.DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3, [interfaceSymbol.getDisplayName(enclosingSymbol), memberWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), innerDiagnostic]));
                    }
                    else {
                        var innerDiagnostic = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_of_property_0_in_type_1_is_not_a_subtype_of_string_indexer_type_in_type_2_NL_3, [("" + memberName), memberWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), comparisonInfo.message]);
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, TypeScript.DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3, [interfaceSymbol.getDisplayName(enclosingSymbol), memberWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), innerDiagnostic]));
                    }
                    return true;
                }
            }
            return false;
        };
        PullTypeResolver.prototype.checkThatInheritedNumberSignatureIsSubtypeOfInheritedStringSignature = function (interfaceName, interfaceSymbol, inheritedIndexSignatures, context) {
            if (inheritedIndexSignatures.numberSignatureWithBaseOrigin && inheritedIndexSignatures.stringSignatureWithBaseOrigin) {
                if (inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin === inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin) {
                    return false;
                }
                var comparisonInfo = new TypeComparisonInfo();
                var signatureIsSubtype = this.sourceIsSubtypeOfTarget(inheritedIndexSignatures.numberSignatureWithBaseOrigin.signature.returnType, inheritedIndexSignatures.stringSignatureWithBaseOrigin.signature.returnType, interfaceName, context, comparisonInfo);
                if (!signatureIsSubtype) {
                    var enclosingSymbol = this.getEnclosingSymbolForAST(interfaceName);
                    var innerDiagnostic = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_of_number_indexer_in_type_0_is_not_a_subtype_of_string_indexer_type_in_type_1_NL_2, [inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol),
                        inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), comparisonInfo.message]);
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, TypeScript.DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3, [interfaceSymbol.getDisplayName(enclosingSymbol), inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(),
                        inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), innerDiagnostic]));
                    return true;
                }
            }
            return false;
        };
        PullTypeResolver.prototype.checkAssignability = function (ast, source, target, context) {
            var comparisonInfo = new TypeComparisonInfo();
            var isAssignable = this.sourceIsAssignableToTarget(source, target, ast, context, comparisonInfo);
            if (!isAssignable) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                if (comparisonInfo.message) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [source.toString(enclosingSymbol), target.toString(enclosingSymbol), comparisonInfo.message]));
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [source.toString(enclosingSymbol), target.toString(enclosingSymbol)]));
                }
            }
        };
        PullTypeResolver.prototype.isReference = function (ast, astSymbol) {
            if (ast.kind() === TypeScript.SyntaxKind.ParenthesizedExpression) {
                return this.isReference(ast.expression, astSymbol);
            }
            if (ast.kind() !== TypeScript.SyntaxKind.IdentifierName && ast.kind() !== TypeScript.SyntaxKind.MemberAccessExpression && ast.kind() !== TypeScript.SyntaxKind.ElementAccessExpression) {
                return false;
            }
            if (ast.kind() === TypeScript.SyntaxKind.IdentifierName) {
                if (astSymbol.kind === TypeScript.PullElementKind.Variable && astSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.Enum)) {
                    return false;
                }
                if (astSymbol.kind === TypeScript.PullElementKind.Variable && astSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.SomeInitializedModule)) {
                    return false;
                }
                if (astSymbol.kind === TypeScript.PullElementKind.ConstructorMethod) {
                    return false;
                }
            }
            if (ast.kind() === TypeScript.SyntaxKind.MemberAccessExpression && astSymbol.kind === TypeScript.PullElementKind.EnumMember) {
                return false;
            }
            return true;
        };
        PullTypeResolver.prototype.checkForSuperMemberAccess = function (expression, name, resolvedName, context) {
            if (resolvedName) {
                if (expression.kind() === TypeScript.SyntaxKind.SuperKeyword &&
                    !resolvedName.isError() &&
                    resolvedName.kind !== TypeScript.PullElementKind.Method) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, TypeScript.DiagnosticCode.Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword));
                    return true;
                }
            }
            return false;
        };
        PullTypeResolver.prototype.getEnclosingDeclForAST = function (ast) {
            return this.semanticInfoChain.getEnclosingDecl(ast);
        };
        PullTypeResolver.prototype.getEnclosingSymbolForAST = function (ast) {
            var enclosingDecl = this.getEnclosingDeclForAST(ast);
            return enclosingDecl ? enclosingDecl.getSymbol() : null;
        };
        PullTypeResolver.prototype.checkForPrivateMemberAccess = function (name, expressionType, resolvedName, context) {
            if (resolvedName) {
                if (resolvedName.anyDeclHasFlag(TypeScript.PullElementFlags.Private)) {
                    var memberContainer = resolvedName.getContainer();
                    if (memberContainer && memberContainer.kind === TypeScript.PullElementKind.ConstructorType) {
                        memberContainer = memberContainer.getAssociatedContainerType();
                    }
                    if (memberContainer && memberContainer.isClass()) {
                        var memberClass = memberContainer.getDeclarations()[0].ast();
                        TypeScript.Debug.assert(memberClass);
                        var containingClass = this.getEnclosingClassDeclaration(name);
                        if (!containingClass || containingClass !== memberClass) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, TypeScript.DiagnosticCode._0_1_is_inaccessible, [memberContainer.toString(null, false), name.text()]));
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        PullTypeResolver.prototype.instantiateType = function (type, typeParameterArgumentMap, instantiateFunctionTypeParameters) {
            if (instantiateFunctionTypeParameters === void 0) { instantiateFunctionTypeParameters = false; }
            if (type.isPrimitive()) {
                return type;
            }
            if (type.isError()) {
                return type;
            }
            if (typeParameterArgumentMap[type.pullSymbolID]) {
                return typeParameterArgumentMap[type.pullSymbolID];
            }
            if (type.isTypeParameter() && type.isFunctionTypeParameter()) {
                return type;
            }
            type._resolveDeclaredSymbol();
            if (type.wrapsSomeTypeParameter(typeParameterArgumentMap)) {
                return TypeScript.PullInstantiatedTypeReferenceSymbol.create(this, type, typeParameterArgumentMap, instantiateFunctionTypeParameters);
            }
            return type;
        };
        PullTypeResolver.prototype.instantiateSignature = function (signature, typeParameterArgumentMap, instantiateFunctionTypeParameters) {
            if (instantiateFunctionTypeParameters === void 0) { instantiateFunctionTypeParameters = false; }
            if (!signature.wrapsSomeTypeParameter(typeParameterArgumentMap)) {
                return signature;
            }
            var typeArguments = [];
            TypeScript.nSpecializedSignaturesCreated++;
            var instantiatedSignature = new TypeScript.PullSignatureSymbol(signature.kind);
            instantiatedSignature.setRootSymbol(signature);
            var typeParameters = signature.getTypeParameters();
            var constraint = null;
            var typeParameter = null;
            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = typeParameters[i];
                instantiatedSignature.addTypeParameter(typeParameter);
            }
            instantiatedSignature.returnType = this.instantiateType((signature.returnType || this.semanticInfoChain.anyTypeSymbol), typeParameterArgumentMap, instantiateFunctionTypeParameters);
            if (instantiateFunctionTypeParameters) {
                instantiatedSignature.functionType = this.instantiateType(signature.functionType, typeParameterArgumentMap, instantiateFunctionTypeParameters);
            }
            var parameters = signature.parameters;
            var parameter = null;
            if (parameters) {
                for (var j = 0; j < parameters.length; j++) {
                    parameter = new TypeScript.PullSymbol(parameters[j].name, TypeScript.PullElementKind.Parameter);
                    parameter.setRootSymbol(parameters[j]);
                    if (parameters[j].isOptional) {
                        parameter.isOptional = true;
                    }
                    if (parameters[j].isVarArg) {
                        parameter.isVarArg = true;
                        instantiatedSignature.hasVarArgs = true;
                    }
                    instantiatedSignature.addParameter(parameter, parameter.isOptional);
                    parameter.type = this.instantiateType(parameters[j].type, typeParameterArgumentMap, instantiateFunctionTypeParameters);
                }
            }
            return instantiatedSignature;
        };
        PullTypeResolver.globalTypeCheckPhase = 0;
        return PullTypeResolver;
    }());
    TypeScript.PullTypeResolver = PullTypeResolver;
    var TypeComparisonInfo = (function () {
        function TypeComparisonInfo(sourceComparisonInfo) {
            this.onlyCaptureFirstError = false;
            this.flags = TypeScript.TypeRelationshipFlags.SuccessfulComparison;
            this.message = "";
            this.stringConstantVal = null;
            this.indent = 1;
            if (sourceComparisonInfo) {
                this.flags = sourceComparisonInfo.flags;
                this.onlyCaptureFirstError = sourceComparisonInfo.onlyCaptureFirstError;
                this.stringConstantVal = sourceComparisonInfo.stringConstantVal;
                this.indent = sourceComparisonInfo.indent + 1;
            }
        }
        TypeComparisonInfo.prototype.indentString = function () {
            var result = "";
            for (var i = 0; i < this.indent; i++) {
                result += "\t";
            }
            return result;
        };
        TypeComparisonInfo.prototype.addMessage = function (message) {
            if (!this.onlyCaptureFirstError && this.message) {
                this.message = this.message + TypeScript.newLine() + this.indentString() + message;
            }
            else {
                this.message = this.indentString() + message;
            }
        };
        return TypeComparisonInfo;
    }());
    TypeScript.TypeComparisonInfo = TypeComparisonInfo;
    function getPropertyAssignmentNameTextFromIdentifier(identifier) {
        if (identifier.kind() === TypeScript.SyntaxKind.IdentifierName) {
            return { actualText: identifier.text(), memberName: identifier.valueText() };
        }
        else if (identifier.kind() === TypeScript.SyntaxKind.StringLiteral) {
            return { actualText: identifier.text(), memberName: identifier.valueText() };
        }
        else if (identifier.kind() === TypeScript.SyntaxKind.NumericLiteral) {
            return { actualText: identifier.text(), memberName: identifier.valueText() };
        }
        else {
            throw TypeScript.Errors.invalidOperation();
        }
    }
    TypeScript.getPropertyAssignmentNameTextFromIdentifier = getPropertyAssignmentNameTextFromIdentifier;
    function isTypesOnlyLocation(ast) {
        while (ast && ast.parent) {
            switch (ast.parent.kind()) {
                case TypeScript.SyntaxKind.TypeAnnotation:
                    return true;
                case TypeScript.SyntaxKind.TypeQuery:
                    return false;
                case TypeScript.SyntaxKind.ConstructorType:
                    var constructorType = ast.parent;
                    if (constructorType.type === ast) {
                        return true;
                    }
                    break;
                case TypeScript.SyntaxKind.FunctionType:
                    var functionType = ast.parent;
                    if (functionType.type === ast) {
                        return true;
                    }
                    break;
                case TypeScript.SyntaxKind.Constraint:
                    var constraint = ast.parent;
                    if (constraint.type === ast) {
                        return true;
                    }
                    break;
                case TypeScript.SyntaxKind.CastExpression:
                    var castExpression = ast.parent;
                    return castExpression.type === ast;
                case TypeScript.SyntaxKind.ExtendsHeritageClause:
                case TypeScript.SyntaxKind.ImplementsHeritageClause:
                    return true;
                case TypeScript.SyntaxKind.TypeArgumentList:
                    return true;
                case TypeScript.SyntaxKind.ClassDeclaration:
                case TypeScript.SyntaxKind.InterfaceDeclaration:
                case TypeScript.SyntaxKind.ModuleDeclaration:
                case TypeScript.SyntaxKind.FunctionDeclaration:
                case TypeScript.SyntaxKind.MethodSignature:
                case TypeScript.SyntaxKind.MemberAccessExpression:
                case TypeScript.SyntaxKind.Parameter:
                    return false;
            }
            ast = ast.parent;
        }
        return false;
    }
    TypeScript.isTypesOnlyLocation = isTypesOnlyLocation;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.declCacheHit = 0;
    TypeScript.declCacheMiss = 0;
    TypeScript.symbolCacheHit = 0;
    TypeScript.symbolCacheMiss = 0;
    var sentinalEmptyArray = [];
    var SemanticInfoChain = (function () {
        function SemanticInfoChain(compiler, logger) {
            this.compiler = compiler;
            this.logger = logger;
            this.documents = [];
            this.fileNameToDocument = TypeScript.createIntrinsicsObject();
            this.anyTypeDecl = null;
            this.booleanTypeDecl = null;
            this.numberTypeDecl = null;
            this.stringTypeDecl = null;
            this.nullTypeDecl = null;
            this.undefinedTypeDecl = null;
            this.voidTypeDecl = null;
            this.undefinedValueDecl = null;
            this.anyTypeSymbol = null;
            this.booleanTypeSymbol = null;
            this.numberTypeSymbol = null;
            this.stringTypeSymbol = null;
            this.nullTypeSymbol = null;
            this.undefinedTypeSymbol = null;
            this.voidTypeSymbol = null;
            this.undefinedValueSymbol = null;
            this.emptyTypeSymbol = null;
            this.astSymbolMap = [];
            this.astAliasSymbolMap = [];
            this.astCallResolutionDataMap = [];
            this.declSymbolMap = [];
            this.declSignatureSymbolMap = [];
            this.declCache = null;
            this.symbolCache = null;
            this.fileNameToDiagnostics = null;
            this._binder = null;
            this._resolver = null;
            this._topLevelDecls = null;
            this._fileNames = null;
            var span = new TypeScript.TextSpan(0, 0);
            var globalDecl = new TypeScript.RootPullDecl("", "", TypeScript.PullElementKind.Global, TypeScript.PullElementFlags.None, span, this, false);
            this.documents[0] = new TypeScript.Document(this.compiler, this, "", [], null, TypeScript.ByteOrderMark.None, 0, false, null, globalDecl);
            this.anyTypeDecl = new TypeScript.NormalPullDecl("any", "any", TypeScript.PullElementKind.Primitive, TypeScript.PullElementFlags.None, globalDecl, span);
            this.booleanTypeDecl = new TypeScript.NormalPullDecl("boolean", "boolean", TypeScript.PullElementKind.Primitive, TypeScript.PullElementFlags.None, globalDecl, span);
            this.numberTypeDecl = new TypeScript.NormalPullDecl("number", "number", TypeScript.PullElementKind.Primitive, TypeScript.PullElementFlags.None, globalDecl, span);
            this.stringTypeDecl = new TypeScript.NormalPullDecl("string", "string", TypeScript.PullElementKind.Primitive, TypeScript.PullElementFlags.None, globalDecl, span);
            this.voidTypeDecl = new TypeScript.NormalPullDecl("void", "void", TypeScript.PullElementKind.Primitive, TypeScript.PullElementFlags.None, globalDecl, span);
            this.nullTypeDecl = new TypeScript.RootPullDecl("null", "", TypeScript.PullElementKind.Primitive, TypeScript.PullElementFlags.None, span, this, false);
            this.undefinedTypeDecl = new TypeScript.RootPullDecl("undefined", "", TypeScript.PullElementKind.Primitive, TypeScript.PullElementFlags.None, span, this, false);
            this.undefinedValueDecl = new TypeScript.NormalPullDecl("undefined", "undefined", TypeScript.PullElementKind.Variable, TypeScript.PullElementFlags.Ambient, globalDecl, span);
            this.invalidate();
        }
        SemanticInfoChain.prototype.getDocument = function (fileName) {
            var document = this.fileNameToDocument[fileName];
            return document ? document : null;
        };
        SemanticInfoChain.prototype.lineMap = function (fileName) {
            return this.getDocument(fileName).lineMap();
        };
        SemanticInfoChain.prototype.fileNames = function () {
            if (this._fileNames === null) {
                this._fileNames = this.documents.slice(1).map(function (s) { return s.fileName; });
            }
            return this._fileNames;
        };
        SemanticInfoChain.prototype.bindPrimitiveSymbol = function (decl, newSymbol) {
            newSymbol.addDeclaration(decl);
            decl.setSymbol(newSymbol);
            newSymbol.setResolved();
            return newSymbol;
        };
        SemanticInfoChain.prototype.addPrimitiveTypeSymbol = function (decl) {
            var newSymbol = new TypeScript.PullPrimitiveTypeSymbol(decl.name);
            return this.bindPrimitiveSymbol(decl, newSymbol);
        };
        SemanticInfoChain.prototype.addPrimitiveValueSymbol = function (decl, type) {
            var newSymbol = new TypeScript.PullSymbol(decl.name, TypeScript.PullElementKind.Variable);
            newSymbol.type = type;
            return this.bindPrimitiveSymbol(decl, newSymbol);
        };
        SemanticInfoChain.prototype.resetGlobalSymbols = function () {
            this.anyTypeSymbol = this.addPrimitiveTypeSymbol(this.anyTypeDecl);
            this.booleanTypeSymbol = this.addPrimitiveTypeSymbol(this.booleanTypeDecl);
            this.numberTypeSymbol = this.addPrimitiveTypeSymbol(this.numberTypeDecl);
            this.stringTypeSymbol = this.addPrimitiveTypeSymbol(this.stringTypeDecl);
            this.voidTypeSymbol = this.addPrimitiveTypeSymbol(this.voidTypeDecl);
            this.nullTypeSymbol = this.addPrimitiveTypeSymbol(this.nullTypeDecl);
            this.undefinedTypeSymbol = this.addPrimitiveTypeSymbol(this.undefinedTypeDecl);
            this.undefinedValueSymbol = this.addPrimitiveValueSymbol(this.undefinedValueDecl, this.undefinedTypeSymbol);
            var span = new TypeScript.TextSpan(0, 0);
            var emptyTypeDecl = new TypeScript.PullSynthesizedDecl("{}", "{}", TypeScript.PullElementKind.ObjectType, TypeScript.PullElementFlags.None, null, span, this);
            var emptyTypeSymbol = new TypeScript.PullTypeSymbol("{}", TypeScript.PullElementKind.ObjectType);
            emptyTypeDecl.setSymbol(emptyTypeSymbol);
            emptyTypeSymbol.addDeclaration(emptyTypeDecl);
            emptyTypeSymbol.setResolved();
            this.emptyTypeSymbol = emptyTypeSymbol;
        };
        SemanticInfoChain.prototype.addDocument = function (document) {
            var fileName = document.fileName;
            var existingIndex = TypeScript.ArrayUtilities.indexOf(this.documents, function (u) { return u.fileName === fileName; });
            if (existingIndex < 0) {
                this.documents.push(document);
            }
            else {
                this.documents[existingIndex] = document;
            }
            this.fileNameToDocument[fileName] = document;
            this.invalidate();
        };
        SemanticInfoChain.prototype.removeDocument = function (fileName) {
            TypeScript.Debug.assert(fileName !== "", "Can't remove the semantic info for the global decl.");
            var index = TypeScript.ArrayUtilities.indexOf(this.documents, function (u) { return u.fileName === fileName; });
            if (index > 0) {
                this.fileNameToDocument[fileName] = undefined;
                this.documents.splice(index, 1);
                this.invalidate();
            }
        };
        SemanticInfoChain.prototype.getDeclPathCacheID = function (declPath, declKind) {
            var cacheID = "";
            for (var i = 0; i < declPath.length; i++) {
                cacheID += "#" + declPath[i];
            }
            return cacheID + "#" + declKind.toString();
        };
        SemanticInfoChain.prototype.findTopLevelSymbol = function (name, kind, doNotGoPastThisDecl) {
            var cacheID = this.getDeclPathCacheID([name], kind);
            var symbol = this.symbolCache[cacheID];
            if (!symbol) {
                for (var i = 0, n = this.documents.length; i < n; i++) {
                    var topLevelDecl = this.documents[i].topLevelDecl();
                    var symbol = this.findTopLevelSymbolInDecl(topLevelDecl, name, kind, doNotGoPastThisDecl);
                    if (symbol) {
                        break;
                    }
                    if (doNotGoPastThisDecl && topLevelDecl.name == doNotGoPastThisDecl.fileName()) {
                        return null;
                    }
                }
                if (symbol) {
                    this.symbolCache[cacheID] = symbol;
                }
            }
            return symbol;
        };
        SemanticInfoChain.prototype.findTopLevelSymbolInDecl = function (topLevelDecl, name, kind, doNotGoPastThisDecl) {
            var doNotGoPastThisPosition = doNotGoPastThisDecl && doNotGoPastThisDecl.fileName() === topLevelDecl.fileName()
                ? doNotGoPastThisDecl.ast().start()
                : -1;
            var foundDecls = topLevelDecl.searchChildDecls(name, kind);
            for (var j = 0; j < foundDecls.length; j++) {
                var foundDecl = foundDecls[j];
                if (doNotGoPastThisPosition !== -1 &&
                    foundDecl.ast() &&
                    foundDecl.ast().start() > doNotGoPastThisPosition) {
                    break;
                }
                var symbol = foundDecls[j].getSymbol();
                if (symbol) {
                    return symbol;
                }
            }
            return null;
        };
        SemanticInfoChain.prototype.findExternalModule = function (id) {
            id = TypeScript.normalizePath(id);
            var dtsFile = id + ".d.ts";
            var dtsCacheID = this.getDeclPathCacheID([dtsFile], TypeScript.PullElementKind.DynamicModule);
            var symbol = this.symbolCache[dtsCacheID];
            if (symbol) {
                return symbol;
            }
            var tsFile = id + ".ts";
            var tsCacheID = this.getDeclPathCacheID([tsFile], TypeScript.PullElementKind.DynamicModule);
            symbol = this.symbolCache[tsCacheID];
            if (symbol != undefined) {
                return symbol;
            }
            symbol = null;
            for (var i = 0; i < this.documents.length; i++) {
                var document = this.documents[i];
                var topLevelDecl = document.topLevelDecl();
                if (topLevelDecl.isExternalModule()) {
                    var isDtsFile = document.fileName == dtsFile;
                    if (isDtsFile || document.fileName == tsFile) {
                        var dynamicModuleDecl = topLevelDecl.getChildDecls()[0];
                        symbol = dynamicModuleDecl.getSymbol();
                        this.symbolCache[dtsCacheID] = isDtsFile ? symbol : null;
                        this.symbolCache[tsCacheID] = !TypeScript.isDTSFile ? symbol : null;
                        return symbol;
                    }
                }
            }
            this.symbolCache[dtsCacheID] = null;
            this.symbolCache[tsCacheID] = null;
            return symbol;
        };
        SemanticInfoChain.prototype.findAmbientExternalModuleInGlobalContext = function (id) {
            var cacheID = this.getDeclPathCacheID([id], TypeScript.PullElementKind.DynamicModule);
            var symbol = this.symbolCache[cacheID];
            if (symbol == undefined) {
                symbol = null;
                for (var i = 0; i < this.documents.length; i++) {
                    var document = this.documents[i];
                    var topLevelDecl = document.topLevelDecl();
                    if (!topLevelDecl.isExternalModule()) {
                        var dynamicModules = topLevelDecl.searchChildDecls(id, TypeScript.PullElementKind.DynamicModule);
                        if (dynamicModules.length) {
                            symbol = dynamicModules[0].getSymbol();
                            break;
                        }
                    }
                }
                this.symbolCache[cacheID] = symbol;
            }
            return symbol;
        };
        SemanticInfoChain.prototype.findDecls = function (declPath, declKind) {
            var cacheID = this.getDeclPathCacheID(declPath, declKind);
            if (declPath.length) {
                var cachedDecls = this.declCache[cacheID];
                if (cachedDecls && cachedDecls.length) {
                    TypeScript.declCacheHit++;
                    return cachedDecls;
                }
            }
            TypeScript.declCacheMiss++;
            var declsToSearch = this.topLevelDecls();
            var decls = [];
            var path;
            var foundDecls = [];
            var keepSearching = (declKind & TypeScript.PullElementKind.SomeContainer) || (declKind & TypeScript.PullElementKind.Interface);
            for (var i = 0; i < declPath.length; i++) {
                path = declPath[i];
                decls = [];
                for (var j = 0; j < declsToSearch.length; j++) {
                    foundDecls = declsToSearch[j].searchChildDecls(path, i === (declPath.length - 1) ? declKind : TypeScript.PullElementKind.Container);
                    for (var k = 0; k < foundDecls.length; k++) {
                        if (decls == TypeScript.sentinelEmptyArray) {
                            decls = [];
                        }
                        decls[decls.length] = foundDecls[k];
                    }
                    if (foundDecls.length && !keepSearching) {
                        break;
                    }
                }
                declsToSearch = decls;
                if (!declsToSearch) {
                    break;
                }
            }
            if (decls.length) {
                this.declCache[cacheID] = decls;
            }
            return decls;
        };
        SemanticInfoChain.prototype.findDeclsFromPath = function (declPath, declKind) {
            var declString = [];
            for (var i = 0, n = declPath.length; i < n; i++) {
                if (declPath[i].kind & TypeScript.PullElementKind.Script) {
                    continue;
                }
                declString.push(declPath[i].name);
            }
            return this.findDecls(declString, declKind);
        };
        SemanticInfoChain.prototype.findSymbol = function (declPath, declType) {
            var cacheID = this.getDeclPathCacheID(declPath, declType);
            if (declPath.length) {
                var cachedSymbol = this.symbolCache[cacheID];
                if (cachedSymbol) {
                    TypeScript.symbolCacheHit++;
                    return cachedSymbol;
                }
            }
            TypeScript.symbolCacheMiss++;
            var decls = this.findDecls(declPath, declType);
            var symbol = null;
            if (decls.length) {
                var decl = decls[0];
                if (TypeScript.hasFlag(declType, TypeScript.PullElementKind.SomeContainer)) {
                    var valueDecl = decl.getValueDecl();
                    if (valueDecl) {
                        valueDecl.ensureSymbolIsBound();
                    }
                }
                symbol = decl.getSymbol();
                if (symbol) {
                    this.symbolCache[cacheID] = symbol;
                }
            }
            return symbol;
        };
        SemanticInfoChain.prototype.cacheGlobalSymbol = function (symbol, kind) {
            var cacheID1 = this.getDeclPathCacheID([symbol.name], kind);
            var cacheID2 = this.getDeclPathCacheID([symbol.name], symbol.kind);
            if (!this.symbolCache[cacheID1]) {
                this.symbolCache[cacheID1] = symbol;
            }
            if (!this.symbolCache[cacheID2]) {
                this.symbolCache[cacheID2] = symbol;
            }
        };
        SemanticInfoChain.prototype.invalidate = function (oldSettings, newSettings) {
            if (oldSettings === void 0) { oldSettings = null; }
            if (newSettings === void 0) { newSettings = null; }
            TypeScript.PullTypeResolver.globalTypeCheckPhase++;
            var cleanStart = new Date().getTime();
            this.astSymbolMap.length = 0;
            this.astAliasSymbolMap.length = 0;
            this.astCallResolutionDataMap.length = 0;
            this.declCache = TypeScript.createIntrinsicsObject();
            this.symbolCache = TypeScript.createIntrinsicsObject();
            this.fileNameToDiagnostics = TypeScript.createIntrinsicsObject();
            this._binder = null;
            this._resolver = null;
            this._topLevelDecls = null;
            this._fileNames = null;
            this.declSymbolMap.length = 0;
            this.declSignatureSymbolMap.length = 0;
            if (oldSettings && newSettings) {
                if (this.settingsChangeAffectsSyntax(oldSettings, newSettings)) {
                    for (var i = 1, n = this.documents.length; i < n; i++) {
                        this.documents[i].invalidate();
                    }
                }
            }
            TypeScript.pullSymbolID = 0;
            TypeScript.globalTyvarID = 0;
            this.resetGlobalSymbols();
            var cleanEnd = new Date().getTime();
        };
        SemanticInfoChain.prototype.settingsChangeAffectsSyntax = function (before, after) {
            return before.allowAutomaticSemicolonInsertion() !== after.allowAutomaticSemicolonInsertion() ||
                before.codeGenTarget() !== after.codeGenTarget() ||
                before.propagateEnumConstants() != after.propagateEnumConstants();
        };
        SemanticInfoChain.prototype.setSymbolForAST = function (ast, symbol) {
            this.astSymbolMap[ast.syntaxID()] = symbol;
        };
        SemanticInfoChain.prototype.getSymbolForAST = function (ast) {
            return this.astSymbolMap[ast.syntaxID()];
        };
        SemanticInfoChain.prototype.setAliasSymbolForAST = function (ast, symbol) {
            this.astAliasSymbolMap[ast.syntaxID()] = symbol;
        };
        SemanticInfoChain.prototype.getAliasSymbolForAST = function (ast) {
            return this.astAliasSymbolMap[ast.syntaxID()];
        };
        SemanticInfoChain.prototype.getCallResolutionDataForAST = function (ast) {
            return this.astCallResolutionDataMap[ast.syntaxID()];
        };
        SemanticInfoChain.prototype.setCallResolutionDataForAST = function (ast, callResolutionData) {
            if (callResolutionData) {
                this.astCallResolutionDataMap[ast.syntaxID()] = callResolutionData;
            }
        };
        SemanticInfoChain.prototype.setSymbolForDecl = function (decl, symbol) {
            this.declSymbolMap[decl.declID] = symbol;
        };
        SemanticInfoChain.prototype.getSymbolForDecl = function (decl) {
            return this.declSymbolMap[decl.declID];
        };
        SemanticInfoChain.prototype.setSignatureSymbolForDecl = function (decl, signatureSymbol) {
            this.declSignatureSymbolMap[decl.declID] = signatureSymbol;
        };
        SemanticInfoChain.prototype.getSignatureSymbolForDecl = function (decl) {
            return this.declSignatureSymbolMap[decl.declID];
        };
        SemanticInfoChain.prototype.addDiagnostic = function (diagnostic) {
            var fileName = diagnostic.fileName();
            var diagnostics = this.fileNameToDiagnostics[fileName];
            if (!diagnostics) {
                diagnostics = [];
                this.fileNameToDiagnostics[fileName] = diagnostics;
            }
            diagnostics.push(diagnostic);
        };
        SemanticInfoChain.prototype.getDiagnostics = function (fileName) {
            var diagnostics = this.fileNameToDiagnostics[fileName];
            return diagnostics ? diagnostics : [];
        };
        SemanticInfoChain.prototype.getBinder = function () {
            if (!this._binder) {
                this._binder = new TypeScript.PullSymbolBinder(this);
            }
            return this._binder;
        };
        SemanticInfoChain.prototype.getResolver = function () {
            if (!this._resolver) {
                this._resolver = new TypeScript.PullTypeResolver(this.compiler.compilationSettings(), this);
            }
            return this._resolver;
        };
        SemanticInfoChain.prototype.addSyntheticIndexSignature = function (containingDecl, containingSymbol, ast, indexParamName, indexParamType, returnType) {
            var indexSignature = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.IndexSignature);
            var indexParameterSymbol = new TypeScript.PullSymbol(indexParamName, TypeScript.PullElementKind.Parameter);
            indexParameterSymbol.type = indexParamType;
            indexSignature.addParameter(indexParameterSymbol);
            indexSignature.returnType = returnType;
            indexSignature.setResolved();
            indexParameterSymbol.setResolved();
            containingSymbol.addIndexSignature(indexSignature);
            var span = TypeScript.TextSpan.fromBounds(ast.start(), ast.end());
            var indexSigDecl = new TypeScript.PullSynthesizedDecl("", "", TypeScript.PullElementKind.IndexSignature, TypeScript.PullElementFlags.Signature, containingDecl, span, containingDecl.semanticInfoChain());
            var indexParamDecl = new TypeScript.PullSynthesizedDecl(indexParamName, indexParamName, TypeScript.PullElementKind.Parameter, TypeScript.PullElementFlags.None, indexSigDecl, span, containingDecl.semanticInfoChain());
            indexSigDecl.setSignatureSymbol(indexSignature);
            indexParamDecl.setSymbol(indexParameterSymbol);
            indexSignature.addDeclaration(indexSigDecl);
            indexParameterSymbol.addDeclaration(indexParamDecl);
        };
        SemanticInfoChain.prototype.getDeclForAST = function (ast) {
            var document = this.getDocument(ast.fileName());
            if (document) {
                return document._getDeclForAST(ast);
            }
            return null;
        };
        SemanticInfoChain.prototype.getEnclosingDecl = function (ast) {
            return this.getDocument(ast.fileName()).getEnclosingDecl(ast);
        };
        SemanticInfoChain.prototype.setDeclForAST = function (ast, decl) {
            this.getDocument(decl.fileName())._setDeclForAST(ast, decl);
        };
        SemanticInfoChain.prototype.getASTForDecl = function (decl) {
            var document = this.getDocument(decl.fileName());
            if (document) {
                return document._getASTForDecl(decl);
            }
            return null;
        };
        SemanticInfoChain.prototype.setASTForDecl = function (decl, ast) {
            this.getDocument(decl.fileName())._setASTForDecl(decl, ast);
        };
        SemanticInfoChain.prototype.topLevelDecl = function (fileName) {
            var document = this.getDocument(fileName);
            if (document) {
                return document.topLevelDecl();
            }
            return null;
        };
        SemanticInfoChain.prototype.topLevelDecls = function () {
            if (!this._topLevelDecls) {
                this._topLevelDecls = TypeScript.ArrayUtilities.select(this.documents, function (u) { return u.topLevelDecl(); });
            }
            return this._topLevelDecls;
        };
        SemanticInfoChain.prototype.addDiagnosticFromAST = function (ast, diagnosticKey, args) {
            if (args === void 0) { args = null; }
            this.addDiagnostic(this.diagnosticFromAST(ast, diagnosticKey, args));
        };
        SemanticInfoChain.prototype.diagnosticFromAST = function (ast, diagnosticKey, args) {
            if (args === void 0) { args = null; }
            return new TypeScript.Diagnostic(ast.fileName(), this.lineMap(ast.fileName()), ast.start(), ast.width(), diagnosticKey, args);
        };
        return SemanticInfoChain;
    }());
    TypeScript.SemanticInfoChain = SemanticInfoChain;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DeclCollectionContext = (function () {
        function DeclCollectionContext(document, semanticInfoChain, propagateEnumConstants) {
            this.document = document;
            this.semanticInfoChain = semanticInfoChain;
            this.propagateEnumConstants = propagateEnumConstants;
            this.isDeclareFile = false;
            this.parentChain = [];
        }
        DeclCollectionContext.prototype.getParent = function () { return this.parentChain ? this.parentChain[this.parentChain.length - 1] : null; };
        DeclCollectionContext.prototype.pushParent = function (parentDecl) { if (parentDecl) {
            this.parentChain[this.parentChain.length] = parentDecl;
        } };
        DeclCollectionContext.prototype.popParent = function () { this.parentChain.length--; };
        return DeclCollectionContext;
    }());
    function containingModuleHasExportAssignment(ast) {
        ast = ast.parent;
        while (ast) {
            if (ast.kind() === TypeScript.SyntaxKind.ModuleDeclaration) {
                var moduleDecl = ast;
                return moduleDecl.moduleElements.any(function (m) { return m.kind() === TypeScript.SyntaxKind.ExportAssignment; });
            }
            else if (ast.kind() === TypeScript.SyntaxKind.SourceUnit) {
                var sourceUnit = ast;
                return sourceUnit.moduleElements.any(function (m) { return m.kind() === TypeScript.SyntaxKind.ExportAssignment; });
            }
            ast = ast.parent;
        }
        return false;
    }
    function isParsingAmbientModule(ast, context) {
        ast = ast.parent;
        while (ast) {
            if (ast.kind() === TypeScript.SyntaxKind.ModuleDeclaration) {
                if (TypeScript.hasModifier(ast.modifiers, TypeScript.PullElementFlags.Ambient)) {
                    return true;
                }
            }
            ast = ast.parent;
        }
        return false;
    }
    function preCollectImportDecls(ast, context) {
        var importDecl = ast;
        var declFlags = TypeScript.PullElementFlags.None;
        var span = TypeScript.TextSpan.fromBounds(importDecl.start(), importDecl.end());
        var parent = context.getParent();
        if (TypeScript.hasModifier(importDecl.modifiers, TypeScript.PullElementFlags.Exported) && !containingModuleHasExportAssignment(ast)) {
            declFlags |= TypeScript.PullElementFlags.Exported;
        }
        var decl = new TypeScript.NormalPullDecl(importDecl.identifier.valueText(), importDecl.identifier.text(), TypeScript.PullElementKind.TypeAlias, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(ast, decl);
        context.semanticInfoChain.setASTForDecl(decl, ast);
    }
    function preCollectScriptDecls(sourceUnit, context) {
        var span = TypeScript.TextSpan.fromBounds(sourceUnit.start(), sourceUnit.end());
        var fileName = sourceUnit.fileName();
        var isExternalModule = context.document.isExternalModule();
        var decl = new TypeScript.RootPullDecl(fileName, fileName, TypeScript.PullElementKind.Script, TypeScript.PullElementFlags.None, span, context.semanticInfoChain, isExternalModule);
        context.semanticInfoChain.setDeclForAST(sourceUnit, decl);
        context.semanticInfoChain.setASTForDecl(decl, sourceUnit);
        context.isDeclareFile = context.document.isDeclareFile();
        context.pushParent(decl);
        if (isExternalModule) {
            var declFlags = TypeScript.PullElementFlags.Exported;
            if (TypeScript.isDTSFile(fileName)) {
                declFlags |= TypeScript.PullElementFlags.Ambient;
            }
            var moduleContainsExecutableCode = containsExecutableCode(sourceUnit.moduleElements);
            var kind = TypeScript.PullElementKind.DynamicModule;
            var span = TypeScript.TextSpan.fromBounds(sourceUnit.start(), sourceUnit.end());
            var valueText = TypeScript.quoteStr(fileName);
            var decl = new TypeScript.NormalPullDecl(valueText, fileName, kind, declFlags, context.getParent(), span);
            context.semanticInfoChain.setASTForDecl(decl, sourceUnit);
            context.semanticInfoChain.setDeclForAST(sourceUnit, decl);
            if (moduleContainsExecutableCode) {
                createModuleVariableDecl(decl, sourceUnit, context);
            }
            context.pushParent(decl);
        }
    }
    function preCollectEnumDecls(enumDecl, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var enumName = enumDecl.identifier.valueText();
        var kind = TypeScript.PullElementKind.Container;
        if ((TypeScript.hasModifier(enumDecl.modifiers, TypeScript.PullElementFlags.Exported) || isParsingAmbientModule(enumDecl, context)) && !containingModuleHasExportAssignment(enumDecl)) {
            declFlags |= TypeScript.PullElementFlags.Exported;
        }
        if (TypeScript.hasModifier(enumDecl.modifiers, TypeScript.PullElementFlags.Ambient) || isParsingAmbientModule(enumDecl, context) || context.isDeclareFile) {
            declFlags |= TypeScript.PullElementFlags.Ambient;
        }
        declFlags |= TypeScript.PullElementFlags.Enum;
        kind = TypeScript.PullElementKind.Enum;
        var span = TypeScript.TextSpan.fromBounds(enumDecl.start(), enumDecl.end());
        var enumDeclaration = new TypeScript.NormalPullDecl(enumName, enumDecl.identifier.text(), kind, declFlags, context.getParent(), span);
        context.semanticInfoChain.setDeclForAST(enumDecl, enumDeclaration);
        context.semanticInfoChain.setASTForDecl(enumDeclaration, enumDecl);
        var enumIndexerDecl = new TypeScript.NormalPullDecl("", "", TypeScript.PullElementKind.IndexSignature, TypeScript.PullElementFlags.Signature, enumDeclaration, span);
        var enumIndexerParameter = new TypeScript.NormalPullDecl("x", "x", TypeScript.PullElementKind.Parameter, TypeScript.PullElementFlags.None, enumIndexerDecl, span);
        var valueDecl = new TypeScript.NormalPullDecl(enumDeclaration.name, enumDeclaration.getDisplayName(), TypeScript.PullElementKind.Variable, enumDeclaration.flags, context.getParent(), enumDeclaration.getSpan());
        enumDeclaration.setValueDecl(valueDecl);
        context.semanticInfoChain.setASTForDecl(valueDecl, enumDecl);
        context.pushParent(enumDeclaration);
    }
    function createEnumElementDecls(propertyDecl, context) {
        var parent = context.getParent();
        var span = TypeScript.TextSpan.fromBounds(propertyDecl.start(), propertyDecl.end());
        var decl = new TypeScript.PullEnumElementDecl(propertyDecl.propertyName.valueText(), propertyDecl.propertyName.text(), parent, span);
        context.semanticInfoChain.setDeclForAST(propertyDecl, decl);
        context.semanticInfoChain.setASTForDecl(decl, propertyDecl);
    }
    function preCollectModuleDecls(moduleDecl, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var moduleContainsExecutableCode = containsExecutableCode(moduleDecl.moduleElements);
        var isDynamic = moduleDecl.stringLiteral !== null;
        if ((TypeScript.hasModifier(moduleDecl.modifiers, TypeScript.PullElementFlags.Exported) || isParsingAmbientModule(moduleDecl, context)) && !containingModuleHasExportAssignment(moduleDecl)) {
            declFlags |= TypeScript.PullElementFlags.Exported;
        }
        if (TypeScript.hasModifier(moduleDecl.modifiers, TypeScript.PullElementFlags.Ambient) || isParsingAmbientModule(moduleDecl, context) || context.isDeclareFile) {
            declFlags |= TypeScript.PullElementFlags.Ambient;
        }
        var kind = isDynamic ? TypeScript.PullElementKind.DynamicModule : TypeScript.PullElementKind.Container;
        var span = TypeScript.TextSpan.fromBounds(moduleDecl.start(), moduleDecl.end());
        if (moduleDecl.stringLiteral) {
            var valueText = TypeScript.quoteStr(moduleDecl.stringLiteral.valueText());
            var text = moduleDecl.stringLiteral.text();
            var decl = new TypeScript.NormalPullDecl(valueText, text, kind, declFlags, context.getParent(), span);
            context.semanticInfoChain.setDeclForAST(moduleDecl, decl);
            context.semanticInfoChain.setDeclForAST(moduleDecl.stringLiteral, decl);
            context.semanticInfoChain.setASTForDecl(decl, moduleDecl.stringLiteral);
            if (moduleContainsExecutableCode) {
                createModuleVariableDecl(decl, moduleDecl.stringLiteral, context);
            }
            context.pushParent(decl);
        }
        else {
            var moduleNames = getModuleNames(moduleDecl.name);
            for (var i = 0, n = moduleNames.length; i < n; i++) {
                var moduleName = moduleNames[i];
                var specificFlags = declFlags;
                if (i > 0) {
                    specificFlags |= TypeScript.PullElementFlags.Exported;
                }
                var decl = new TypeScript.NormalPullDecl(moduleName.valueText(), moduleName.text(), kind, specificFlags, context.getParent(), span);
                context.semanticInfoChain.setDeclForAST(moduleDecl, decl);
                context.semanticInfoChain.setDeclForAST(moduleName, decl);
                context.semanticInfoChain.setASTForDecl(decl, moduleName);
                if (moduleContainsExecutableCode) {
                    createModuleVariableDecl(decl, moduleName, context);
                }
                context.pushParent(decl);
            }
        }
    }
    function getModuleNames(name, result) {
        result = result || [];
        if (name.kind() === TypeScript.SyntaxKind.QualifiedName) {
            getModuleNames(name.left, result);
            result.push(name.right);
        }
        else {
            result.push(name);
        }
        return result;
    }
    TypeScript.getModuleNames = getModuleNames;
    function createModuleVariableDecl(decl, moduleNameAST, context) {
        decl.setFlags(decl.flags | getInitializationFlag(decl));
        var valueDecl = new TypeScript.NormalPullDecl(decl.name, decl.getDisplayName(), TypeScript.PullElementKind.Variable, decl.flags, context.getParent(), decl.getSpan());
        decl.setValueDecl(valueDecl);
        context.semanticInfoChain.setASTForDecl(valueDecl, moduleNameAST);
    }
    function containsExecutableCode(members) {
        for (var i = 0, n = members.childCount(); i < n; i++) {
            var member = members.childAt(i);
            if (member.kind() === TypeScript.SyntaxKind.ModuleDeclaration) {
                var moduleDecl = member;
                if (containsExecutableCode(moduleDecl.moduleElements)) {
                    return true;
                }
            }
            else if (member.kind() !== TypeScript.SyntaxKind.InterfaceDeclaration && member.kind() !== TypeScript.SyntaxKind.ImportDeclaration) {
                return true;
            }
        }
        return false;
    }
    function preCollectClassDecls(classDecl, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var constructorDeclKind = TypeScript.PullElementKind.Variable;
        if ((TypeScript.hasModifier(classDecl.modifiers, TypeScript.PullElementFlags.Exported) || isParsingAmbientModule(classDecl, context)) && !containingModuleHasExportAssignment(classDecl)) {
            declFlags |= TypeScript.PullElementFlags.Exported;
        }
        if (TypeScript.hasModifier(classDecl.modifiers, TypeScript.PullElementFlags.Ambient) || isParsingAmbientModule(classDecl, context) || context.isDeclareFile) {
            declFlags |= TypeScript.PullElementFlags.Ambient;
        }
        var span = TypeScript.TextSpan.fromBounds(classDecl.start(), classDecl.end());
        var parent = context.getParent();
        var decl = new TypeScript.NormalPullDecl(classDecl.identifier.valueText(), classDecl.identifier.text(), TypeScript.PullElementKind.Class, declFlags, parent, span);
        var constructorDecl = new TypeScript.NormalPullDecl(classDecl.identifier.valueText(), classDecl.identifier.text(), constructorDeclKind, declFlags | TypeScript.PullElementFlags.ClassConstructorVariable, parent, span);
        decl.setValueDecl(constructorDecl);
        context.semanticInfoChain.setDeclForAST(classDecl, decl);
        context.semanticInfoChain.setASTForDecl(decl, classDecl);
        context.semanticInfoChain.setASTForDecl(constructorDecl, classDecl);
        context.pushParent(decl);
    }
    function preCollectObjectTypeDecls(objectType, context) {
        if (objectType.parent.kind() === TypeScript.SyntaxKind.InterfaceDeclaration) {
            return;
        }
        var declFlags = TypeScript.PullElementFlags.None;
        var span = TypeScript.TextSpan.fromBounds(objectType.start(), objectType.end());
        var parent = context.getParent();
        if (parent && (parent.kind === TypeScript.PullElementKind.WithBlock || (parent.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.NormalPullDecl("", "", TypeScript.PullElementKind.ObjectType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(objectType, decl);
        context.semanticInfoChain.setASTForDecl(decl, objectType);
        context.pushParent(decl);
    }
    function preCollectInterfaceDecls(interfaceDecl, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        if ((TypeScript.hasModifier(interfaceDecl.modifiers, TypeScript.PullElementFlags.Exported) || isParsingAmbientModule(interfaceDecl, context)) && !containingModuleHasExportAssignment(interfaceDecl)) {
            declFlags |= TypeScript.PullElementFlags.Exported;
        }
        var span = TypeScript.TextSpan.fromBounds(interfaceDecl.start(), interfaceDecl.end());
        var parent = context.getParent();
        var decl = new TypeScript.NormalPullDecl(interfaceDecl.identifier.valueText(), interfaceDecl.identifier.text(), TypeScript.PullElementKind.Interface, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(interfaceDecl, decl);
        context.semanticInfoChain.setASTForDecl(decl, interfaceDecl);
        context.pushParent(decl);
    }
    function preCollectParameterDecl(argDecl, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        if (TypeScript.hasModifier(argDecl.modifiers, TypeScript.PullElementFlags.Private)) {
            declFlags |= TypeScript.PullElementFlags.Private;
        }
        else {
            declFlags |= TypeScript.PullElementFlags.Public;
        }
        if (argDecl.questionToken !== null || argDecl.equalsValueClause !== null || argDecl.dotDotDotToken !== null) {
            declFlags |= TypeScript.PullElementFlags.Optional;
        }
        var parent = context.getParent();
        if (parent && (parent.kind === TypeScript.PullElementKind.WithBlock || (parent.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var span = TypeScript.TextSpan.fromBounds(argDecl.start(), argDecl.end());
        var decl = new TypeScript.NormalPullDecl(argDecl.identifier.valueText(), argDecl.identifier.text(), TypeScript.PullElementKind.Parameter, declFlags, parent, span);
        if (argDecl.equalsValueClause) {
            parent.flags |= TypeScript.PullElementFlags.HasDefaultArgs;
        }
        if (parent.kind == TypeScript.PullElementKind.ConstructorMethod) {
            decl.setFlag(TypeScript.PullElementFlags.ConstructorParameter);
        }
        var isPublicOrPrivate = TypeScript.hasModifier(argDecl.modifiers, TypeScript.PullElementFlags.Public | TypeScript.PullElementFlags.Private);
        var isInConstructor = parent.kind === TypeScript.PullElementKind.ConstructorMethod;
        if (isPublicOrPrivate && isInConstructor) {
            var parentsParent = context.parentChain[context.parentChain.length - 2];
            var propDecl = new TypeScript.NormalPullDecl(argDecl.identifier.valueText(), argDecl.identifier.text(), TypeScript.PullElementKind.Property, declFlags, parentsParent, span);
            propDecl.setValueDecl(decl);
            decl.setFlag(TypeScript.PullElementFlags.PropertyParameter);
            propDecl.setFlag(TypeScript.PullElementFlags.PropertyParameter);
            if (parent.kind == TypeScript.PullElementKind.ConstructorMethod) {
                propDecl.setFlag(TypeScript.PullElementFlags.ConstructorParameter);
            }
            context.semanticInfoChain.setASTForDecl(decl, argDecl);
            context.semanticInfoChain.setASTForDecl(propDecl, argDecl);
            context.semanticInfoChain.setDeclForAST(argDecl, propDecl);
        }
        else {
            context.semanticInfoChain.setASTForDecl(decl, argDecl);
            context.semanticInfoChain.setDeclForAST(argDecl, decl);
        }
        parent.addVariableDeclToGroup(decl);
    }
    function preCollectTypeParameterDecl(typeParameterDecl, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var span = TypeScript.TextSpan.fromBounds(typeParameterDecl.start(), typeParameterDecl.end());
        var parent = context.getParent();
        if (parent && (parent.kind === TypeScript.PullElementKind.WithBlock || (parent.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.NormalPullDecl(typeParameterDecl.identifier.valueText(), typeParameterDecl.identifier.text(), TypeScript.PullElementKind.TypeParameter, declFlags, parent, span);
        context.semanticInfoChain.setASTForDecl(decl, typeParameterDecl);
        context.semanticInfoChain.setDeclForAST(typeParameterDecl, decl);
    }
    function createPropertySignature(propertyDecl, context) {
        var declFlags = TypeScript.PullElementFlags.Public;
        var parent = context.getParent();
        var declType = TypeScript.PullElementKind.Property;
        if (propertyDecl.questionToken !== null) {
            declFlags |= TypeScript.PullElementFlags.Optional;
        }
        var span = TypeScript.TextSpan.fromBounds(propertyDecl.start(), propertyDecl.end());
        var decl = new TypeScript.NormalPullDecl(propertyDecl.propertyName.valueText(), propertyDecl.propertyName.text(), declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(propertyDecl, decl);
        context.semanticInfoChain.setASTForDecl(decl, propertyDecl);
    }
    function createMemberVariableDeclaration(memberDecl, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.Property;
        if (TypeScript.hasModifier(memberDecl.modifiers, TypeScript.PullElementFlags.Private)) {
            declFlags |= TypeScript.PullElementFlags.Private;
        }
        else {
            declFlags |= TypeScript.PullElementFlags.Public;
        }
        if (TypeScript.hasModifier(memberDecl.modifiers, TypeScript.PullElementFlags.Static)) {
            declFlags |= TypeScript.PullElementFlags.Static;
        }
        var span = TypeScript.TextSpan.fromBounds(memberDecl.start(), memberDecl.end());
        var parent = context.getParent();
        var decl = new TypeScript.NormalPullDecl(memberDecl.variableDeclarator.propertyName.valueText(), memberDecl.variableDeclarator.propertyName.text(), declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(memberDecl, decl);
        context.semanticInfoChain.setDeclForAST(memberDecl.variableDeclarator, decl);
        context.semanticInfoChain.setASTForDecl(decl, memberDecl);
    }
    function createVariableDeclaration(varDecl, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.Variable;
        var modifiers = TypeScript.getVariableDeclaratorModifiers(varDecl);
        if ((TypeScript.hasModifier(modifiers, TypeScript.PullElementFlags.Exported) || isParsingAmbientModule(varDecl, context)) && !containingModuleHasExportAssignment(varDecl)) {
            declFlags |= TypeScript.PullElementFlags.Exported;
        }
        if (TypeScript.hasModifier(modifiers, TypeScript.PullElementFlags.Ambient) || isParsingAmbientModule(varDecl, context) || context.isDeclareFile) {
            declFlags |= TypeScript.PullElementFlags.Ambient;
        }
        var span = TypeScript.TextSpan.fromBounds(varDecl.start(), varDecl.end());
        var parent = context.getParent();
        if (parent && (parent.kind === TypeScript.PullElementKind.WithBlock || (parent.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.NormalPullDecl(varDecl.propertyName.valueText(), varDecl.propertyName.text(), declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(varDecl, decl);
        context.semanticInfoChain.setASTForDecl(decl, varDecl);
        if (parent) {
            parent.addVariableDeclToGroup(decl);
        }
    }
    function preCollectVarDecls(ast, context) {
        if (ast.parent.kind() === TypeScript.SyntaxKind.MemberVariableDeclaration) {
            return;
        }
        var varDecl = ast;
        createVariableDeclaration(varDecl, context);
    }
    function createFunctionTypeDeclaration(functionTypeDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.Signature;
        var declType = TypeScript.PullElementKind.FunctionType;
        var span = TypeScript.TextSpan.fromBounds(functionTypeDeclAST.start(), functionTypeDeclAST.end());
        var parent = context.getParent();
        if (parent && (parent.kind === TypeScript.PullElementKind.WithBlock || (parent.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(functionTypeDeclAST, decl);
        context.semanticInfoChain.setASTForDecl(decl, functionTypeDeclAST);
        context.pushParent(decl);
    }
    function createConstructorTypeDeclaration(constructorTypeDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.ConstructorType;
        var span = TypeScript.TextSpan.fromBounds(constructorTypeDeclAST.start(), constructorTypeDeclAST.end());
        var parent = context.getParent();
        if (parent && (parent.kind === TypeScript.PullElementKind.WithBlock || (parent.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(constructorTypeDeclAST, decl);
        context.semanticInfoChain.setASTForDecl(decl, constructorTypeDeclAST);
        context.pushParent(decl);
    }
    function createFunctionDeclaration(funcDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.Function;
        if ((TypeScript.hasModifier(funcDeclAST.modifiers, TypeScript.PullElementFlags.Exported) || isParsingAmbientModule(funcDeclAST, context)) && !containingModuleHasExportAssignment(funcDeclAST)) {
            declFlags |= TypeScript.PullElementFlags.Exported;
        }
        if (TypeScript.hasModifier(funcDeclAST.modifiers, TypeScript.PullElementFlags.Ambient) || isParsingAmbientModule(funcDeclAST, context) || context.isDeclareFile) {
            declFlags |= TypeScript.PullElementFlags.Ambient;
        }
        if (!funcDeclAST.block) {
            declFlags |= TypeScript.PullElementFlags.Signature;
        }
        var span = TypeScript.TextSpan.fromBounds(funcDeclAST.start(), funcDeclAST.end());
        var parent = context.getParent();
        if (parent && (parent.kind === TypeScript.PullElementKind.WithBlock || (parent.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.NormalPullDecl(funcDeclAST.identifier.valueText(), funcDeclAST.identifier.text(), declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(funcDeclAST, decl);
        context.semanticInfoChain.setASTForDecl(decl, funcDeclAST);
        context.pushParent(decl);
    }
    function createAnyFunctionExpressionDeclaration(functionExpressionDeclAST, id, context, displayName) {
        if (displayName === void 0) { displayName = null; }
        var declFlags = TypeScript.PullElementFlags.None;
        if (functionExpressionDeclAST.kind() === TypeScript.SyntaxKind.SimpleArrowFunctionExpression ||
            functionExpressionDeclAST.kind() === TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression) {
            declFlags |= TypeScript.PullElementFlags.ArrowFunction;
        }
        var span = TypeScript.TextSpan.fromBounds(functionExpressionDeclAST.start(), functionExpressionDeclAST.end());
        var parent = context.getParent();
        if (parent && (parent.kind === TypeScript.PullElementKind.WithBlock || (parent.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var name = id ? id.text() : "";
        var displayNameText = displayName ? displayName.text() : "";
        var decl = new TypeScript.PullFunctionExpressionDecl(name, declFlags, parent, span, displayNameText);
        context.semanticInfoChain.setDeclForAST(functionExpressionDeclAST, decl);
        context.semanticInfoChain.setASTForDecl(decl, functionExpressionDeclAST);
        context.pushParent(decl);
        if (functionExpressionDeclAST.kind() === TypeScript.SyntaxKind.SimpleArrowFunctionExpression) {
            var simpleArrow = functionExpressionDeclAST;
            var declFlags = TypeScript.PullElementFlags.Public;
            var parent = context.getParent();
            if (TypeScript.hasFlag(parent.flags, TypeScript.PullElementFlags.DeclaredInAWithBlock)) {
                declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
            }
            var span = TypeScript.TextSpan.fromBounds(simpleArrow.identifier.start(), simpleArrow.identifier.end());
            var decl = new TypeScript.NormalPullDecl(simpleArrow.identifier.valueText(), simpleArrow.identifier.text(), TypeScript.PullElementKind.Parameter, declFlags, parent, span);
            context.semanticInfoChain.setASTForDecl(decl, simpleArrow.identifier);
            context.semanticInfoChain.setDeclForAST(simpleArrow.identifier, decl);
            parent.addVariableDeclToGroup(decl);
        }
    }
    function createMemberFunctionDeclaration(funcDecl, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.Method;
        if (TypeScript.hasModifier(funcDecl.modifiers, TypeScript.PullElementFlags.Static)) {
            declFlags |= TypeScript.PullElementFlags.Static;
        }
        if (TypeScript.hasModifier(funcDecl.modifiers, TypeScript.PullElementFlags.Private)) {
            declFlags |= TypeScript.PullElementFlags.Private;
        }
        else {
            declFlags |= TypeScript.PullElementFlags.Public;
        }
        if (!funcDecl.block) {
            declFlags |= TypeScript.PullElementFlags.Signature;
        }
        var span = TypeScript.TextSpan.fromBounds(funcDecl.start(), funcDecl.end());
        var parent = context.getParent();
        var decl = new TypeScript.NormalPullDecl(funcDecl.propertyName.valueText(), funcDecl.propertyName.text(), declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(funcDecl, decl);
        context.semanticInfoChain.setASTForDecl(decl, funcDecl);
        context.pushParent(decl);
    }
    function createIndexSignatureDeclaration(indexSignatureDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.Signature;
        var declType = TypeScript.PullElementKind.IndexSignature;
        var span = TypeScript.TextSpan.fromBounds(indexSignatureDeclAST.start(), indexSignatureDeclAST.end());
        var parent = context.getParent();
        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(indexSignatureDeclAST, decl);
        context.semanticInfoChain.setASTForDecl(decl, indexSignatureDeclAST);
        context.pushParent(decl);
    }
    function createCallSignatureDeclaration(callSignature, context) {
        var isChildOfObjectType = callSignature.parent && callSignature.parent.parent &&
            callSignature.parent.kind() === TypeScript.SyntaxKind.SeparatedList &&
            callSignature.parent.parent.kind() === TypeScript.SyntaxKind.ObjectType;
        if (!isChildOfObjectType) {
            return;
        }
        var declFlags = TypeScript.PullElementFlags.Signature;
        var declType = TypeScript.PullElementKind.CallSignature;
        var span = TypeScript.TextSpan.fromBounds(callSignature.start(), callSignature.end());
        var parent = context.getParent();
        if (parent && (parent.kind === TypeScript.PullElementKind.WithBlock || (parent.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(callSignature, decl);
        context.semanticInfoChain.setASTForDecl(decl, callSignature);
        context.pushParent(decl);
    }
    function createMethodSignatureDeclaration(method, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.Method;
        declFlags |= TypeScript.PullElementFlags.Public;
        declFlags |= TypeScript.PullElementFlags.Signature;
        if (method.questionToken !== null) {
            declFlags |= TypeScript.PullElementFlags.Optional;
        }
        var span = TypeScript.TextSpan.fromBounds(method.start(), method.end());
        var parent = context.getParent();
        var decl = new TypeScript.NormalPullDecl(method.propertyName.valueText(), method.propertyName.text(), declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(method, decl);
        context.semanticInfoChain.setASTForDecl(decl, method);
        context.pushParent(decl);
    }
    function createConstructSignatureDeclaration(constructSignatureDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.Signature;
        var declType = TypeScript.PullElementKind.ConstructSignature;
        var span = TypeScript.TextSpan.fromBounds(constructSignatureDeclAST.start(), constructSignatureDeclAST.end());
        var parent = context.getParent();
        if (parent && (parent.kind === TypeScript.PullElementKind.WithBlock || (parent.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(constructSignatureDeclAST, decl);
        context.semanticInfoChain.setASTForDecl(decl, constructSignatureDeclAST);
        context.pushParent(decl);
    }
    function createClassConstructorDeclaration(constructorDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.ConstructorMethod;
        if (!constructorDeclAST.block) {
            declFlags |= TypeScript.PullElementFlags.Signature;
        }
        var span = TypeScript.TextSpan.fromBounds(constructorDeclAST.start(), constructorDeclAST.end());
        var parent = context.getParent();
        if (parent) {
            var parentFlags = parent.flags;
            if (parentFlags & TypeScript.PullElementFlags.Exported) {
                declFlags |= TypeScript.PullElementFlags.Exported;
            }
        }
        var decl = new TypeScript.NormalPullDecl(parent.name, parent.getDisplayName(), declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(constructorDeclAST, decl);
        context.semanticInfoChain.setASTForDecl(decl, constructorDeclAST);
        context.pushParent(decl);
    }
    function createGetAccessorDeclaration(getAccessorDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.Public;
        var declType = TypeScript.PullElementKind.GetAccessor;
        if (TypeScript.hasModifier(getAccessorDeclAST.modifiers, TypeScript.PullElementFlags.Static)) {
            declFlags |= TypeScript.PullElementFlags.Static;
        }
        if (TypeScript.hasModifier(getAccessorDeclAST.modifiers, TypeScript.PullElementFlags.Private)) {
            declFlags |= TypeScript.PullElementFlags.Private;
        }
        else {
            declFlags |= TypeScript.PullElementFlags.Public;
        }
        var span = TypeScript.TextSpan.fromBounds(getAccessorDeclAST.start(), getAccessorDeclAST.end());
        var parent = context.getParent();
        if (parent && (parent.kind === TypeScript.PullElementKind.WithBlock || (parent.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.NormalPullDecl(getAccessorDeclAST.propertyName.valueText(), getAccessorDeclAST.propertyName.text(), declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(getAccessorDeclAST, decl);
        context.semanticInfoChain.setASTForDecl(decl, getAccessorDeclAST);
        context.pushParent(decl);
    }
    function createFunctionExpressionDeclaration(expression, context) {
        createAnyFunctionExpressionDeclaration(expression, expression.identifier, context);
    }
    function createSetAccessorDeclaration(setAccessorDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.Public;
        var declType = TypeScript.PullElementKind.SetAccessor;
        if (TypeScript.hasModifier(setAccessorDeclAST.modifiers, TypeScript.PullElementFlags.Static)) {
            declFlags |= TypeScript.PullElementFlags.Static;
        }
        if (TypeScript.hasModifier(setAccessorDeclAST.modifiers, TypeScript.PullElementFlags.Private)) {
            declFlags |= TypeScript.PullElementFlags.Private;
        }
        else {
            declFlags |= TypeScript.PullElementFlags.Public;
        }
        var span = TypeScript.TextSpan.fromBounds(setAccessorDeclAST.start(), setAccessorDeclAST.end());
        var parent = context.getParent();
        if (parent && (parent.kind === TypeScript.PullElementKind.WithBlock || (parent.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.NormalPullDecl(setAccessorDeclAST.propertyName.valueText(), setAccessorDeclAST.propertyName.text(), declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(setAccessorDeclAST, decl);
        context.semanticInfoChain.setASTForDecl(decl, setAccessorDeclAST);
        context.pushParent(decl);
    }
    function preCollectCatchDecls(ast, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.CatchBlock;
        var span = TypeScript.TextSpan.fromBounds(ast.start(), ast.end());
        var parent = context.getParent();
        if (parent && (parent.kind === TypeScript.PullElementKind.WithBlock || (parent.flags & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(ast, decl);
        context.semanticInfoChain.setASTForDecl(decl, ast);
        context.pushParent(decl);
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.CatchVariable;
        var span = TypeScript.TextSpan.fromBounds(ast.identifier.start(), ast.identifier.end());
        var parent = context.getParent();
        if (TypeScript.hasFlag(parent.flags, TypeScript.PullElementFlags.DeclaredInAWithBlock)) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.NormalPullDecl(ast.identifier.valueText(), ast.identifier.text(), declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(ast.identifier, decl);
        context.semanticInfoChain.setASTForDecl(decl, ast.identifier);
        if (parent) {
            parent.addVariableDeclToGroup(decl);
        }
    }
    function preCollectWithDecls(ast, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.WithBlock;
        var span = TypeScript.TextSpan.fromBounds(ast.start(), ast.end());
        var parent = context.getParent();
        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent, span);
        context.semanticInfoChain.setDeclForAST(ast, decl);
        context.semanticInfoChain.setASTForDecl(decl, ast);
        context.pushParent(decl);
    }
    function preCollectObjectLiteralDecls(ast, context) {
        var span = TypeScript.TextSpan.fromBounds(ast.start(), ast.end());
        var decl = new TypeScript.NormalPullDecl("", "", TypeScript.PullElementKind.ObjectLiteral, TypeScript.PullElementFlags.None, context.getParent(), span);
        context.semanticInfoChain.setDeclForAST(ast, decl);
        context.semanticInfoChain.setASTForDecl(decl, ast);
        context.pushParent(decl);
    }
    function preCollectSimplePropertyAssignmentDecls(propertyAssignment, context) {
        var assignmentText = TypeScript.getPropertyAssignmentNameTextFromIdentifier(propertyAssignment.propertyName);
        var span = TypeScript.TextSpan.fromBounds(propertyAssignment.start(), propertyAssignment.end());
        var decl = new TypeScript.NormalPullDecl(assignmentText.memberName, assignmentText.actualText, TypeScript.PullElementKind.Property, TypeScript.PullElementFlags.Public, context.getParent(), span);
        context.semanticInfoChain.setDeclForAST(propertyAssignment, decl);
        context.semanticInfoChain.setASTForDecl(decl, propertyAssignment);
    }
    function preCollectFunctionPropertyAssignmentDecls(propertyAssignment, context) {
        var assignmentText = TypeScript.getPropertyAssignmentNameTextFromIdentifier(propertyAssignment.propertyName);
        var span = TypeScript.TextSpan.fromBounds(propertyAssignment.start(), propertyAssignment.end());
        var decl = new TypeScript.NormalPullDecl(assignmentText.memberName, assignmentText.actualText, TypeScript.PullElementKind.Property, TypeScript.PullElementFlags.Public, context.getParent(), span);
        context.semanticInfoChain.setDeclForAST(propertyAssignment, decl);
        context.semanticInfoChain.setASTForDecl(decl, propertyAssignment);
        createAnyFunctionExpressionDeclaration(propertyAssignment, propertyAssignment.propertyName, context, propertyAssignment.propertyName);
    }
    function preCollectDecls(ast, context) {
        switch (ast.kind()) {
            case TypeScript.SyntaxKind.SourceUnit:
                preCollectScriptDecls(ast, context);
                break;
            case TypeScript.SyntaxKind.EnumDeclaration:
                preCollectEnumDecls(ast, context);
                break;
            case TypeScript.SyntaxKind.EnumElement:
                createEnumElementDecls(ast, context);
                break;
            case TypeScript.SyntaxKind.ModuleDeclaration:
                preCollectModuleDecls(ast, context);
                break;
            case TypeScript.SyntaxKind.ClassDeclaration:
                preCollectClassDecls(ast, context);
                break;
            case TypeScript.SyntaxKind.InterfaceDeclaration:
                preCollectInterfaceDecls(ast, context);
                break;
            case TypeScript.SyntaxKind.ObjectType:
                preCollectObjectTypeDecls(ast, context);
                break;
            case TypeScript.SyntaxKind.Parameter:
                preCollectParameterDecl(ast, context);
                break;
            case TypeScript.SyntaxKind.MemberVariableDeclaration:
                createMemberVariableDeclaration(ast, context);
                break;
            case TypeScript.SyntaxKind.PropertySignature:
                createPropertySignature(ast, context);
                break;
            case TypeScript.SyntaxKind.VariableDeclarator:
                preCollectVarDecls(ast, context);
                break;
            case TypeScript.SyntaxKind.ConstructorDeclaration:
                createClassConstructorDeclaration(ast, context);
                break;
            case TypeScript.SyntaxKind.GetAccessor:
                createGetAccessorDeclaration(ast, context);
                break;
            case TypeScript.SyntaxKind.SetAccessor:
                createSetAccessorDeclaration(ast, context);
                break;
            case TypeScript.SyntaxKind.FunctionExpression:
                createFunctionExpressionDeclaration(ast, context);
                break;
            case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                createMemberFunctionDeclaration(ast, context);
                break;
            case TypeScript.SyntaxKind.IndexSignature:
                createIndexSignatureDeclaration(ast, context);
                break;
            case TypeScript.SyntaxKind.FunctionType:
                createFunctionTypeDeclaration(ast, context);
                break;
            case TypeScript.SyntaxKind.ConstructorType:
                createConstructorTypeDeclaration(ast, context);
                break;
            case TypeScript.SyntaxKind.CallSignature:
                createCallSignatureDeclaration(ast, context);
                break;
            case TypeScript.SyntaxKind.ConstructSignature:
                createConstructSignatureDeclaration(ast, context);
                break;
            case TypeScript.SyntaxKind.MethodSignature:
                createMethodSignatureDeclaration(ast, context);
                break;
            case TypeScript.SyntaxKind.FunctionDeclaration:
                createFunctionDeclaration(ast, context);
                break;
            case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
            case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                createAnyFunctionExpressionDeclaration(ast, null, context);
                break;
            case TypeScript.SyntaxKind.ImportDeclaration:
                preCollectImportDecls(ast, context);
                break;
            case TypeScript.SyntaxKind.TypeParameter:
                preCollectTypeParameterDecl(ast, context);
                break;
            case TypeScript.SyntaxKind.CatchClause:
                preCollectCatchDecls(ast, context);
                break;
            case TypeScript.SyntaxKind.WithStatement:
                preCollectWithDecls(ast, context);
                break;
            case TypeScript.SyntaxKind.ObjectLiteralExpression:
                preCollectObjectLiteralDecls(ast, context);
                break;
            case TypeScript.SyntaxKind.SimplePropertyAssignment:
                preCollectSimplePropertyAssignmentDecls(ast, context);
                break;
            case TypeScript.SyntaxKind.FunctionPropertyAssignment:
                preCollectFunctionPropertyAssignmentDecls(ast, context);
                break;
        }
    }
    function isContainer(decl) {
        return decl.kind === TypeScript.PullElementKind.Container || decl.kind === TypeScript.PullElementKind.DynamicModule || decl.kind === TypeScript.PullElementKind.Enum;
    }
    function getInitializationFlag(decl) {
        if (decl.kind & TypeScript.PullElementKind.Container) {
            return TypeScript.PullElementFlags.InitializedModule;
        }
        else if (decl.kind & TypeScript.PullElementKind.DynamicModule) {
            return TypeScript.PullElementFlags.InitializedDynamicModule;
        }
        return TypeScript.PullElementFlags.None;
    }
    function hasInitializationFlag(decl) {
        var kind = decl.kind;
        if (kind & TypeScript.PullElementKind.Container) {
            return (decl.flags & TypeScript.PullElementFlags.InitializedModule) !== 0;
        }
        else if (kind & TypeScript.PullElementKind.DynamicModule) {
            return (decl.flags & TypeScript.PullElementFlags.InitializedDynamicModule) !== 0;
        }
        return false;
    }
    function postCollectDecls(ast, context) {
        var currentDecl = context.getParent();
        if (ast.kind() === TypeScript.SyntaxKind.IdentifierName || ast.kind() === TypeScript.SyntaxKind.StringLiteral) {
            if (currentDecl.kind === TypeScript.PullElementKind.Container || currentDecl.kind === TypeScript.PullElementKind.DynamicModule) {
                return;
            }
        }
        if (ast.kind() === TypeScript.SyntaxKind.ModuleDeclaration) {
            var moduleDeclaration = ast;
            if (moduleDeclaration.stringLiteral) {
                TypeScript.Debug.assert(currentDecl.ast() === moduleDeclaration.stringLiteral);
                context.popParent();
            }
            else {
                var moduleNames = getModuleNames(moduleDeclaration.name);
                for (var i = moduleNames.length - 1; i >= 0; i--) {
                    var moduleName = moduleNames[i];
                    TypeScript.Debug.assert(currentDecl.ast() === moduleName);
                    context.popParent();
                    currentDecl = context.getParent();
                }
            }
        }
        if (ast.kind() === TypeScript.SyntaxKind.EnumDeclaration) {
            computeEnumElementConstantValues(ast, currentDecl, context);
        }
        while (currentDecl.getParentDecl() && currentDecl.ast() === ast) {
            context.popParent();
            currentDecl = context.getParent();
        }
    }
    function computeEnumElementConstantValues(ast, enumDecl, context) {
        TypeScript.Debug.assert(enumDecl.kind === TypeScript.PullElementKind.Enum);
        var isAmbientEnum = TypeScript.hasFlag(enumDecl.flags, TypeScript.PullElementFlags.Ambient);
        var inConstantSection = !isAmbientEnum;
        var currentConstantValue = 0;
        var enumMemberDecls = enumDecl.getChildDecls();
        for (var i = 0, n = ast.enumElements.nonSeparatorCount(); i < n; i++) {
            var enumElement = ast.enumElements.nonSeparatorAt(i);
            var enumElementDecl = TypeScript.ArrayUtilities.first(enumMemberDecls, function (d) {
                return context.semanticInfoChain.getASTForDecl(d) === enumElement;
            });
            TypeScript.Debug.assert(enumElementDecl.kind === TypeScript.PullElementKind.EnumMember);
            if (enumElement.equalsValueClause === null) {
                if (inConstantSection) {
                    enumElementDecl.constantValue = currentConstantValue;
                    currentConstantValue++;
                }
            }
            else {
                enumElementDecl.constantValue = computeEnumElementConstantValue(enumElement.equalsValueClause.value, enumMemberDecls, context);
                if (enumElementDecl.constantValue !== null && !isAmbientEnum) {
                    inConstantSection = true;
                    currentConstantValue = enumElementDecl.constantValue + 1;
                }
                else {
                    inConstantSection = false;
                }
            }
            TypeScript.Debug.assert(enumElementDecl.constantValue !== undefined);
        }
    }
    function computeEnumElementConstantValue(expression, enumMemberDecls, context) {
        TypeScript.Debug.assert(expression);
        if (TypeScript.isIntegerLiteralAST(expression)) {
            var token;
            switch (expression.kind()) {
                case TypeScript.SyntaxKind.PlusExpression:
                case TypeScript.SyntaxKind.NegateExpression:
                    token = expression.operand;
                    break;
                default:
                    token = expression;
            }
            var value = token.value();
            return value && expression.kind() === TypeScript.SyntaxKind.NegateExpression ? -value : value;
        }
        else if (context.propagateEnumConstants) {
            switch (expression.kind()) {
                case TypeScript.SyntaxKind.IdentifierName:
                    var name = expression;
                    var matchingEnumElement = TypeScript.ArrayUtilities.firstOrDefault(enumMemberDecls, function (d) { return d.name === name.valueText(); });
                    return matchingEnumElement ? matchingEnumElement.constantValue : null;
                case TypeScript.SyntaxKind.LeftShiftExpression:
                    var binaryExpression = expression;
                    var left = computeEnumElementConstantValue(binaryExpression.left, enumMemberDecls, context);
                    var right = computeEnumElementConstantValue(binaryExpression.right, enumMemberDecls, context);
                    if (left === null || right === null) {
                        return null;
                    }
                    return left << right;
                case TypeScript.SyntaxKind.BitwiseOrExpression:
                    var binaryExpression = expression;
                    var left = computeEnumElementConstantValue(binaryExpression.left, enumMemberDecls, context);
                    var right = computeEnumElementConstantValue(binaryExpression.right, enumMemberDecls, context);
                    if (left === null || right === null) {
                        return null;
                    }
                    return left | right;
            }
            return null;
        }
        else {
            return null;
        }
    }
    var DeclarationCreator;
    (function (DeclarationCreator) {
        function create(document, semanticInfoChain, compilationSettings) {
            var declCollectionContext = new DeclCollectionContext(document, semanticInfoChain, compilationSettings.propagateEnumConstants());
            TypeScript.getAstWalkerFactory().simpleWalk(document.sourceUnit(), function (ast, state) {
                preCollectDecls(ast, state);
            }, function (ast, state) {
                postCollectDecls(ast, state);
            }, declCollectionContext);
            return declCollectionContext.getParent();
        }
        DeclarationCreator.create = create;
    })(DeclarationCreator = TypeScript.DeclarationCreator || (TypeScript.DeclarationCreator = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullSymbolBinder = (function () {
        function PullSymbolBinder(semanticInfoChain) {
            this.semanticInfoChain = semanticInfoChain;
            this.declsBeingBound = [];
        }
        PullSymbolBinder.prototype.getParent = function (decl, returnInstanceType) {
            if (returnInstanceType === void 0) { returnInstanceType = false; }
            var parentDecl = decl.getParentDecl();
            if (parentDecl.kind == TypeScript.PullElementKind.Script) {
                return null;
            }
            var parent = parentDecl.getSymbol();
            if (!parent && parentDecl && !parentDecl.hasBeenBound()) {
                this.bindDeclToPullSymbol(parentDecl);
            }
            parent = parentDecl.getSymbol();
            if (parent) {
                var parentDeclKind = parentDecl.kind;
                if (parentDeclKind == TypeScript.PullElementKind.GetAccessor) {
                    parent = parent.getGetter();
                }
                else if (parentDeclKind == TypeScript.PullElementKind.SetAccessor) {
                    parent = parent.getSetter();
                }
            }
            if (parent) {
                if (returnInstanceType && parent.isType() && parent.isContainer()) {
                    var instanceSymbol = parent.getInstanceSymbol();
                    if (instanceSymbol) {
                        return instanceSymbol.type;
                    }
                }
                return parent.type;
            }
            return null;
        };
        PullSymbolBinder.prototype.findDeclsInContext = function (startingDecl, declKind, searchGlobally) {
            if (!searchGlobally) {
                var parentDecl = startingDecl.getParentDecl();
                return parentDecl.searchChildDecls(startingDecl.name, declKind);
            }
            var contextSymbolPath = startingDecl.getParentPath();
            if (contextSymbolPath.length) {
                var copyOfContextSymbolPath = [];
                for (var i = 0; i < contextSymbolPath.length; i++) {
                    if (contextSymbolPath[i].kind & TypeScript.PullElementKind.Script) {
                        continue;
                    }
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i].name;
                }
                return this.semanticInfoChain.findDecls(copyOfContextSymbolPath, declKind);
            }
        };
        PullSymbolBinder.prototype.getExistingSymbol = function (decl, searchKind, parent) {
            var lookingForValue = (searchKind & TypeScript.PullElementKind.SomeValue) !== 0;
            var lookingForType = (searchKind & TypeScript.PullElementKind.SomeType) !== 0;
            var lookingForContainer = (searchKind & TypeScript.PullElementKind.SomeContainer) !== 0;
            var name = decl.name;
            if (parent) {
                var isExported = (decl.flags & TypeScript.PullElementFlags.Exported) !== 0;
                var prevSymbol = null;
                if (lookingForValue) {
                    prevSymbol = parent.findContainedNonMember(name);
                }
                else if (lookingForType) {
                    prevSymbol = parent.findContainedNonMemberType(name, searchKind);
                }
                else if (lookingForContainer) {
                    prevSymbol = parent.findContainedNonMemberContainer(name, searchKind);
                }
                var prevIsExported = !prevSymbol;
                if (!prevSymbol) {
                    if (lookingForValue) {
                        prevSymbol = parent.findMember(name, false);
                    }
                    else if (lookingForType) {
                        prevSymbol = parent.findNestedType(name, searchKind);
                    }
                    else if (lookingForContainer) {
                        prevSymbol = parent.findNestedContainer(name, searchKind);
                    }
                }
                if (isExported && prevIsExported) {
                    return prevSymbol;
                }
                if (prevSymbol) {
                    var prevDecls = prevSymbol.getDeclarations();
                    var lastPrevDecl = prevDecls[prevDecls.length - 1];
                    var parentDecl = decl.getParentDecl();
                    var prevParentDecl = lastPrevDecl && lastPrevDecl.getParentDecl();
                    if (parentDecl !== prevParentDecl) {
                        return null;
                    }
                    return prevSymbol;
                }
            }
            else {
                var parentDecl = decl.getParentDecl();
                if (parentDecl && parentDecl.kind === TypeScript.PullElementKind.Script) {
                    return this.semanticInfoChain.findTopLevelSymbol(name, searchKind, decl);
                }
                else {
                    var prevDecls = parentDecl && parentDecl.searchChildDecls(name, searchKind);
                    return prevDecls[0] && prevDecls[0].getSymbol();
                }
            }
            return null;
        };
        PullSymbolBinder.prototype.checkThatExportsMatch = function (decl, prevSymbol, reportError) {
            if (reportError === void 0) { reportError = true; }
            var isExported = (decl.flags & TypeScript.PullElementFlags.Exported) !== 0;
            var prevDecls = prevSymbol.getDeclarations();
            var prevIsExported = (prevDecls[prevDecls.length - 1].flags & TypeScript.PullElementFlags.Exported) !== 0;
            if ((isExported !== prevIsExported) && !prevSymbol.isSignature() && (decl.kind & TypeScript.PullElementKind.SomeSignature) == 0) {
                if (reportError) {
                    var ast = this.semanticInfoChain.getASTForDecl(decl);
                    this.semanticInfoChain.addDiagnosticFromAST(ast, TypeScript.DiagnosticCode.All_declarations_of_merged_declaration_0_must_be_exported_or_not_exported, [decl.getDisplayName()]);
                }
                return false;
            }
            return true;
        };
        PullSymbolBinder.prototype.bindEnumDeclarationToPullSymbol = function (enumContainerDecl) {
            var enumName = enumContainerDecl.name;
            var enumContainerSymbol = null;
            var enumInstanceSymbol = null;
            var moduleInstanceTypeSymbol = null;
            var enumInstanceDecl = enumContainerDecl.getValueDecl();
            var enumDeclKind = enumContainerDecl.kind;
            var parent = this.getParent(enumContainerDecl);
            var parentInstanceSymbol = this.getParent(enumContainerDecl, true);
            var parentDecl = enumContainerDecl.getParentDecl();
            var enumAST = this.semanticInfoChain.getASTForDecl(enumContainerDecl);
            var isExported = enumContainerDecl.flags & TypeScript.PullElementFlags.Exported;
            var isInitializedModule = (enumContainerDecl.flags & TypeScript.PullElementFlags.SomeInitializedModule) != 0;
            var createdNewSymbol = false;
            enumContainerSymbol = this.getExistingSymbol(enumContainerDecl, TypeScript.PullElementKind.Enum, parent);
            if (enumContainerSymbol) {
                if (enumContainerSymbol.kind !== enumDeclKind) {
                    if (isInitializedModule) {
                        this.semanticInfoChain.addDiagnosticFromAST(enumAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [enumContainerDecl.getDisplayName()]);
                    }
                    enumContainerSymbol = null;
                }
                else if (!this.checkThatExportsMatch(enumContainerDecl, enumContainerSymbol)) {
                    enumContainerSymbol = null;
                }
            }
            if (enumContainerSymbol) {
                enumInstanceSymbol = enumContainerSymbol.getInstanceSymbol();
            }
            else {
                enumContainerSymbol = new TypeScript.PullContainerSymbol(enumName, enumDeclKind);
                createdNewSymbol = true;
                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(enumContainerSymbol, TypeScript.PullElementKind.Enum);
                }
            }
            enumContainerSymbol.addDeclaration(enumContainerDecl);
            enumContainerDecl.setSymbol(enumContainerSymbol);
            this.semanticInfoChain.setSymbolForAST(enumAST.identifier, enumContainerSymbol);
            this.semanticInfoChain.setSymbolForAST(enumAST, enumContainerSymbol);
            if (!enumInstanceSymbol && isInitializedModule) {
                var variableSymbol = null;
                if (parentInstanceSymbol) {
                    if (isExported) {
                        variableSymbol = parentInstanceSymbol.findMember(enumName, false);
                        if (!variableSymbol) {
                            variableSymbol = parentInstanceSymbol.findContainedNonMember(enumName);
                        }
                    }
                    else {
                        variableSymbol = parentInstanceSymbol.findContainedNonMember(enumName);
                        if (!variableSymbol) {
                            variableSymbol = parentInstanceSymbol.findMember(enumName, false);
                        }
                    }
                    if (variableSymbol) {
                        var declarations = variableSymbol.getDeclarations();
                        if (declarations.length) {
                            var variableSymbolParentDecl = declarations[0].getParentDecl();
                            if (parentDecl !== variableSymbolParentDecl) {
                                variableSymbol = null;
                            }
                        }
                    }
                }
                else if (!(enumContainerDecl.flags & TypeScript.PullElementFlags.Exported)) {
                    var siblingDecls = parentDecl.getChildDecls();
                    var augmentedDecl = null;
                    for (var i = 0; i < siblingDecls.length; i++) {
                        if (siblingDecls[i] == enumContainerDecl) {
                            break;
                        }
                        if ((siblingDecls[i].name == enumName) && (siblingDecls[i].kind & TypeScript.PullElementKind.SomeValue)) {
                            augmentedDecl = siblingDecls[i];
                            break;
                        }
                    }
                    if (augmentedDecl) {
                        variableSymbol = augmentedDecl.getSymbol();
                        if (variableSymbol) {
                            if (variableSymbol.isContainer()) {
                                variableSymbol = variableSymbol.getInstanceSymbol();
                            }
                            else if (variableSymbol && variableSymbol.isType()) {
                                variableSymbol = variableSymbol.getConstructorMethod();
                            }
                        }
                    }
                }
                if (variableSymbol) {
                    enumInstanceSymbol = variableSymbol;
                    moduleInstanceTypeSymbol = variableSymbol.type;
                }
                else {
                    enumInstanceSymbol = new TypeScript.PullSymbol(enumName, TypeScript.PullElementKind.Variable);
                }
                enumContainerSymbol.setInstanceSymbol(enumInstanceSymbol);
                if (!moduleInstanceTypeSymbol) {
                    moduleInstanceTypeSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.ObjectType);
                    enumInstanceSymbol.type = moduleInstanceTypeSymbol;
                }
                moduleInstanceTypeSymbol.addDeclaration(enumContainerDecl);
                if (!moduleInstanceTypeSymbol.getAssociatedContainerType()) {
                    moduleInstanceTypeSymbol.setAssociatedContainerType(enumContainerSymbol);
                }
            }
            var moduleDeclarations = enumContainerSymbol.getDeclarations();
            if (moduleDeclarations.length > 1 && enumAST.enumElements.nonSeparatorCount() > 0) {
                var multipleEnums = TypeScript.ArrayUtilities.where(moduleDeclarations, function (d) { return d.kind === TypeScript.PullElementKind.Enum; }).length > 1;
                if (multipleEnums) {
                    var firstVariable = enumAST.enumElements.nonSeparatorAt(0);
                    if (!firstVariable.equalsValueClause) {
                        this.semanticInfoChain.addDiagnosticFromAST(firstVariable, TypeScript.DiagnosticCode.Enums_with_multiple_declarations_must_provide_an_initializer_for_the_first_enum_element, null);
                    }
                }
            }
            if (createdNewSymbol && parent) {
                if (enumContainerDecl.flags & TypeScript.PullElementFlags.Exported) {
                    parent.addEnclosedMemberType(enumContainerSymbol);
                }
                else {
                    parent.addEnclosedNonMemberType(enumContainerSymbol);
                }
            }
            this.bindEnumIndexerDeclsToPullSymbols(enumContainerDecl, enumContainerSymbol);
            var valueDecl = enumContainerDecl.getValueDecl();
            if (valueDecl) {
                valueDecl.ensureSymbolIsBound();
            }
            var otherDecls = this.findDeclsInContext(enumContainerDecl, enumContainerDecl.kind, true);
            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };
        PullSymbolBinder.prototype.bindEnumIndexerDeclsToPullSymbols = function (enumContainerDecl, enumContainerSymbol) {
            var indexSigDecl = enumContainerDecl.getChildDecls().filter(function (decl) { return decl.kind == TypeScript.PullElementKind.IndexSignature; })[0];
            var indexParamDecl = indexSigDecl.getChildDecls()[0];
            var syntheticIndexerParameterSymbol = new TypeScript.PullSymbol(indexParamDecl.name, TypeScript.PullElementKind.Parameter);
            syntheticIndexerParameterSymbol.type = this.semanticInfoChain.numberTypeSymbol;
            syntheticIndexerParameterSymbol.setResolved();
            var syntheticIndexerSignatureSymbol = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.IndexSignature);
            syntheticIndexerSignatureSymbol.addParameter(syntheticIndexerParameterSymbol);
            syntheticIndexerSignatureSymbol.returnType = this.semanticInfoChain.stringTypeSymbol;
            syntheticIndexerSignatureSymbol.setResolved();
            var enumContainerInstanceTypeSymbol = enumContainerSymbol.getInstanceSymbol().type;
            enumContainerInstanceTypeSymbol.addIndexSignature(syntheticIndexerSignatureSymbol);
            indexSigDecl.setSignatureSymbol(syntheticIndexerSignatureSymbol);
            indexParamDecl.setSymbol(syntheticIndexerParameterSymbol);
            syntheticIndexerSignatureSymbol.addDeclaration(indexSigDecl);
            syntheticIndexerParameterSymbol.addDeclaration(indexParamDecl);
        };
        PullSymbolBinder.prototype.bindModuleDeclarationToPullSymbol = function (moduleContainerDecl) {
            var modName = moduleContainerDecl.name;
            var moduleContainerTypeSymbol = null;
            var moduleInstanceSymbol = null;
            var moduleInstanceTypeSymbol = null;
            var moduleKind = moduleContainerDecl.kind;
            var parent = this.getParent(moduleContainerDecl);
            var parentInstanceSymbol = this.getParent(moduleContainerDecl, true);
            var parentDecl = moduleContainerDecl.getParentDecl();
            var moduleNameAST = this.semanticInfoChain.getASTForDecl(moduleContainerDecl);
            var moduleDeclAST = TypeScript.getEnclosingModuleDeclaration(moduleNameAST);
            if (!moduleDeclAST) {
                TypeScript.Debug.assert(moduleContainerDecl.kind === TypeScript.PullElementKind.DynamicModule);
                TypeScript.Debug.assert(moduleNameAST.kind() === TypeScript.SyntaxKind.SourceUnit);
                moduleDeclAST = moduleNameAST;
            }
            var isExported = TypeScript.hasFlag(moduleContainerDecl.flags, TypeScript.PullElementFlags.Exported);
            var searchKind = TypeScript.PullElementKind.SomeContainer;
            var isInitializedModule = (moduleContainerDecl.flags & TypeScript.PullElementFlags.SomeInitializedModule) != 0;
            if (parent && moduleKind == TypeScript.PullElementKind.DynamicModule) {
                this.semanticInfoChain.addDiagnosticFromAST(moduleNameAST, TypeScript.DiagnosticCode.Ambient_external_module_declaration_must_be_defined_in_global_context, null);
            }
            var createdNewSymbol = false;
            moduleContainerTypeSymbol = this.getExistingSymbol(moduleContainerDecl, searchKind, parent);
            if (moduleContainerTypeSymbol) {
                if (moduleContainerTypeSymbol.kind !== moduleKind) {
                    if (isInitializedModule) {
                        this.semanticInfoChain.addDiagnosticFromAST(moduleNameAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [moduleContainerDecl.getDisplayName()]);
                    }
                    moduleContainerTypeSymbol = null;
                }
                else if (moduleKind == TypeScript.PullElementKind.DynamicModule) {
                    this.semanticInfoChain.addDiagnosticFromAST(moduleNameAST, TypeScript.DiagnosticCode.Ambient_external_module_declaration_cannot_be_reopened);
                }
                else if (!this.checkThatExportsMatch(moduleContainerDecl, moduleContainerTypeSymbol)) {
                    moduleContainerTypeSymbol = null;
                }
            }
            if (moduleContainerTypeSymbol) {
                moduleInstanceSymbol = moduleContainerTypeSymbol.getInstanceSymbol();
            }
            else {
                moduleContainerTypeSymbol = new TypeScript.PullContainerSymbol(modName, moduleKind);
                createdNewSymbol = true;
                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(moduleContainerTypeSymbol, searchKind);
                }
            }
            moduleContainerTypeSymbol.addDeclaration(moduleContainerDecl);
            moduleContainerDecl.setSymbol(moduleContainerTypeSymbol);
            this.semanticInfoChain.setSymbolForAST(moduleNameAST, moduleContainerTypeSymbol);
            this.semanticInfoChain.setSymbolForAST(moduleDeclAST, moduleContainerTypeSymbol);
            if (!moduleInstanceSymbol && isInitializedModule) {
                var variableSymbol = null;
                if (parentInstanceSymbol) {
                    if (isExported) {
                        variableSymbol = parentInstanceSymbol.findMember(modName, false);
                        if (!variableSymbol) {
                            variableSymbol = parentInstanceSymbol.findContainedNonMember(modName);
                        }
                    }
                    else {
                        variableSymbol = parentInstanceSymbol.findContainedNonMember(modName);
                        if (!variableSymbol) {
                            variableSymbol = parentInstanceSymbol.findMember(modName, false);
                        }
                    }
                    if (variableSymbol) {
                        var declarations = variableSymbol.getDeclarations();
                        if (declarations.length) {
                            var variableSymbolParentDecl = declarations[0].getParentDecl();
                            if (parentDecl !== variableSymbolParentDecl) {
                                variableSymbol = null;
                            }
                        }
                    }
                }
                else if (!isExported) {
                    var siblingDecls = parentDecl.getChildDecls();
                    for (var i = 0; i < siblingDecls.length; i++) {
                        var sibling = siblingDecls[i];
                        if (sibling !== moduleContainerDecl &&
                            sibling.name === modName &&
                            TypeScript.hasFlag(sibling.kind, TypeScript.PullElementKind.SomeValue)) {
                            if (sibling.hasSymbol()) {
                                variableSymbol = sibling.getSymbol();
                                if (variableSymbol.isContainer()) {
                                    variableSymbol = variableSymbol.getInstanceSymbol();
                                }
                                else if (variableSymbol && variableSymbol.isType()) {
                                    variableSymbol = variableSymbol.getConstructorMethod();
                                }
                                break;
                            }
                        }
                    }
                }
                if (variableSymbol) {
                    moduleInstanceSymbol = variableSymbol;
                    moduleInstanceTypeSymbol = variableSymbol.type;
                }
                else {
                    moduleInstanceSymbol = new TypeScript.PullSymbol(modName, TypeScript.PullElementKind.Variable);
                }
                moduleContainerTypeSymbol.setInstanceSymbol(moduleInstanceSymbol);
                if (!moduleInstanceTypeSymbol) {
                    moduleInstanceTypeSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.ObjectType);
                    moduleInstanceSymbol.type = moduleInstanceTypeSymbol;
                }
                moduleInstanceTypeSymbol.addDeclaration(moduleContainerDecl);
                if (!moduleInstanceTypeSymbol.getAssociatedContainerType()) {
                    moduleInstanceTypeSymbol.setAssociatedContainerType(moduleContainerTypeSymbol);
                }
            }
            var moduleDeclarations = moduleContainerTypeSymbol.getDeclarations();
            if (createdNewSymbol) {
                if (parent) {
                    if (moduleContainerDecl.flags & TypeScript.PullElementFlags.Exported) {
                        parent.addEnclosedMemberContainer(moduleContainerTypeSymbol);
                    }
                    else {
                        parent.addEnclosedNonMemberContainer(moduleContainerTypeSymbol);
                    }
                }
            }
            var valueDecl = moduleContainerDecl.getValueDecl();
            if (valueDecl) {
                valueDecl.ensureSymbolIsBound();
                if (!valueDecl.hasSymbol()) {
                    valueDecl.setSymbol(moduleInstanceSymbol);
                    if (!moduleInstanceSymbol.hasDeclaration(valueDecl)) {
                        moduleInstanceSymbol.addDeclaration(valueDecl);
                    }
                }
            }
            var otherDecls = this.findDeclsInContext(moduleContainerDecl, moduleContainerDecl.kind, true);
            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };
        PullSymbolBinder.prototype.bindImportDeclaration = function (importDeclaration) {
            var declFlags = importDeclaration.flags;
            var declKind = importDeclaration.kind;
            var importDeclAST = this.semanticInfoChain.getASTForDecl(importDeclaration);
            var isExported = false;
            var importSymbol = null;
            var declName = importDeclaration.name;
            var parentHadSymbol = false;
            var parent = this.getParent(importDeclaration);
            importSymbol = this.getExistingSymbol(importDeclaration, TypeScript.PullElementKind.SomeContainer, parent);
            if (importSymbol) {
                parentHadSymbol = true;
            }
            if (importSymbol) {
                this.semanticInfoChain.addDiagnosticFromAST(importDeclAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [importDeclaration.getDisplayName()]);
                importSymbol = null;
            }
            if (!importSymbol) {
                importSymbol = new TypeScript.PullTypeAliasSymbol(declName);
                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(importSymbol, TypeScript.PullElementKind.SomeContainer);
                }
            }
            importSymbol.addDeclaration(importDeclaration);
            importDeclaration.setSymbol(importSymbol);
            this.semanticInfoChain.setSymbolForAST(importDeclAST, importSymbol);
            if (parent && !parentHadSymbol) {
                if (declFlags & TypeScript.PullElementFlags.Exported) {
                    parent.addEnclosedMemberContainer(importSymbol);
                }
                else {
                    parent.addEnclosedNonMemberContainer(importSymbol);
                }
            }
        };
        PullSymbolBinder.prototype.bindClassDeclarationToPullSymbol = function (classDecl) {
            var className = classDecl.name;
            var classSymbol = null;
            var constructorSymbol = null;
            var constructorTypeSymbol = null;
            var classAST = this.semanticInfoChain.getASTForDecl(classDecl);
            var parent = this.getParent(classDecl);
            var parentDecl = classDecl.getParentDecl();
            var isExported = classDecl.flags & TypeScript.PullElementFlags.Exported;
            var isGeneric = false;
            classSymbol = this.getExistingSymbol(classDecl, TypeScript.PullElementKind.SomeType, parent);
            if (classSymbol && classSymbol.kind === TypeScript.PullElementKind.Interface) {
                this.semanticInfoChain.addDiagnosticFromAST(classAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [classDecl.getDisplayName()]);
                classSymbol = null;
            }
            var decls;
            classSymbol = new TypeScript.PullTypeSymbol(className, TypeScript.PullElementKind.Class);
            if (!parent) {
                this.semanticInfoChain.cacheGlobalSymbol(classSymbol, TypeScript.PullElementKind.Class);
            }
            classSymbol.addDeclaration(classDecl);
            classDecl.setSymbol(classSymbol);
            this.semanticInfoChain.setSymbolForAST(classAST.identifier, classSymbol);
            this.semanticInfoChain.setSymbolForAST(classAST, classSymbol);
            if (parent) {
                if (classDecl.flags & TypeScript.PullElementFlags.Exported) {
                    parent.addEnclosedMemberType(classSymbol);
                }
                else {
                    parent.addEnclosedNonMemberType(classSymbol);
                }
            }
            constructorSymbol = classSymbol.getConstructorMethod();
            constructorTypeSymbol = constructorSymbol ? constructorSymbol.type : null;
            if (!constructorSymbol) {
                var siblingValueDecls = null;
                if (parentDecl) {
                    siblingValueDecls = parentDecl.searchChildDecls(className, TypeScript.PullElementKind.SomeValue);
                    if (siblingValueDecls && siblingValueDecls[0] && siblingValueDecls[0].hasSymbol()) {
                        constructorSymbol = siblingValueDecls[0].getSymbol();
                    }
                }
                if (constructorSymbol) {
                    constructorTypeSymbol = constructorSymbol.type;
                }
                else {
                    constructorSymbol = new TypeScript.PullSymbol(className, TypeScript.PullElementKind.ConstructorMethod);
                    constructorTypeSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.ConstructorType);
                    constructorSymbol.setIsSynthesized();
                    constructorSymbol.type = constructorTypeSymbol;
                }
                classSymbol.setConstructorMethod(constructorSymbol);
                classSymbol.setHasDefaultConstructor();
            }
            if (constructorSymbol.getIsSynthesized()) {
                constructorSymbol.addDeclaration(classDecl.getValueDecl());
                constructorTypeSymbol.addDeclaration(classDecl);
            }
            else {
                classSymbol.setHasDefaultConstructor(false);
            }
            constructorTypeSymbol.setAssociatedContainerType(classSymbol);
            var typeParameters = classDecl.getTypeParameters();
            var typeParameter;
            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = classSymbol.findTypeParameter(typeParameters[i].name);
                if (typeParameter != null) {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                }
                typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, false);
                classSymbol.addTypeParameter(typeParameter);
                constructorTypeSymbol.addConstructorTypeParameter(typeParameter);
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            var valueDecl = classDecl.getValueDecl();
            if (valueDecl) {
                valueDecl.ensureSymbolIsBound();
            }
            this.bindStaticPrototypePropertyOfClass(classSymbol, constructorTypeSymbol);
        };
        PullSymbolBinder.prototype.bindInterfaceDeclarationToPullSymbol = function (interfaceDecl) {
            var interfaceName = interfaceDecl.name;
            var interfaceSymbol = null;
            var interfaceAST = this.semanticInfoChain.getASTForDecl(interfaceDecl);
            var createdNewSymbol = false;
            var parent = this.getParent(interfaceDecl);
            var acceptableSharedKind = TypeScript.PullElementKind.Interface;
            interfaceSymbol = this.getExistingSymbol(interfaceDecl, TypeScript.PullElementKind.SomeType, parent);
            if (interfaceSymbol) {
                if (!(interfaceSymbol.kind & acceptableSharedKind)) {
                    this.semanticInfoChain.addDiagnosticFromAST(interfaceAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [interfaceDecl.getDisplayName()]);
                    interfaceSymbol = null;
                }
                else if (!this.checkThatExportsMatch(interfaceDecl, interfaceSymbol)) {
                    interfaceSymbol = null;
                }
            }
            if (!interfaceSymbol) {
                interfaceSymbol = new TypeScript.PullTypeSymbol(interfaceName, TypeScript.PullElementKind.Interface);
                createdNewSymbol = true;
                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(interfaceSymbol, acceptableSharedKind);
                }
            }
            interfaceSymbol.addDeclaration(interfaceDecl);
            interfaceDecl.setSymbol(interfaceSymbol);
            if (createdNewSymbol) {
                if (parent) {
                    if (interfaceDecl.flags & TypeScript.PullElementFlags.Exported) {
                        parent.addEnclosedMemberType(interfaceSymbol);
                    }
                    else {
                        parent.addEnclosedNonMemberType(interfaceSymbol);
                    }
                }
            }
            var typeParameters = interfaceDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = interfaceSymbol.findTypeParameter(typeParameters[i].name);
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, false);
                    interfaceSymbol.addTypeParameter(typeParameter);
                }
                else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        var typeParameterDeclParent = typeParameterDecls[j].getParentDecl();
                        if (typeParameterDeclParent && typeParameterDeclParent === interfaceDecl) {
                            var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                            this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                            break;
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            var otherDecls = this.findDeclsInContext(interfaceDecl, interfaceDecl.kind, true);
            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };
        PullSymbolBinder.prototype.bindObjectTypeDeclarationToPullSymbol = function (objectDecl) {
            var objectSymbolAST = this.semanticInfoChain.getASTForDecl(objectDecl);
            var objectSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.ObjectType);
            objectSymbol.addDeclaration(objectDecl);
            objectDecl.setSymbol(objectSymbol);
            this.semanticInfoChain.setSymbolForAST(objectSymbolAST, objectSymbol);
            var childDecls = objectDecl.getChildDecls();
            for (var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
        };
        PullSymbolBinder.prototype.bindConstructorTypeDeclarationToPullSymbol = function (constructorTypeDeclaration) {
            var declKind = constructorTypeDeclaration.kind;
            var declFlags = constructorTypeDeclaration.flags;
            var constructorTypeAST = this.semanticInfoChain.getASTForDecl(constructorTypeDeclaration);
            var constructorTypeSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.ConstructorType);
            constructorTypeDeclaration.setSymbol(constructorTypeSymbol);
            constructorTypeSymbol.addDeclaration(constructorTypeDeclaration);
            this.semanticInfoChain.setSymbolForAST(constructorTypeAST, constructorTypeSymbol);
            var signature = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.ConstructSignature);
            var funcDecl = this.semanticInfoChain.getASTForDecl(constructorTypeDeclaration);
            if (TypeScript.lastParameterIsRest(funcDecl.parameterList)) {
                signature.hasVarArgs = true;
            }
            signature.addDeclaration(constructorTypeDeclaration);
            constructorTypeDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(funcDecl, TypeScript.Parameters.fromParameterList(funcDecl.parameterList), constructorTypeSymbol, signature);
            constructorTypeSymbol.addConstructSignature(signature);
            var typeParameters = constructorTypeDeclaration.getTypeParameters();
            var typeParameter;
            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructorTypeSymbol.findTypeParameter(typeParameters[i].name);
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, false);
                    constructorTypeSymbol.addConstructorTypeParameter(typeParameter);
                }
                else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]);
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };
        PullSymbolBinder.prototype.bindVariableDeclarationToPullSymbol = function (variableDeclaration) {
            var declFlags = variableDeclaration.flags;
            var declKind = variableDeclaration.kind;
            var varDeclAST = this.semanticInfoChain.getASTForDecl(variableDeclaration);
            var isExported = (declFlags & TypeScript.PullElementFlags.Exported) !== 0;
            var variableSymbol = null;
            var declName = variableDeclaration.name;
            var parentHadSymbol = false;
            var parent = this.getParent(variableDeclaration, true);
            var parentDecl = variableDeclaration.getParentDecl();
            var isImplicit = (declFlags & TypeScript.PullElementFlags.ImplicitVariable) !== 0;
            var isModuleValue = (declFlags & (TypeScript.PullElementFlags.InitializedModule)) != 0;
            var isEnumValue = (declFlags & TypeScript.PullElementFlags.Enum) != 0;
            var isClassConstructorVariable = (declFlags & TypeScript.PullElementFlags.ClassConstructorVariable) != 0;
            variableSymbol = this.getExistingSymbol(variableDeclaration, TypeScript.PullElementKind.SomeValue, parent);
            if (variableSymbol && !variableSymbol.isType()) {
                parentHadSymbol = true;
            }
            var decl;
            var decls;
            var ast;
            var members;
            if (variableSymbol) {
                var prevKind = variableSymbol.kind;
                var prevIsEnum = variableSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.Enum);
                var prevIsClassConstructorVariable = variableSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.ClassConstructorVariable);
                var prevIsModuleValue = variableSymbol.allDeclsHaveFlag(TypeScript.PullElementFlags.InitializedModule);
                var prevIsImplicit = variableSymbol.anyDeclHasFlag(TypeScript.PullElementFlags.ImplicitVariable);
                var prevIsFunction = prevKind == TypeScript.PullElementKind.Function;
                var prevIsAmbient = variableSymbol.allDeclsHaveFlag(TypeScript.PullElementFlags.Ambient);
                var isAmbientOrPrevIsAmbient = prevIsAmbient || (variableDeclaration.flags & TypeScript.PullElementFlags.Ambient) != 0;
                var prevDecl = variableSymbol.getDeclarations()[0];
                var prevParentDecl = prevDecl.getParentDecl();
                var bothAreGlobal = parentDecl && (parentDecl.kind == TypeScript.PullElementKind.Script) && (prevParentDecl.kind == TypeScript.PullElementKind.Script);
                var shareParent = bothAreGlobal || prevDecl.getParentDecl() == variableDeclaration.getParentDecl();
                var prevIsParam = shareParent && prevKind == TypeScript.PullElementKind.Parameter && declKind == TypeScript.PullElementKind.Variable;
                var acceptableRedeclaration = prevIsParam ||
                    (isImplicit &&
                        ((!isEnumValue && !isClassConstructorVariable && prevIsFunction) ||
                            ((isModuleValue || isEnumValue) && (prevIsModuleValue || prevIsEnum)) ||
                            (isClassConstructorVariable && prevIsModuleValue && isAmbientOrPrevIsAmbient) ||
                            (isModuleValue && prevIsClassConstructorVariable)));
                if (acceptableRedeclaration && (prevIsClassConstructorVariable || prevIsFunction) && !isAmbientOrPrevIsAmbient) {
                    if (prevDecl.fileName() != variableDeclaration.fileName()) {
                        this.semanticInfoChain.addDiagnostic(TypeScript.diagnosticFromDecl(variableDeclaration, TypeScript.DiagnosticCode.Module_0_cannot_merge_with_previous_declaration_of_1_in_a_different_file_2, [declName, declName, prevDecl.fileName()]));
                        variableSymbol.type = this.semanticInfoChain.getResolver().getNewErrorTypeSymbol(declName);
                    }
                }
                if (!acceptableRedeclaration || prevIsParam) {
                    if (!prevIsParam && (isImplicit || prevIsImplicit || (prevKind & TypeScript.PullElementKind.SomeFunction) !== 0) || !shareParent) {
                        var diagnostic = TypeScript.diagnosticFromDecl(variableDeclaration, TypeScript.DiagnosticCode.Duplicate_identifier_0, [variableDeclaration.getDisplayName()]);
                        this.semanticInfoChain.addDiagnostic(diagnostic);
                        variableSymbol.type = this.semanticInfoChain.getResolver().getNewErrorTypeSymbol(declName);
                    }
                    else {
                        this.checkThatExportsMatch(variableDeclaration, variableSymbol);
                        variableSymbol = null;
                        parentHadSymbol = false;
                    }
                }
                if (variableSymbol &&
                    !(variableSymbol.type && variableSymbol.type.isError()) &&
                    !this.checkThatExportsMatch(variableDeclaration, variableSymbol, !(isModuleValue && prevIsModuleValue))) {
                    variableSymbol.type = this.semanticInfoChain.getResolver().getNewErrorTypeSymbol(declName);
                }
            }
            if ((declFlags & TypeScript.PullElementFlags.ImplicitVariable) === 0) {
                if (!variableSymbol) {
                    variableSymbol = new TypeScript.PullSymbol(declName, declKind);
                    if (!parent && parentDecl.kind === TypeScript.PullElementKind.Script) {
                        this.semanticInfoChain.cacheGlobalSymbol(variableSymbol, declKind);
                    }
                }
                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);
                this.semanticInfoChain.setSymbolForAST(varDeclAST.propertyName, variableSymbol);
                this.semanticInfoChain.setSymbolForAST(varDeclAST, variableSymbol);
            }
            else if (!parentHadSymbol) {
                if (isClassConstructorVariable) {
                    var classTypeSymbol = variableSymbol;
                    if (parent) {
                        members = parent.getMembers();
                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].name === declName) && (members[i].kind === TypeScript.PullElementKind.Class)) {
                                classTypeSymbol = members[i];
                                break;
                            }
                        }
                    }
                    if (!classTypeSymbol) {
                        var parentDecl = variableDeclaration.getParentDecl();
                        if (parentDecl) {
                            var childDecls = parentDecl.searchChildDecls(declName, TypeScript.PullElementKind.SomeType);
                            if (childDecls.length) {
                                for (var i = 0; i < childDecls.length; i++) {
                                    if (childDecls[i].getValueDecl() === variableDeclaration) {
                                        classTypeSymbol = childDecls[i].getSymbol();
                                    }
                                }
                            }
                        }
                        if (!classTypeSymbol) {
                            classTypeSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, TypeScript.PullElementKind.SomeType, variableDeclaration);
                        }
                    }
                    if (classTypeSymbol && (classTypeSymbol.kind !== TypeScript.PullElementKind.Class)) {
                        classTypeSymbol = null;
                    }
                    if (classTypeSymbol && classTypeSymbol.isClass()) {
                        variableSymbol = classTypeSymbol.getConstructorMethod();
                        variableDeclaration.setSymbol(variableSymbol);
                        decls = classTypeSymbol.getDeclarations();
                        if (decls.length) {
                            decl = decls[decls.length - 1];
                            ast = this.semanticInfoChain.getASTForDecl(decl);
                        }
                    }
                    else {
                        if (!variableSymbol) {
                            variableSymbol = new TypeScript.PullSymbol(declName, declKind);
                        }
                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);
                        variableSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
                else if (declFlags & TypeScript.PullElementFlags.SomeInitializedModule) {
                    var moduleContainerTypeSymbol = null;
                    var moduleParent = this.getParent(variableDeclaration);
                    if (moduleParent) {
                        members = moduleParent.getMembers();
                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].name === declName) && (members[i].isContainer())) {
                                moduleContainerTypeSymbol = members[i];
                                break;
                            }
                        }
                    }
                    if (!moduleContainerTypeSymbol) {
                        var parentDecl = variableDeclaration.getParentDecl();
                        if (parentDecl) {
                            var searchKind = (declFlags & (TypeScript.PullElementFlags.InitializedModule | TypeScript.PullElementFlags.InitializedDynamicModule)) ? TypeScript.PullElementKind.SomeContainer : TypeScript.PullElementKind.Enum;
                            var childDecls = parentDecl.searchChildDecls(declName, searchKind);
                            if (childDecls.length) {
                                for (var i = 0; i < childDecls.length; i++) {
                                    if (childDecls[i].getValueDecl() === variableDeclaration) {
                                        moduleContainerTypeSymbol = childDecls[i].getSymbol();
                                    }
                                }
                            }
                        }
                        if (!moduleContainerTypeSymbol) {
                            moduleContainerTypeSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, TypeScript.PullElementKind.SomeContainer, variableDeclaration);
                            if (!moduleContainerTypeSymbol) {
                                moduleContainerTypeSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, TypeScript.PullElementKind.Enum, variableDeclaration);
                            }
                        }
                    }
                    if (moduleContainerTypeSymbol && (!moduleContainerTypeSymbol.isContainer())) {
                        moduleContainerTypeSymbol = null;
                    }
                    if (moduleContainerTypeSymbol) {
                        variableSymbol = moduleContainerTypeSymbol.getInstanceSymbol();
                        if (!variableSymbol.hasDeclaration(variableDeclaration)) {
                            variableSymbol.addDeclaration(variableDeclaration);
                        }
                        variableDeclaration.setSymbol(variableSymbol);
                    }
                    else {
                        TypeScript.Debug.assert(false, "Attempted to bind invalid implicit variable symbol");
                    }
                }
            }
            else {
                if (!variableSymbol.hasDeclaration(variableDeclaration)) {
                    variableSymbol.addDeclaration(variableDeclaration);
                }
                variableDeclaration.setSymbol(variableSymbol);
            }
            if (parent && !parentHadSymbol) {
                if (declFlags & TypeScript.PullElementFlags.Exported) {
                    parent.addMember(variableSymbol);
                }
                else {
                    parent.addEnclosedNonMember(variableSymbol);
                }
            }
            var otherDecls = this.findDeclsInContext(variableDeclaration, variableDeclaration.kind, false);
            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };
        PullSymbolBinder.prototype.bindCatchVariableToPullSymbol = function (variableDeclaration) {
            var declFlags = variableDeclaration.flags;
            var declKind = variableDeclaration.kind;
            var identifier = this.semanticInfoChain.getASTForDecl(variableDeclaration);
            var declName = variableDeclaration.name;
            var variableSymbol = new TypeScript.PullSymbol(declName, declKind);
            variableSymbol.addDeclaration(variableDeclaration);
            variableDeclaration.setSymbol(variableSymbol);
            variableSymbol.type = this.semanticInfoChain.anyTypeSymbol;
            this.semanticInfoChain.setSymbolForAST(identifier, variableSymbol);
        };
        PullSymbolBinder.prototype.bindEnumMemberDeclarationToPullSymbol = function (propertyDeclaration) {
            var declFlags = propertyDeclaration.flags;
            var declKind = propertyDeclaration.kind;
            var propDeclAST = this.semanticInfoChain.getASTForDecl(propertyDeclaration);
            var declName = propertyDeclaration.name;
            var parentHadSymbol = false;
            var parent = this.getParent(propertyDeclaration, true);
            var propertySymbol = parent.findMember(declName, false);
            if (propertySymbol) {
                this.semanticInfoChain.addDiagnostic(TypeScript.diagnosticFromDecl(propertyDeclaration, TypeScript.DiagnosticCode.Duplicate_identifier_0, [propertyDeclaration.getDisplayName()]));
            }
            if (propertySymbol) {
                parentHadSymbol = true;
            }
            if (!parentHadSymbol) {
                propertySymbol = new TypeScript.PullSymbol(declName, declKind);
            }
            propertySymbol.addDeclaration(propertyDeclaration);
            propertyDeclaration.setSymbol(propertySymbol);
            this.semanticInfoChain.setSymbolForAST(propDeclAST.propertyName, propertySymbol);
            this.semanticInfoChain.setSymbolForAST(propDeclAST, propertySymbol);
            if (parent && !parentHadSymbol) {
                parent.addMember(propertySymbol);
            }
        };
        PullSymbolBinder.prototype.bindPropertyDeclarationToPullSymbol = function (propertyDeclaration) {
            var declFlags = propertyDeclaration.flags;
            var declKind = propertyDeclaration.kind;
            var ast = this.semanticInfoChain.getASTForDecl(propertyDeclaration);
            var astName = ast.kind() === TypeScript.SyntaxKind.MemberVariableDeclaration
                ? ast.variableDeclarator.propertyName
                : ast.kind() === TypeScript.SyntaxKind.PropertySignature
                    ? ast.propertyName
                    : ast.kind() === TypeScript.SyntaxKind.Parameter
                        ? ast.identifier
                        : ast.propertyName;
            var isStatic = false;
            var isOptional = false;
            var propertySymbol = null;
            if (TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.Static)) {
                isStatic = true;
            }
            if (TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.Optional)) {
                isOptional = true;
            }
            var declName = propertyDeclaration.name;
            var parentHadSymbol = false;
            var parent = this.getParent(propertyDeclaration, true);
            if (parent.isClass() && isStatic) {
                parent = parent.getConstructorMethod().type;
            }
            propertySymbol = parent.findMember(declName, false);
            if (propertySymbol) {
                this.semanticInfoChain.addDiagnostic(TypeScript.diagnosticFromDecl(propertyDeclaration, TypeScript.DiagnosticCode.Duplicate_identifier_0, [propertyDeclaration.getDisplayName()]));
            }
            if (propertySymbol) {
                parentHadSymbol = true;
            }
            var classTypeSymbol;
            if (!parentHadSymbol) {
                propertySymbol = new TypeScript.PullSymbol(declName, declKind);
            }
            propertySymbol.addDeclaration(propertyDeclaration);
            propertyDeclaration.setSymbol(propertySymbol);
            this.semanticInfoChain.setSymbolForAST(astName, propertySymbol);
            this.semanticInfoChain.setSymbolForAST(ast, propertySymbol);
            if (isOptional) {
                propertySymbol.isOptional = true;
            }
            if (parent && !parentHadSymbol) {
                parent.addMember(propertySymbol);
            }
        };
        PullSymbolBinder.prototype.bindParameterSymbols = function (functionDeclaration, parameterList, funcType, signatureSymbol) {
            var parameters = [];
            var params = TypeScript.createIntrinsicsObject();
            var funcDecl = this.semanticInfoChain.getDeclForAST(functionDeclaration);
            if (parameterList) {
                for (var i = 0, n = parameterList.length; i < n; i++) {
                    var argDecl = parameterList.astAt(i);
                    var id = parameterList.identifierAt(i);
                    var decl = this.semanticInfoChain.getDeclForAST(argDecl);
                    var isProperty = TypeScript.hasFlag(decl.flags, TypeScript.PullElementFlags.PropertyParameter);
                    var parameterSymbol = new TypeScript.PullSymbol(id.valueText(), TypeScript.PullElementKind.Parameter);
                    if ((i === (n - 1)) && parameterList.lastParameterIsRest()) {
                        parameterSymbol.isVarArg = true;
                    }
                    if (decl.flags & TypeScript.PullElementFlags.Optional) {
                        parameterSymbol.isOptional = true;
                    }
                    if (params[id.valueText()]) {
                        this.semanticInfoChain.addDiagnosticFromAST(argDecl, TypeScript.DiagnosticCode.Duplicate_identifier_0, [id.text()]);
                    }
                    else {
                        params[id.valueText()] = true;
                    }
                    if (decl) {
                        if (isProperty) {
                            decl.ensureSymbolIsBound();
                            var valDecl = decl.getValueDecl();
                            if (valDecl) {
                                valDecl.setSymbol(parameterSymbol);
                                parameterSymbol.addDeclaration(valDecl);
                            }
                        }
                        else {
                            parameterSymbol.addDeclaration(decl);
                            decl.setSymbol(parameterSymbol);
                        }
                    }
                    signatureSymbol.addParameter(parameterSymbol, parameterSymbol.isOptional);
                    if (signatureSymbol.isDefinition()) {
                        funcType.addEnclosedNonMember(parameterSymbol);
                    }
                }
            }
        };
        PullSymbolBinder.prototype.bindFunctionDeclarationToPullSymbol = function (functionDeclaration) {
            var declKind = functionDeclaration.kind;
            var declFlags = functionDeclaration.flags;
            var funcDeclAST = this.semanticInfoChain.getASTForDecl(functionDeclaration);
            var isExported = (declFlags & TypeScript.PullElementFlags.Exported) !== 0;
            var funcName = functionDeclaration.name;
            var isSignature = (declFlags & TypeScript.PullElementFlags.Signature) !== 0;
            var parent = this.getParent(functionDeclaration, true);
            var parentDecl = functionDeclaration.getParentDecl();
            var parentHadSymbol = false;
            var functionSymbol = null;
            var functionTypeSymbol = null;
            functionSymbol = this.getExistingSymbol(functionDeclaration, TypeScript.PullElementKind.SomeValue, parent);
            if (functionSymbol) {
                var previousIsAmbient = functionSymbol.allDeclsHaveFlag(TypeScript.PullElementFlags.Ambient);
                var isAmbientOrPreviousIsAmbient = previousIsAmbient || (functionDeclaration.flags & TypeScript.PullElementFlags.Ambient ? true : false);
                var acceptableRedeclaration = functionSymbol.kind === TypeScript.PullElementKind.Function && (isSignature || functionSymbol.allDeclsHaveFlag(TypeScript.PullElementFlags.Signature)) ||
                    functionSymbol.allDeclsHaveFlag(TypeScript.PullElementFlags.InitializedModule) && isAmbientOrPreviousIsAmbient;
                if (!acceptableRedeclaration) {
                    this.semanticInfoChain.addDiagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [functionDeclaration.getDisplayName()]);
                    functionSymbol.type = this.semanticInfoChain.getResolver().getNewErrorTypeSymbol(funcName);
                }
            }
            if (functionSymbol) {
                functionTypeSymbol = functionSymbol.type;
                parentHadSymbol = true;
            }
            if (!functionSymbol) {
                functionSymbol = new TypeScript.PullSymbol(funcName, TypeScript.PullElementKind.Function);
            }
            if (!functionTypeSymbol) {
                functionTypeSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.FunctionType);
                functionSymbol.type = functionTypeSymbol;
                functionTypeSymbol.setFunctionSymbol(functionSymbol);
            }
            functionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionDeclaration);
            functionTypeSymbol.addDeclaration(functionDeclaration);
            this.semanticInfoChain.setSymbolForAST(funcDeclAST.identifier, functionSymbol);
            this.semanticInfoChain.setSymbolForAST(funcDeclAST, functionSymbol);
            if (parent && !parentHadSymbol) {
                if (isExported) {
                    parent.addMember(functionSymbol);
                }
                else {
                    parent.addEnclosedNonMember(functionSymbol);
                }
            }
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.CallSignature) : new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.CallSignature);
            signature.addDeclaration(functionDeclaration);
            functionDeclaration.setSignatureSymbol(signature);
            if (TypeScript.lastParameterIsRest(funcDeclAST.callSignature.parameterList)) {
                signature.hasVarArgs = true;
            }
            var funcDecl = this.semanticInfoChain.getASTForDecl(functionDeclaration);
            this.bindParameterSymbols(funcDecl, TypeScript.Parameters.fromParameterList(funcDecl.callSignature.parameterList), functionTypeSymbol, signature);
            var typeParameters = functionDeclaration.getTypeParameters();
            var typeParameter;
            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].name);
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);
                    signature.addTypeParameter(typeParameter);
                }
                else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]);
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            functionTypeSymbol.addCallSignature(signature);
            var otherDecls = this.findDeclsInContext(functionDeclaration, functionDeclaration.kind, false);
            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };
        PullSymbolBinder.prototype.bindFunctionExpressionToPullSymbol = function (functionExpressionDeclaration) {
            var declKind = functionExpressionDeclaration.kind;
            var declFlags = functionExpressionDeclaration.flags;
            var ast = this.semanticInfoChain.getASTForDecl(functionExpressionDeclaration);
            var parameters = ast.kind() === TypeScript.SyntaxKind.SimpleArrowFunctionExpression
                ? TypeScript.Parameters.fromIdentifier(ast.identifier)
                : TypeScript.Parameters.fromParameterList(TypeScript.getParameterList(ast));
            var funcExpAST = ast;
            var functionName = declKind == TypeScript.PullElementKind.FunctionExpression ?
                functionExpressionDeclaration.getFunctionExpressionName() :
                functionExpressionDeclaration.name;
            var functionSymbol = new TypeScript.PullSymbol(functionName, declKind);
            var functionTypeSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.FunctionType);
            functionTypeSymbol.setFunctionSymbol(functionSymbol);
            functionSymbol.type = functionTypeSymbol;
            functionExpressionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionExpressionDeclaration);
            functionTypeSymbol.addDeclaration(functionExpressionDeclaration);
            var name = funcExpAST.kind() === TypeScript.SyntaxKind.FunctionExpression
                ? funcExpAST.identifier
                : funcExpAST.kind() === TypeScript.SyntaxKind.FunctionPropertyAssignment
                    ? funcExpAST.propertyName
                    : null;
            if (name) {
                this.semanticInfoChain.setSymbolForAST(name, functionSymbol);
            }
            this.semanticInfoChain.setSymbolForAST(funcExpAST, functionSymbol);
            var signature = new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.CallSignature);
            if (parameters.lastParameterIsRest()) {
                signature.hasVarArgs = true;
            }
            var typeParameters = functionExpressionDeclaration.getTypeParameters();
            var typeParameter;
            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].name);
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);
                    signature.addTypeParameter(typeParameter);
                }
                else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            signature.addDeclaration(functionExpressionDeclaration);
            functionExpressionDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(funcExpAST, parameters, functionTypeSymbol, signature);
            functionTypeSymbol.addCallSignature(signature);
        };
        PullSymbolBinder.prototype.bindFunctionTypeDeclarationToPullSymbol = function (functionTypeDeclaration) {
            var declKind = functionTypeDeclaration.kind;
            var declFlags = functionTypeDeclaration.flags;
            var funcTypeAST = this.semanticInfoChain.getASTForDecl(functionTypeDeclaration);
            var functionTypeSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.FunctionType);
            functionTypeDeclaration.setSymbol(functionTypeSymbol);
            functionTypeSymbol.addDeclaration(functionTypeDeclaration);
            this.semanticInfoChain.setSymbolForAST(funcTypeAST, functionTypeSymbol);
            var isSignature = (declFlags & TypeScript.PullElementFlags.Signature) !== 0;
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.CallSignature) : new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.CallSignature);
            if (TypeScript.lastParameterIsRest(funcTypeAST.parameterList)) {
                signature.hasVarArgs = true;
            }
            var typeParameters = functionTypeDeclaration.getTypeParameters();
            var typeParameter;
            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].name);
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);
                    signature.addTypeParameter(typeParameter);
                }
                else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]);
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            signature.addDeclaration(functionTypeDeclaration);
            functionTypeDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(funcTypeAST, TypeScript.Parameters.fromParameterList(funcTypeAST.parameterList), functionTypeSymbol, signature);
            functionTypeSymbol.addCallSignature(signature);
        };
        PullSymbolBinder.prototype.bindMethodDeclarationToPullSymbol = function (methodDeclaration) {
            var declKind = methodDeclaration.kind;
            var declFlags = methodDeclaration.flags;
            var methodAST = this.semanticInfoChain.getASTForDecl(methodDeclaration);
            var isPrivate = (declFlags & TypeScript.PullElementFlags.Private) !== 0;
            var isStatic = (declFlags & TypeScript.PullElementFlags.Static) !== 0;
            var isOptional = (declFlags & TypeScript.PullElementFlags.Optional) !== 0;
            var methodName = methodDeclaration.name;
            var isSignature = (declFlags & TypeScript.PullElementFlags.Signature) !== 0;
            var parent = this.getParent(methodDeclaration, true);
            var parentHadSymbol = false;
            var methodSymbol = null;
            var methodTypeSymbol = null;
            if (parent.isClass() && isStatic) {
                parent = parent.getConstructorMethod().type;
            }
            methodSymbol = parent.findMember(methodName, false);
            if (methodSymbol &&
                (methodSymbol.kind !== TypeScript.PullElementKind.Method ||
                    (!isSignature && !methodSymbol.allDeclsHaveFlag(TypeScript.PullElementFlags.Signature)))) {
                this.semanticInfoChain.addDiagnosticFromAST(methodAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [methodDeclaration.getDisplayName()]);
                methodSymbol = null;
            }
            if (methodSymbol) {
                methodTypeSymbol = methodSymbol.type;
                parentHadSymbol = true;
            }
            if (!methodSymbol) {
                methodSymbol = new TypeScript.PullSymbol(methodName, TypeScript.PullElementKind.Method);
            }
            if (!methodTypeSymbol) {
                methodTypeSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.FunctionType);
                methodSymbol.type = methodTypeSymbol;
                methodTypeSymbol.setFunctionSymbol(methodSymbol);
            }
            methodDeclaration.setSymbol(methodSymbol);
            methodSymbol.addDeclaration(methodDeclaration);
            methodTypeSymbol.addDeclaration(methodDeclaration);
            var nameAST = methodAST.kind() === TypeScript.SyntaxKind.MemberFunctionDeclaration
                ? methodAST.propertyName
                : methodAST.propertyName;
            TypeScript.Debug.assert(nameAST);
            this.semanticInfoChain.setSymbolForAST(nameAST, methodSymbol);
            this.semanticInfoChain.setSymbolForAST(methodAST, methodSymbol);
            if (isOptional) {
                methodSymbol.isOptional = true;
            }
            if (!parentHadSymbol) {
                parent.addMember(methodSymbol);
            }
            var sigKind = TypeScript.PullElementKind.CallSignature;
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(sigKind) : new TypeScript.PullDefinitionSignatureSymbol(sigKind);
            var parameterList = TypeScript.getParameterList(methodAST);
            if (TypeScript.lastParameterIsRest(parameterList)) {
                signature.hasVarArgs = true;
            }
            var typeParameters = methodDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterName;
            var typeParameterAST;
            for (var i = 0; i < typeParameters.length; i++) {
                typeParameterName = typeParameters[i].name;
                typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameters[i]);
                typeParameter = signature.findTypeParameter(typeParameterName);
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameterName, true);
                    signature.addTypeParameter(typeParameter);
                }
                else {
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            signature.addDeclaration(methodDeclaration);
            methodDeclaration.setSignatureSymbol(signature);
            var funcDecl = this.semanticInfoChain.getASTForDecl(methodDeclaration);
            this.bindParameterSymbols(funcDecl, TypeScript.Parameters.fromParameterList(TypeScript.getParameterList(funcDecl)), methodTypeSymbol, signature);
            methodTypeSymbol.addCallSignature(signature);
            var otherDecls = this.findDeclsInContext(methodDeclaration, methodDeclaration.kind, false);
            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };
        PullSymbolBinder.prototype.bindStaticPrototypePropertyOfClass = function (classTypeSymbol, constructorTypeSymbol) {
            var prototypeStr = "prototype";
            var prototypeSymbol = constructorTypeSymbol.findMember(prototypeStr, false);
            if (prototypeSymbol && !prototypeSymbol.getIsSynthesized()) {
                this.semanticInfoChain.addDiagnostic(TypeScript.diagnosticFromDecl(prototypeSymbol.getDeclarations()[0], TypeScript.DiagnosticCode.Duplicate_identifier_0, [prototypeSymbol.getDisplayName()]));
            }
            if (!prototypeSymbol || !prototypeSymbol.getIsSynthesized()) {
                var prototypeDecl = new TypeScript.PullSynthesizedDecl(prototypeStr, prototypeStr, TypeScript.PullElementKind.Property, TypeScript.PullElementFlags.Public | TypeScript.PullElementFlags.Static, constructorTypeSymbol.getDeclarations()[0], classTypeSymbol.getDeclarations()[0].getSpan(), this.semanticInfoChain);
                prototypeSymbol = new TypeScript.PullSymbol(prototypeStr, TypeScript.PullElementKind.Property);
                prototypeSymbol.setIsSynthesized();
                prototypeSymbol.addDeclaration(prototypeDecl);
                prototypeSymbol.type = classTypeSymbol;
                constructorTypeSymbol.addMember(prototypeSymbol);
                if (prototypeSymbol.type && prototypeSymbol.type.isGeneric()) {
                    var resolver = this.semanticInfoChain.getResolver();
                    prototypeSymbol.type = resolver.instantiateTypeToAny(prototypeSymbol.type, new TypeScript.PullTypeResolutionContext(resolver));
                }
                prototypeSymbol.setResolved();
            }
        };
        PullSymbolBinder.prototype.bindConstructorDeclarationToPullSymbol = function (constructorDeclaration) {
            var declKind = constructorDeclaration.kind;
            var declFlags = constructorDeclaration.flags;
            var constructorAST = this.semanticInfoChain.getASTForDecl(constructorDeclaration);
            var constructorName = constructorDeclaration.name;
            var isSignature = (declFlags & TypeScript.PullElementFlags.Signature) !== 0;
            var parent = this.getParent(constructorDeclaration, true);
            var parentHadSymbol = false;
            var constructorSymbol = parent.getConstructorMethod();
            var constructorTypeSymbol = null;
            if (constructorSymbol &&
                (constructorSymbol.kind !== TypeScript.PullElementKind.ConstructorMethod ||
                    (!isSignature &&
                        constructorSymbol.type &&
                        constructorSymbol.type.hasOwnConstructSignatures()))) {
                var hasDefinitionSignature = false;
                var constructorSigs = constructorSymbol.type.getConstructSignatures();
                for (var i = 0; i < constructorSigs.length; i++) {
                    if (!constructorSigs[i].anyDeclHasFlag(TypeScript.PullElementFlags.Signature)) {
                        hasDefinitionSignature = true;
                        break;
                    }
                }
                if (hasDefinitionSignature) {
                    this.semanticInfoChain.addDiagnosticFromAST(constructorAST, TypeScript.DiagnosticCode.Multiple_constructor_implementations_are_not_allowed);
                    constructorSymbol = null;
                }
            }
            if (constructorSymbol) {
                constructorTypeSymbol = constructorSymbol.type;
            }
            else {
                constructorSymbol = new TypeScript.PullSymbol(constructorName, TypeScript.PullElementKind.ConstructorMethod);
                constructorTypeSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.ConstructorType);
            }
            parent.setConstructorMethod(constructorSymbol);
            constructorSymbol.type = constructorTypeSymbol;
            constructorDeclaration.setSymbol(constructorSymbol);
            constructorSymbol.addDeclaration(constructorDeclaration);
            constructorTypeSymbol.addDeclaration(constructorDeclaration);
            constructorSymbol.setIsSynthesized(false);
            this.semanticInfoChain.setSymbolForAST(constructorAST, constructorSymbol);
            var constructSignature = isSignature ? new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.ConstructSignature) : new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.ConstructSignature);
            constructSignature.returnType = parent;
            constructSignature.addDeclaration(constructorDeclaration);
            constructorDeclaration.setSignatureSymbol(constructSignature);
            this.bindParameterSymbols(constructorAST, TypeScript.Parameters.fromParameterList(constructorAST.parameterList), constructorTypeSymbol, constructSignature);
            var typeParameters = constructorTypeSymbol.getTypeParameters();
            for (var i = 0; i < typeParameters.length; i++) {
                constructSignature.addTypeParameter(typeParameters[i]);
            }
            if (TypeScript.lastParameterIsRest(constructorAST.parameterList)) {
                constructSignature.hasVarArgs = true;
            }
            constructorTypeSymbol.addConstructSignature(constructSignature);
            var otherDecls = this.findDeclsInContext(constructorDeclaration, constructorDeclaration.kind, false);
            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
            this.bindStaticPrototypePropertyOfClass(parent, constructorTypeSymbol);
        };
        PullSymbolBinder.prototype.bindConstructSignatureDeclarationToPullSymbol = function (constructSignatureDeclaration) {
            var parent = this.getParent(constructSignatureDeclaration, true);
            var constructorAST = this.semanticInfoChain.getASTForDecl(constructSignatureDeclaration);
            var constructSignature = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.ConstructSignature);
            if (TypeScript.lastParameterIsRest(constructorAST.callSignature.parameterList)) {
                constructSignature.hasVarArgs = true;
            }
            var typeParameters = constructSignatureDeclaration.getTypeParameters();
            var typeParameter;
            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructSignature.findTypeParameter(typeParameters[i].name);
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);
                    constructSignature.addTypeParameter(typeParameter);
                }
                else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            constructSignature.addDeclaration(constructSignatureDeclaration);
            constructSignatureDeclaration.setSignatureSymbol(constructSignature);
            var funcDecl = this.semanticInfoChain.getASTForDecl(constructSignatureDeclaration);
            this.bindParameterSymbols(funcDecl, TypeScript.Parameters.fromParameterList(TypeScript.getParameterList(funcDecl)), null, constructSignature);
            this.semanticInfoChain.setSymbolForAST(this.semanticInfoChain.getASTForDecl(constructSignatureDeclaration), constructSignature);
            parent.addConstructSignature(constructSignature);
        };
        PullSymbolBinder.prototype.bindCallSignatureDeclarationToPullSymbol = function (callSignatureDeclaration) {
            var parent = this.getParent(callSignatureDeclaration, true);
            var callSignatureAST = this.semanticInfoChain.getASTForDecl(callSignatureDeclaration);
            var callSignature = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.CallSignature);
            if (TypeScript.lastParameterIsRest(callSignatureAST.parameterList)) {
                callSignature.hasVarArgs = true;
            }
            var typeParameters = callSignatureDeclaration.getTypeParameters();
            var typeParameter;
            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = callSignature.findTypeParameter(typeParameters[i].name);
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);
                    callSignature.addTypeParameter(typeParameter);
                }
                else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            callSignature.addDeclaration(callSignatureDeclaration);
            callSignatureDeclaration.setSignatureSymbol(callSignature);
            var funcDecl = this.semanticInfoChain.getASTForDecl(callSignatureDeclaration);
            this.bindParameterSymbols(funcDecl, TypeScript.Parameters.fromParameterList(funcDecl.parameterList), null, callSignature);
            this.semanticInfoChain.setSymbolForAST(this.semanticInfoChain.getASTForDecl(callSignatureDeclaration), callSignature);
            parent.addCallSignature(callSignature);
        };
        PullSymbolBinder.prototype.bindIndexSignatureDeclarationToPullSymbol = function (indexSignatureDeclaration) {
            var indexSignature = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.IndexSignature);
            indexSignature.addDeclaration(indexSignatureDeclaration);
            indexSignatureDeclaration.setSignatureSymbol(indexSignature);
            var funcDecl = this.semanticInfoChain.getASTForDecl(indexSignatureDeclaration);
            this.bindParameterSymbols(funcDecl, TypeScript.Parameters.fromParameter(funcDecl.parameter), null, indexSignature);
            this.semanticInfoChain.setSymbolForAST(this.semanticInfoChain.getASTForDecl(indexSignatureDeclaration), indexSignature);
            var parent = this.getParent(indexSignatureDeclaration);
            parent.addIndexSignature(indexSignature);
            indexSignature.setContainer(parent);
        };
        PullSymbolBinder.prototype.bindGetAccessorDeclarationToPullSymbol = function (getAccessorDeclaration) {
            var declKind = getAccessorDeclaration.kind;
            var declFlags = getAccessorDeclaration.flags;
            var funcDeclAST = this.semanticInfoChain.getASTForDecl(getAccessorDeclaration);
            var isExported = (declFlags & TypeScript.PullElementFlags.Exported) !== 0;
            var funcName = getAccessorDeclaration.name;
            var isSignature = (declFlags & TypeScript.PullElementFlags.Signature) !== 0;
            var isStatic = false;
            if (TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.Static)) {
                isStatic = true;
            }
            var parent = this.getParent(getAccessorDeclaration, true);
            var parentHadSymbol = false;
            var accessorSymbol = null;
            var getterSymbol = null;
            var getterTypeSymbol = null;
            if (isStatic) {
                parent = parent.getConstructorMethod().type;
            }
            accessorSymbol = parent.findMember(funcName, false);
            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    this.semanticInfoChain.addDiagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [getAccessorDeclaration.getDisplayName()]);
                    accessorSymbol = null;
                }
                else {
                    getterSymbol = accessorSymbol.getGetter();
                    if (getterSymbol) {
                        this.semanticInfoChain.addDiagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Getter_0_already_declared, [getAccessorDeclaration.getDisplayName()]);
                        accessorSymbol = null;
                        getterSymbol = null;
                    }
                }
            }
            if (accessorSymbol) {
                parentHadSymbol = true;
            }
            if (accessorSymbol && getterSymbol) {
                getterTypeSymbol = getterSymbol.type;
            }
            if (!accessorSymbol) {
                accessorSymbol = new TypeScript.PullAccessorSymbol(funcName);
            }
            if (!getterSymbol) {
                getterSymbol = new TypeScript.PullSymbol(funcName, TypeScript.PullElementKind.Function);
                getterTypeSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.FunctionType);
                getterTypeSymbol.setFunctionSymbol(getterSymbol);
                getterSymbol.type = getterTypeSymbol;
                accessorSymbol.setGetter(getterSymbol);
            }
            getAccessorDeclaration.setSymbol(accessorSymbol);
            accessorSymbol.addDeclaration(getAccessorDeclaration);
            getterSymbol.addDeclaration(getAccessorDeclaration);
            var nameAST = funcDeclAST.propertyName;
            this.semanticInfoChain.setSymbolForAST(nameAST, accessorSymbol);
            this.semanticInfoChain.setSymbolForAST(funcDeclAST, getterSymbol);
            if (!parentHadSymbol) {
                parent.addMember(accessorSymbol);
            }
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.CallSignature) : new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.CallSignature);
            signature.addDeclaration(getAccessorDeclaration);
            getAccessorDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(funcDeclAST, TypeScript.Parameters.fromParameterList(funcDeclAST.parameterList), getterTypeSymbol, signature);
            getterTypeSymbol.addCallSignature(signature);
        };
        PullSymbolBinder.prototype.bindSetAccessorDeclarationToPullSymbol = function (setAccessorDeclaration) {
            var declKind = setAccessorDeclaration.kind;
            var declFlags = setAccessorDeclaration.flags;
            var funcDeclAST = this.semanticInfoChain.getASTForDecl(setAccessorDeclaration);
            var isExported = (declFlags & TypeScript.PullElementFlags.Exported) !== 0;
            var funcName = setAccessorDeclaration.name;
            var isSignature = (declFlags & TypeScript.PullElementFlags.Signature) !== 0;
            var isStatic = false;
            if (TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.Static)) {
                isStatic = true;
            }
            var parent = this.getParent(setAccessorDeclaration, true);
            var parentHadSymbol = false;
            var accessorSymbol = null;
            var setterSymbol = null;
            var setterTypeSymbol = null;
            if (isStatic) {
                parent = parent.getConstructorMethod().type;
            }
            accessorSymbol = parent.findMember(funcName, false);
            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    this.semanticInfoChain.addDiagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [setAccessorDeclaration.getDisplayName()]);
                    accessorSymbol = null;
                }
                else {
                    setterSymbol = accessorSymbol.getSetter();
                    if (setterSymbol) {
                        this.semanticInfoChain.addDiagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Setter_0_already_declared, [setAccessorDeclaration.getDisplayName()]);
                        accessorSymbol = null;
                        setterSymbol = null;
                    }
                }
            }
            if (accessorSymbol) {
                parentHadSymbol = true;
                if (setterSymbol) {
                    setterTypeSymbol = setterSymbol.type;
                }
            }
            if (!accessorSymbol) {
                accessorSymbol = new TypeScript.PullAccessorSymbol(funcName);
            }
            if (!setterSymbol) {
                setterSymbol = new TypeScript.PullSymbol(funcName, TypeScript.PullElementKind.Function);
                setterTypeSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.FunctionType);
                setterTypeSymbol.setFunctionSymbol(setterSymbol);
                setterSymbol.type = setterTypeSymbol;
                accessorSymbol.setSetter(setterSymbol);
            }
            setAccessorDeclaration.setSymbol(accessorSymbol);
            accessorSymbol.addDeclaration(setAccessorDeclaration);
            setterSymbol.addDeclaration(setAccessorDeclaration);
            var nameAST = funcDeclAST.propertyName;
            this.semanticInfoChain.setSymbolForAST(nameAST, accessorSymbol);
            this.semanticInfoChain.setSymbolForAST(funcDeclAST, setterSymbol);
            if (!parentHadSymbol) {
                parent.addMember(accessorSymbol);
            }
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.CallSignature) : new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.CallSignature);
            signature.addDeclaration(setAccessorDeclaration);
            setAccessorDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(funcDeclAST, TypeScript.Parameters.fromParameterList(funcDeclAST.parameterList), setterTypeSymbol, signature);
            setterTypeSymbol.addCallSignature(signature);
        };
        PullSymbolBinder.prototype.bindDeclToPullSymbol = function (decl) {
            if (decl.hasBeenBound()) {
                return;
            }
            if (this.declsBeingBound.indexOf(decl.declID) >= 0) {
                return;
            }
            this.declsBeingBound.push(decl.declID);
            switch (decl.kind) {
                case TypeScript.PullElementKind.Script:
                    var childDecls = decl.getChildDecls();
                    for (var i = 0; i < childDecls.length; i++) {
                        this.bindDeclToPullSymbol(childDecls[i]);
                    }
                    break;
                case TypeScript.PullElementKind.Enum:
                    this.bindEnumDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.DynamicModule:
                case TypeScript.PullElementKind.Container:
                    this.bindModuleDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.Interface:
                    this.bindInterfaceDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.Class:
                    this.bindClassDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.Function:
                    this.bindFunctionDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.Variable:
                    this.bindVariableDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.CatchVariable:
                    this.bindCatchVariableToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.EnumMember:
                    this.bindEnumMemberDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.Property:
                    this.bindPropertyDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.Method:
                    this.bindMethodDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.ConstructorMethod:
                    this.bindConstructorDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.CallSignature:
                    this.bindCallSignatureDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.ConstructSignature:
                    this.bindConstructSignatureDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.IndexSignature:
                    this.bindIndexSignatureDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.GetAccessor:
                    this.bindGetAccessorDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.SetAccessor:
                    this.bindSetAccessorDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.ObjectType:
                    this.bindObjectTypeDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.FunctionType:
                    this.bindFunctionTypeDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.ConstructorType:
                    this.bindConstructorTypeDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.FunctionExpression:
                    this.bindFunctionExpressionToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.TypeAlias:
                    this.bindImportDeclaration(decl);
                    break;
                case TypeScript.PullElementKind.Parameter:
                case TypeScript.PullElementKind.TypeParameter:
                    decl.getParentDecl().getSymbol();
                    break;
                case TypeScript.PullElementKind.CatchBlock:
                case TypeScript.PullElementKind.WithBlock:
                    break;
                default:
                    TypeScript.CompilerDiagnostics.assert(false, "Unrecognized type declaration");
            }
            TypeScript.Debug.assert(TypeScript.ArrayUtilities.last(this.declsBeingBound) === decl.declID);
            this.declsBeingBound.pop();
        };
        return PullSymbolBinder;
    }());
    TypeScript.PullSymbolBinder = PullSymbolBinder;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullHelpers;
    (function (PullHelpers) {
        function getSignatureForFuncDecl(functionDecl) {
            var funcDecl = functionDecl.ast();
            var funcSymbol = functionDecl.getSymbol();
            if (!funcSymbol) {
                funcSymbol = functionDecl.getSignatureSymbol();
            }
            var functionSignature = null;
            var typeSymbolWithAllSignatures = null;
            if (funcSymbol.isSignature()) {
                functionSignature = funcSymbol;
                var parent = functionDecl.getParentDecl();
                typeSymbolWithAllSignatures = parent.getSymbol().type;
            }
            else {
                functionSignature = functionDecl.getSignatureSymbol();
                typeSymbolWithAllSignatures = funcSymbol.type;
            }
            var signatures;
            if (funcDecl.kind() === TypeScript.SyntaxKind.ConstructorDeclaration || functionDecl.kind === TypeScript.PullElementKind.ConstructSignature) {
                signatures = typeSymbolWithAllSignatures.getConstructSignatures();
            }
            else if (functionDecl.kind === TypeScript.PullElementKind.IndexSignature) {
                signatures = typeSymbolWithAllSignatures.getIndexSignatures();
            }
            else {
                signatures = typeSymbolWithAllSignatures.getCallSignatures();
            }
            return {
                signature: functionSignature,
                allSignatures: signatures
            };
        }
        PullHelpers.getSignatureForFuncDecl = getSignatureForFuncDecl;
        function getAccessorSymbol(getterOrSetter, semanticInfoChain) {
            var functionDecl = semanticInfoChain.getDeclForAST(getterOrSetter);
            var getterOrSetterSymbol = functionDecl.getSymbol();
            return getterOrSetterSymbol;
        }
        PullHelpers.getAccessorSymbol = getAccessorSymbol;
        function getGetterAndSetterFunction(funcDecl, semanticInfoChain) {
            var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, semanticInfoChain);
            var result = {
                getter: null,
                setter: null
            };
            var getter = accessorSymbol.getGetter();
            if (getter) {
                var getterDecl = getter.getDeclarations()[0];
                result.getter = semanticInfoChain.getASTForDecl(getterDecl);
            }
            var setter = accessorSymbol.getSetter();
            if (setter) {
                var setterDecl = setter.getDeclarations()[0];
                result.setter = semanticInfoChain.getASTForDecl(setterDecl);
            }
            return result;
        }
        PullHelpers.getGetterAndSetterFunction = getGetterAndSetterFunction;
        function symbolIsEnum(source) {
            return source && (source.kind & (TypeScript.PullElementKind.Enum | TypeScript.PullElementKind.EnumMember)) !== 0;
        }
        PullHelpers.symbolIsEnum = symbolIsEnum;
        function symbolIsModule(symbol) {
            return symbol && (symbol.kind == TypeScript.PullElementKind.Container || isOneDeclarationOfKind(symbol, TypeScript.PullElementKind.Container));
        }
        PullHelpers.symbolIsModule = symbolIsModule;
        function isOneDeclarationOfKind(symbol, kind) {
            var decls = symbol.getDeclarations();
            for (var i = 0; i < decls.length; i++) {
                if (decls[i].kind === kind) {
                    return true;
                }
            }
            return false;
        }
        function isNameNumeric(name) {
            return isFinite(+name);
        }
        PullHelpers.isNameNumeric = isNameNumeric;
        function typeSymbolsAreIdentical(a, b) {
            if (a.isTypeReference() && !a.getIsSpecialized()) {
                a = a.referencedTypeSymbol;
            }
            if (b.isTypeReference() && !b.getIsSpecialized()) {
                b = b.referencedTypeSymbol;
            }
            return a == b;
        }
        PullHelpers.typeSymbolsAreIdentical = typeSymbolsAreIdentical;
        function getRootType(type) {
            var rootType = type.getRootSymbol();
            while (true) {
                if (type == rootType) {
                    return type;
                }
                type = rootType;
                rootType = type.getRootSymbol();
            }
        }
        PullHelpers.getRootType = getRootType;
        function isSymbolLocal(symbol) {
            var container = symbol.getContainer();
            if (container) {
                var containerKind = container.kind;
                if (containerKind & (TypeScript.PullElementKind.SomeFunction | TypeScript.PullElementKind.FunctionType)) {
                    return true;
                }
                if (containerKind == TypeScript.PullElementKind.ConstructorType && !symbol.anyDeclHasFlag(TypeScript.PullElementFlags.Static)) {
                    return true;
                }
            }
            return false;
        }
        PullHelpers.isSymbolLocal = isSymbolLocal;
    })(PullHelpers = TypeScript.PullHelpers || (TypeScript.PullHelpers = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var GenerativeTypeClassification;
    (function (GenerativeTypeClassification) {
        GenerativeTypeClassification[GenerativeTypeClassification["Unknown"] = 0] = "Unknown";
        GenerativeTypeClassification[GenerativeTypeClassification["Open"] = 1] = "Open";
        GenerativeTypeClassification[GenerativeTypeClassification["Closed"] = 2] = "Closed";
        GenerativeTypeClassification[GenerativeTypeClassification["InfinitelyExpanding"] = 3] = "InfinitelyExpanding";
    })(GenerativeTypeClassification = TypeScript.GenerativeTypeClassification || (TypeScript.GenerativeTypeClassification = {}));
    var PullTypeReferenceSymbol = (function (_super) {
        __extends(PullTypeReferenceSymbol, _super);
        function PullTypeReferenceSymbol(referencedTypeSymbol) {
            var _this = _super.call(this, referencedTypeSymbol.name, referencedTypeSymbol.kind) || this;
            _this.referencedTypeSymbol = referencedTypeSymbol;
            _this.isResolved = true;
            TypeScript.Debug.assert(referencedTypeSymbol != null, "Type root symbol may not be null");
            _this.setRootSymbol(referencedTypeSymbol);
            _this.typeReference = _this;
            return _this;
        }
        PullTypeReferenceSymbol.createTypeReference = function (type) {
            if (type.isTypeReference()) {
                return type;
            }
            var typeReference = type.typeReference;
            if (!typeReference) {
                typeReference = new PullTypeReferenceSymbol(type);
                type.typeReference = typeReference;
            }
            return typeReference;
        };
        PullTypeReferenceSymbol.prototype.isTypeReference = function () {
            return true;
        };
        PullTypeReferenceSymbol.prototype.setResolved = function () { };
        PullTypeReferenceSymbol.prototype.setUnresolved = function () { };
        PullTypeReferenceSymbol.prototype.invalidate = function () { };
        PullTypeReferenceSymbol.prototype.ensureReferencedTypeIsResolved = function () {
            this._getResolver().resolveDeclaredSymbol(this.referencedTypeSymbol);
        };
        PullTypeReferenceSymbol.prototype.getReferencedTypeSymbol = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol;
        };
        PullTypeReferenceSymbol.prototype._getResolver = function () {
            return this.referencedTypeSymbol._getResolver();
        };
        PullTypeReferenceSymbol.prototype.hasMembers = function () {
            return this.referencedTypeSymbol.hasMembers();
        };
        PullTypeReferenceSymbol.prototype.setAssociatedContainerType = function (type) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": setAssociatedContainerType");
        };
        PullTypeReferenceSymbol.prototype.getAssociatedContainerType = function () {
            return this.referencedTypeSymbol.getAssociatedContainerType();
        };
        PullTypeReferenceSymbol.prototype.getFunctionSymbol = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getFunctionSymbol();
        };
        PullTypeReferenceSymbol.prototype.setFunctionSymbol = function (symbol) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": setFunctionSymbol");
        };
        PullTypeReferenceSymbol.prototype.addContainedNonMember = function (nonMember) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addContainedNonMember");
        };
        PullTypeReferenceSymbol.prototype.findContainedNonMemberContainer = function (containerName, kind) {
            if (kind === void 0) { kind = TypeScript.PullElementKind.None; }
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.findContainedNonMemberContainer(containerName, kind);
        };
        PullTypeReferenceSymbol.prototype.addMember = function (memberSymbol) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addMember");
        };
        PullTypeReferenceSymbol.prototype.addEnclosedMemberType = function (enclosedType) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedMemberType");
        };
        PullTypeReferenceSymbol.prototype.addEnclosedMemberContainer = function (enclosedContainer) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedMemberContainer");
        };
        PullTypeReferenceSymbol.prototype.addEnclosedNonMember = function (enclosedNonMember) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedNonMember");
        };
        PullTypeReferenceSymbol.prototype.addEnclosedNonMemberType = function (enclosedNonMemberType) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedNonMemberType");
        };
        PullTypeReferenceSymbol.prototype.addEnclosedNonMemberContainer = function (enclosedNonMemberContainer) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedNonMemberContainer");
        };
        PullTypeReferenceSymbol.prototype.addTypeParameter = function (typeParameter) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addTypeParameter");
        };
        PullTypeReferenceSymbol.prototype.addConstructorTypeParameter = function (typeParameter) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addConstructorTypeParameter");
        };
        PullTypeReferenceSymbol.prototype.findContainedNonMember = function (name) {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.findContainedNonMember(name);
        };
        PullTypeReferenceSymbol.prototype.findContainedNonMemberType = function (typeName, kind) {
            if (kind === void 0) { kind = TypeScript.PullElementKind.None; }
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.findContainedNonMemberType(typeName, kind);
        };
        PullTypeReferenceSymbol.prototype.getMembers = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getMembers();
        };
        PullTypeReferenceSymbol.prototype.setHasDefaultConstructor = function (hasOne) {
            if (hasOne === void 0) { hasOne = true; }
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ":setHasDefaultConstructor");
        };
        PullTypeReferenceSymbol.prototype.getHasDefaultConstructor = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getHasDefaultConstructor();
        };
        PullTypeReferenceSymbol.prototype.getConstructorMethod = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getConstructorMethod();
        };
        PullTypeReferenceSymbol.prototype.setConstructorMethod = function (constructorMethod) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": setConstructorMethod");
        };
        PullTypeReferenceSymbol.prototype.getTypeParameters = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypeParameters();
        };
        PullTypeReferenceSymbol.prototype.isGeneric = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.isGeneric();
        };
        PullTypeReferenceSymbol.prototype.addSpecialization = function (specializedVersionOfThisType, substitutingTypes) {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.addSpecialization(specializedVersionOfThisType, substitutingTypes);
        };
        PullTypeReferenceSymbol.prototype.getSpecialization = function (substitutingTypes) {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getSpecialization(substitutingTypes);
        };
        PullTypeReferenceSymbol.prototype.getKnownSpecializations = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getKnownSpecializations();
        };
        PullTypeReferenceSymbol.prototype.getTypeArguments = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypeArguments();
        };
        PullTypeReferenceSymbol.prototype.getTypeArgumentsOrTypeParameters = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypeArgumentsOrTypeParameters();
        };
        PullTypeReferenceSymbol.prototype.addCallSignature = function (callSignature) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addCallSignature");
        };
        PullTypeReferenceSymbol.prototype.addConstructSignature = function (constructSignature) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addConstructSignature");
        };
        PullTypeReferenceSymbol.prototype.addIndexSignature = function (indexSignature) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addIndexSignature");
        };
        PullTypeReferenceSymbol.prototype.hasOwnCallSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.hasOwnCallSignatures();
        };
        PullTypeReferenceSymbol.prototype.getCallSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getCallSignatures();
        };
        PullTypeReferenceSymbol.prototype.hasOwnConstructSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.hasOwnConstructSignatures();
        };
        PullTypeReferenceSymbol.prototype.getConstructSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getConstructSignatures();
        };
        PullTypeReferenceSymbol.prototype.hasOwnIndexSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.hasOwnIndexSignatures();
        };
        PullTypeReferenceSymbol.prototype.getIndexSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getIndexSignatures();
        };
        PullTypeReferenceSymbol.prototype.addImplementedType = function (implementedType) {
            this.referencedTypeSymbol.addImplementedType(implementedType);
        };
        PullTypeReferenceSymbol.prototype.getImplementedTypes = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getImplementedTypes();
        };
        PullTypeReferenceSymbol.prototype.addExtendedType = function (extendedType) {
            this.referencedTypeSymbol.addExtendedType(extendedType);
        };
        PullTypeReferenceSymbol.prototype.getExtendedTypes = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getExtendedTypes();
        };
        PullTypeReferenceSymbol.prototype.addTypeThatExtendsThisType = function (type) {
            this.referencedTypeSymbol.addTypeThatExtendsThisType(type);
        };
        PullTypeReferenceSymbol.prototype.getTypesThatExtendThisType = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypesThatExtendThisType();
        };
        PullTypeReferenceSymbol.prototype.addTypeThatExplicitlyImplementsThisType = function (type) {
            this.referencedTypeSymbol.addTypeThatExplicitlyImplementsThisType(type);
        };
        PullTypeReferenceSymbol.prototype.getTypesThatExplicitlyImplementThisType = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypesThatExplicitlyImplementThisType();
        };
        PullTypeReferenceSymbol.prototype.hasBase = function (potentialBase, visited) {
            if (visited === void 0) { visited = []; }
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.hasBase(potentialBase, visited);
        };
        PullTypeReferenceSymbol.prototype.isValidBaseKind = function (baseType, isExtendedType) {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.isValidBaseKind(baseType, isExtendedType);
        };
        PullTypeReferenceSymbol.prototype.findMember = function (name, lookInParent) {
            if (lookInParent === void 0) { lookInParent = true; }
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.findMember(name, lookInParent);
        };
        PullTypeReferenceSymbol.prototype.findNestedType = function (name, kind) {
            if (kind === void 0) { kind = TypeScript.PullElementKind.None; }
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.findNestedType(name, kind);
        };
        PullTypeReferenceSymbol.prototype.findNestedContainer = function (name, kind) {
            if (kind === void 0) { kind = TypeScript.PullElementKind.None; }
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.findNestedContainer(name, kind);
        };
        PullTypeReferenceSymbol.prototype.getAllMembers = function (searchDeclKind, memberVisiblity) {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getAllMembers(searchDeclKind, memberVisiblity);
        };
        PullTypeReferenceSymbol.prototype.findTypeParameter = function (name) {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.findTypeParameter(name);
        };
        PullTypeReferenceSymbol.prototype.hasOnlyOverloadCallSignatures = function () {
            return this.referencedTypeSymbol.hasOnlyOverloadCallSignatures();
        };
        return PullTypeReferenceSymbol;
    }(TypeScript.PullTypeSymbol));
    TypeScript.PullTypeReferenceSymbol = PullTypeReferenceSymbol;
    TypeScript.nSpecializationsCreated = 0;
    TypeScript.nSpecializedSignaturesCreated = 0;
    var PullInstantiatedTypeReferenceSymbol = (function (_super) {
        __extends(PullInstantiatedTypeReferenceSymbol, _super);
        function PullInstantiatedTypeReferenceSymbol(referencedTypeSymbol, _typeParameterArgumentMap) {
            var _this = _super.call(this, referencedTypeSymbol) || this;
            _this.referencedTypeSymbol = referencedTypeSymbol;
            _this._typeParameterArgumentMap = _typeParameterArgumentMap;
            _this._instantiatedMembers = null;
            _this._allInstantiatedMemberNameCache = null;
            _this._instantiatedMemberNameCache = TypeScript.createIntrinsicsObject();
            _this._instantiatedCallSignatures = null;
            _this._instantiatedConstructSignatures = null;
            _this._instantiatedIndexSignatures = null;
            _this._typeArgumentReferences = null;
            _this._instantiatedConstructorMethod = null;
            _this._instantiatedAssociatedContainerType = null;
            _this._isArray = undefined;
            _this.isInstanceReferenceType = false;
            _this._generativeTypeClassification = GenerativeTypeClassification.Unknown;
            TypeScript.nSpecializationsCreated++;
            return _this;
        }
        PullInstantiatedTypeReferenceSymbol.prototype.getIsSpecialized = function () { return !this.isInstanceReferenceType; };
        PullInstantiatedTypeReferenceSymbol.prototype.getGenerativeTypeClassification = function (enclosingType) {
            if (this._generativeTypeClassification == GenerativeTypeClassification.Unknown) {
                var typeParameters = enclosingType.getTypeParameters();
                var typeReferenceTypeArguments = this.getRootSymbol().getTypeArguments();
                var referenceTypeArgument = null;
                if (!typeReferenceTypeArguments) {
                    var typeParametersMap = [];
                    for (var i = 0; i < typeParameters.length; i++) {
                        typeParametersMap[typeParameters[i].pullSymbolID] = typeParameters[i];
                    }
                    var rootThis = TypeScript.PullHelpers.getRootType(this);
                    var wrapsSomeTypeParameters = rootThis.wrapsSomeTypeParameter(typeParametersMap);
                    if (wrapsSomeTypeParameters && this.wrapsSomeNestedTypeIntoInfiniteExpansion(enclosingType)) {
                        this._generativeTypeClassification = GenerativeTypeClassification.InfinitelyExpanding;
                    }
                    else if (wrapsSomeTypeParameters) {
                        this._generativeTypeClassification = GenerativeTypeClassification.Open;
                    }
                    else {
                        this._generativeTypeClassification = GenerativeTypeClassification.Closed;
                    }
                }
                else {
                    var i = 0;
                    while (i < typeReferenceTypeArguments.length) {
                        referenceTypeArgument = typeReferenceTypeArguments[i].getRootSymbol();
                        if (referenceTypeArgument.wrapsSomeTypeParameter(this._typeParameterArgumentMap)) {
                            break;
                        }
                        i++;
                    }
                    if (i == typeParameters.length) {
                        this._generativeTypeClassification = GenerativeTypeClassification.Closed;
                    }
                    if (this._generativeTypeClassification == GenerativeTypeClassification.Unknown) {
                        var i = 0;
                        while ((this._generativeTypeClassification == GenerativeTypeClassification.Unknown) &&
                            (i < typeReferenceTypeArguments.length)) {
                            for (var j = 0; j < typeParameters.length; j++) {
                                if (typeParameters[j] == typeReferenceTypeArguments[i]) {
                                    this._generativeTypeClassification = GenerativeTypeClassification.Open;
                                    break;
                                }
                            }
                            i++;
                        }
                        if (this._generativeTypeClassification != GenerativeTypeClassification.Open) {
                            this._generativeTypeClassification = GenerativeTypeClassification.InfinitelyExpanding;
                        }
                    }
                }
            }
            return this._generativeTypeClassification;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.isArrayNamedTypeReference = function () {
            if (this._isArray === undefined) {
                this._isArray = this.getRootSymbol().isArrayNamedTypeReference() || (this.getRootSymbol() == this._getResolver().getArrayNamedType());
            }
            return this._isArray;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.getElementType = function () {
            if (!this.isArrayNamedTypeReference()) {
                return null;
            }
            var typeArguments = this.getTypeArguments();
            if (typeArguments != null) {
                return typeArguments[0];
            }
            return null;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.getReferencedTypeSymbol = function () {
            this.ensureReferencedTypeIsResolved();
            if (this.getIsSpecialized()) {
                return this;
            }
            return this.referencedTypeSymbol;
        };
        PullInstantiatedTypeReferenceSymbol.create = function (resolver, type, typeParameterArgumentMap, instantiateFunctionTypeParameters) {
            if (instantiateFunctionTypeParameters === void 0) { instantiateFunctionTypeParameters = false; }
            TypeScript.Debug.assert(resolver);
            var rootType = type.getRootSymbol();
            var reconstructedTypeArgumentList = [];
            var typeArguments = type.getTypeArguments();
            var typeParameters = rootType.getTypeParameters();
            if (type.getIsSpecialized() && typeArguments && typeArguments.length) {
                for (var i = 0; i < typeArguments.length; i++) {
                    reconstructedTypeArgumentList[reconstructedTypeArgumentList.length] = resolver.instantiateType(typeArguments[i], typeParameterArgumentMap, instantiateFunctionTypeParameters);
                }
                for (var i = 0; i < typeArguments.length; i++) {
                    typeParameterArgumentMap[typeArguments[i].pullSymbolID] = reconstructedTypeArgumentList[i];
                }
            }
            else {
                var tyArg = null;
                for (var typeParameterID in typeParameterArgumentMap) {
                    if (typeParameterArgumentMap.hasOwnProperty(typeParameterID)) {
                        tyArg = typeParameterArgumentMap[typeParameterID];
                        if (tyArg) {
                            reconstructedTypeArgumentList[reconstructedTypeArgumentList.length] = tyArg;
                        }
                    }
                }
            }
            var instantiation;
            if (!instantiateFunctionTypeParameters) {
                instantiation = rootType.getSpecialization(reconstructedTypeArgumentList);
                if (instantiation) {
                    return instantiation;
                }
            }
            var isReferencedType = (type.kind & TypeScript.PullElementKind.SomeInstantiatableType) != 0;
            if (isReferencedType) {
                if (typeParameters && reconstructedTypeArgumentList) {
                    if (typeParameters.length == reconstructedTypeArgumentList.length) {
                        for (var i = 0; i < typeParameters.length; i++) {
                            if (!TypeScript.PullHelpers.typeSymbolsAreIdentical(typeParameters[i], reconstructedTypeArgumentList[i])) {
                                isReferencedType = false;
                                break;
                            }
                        }
                        if (isReferencedType) {
                            typeParameterArgumentMap = [];
                        }
                    }
                    else {
                        isReferencedType = false;
                    }
                }
            }
            var instantiateRoot = isReferencedType;
            if (type.isTypeReference() && type.isGeneric()) {
                var initializationMap = [];
                for (var typeParameterID in typeParameterArgumentMap) {
                    if (typeParameterArgumentMap.hasOwnProperty(typeParameterID)) {
                        initializationMap[+typeParameterID] = typeParameterArgumentMap[+typeParameterID];
                    }
                }
                var oldMap = typeParameterArgumentMap;
                var outerTypeMap = type._typeParameterArgumentMap;
                var innerSubstitution = null;
                var outerSubstitution = null;
                var canRelatePreInstantiatedTypeParametersToRootTypeParameters = true;
                for (var typeParameterID in outerTypeMap) {
                    if (outerTypeMap.hasOwnProperty(typeParameterID)) {
                        outerSubstitution = outerTypeMap[typeParameterID];
                        innerSubstitution = typeParameterArgumentMap[outerSubstitution.pullSymbolID];
                        if (innerSubstitution &&
                            (!outerSubstitution.isTypeParameter() ||
                                !outerTypeMap[innerSubstitution.pullSymbolID] ||
                                !outerTypeMap[outerTypeMap[typeParameterID].pullSymbolID] ||
                                (outerTypeMap[outerTypeMap[typeParameterID].pullSymbolID] == outerSubstitution))) {
                            initializationMap[+typeParameterID] = typeParameterArgumentMap[outerTypeMap[typeParameterID].pullSymbolID];
                            if (!outerSubstitution.isTypeParameter()) {
                                canRelatePreInstantiatedTypeParametersToRootTypeParameters = false;
                            }
                        }
                        else {
                            canRelatePreInstantiatedTypeParametersToRootTypeParameters = false;
                        }
                    }
                }
                if (canRelatePreInstantiatedTypeParametersToRootTypeParameters && typeParameters.length) {
                    typeParameterArgumentMap = [];
                    for (var i = 0; i < typeParameters.length; i++) {
                        typeParameterArgumentMap[typeParameters[i].pullSymbolID] = initializationMap[typeParameters[i].pullSymbolID];
                    }
                    instantiateRoot = true;
                }
                else {
                    typeParameterArgumentMap = initializationMap;
                }
            }
            instantiation = new PullInstantiatedTypeReferenceSymbol(instantiateRoot ? rootType : type, typeParameterArgumentMap);
            if (!instantiateFunctionTypeParameters) {
                rootType.addSpecialization(instantiation, reconstructedTypeArgumentList);
            }
            if (isReferencedType) {
                instantiation.isInstanceReferenceType = true;
            }
            return instantiation;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.isGeneric = function () {
            return !!this.referencedTypeSymbol.getTypeParameters().length;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.getTypeParameterArgumentMap = function () {
            return this._typeParameterArgumentMap;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.getTypeArguments = function () {
            if (this.isInstanceReferenceType) {
                return this.getTypeParameters();
            }
            if (!this._typeArgumentReferences) {
                var typeParameters = this.referencedTypeSymbol.getTypeParameters();
                if (typeParameters.length) {
                    var typeArgument = null;
                    var typeArguments = [];
                    for (var i = 0; i < typeParameters.length; i++) {
                        typeArgument = this._typeParameterArgumentMap[typeParameters[i].pullSymbolID];
                        if (!typeArgument) {
                            TypeScript.Debug.fail("type argument count mismatch");
                        }
                        if (typeArgument) {
                            typeArguments[typeArguments.length] = typeArgument;
                        }
                    }
                    this._typeArgumentReferences = typeArguments;
                }
            }
            return this._typeArgumentReferences;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.getTypeArgumentsOrTypeParameters = function () {
            return this.getTypeArguments();
        };
        PullInstantiatedTypeReferenceSymbol.prototype.getMembers = function () {
            this.ensureReferencedTypeIsResolved();
            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getMembers();
            }
            if (!this._instantiatedMembers) {
                var referencedMembers = this.referencedTypeSymbol.getMembers();
                var referencedMember = null;
                var instantiatedMember = null;
                this._instantiatedMembers = [];
                for (var i = 0; i < referencedMembers.length; i++) {
                    referencedMember = referencedMembers[i];
                    this._getResolver().resolveDeclaredSymbol(referencedMember);
                    if (!this._instantiatedMemberNameCache[referencedMember.name]) {
                        if (!referencedMember.type.wrapsSomeTypeParameter(this._typeParameterArgumentMap)) {
                            instantiatedMember = referencedMember;
                        }
                        else {
                            instantiatedMember = new TypeScript.PullSymbol(referencedMember.name, referencedMember.kind);
                            instantiatedMember.setRootSymbol(referencedMember);
                            instantiatedMember.type = this._getResolver().instantiateType(referencedMember.type, this._typeParameterArgumentMap);
                            instantiatedMember.isOptional = referencedMember.isOptional;
                        }
                        this._instantiatedMemberNameCache[instantiatedMember.name] = instantiatedMember;
                    }
                    else {
                        instantiatedMember = this._instantiatedMemberNameCache[referencedMember.name];
                    }
                    this._instantiatedMembers[this._instantiatedMembers.length] = instantiatedMember;
                }
            }
            return this._instantiatedMembers;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.findMember = function (name, lookInParent) {
            if (lookInParent === void 0) { lookInParent = true; }
            this.ensureReferencedTypeIsResolved();
            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.findMember(name, lookInParent);
            }
            var memberSymbol = this._instantiatedMemberNameCache[name];
            if (!memberSymbol) {
                var referencedMemberSymbol = this.referencedTypeSymbol.findMember(name, lookInParent);
                if (referencedMemberSymbol) {
                    memberSymbol = new TypeScript.PullSymbol(referencedMemberSymbol.name, referencedMemberSymbol.kind);
                    memberSymbol.setRootSymbol(referencedMemberSymbol);
                    this._getResolver().resolveDeclaredSymbol(referencedMemberSymbol);
                    memberSymbol.type = this._getResolver().instantiateType(referencedMemberSymbol.type, this._typeParameterArgumentMap);
                    memberSymbol.isOptional = referencedMemberSymbol.isOptional;
                    this._instantiatedMemberNameCache[memberSymbol.name] = memberSymbol;
                }
                else {
                    memberSymbol = null;
                }
            }
            return memberSymbol;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.getAllMembers = function (searchDeclKind, memberVisiblity) {
            this.ensureReferencedTypeIsResolved();
            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getAllMembers(searchDeclKind, memberVisiblity);
            }
            var requestedMembers = [];
            var allReferencedMembers = this.referencedTypeSymbol.getAllMembers(searchDeclKind, memberVisiblity);
            if (!this._allInstantiatedMemberNameCache) {
                this._allInstantiatedMemberNameCache = TypeScript.createIntrinsicsObject();
                var members = this.getMembers();
                for (var i = 0; i < members.length; i++) {
                    this._allInstantiatedMemberNameCache[members[i].name] = members[i];
                }
            }
            var referencedMember = null;
            var requestedMember = null;
            for (var i = 0; i < allReferencedMembers.length; i++) {
                referencedMember = allReferencedMembers[i];
                this._getResolver().resolveDeclaredSymbol(referencedMember);
                if (this._allInstantiatedMemberNameCache[referencedMember.name]) {
                    requestedMembers[requestedMembers.length] = this._allInstantiatedMemberNameCache[referencedMember.name];
                }
                else {
                    if (!referencedMember.type.wrapsSomeTypeParameter(this._typeParameterArgumentMap)) {
                        this._allInstantiatedMemberNameCache[referencedMember.name] = referencedMember;
                        requestedMembers[requestedMembers.length] = referencedMember;
                    }
                    else {
                        requestedMember = new TypeScript.PullSymbol(referencedMember.name, referencedMember.kind);
                        requestedMember.setRootSymbol(referencedMember);
                        requestedMember.type = this._getResolver().instantiateType(referencedMember.type, this._typeParameterArgumentMap);
                        requestedMember.isOptional = referencedMember.isOptional;
                        this._allInstantiatedMemberNameCache[requestedMember.name] = requestedMember;
                        requestedMembers[requestedMembers.length] = requestedMember;
                    }
                }
            }
            return requestedMembers;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.getConstructorMethod = function () {
            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getConstructorMethod();
            }
            if (!this._instantiatedConstructorMethod) {
                var referencedConstructorMethod = this.referencedTypeSymbol.getConstructorMethod();
                this._instantiatedConstructorMethod = new TypeScript.PullSymbol(referencedConstructorMethod.name, referencedConstructorMethod.kind);
                this._instantiatedConstructorMethod.type = PullInstantiatedTypeReferenceSymbol.create(this._getResolver(), referencedConstructorMethod.type, this._typeParameterArgumentMap);
            }
            return this._instantiatedConstructorMethod;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.getAssociatedContainerType = function () {
            if (!this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getAssociatedContainerType();
            }
            if (!this._instantiatedAssociatedContainerType) {
                var referencedAssociatedContainerType = this.referencedTypeSymbol.getAssociatedContainerType();
                if (referencedAssociatedContainerType) {
                    this._instantiatedAssociatedContainerType = PullInstantiatedTypeReferenceSymbol.create(this._getResolver(), referencedAssociatedContainerType, this._typeParameterArgumentMap);
                }
            }
            return this._instantiatedAssociatedContainerType;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.getCallSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getCallSignatures();
            }
            if (this._instantiatedCallSignatures) {
                return this._instantiatedCallSignatures;
            }
            var referencedCallSignatures = this.referencedTypeSymbol.getCallSignatures();
            this._instantiatedCallSignatures = [];
            for (var i = 0; i < referencedCallSignatures.length; i++) {
                this._getResolver().resolveDeclaredSymbol(referencedCallSignatures[i]);
                if (!referencedCallSignatures[i].wrapsSomeTypeParameter(this._typeParameterArgumentMap)) {
                    this._instantiatedCallSignatures[this._instantiatedCallSignatures.length] = referencedCallSignatures[i];
                }
                else {
                    this._instantiatedCallSignatures[this._instantiatedCallSignatures.length] = this._getResolver().instantiateSignature(referencedCallSignatures[i], this._typeParameterArgumentMap);
                    this._instantiatedCallSignatures[this._instantiatedCallSignatures.length - 1].functionType = this;
                }
            }
            return this._instantiatedCallSignatures;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.getConstructSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getConstructSignatures();
            }
            if (this._instantiatedConstructSignatures) {
                return this._instantiatedConstructSignatures;
            }
            var referencedConstructSignatures = this.referencedTypeSymbol.getConstructSignatures();
            this._instantiatedConstructSignatures = [];
            for (var i = 0; i < referencedConstructSignatures.length; i++) {
                this._getResolver().resolveDeclaredSymbol(referencedConstructSignatures[i]);
                if (!referencedConstructSignatures[i].wrapsSomeTypeParameter(this._typeParameterArgumentMap)) {
                    this._instantiatedConstructSignatures[this._instantiatedConstructSignatures.length] = referencedConstructSignatures[i];
                }
                else {
                    this._instantiatedConstructSignatures[this._instantiatedConstructSignatures.length] = this._getResolver().instantiateSignature(referencedConstructSignatures[i], this._typeParameterArgumentMap);
                    this._instantiatedConstructSignatures[this._instantiatedConstructSignatures.length - 1].functionType = this;
                }
            }
            return this._instantiatedConstructSignatures;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.getIndexSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getIndexSignatures();
            }
            if (this._instantiatedIndexSignatures) {
                return this._instantiatedIndexSignatures;
            }
            var referencedIndexSignatures = this.referencedTypeSymbol.getIndexSignatures();
            this._instantiatedIndexSignatures = [];
            for (var i = 0; i < referencedIndexSignatures.length; i++) {
                this._getResolver().resolveDeclaredSymbol(referencedIndexSignatures[i]);
                if (!referencedIndexSignatures[i].wrapsSomeTypeParameter(this._typeParameterArgumentMap)) {
                    this._instantiatedIndexSignatures[this._instantiatedIndexSignatures.length] = referencedIndexSignatures[i];
                }
                else {
                    this._instantiatedIndexSignatures[this._instantiatedIndexSignatures.length] = this._getResolver().instantiateSignature(referencedIndexSignatures[i], this._typeParameterArgumentMap);
                    this._instantiatedIndexSignatures[this._instantiatedIndexSignatures.length - 1].functionType = this;
                }
            }
            return this._instantiatedIndexSignatures;
        };
        PullInstantiatedTypeReferenceSymbol.prototype.hasBase = function (potentialBase, visited) {
            if (visited === void 0) { visited = []; }
            return this.referencedTypeSymbol.hasBase(potentialBase, visited);
        };
        return PullInstantiatedTypeReferenceSymbol;
    }(PullTypeReferenceSymbol));
    TypeScript.PullInstantiatedTypeReferenceSymbol = PullInstantiatedTypeReferenceSymbol;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxTreeToAstVisitor = (function () {
        function SyntaxTreeToAstVisitor(fileName, lineMap, compilationSettings) {
            this.fileName = fileName;
            this.lineMap = lineMap;
            this.compilationSettings = compilationSettings;
            this.position = 0;
            this.previousTokenTrailingComments = null;
        }
        SyntaxTreeToAstVisitor.visit = function (syntaxTree, fileName, compilationSettings, incrementalAST) {
            var visitor = incrementalAST
                ? new SyntaxTreeToIncrementalAstVisitor(fileName, syntaxTree.lineMap(), compilationSettings)
                : new SyntaxTreeToAstVisitor(fileName, syntaxTree.lineMap(), compilationSettings);
            return syntaxTree.sourceUnit().accept(visitor);
        };
        SyntaxTreeToAstVisitor.prototype.movePast = function (element) {
            if (element !== null) {
                this.position += element.fullWidth();
            }
        };
        SyntaxTreeToAstVisitor.prototype.moveTo = function (element1, element2) {
            if (element2 !== null) {
                this.position += TypeScript.Syntax.childOffset(element1, element2);
            }
        };
        SyntaxTreeToAstVisitor.prototype.setCommentsAndSpan = function (ast, fullStart, node) {
            var firstToken = node.firstToken();
            var lastToken = node.lastToken();
            this.setSpan(ast, fullStart, node, firstToken, lastToken);
            ast.setPreComments(this.convertTokenLeadingComments(firstToken, fullStart));
            ast.setPostComments(this.convertNodeTrailingComments(node, lastToken, fullStart));
        };
        SyntaxTreeToAstVisitor.prototype.createTokenSpan = function (fullStart, element) {
            if (element === null) {
                return null;
            }
            if (element.fullWidth() === 0) {
                return new TypeScript.ASTSpan(-1, -1);
            }
            var leadingTriviaWidth = element.leadingTriviaWidth();
            var trailingTriviaWidth = element.trailingTriviaWidth();
            var start = fullStart + leadingTriviaWidth;
            var end = fullStart + element.fullWidth() - trailingTriviaWidth;
            return new TypeScript.ASTSpan(start, end);
        };
        SyntaxTreeToAstVisitor.prototype.setSpan = function (span, fullStart, element, firstToken, lastToken) {
            if (firstToken === void 0) { firstToken = element.firstToken(); }
            if (lastToken === void 0) { lastToken = element.lastToken(); }
            var leadingTriviaWidth = firstToken ? firstToken.leadingTriviaWidth() : 0;
            var trailingTriviaWidth = lastToken ? lastToken.trailingTriviaWidth() : 0;
            var desiredMinChar = fullStart + leadingTriviaWidth;
            var desiredLimChar = fullStart + element.fullWidth() - trailingTriviaWidth;
            this.setSpanExplicit(span, desiredMinChar, desiredLimChar);
            span._trailingTriviaWidth = trailingTriviaWidth;
        };
        SyntaxTreeToAstVisitor.prototype.setSpanExplicit = function (span, start, end) {
            span._start = start;
            span._end = end;
        };
        SyntaxTreeToAstVisitor.prototype.visitSyntaxList = function (node) {
            var start = this.position;
            var array = new Array(node.childCount());
            for (var i = 0, n = node.childCount(); i < n; i++) {
                array[i] = node.childAt(i).accept(this);
            }
            var result = new TypeScript.ISyntaxList2(this.fileName, array);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSeparatedSyntaxList = function (list) {
            var start = this.position;
            var array = new Array(list.nonSeparatorCount());
            for (var i = 0, n = list.childCount(); i < n; i++) {
                if (i % 2 === 0) {
                    array[i / 2] = list.childAt(i).accept(this);
                    this.previousTokenTrailingComments = null;
                }
                else {
                    var separatorToken = list.childAt(i);
                    this.previousTokenTrailingComments = this.convertTokenTrailingComments(separatorToken, this.position + separatorToken.leadingTriviaWidth() + separatorToken.width());
                    this.movePast(separatorToken);
                }
            }
            var result = new TypeScript.ISeparatedSyntaxList2(this.fileName, array, list.separatorCount());
            this.setSpan(result, start, list);
            result.setPostComments(this.previousTokenTrailingComments);
            this.previousTokenTrailingComments = null;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.convertComment = function (trivia, commentStartPosition, hasTrailingNewLine) {
            var comment = new TypeScript.Comment(trivia, hasTrailingNewLine, commentStartPosition, commentStartPosition + trivia.fullWidth());
            return comment;
        };
        SyntaxTreeToAstVisitor.prototype.convertComments = function (triviaList, commentStartPosition) {
            var result = [];
            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                if (trivia.isComment()) {
                    var hasTrailingNewLine = ((i + 1) < n) && triviaList.syntaxTriviaAt(i + 1).isNewLine();
                    result.push(this.convertComment(trivia, commentStartPosition, hasTrailingNewLine));
                }
                commentStartPosition += trivia.fullWidth();
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.mergeComments = function (comments1, comments2) {
            if (comments1 === null) {
                return comments2;
            }
            if (comments2 === null) {
                return comments1;
            }
            return comments1.concat(comments2);
        };
        SyntaxTreeToAstVisitor.prototype.convertTokenLeadingComments = function (token, commentStartPosition) {
            if (token === null) {
                return null;
            }
            var preComments = token.hasLeadingComment()
                ? this.convertComments(token.leadingTrivia(), commentStartPosition)
                : null;
            var previousTokenTrailingComments = this.previousTokenTrailingComments;
            this.previousTokenTrailingComments = null;
            return this.mergeComments(previousTokenTrailingComments, preComments);
        };
        SyntaxTreeToAstVisitor.prototype.convertTokenTrailingComments = function (token, commentStartPosition) {
            if (token === null || !token.hasTrailingComment() || token.hasTrailingNewLine()) {
                return null;
            }
            return this.convertComments(token.trailingTrivia(), commentStartPosition);
        };
        SyntaxTreeToAstVisitor.prototype.convertNodeTrailingComments = function (node, lastToken, nodeStart) {
            if (lastToken === null || !lastToken.hasTrailingComment() || lastToken.hasTrailingNewLine()) {
                return null;
            }
            return this.convertComments(lastToken.trailingTrivia(), nodeStart + node.fullWidth() - lastToken.trailingTriviaWidth());
        };
        SyntaxTreeToAstVisitor.prototype.visitIdentifier = function (token) {
            return this.visitToken(token);
        };
        SyntaxTreeToAstVisitor.prototype.visitToken = function (token) {
            var fullStart = this.position;
            var result = this.visitTokenWorker(token);
            this.movePast(token);
            var start = fullStart + token.leadingTriviaWidth();
            this.setSpanExplicit(result, start, start + token.width());
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTokenWorker = function (token) {
            switch (token.tokenKind) {
                case TypeScript.SyntaxKind.AnyKeyword:
                    return new TypeScript.BuiltInType(TypeScript.SyntaxKind.AnyKeyword, token.text(), token.valueText());
                case TypeScript.SyntaxKind.BooleanKeyword:
                    return new TypeScript.BuiltInType(TypeScript.SyntaxKind.BooleanKeyword, token.text(), token.valueText());
                case TypeScript.SyntaxKind.NumberKeyword:
                    return new TypeScript.BuiltInType(TypeScript.SyntaxKind.NumberKeyword, token.text(), token.valueText());
                case TypeScript.SyntaxKind.StringKeyword:
                    return new TypeScript.BuiltInType(TypeScript.SyntaxKind.StringKeyword, token.text(), token.valueText());
                case TypeScript.SyntaxKind.VoidKeyword:
                    return new TypeScript.BuiltInType(TypeScript.SyntaxKind.VoidKeyword, token.text(), token.valueText());
                case TypeScript.SyntaxKind.ThisKeyword:
                    return new TypeScript.ThisExpression(token.text(), token.valueText());
                case TypeScript.SyntaxKind.SuperKeyword:
                    return new TypeScript.SuperExpression(token.text(), token.valueText());
                case TypeScript.SyntaxKind.TrueKeyword:
                    return new TypeScript.LiteralExpression(TypeScript.SyntaxKind.TrueKeyword, token.text(), token.valueText());
                case TypeScript.SyntaxKind.FalseKeyword:
                    return new TypeScript.LiteralExpression(TypeScript.SyntaxKind.FalseKeyword, token.text(), token.valueText());
                case TypeScript.SyntaxKind.NullKeyword:
                    return new TypeScript.LiteralExpression(TypeScript.SyntaxKind.NullKeyword, token.text(), token.valueText());
                case TypeScript.SyntaxKind.StringLiteral:
                    return new TypeScript.StringLiteral(token.text(), token.valueText());
                case TypeScript.SyntaxKind.RegularExpressionLiteral:
                    return new TypeScript.RegularExpressionLiteral(token.text(), token.valueText());
                case TypeScript.SyntaxKind.NumericLiteral:
                    var fullStart = this.position;
                    var preComments = this.convertTokenLeadingComments(token, fullStart);
                    var result = new TypeScript.NumericLiteral(token.value(), token.text(), token.valueText());
                    result.setPreComments(preComments);
                    return result;
                case TypeScript.SyntaxKind.IdentifierName:
                    return new TypeScript.Identifier(token.text());
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        SyntaxTreeToAstVisitor.prototype.visitSourceUnit = function (node) {
            var start = this.position;
            TypeScript.Debug.assert(start === 0);
            var bod = this.visitSyntaxList(node.moduleElements);
            var result = new TypeScript.SourceUnit(bod, this.fileName);
            this.setSpanExplicit(result, start, start + node.fullWidth());
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitExternalModuleReference = function (node) {
            var start = this.position;
            this.moveTo(node, node.stringLiteral);
            var stringLiteral = node.stringLiteral.accept(this);
            this.movePast(node.closeParenToken);
            var result = new TypeScript.ExternalModuleReference(stringLiteral);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitModuleNameModuleReference = function (node) {
            var start = this.position;
            var moduleName = node.moduleName.accept(this);
            var result = new TypeScript.ModuleNameModuleReference(moduleName);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitClassDeclaration = function (node) {
            var start = this.position;
            this.moveTo(node, node.identifier);
            var name = this.visitIdentifier(node.identifier);
            var typeParameters = this.visitTypeParameterList(node.typeParameterList);
            var heritageClauses = node.heritageClauses ? this.visitSyntaxList(node.heritageClauses) : null;
            this.movePast(node.openBraceToken);
            var members = this.visitSyntaxList(node.classElements);
            var closeBraceToken = this.createTokenSpan(this.position, node.closeBraceToken);
            this.movePast(node.closeBraceToken);
            var modifiers = this.visitModifiers(node.modifiers);
            var result = new TypeScript.ClassDeclaration(modifiers, name, typeParameters, heritageClauses, members, closeBraceToken);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitModifiers = function (modifiers) {
            var result = null;
            if (TypeScript.SyntaxUtilities.containsToken(modifiers, TypeScript.SyntaxKind.ExportKeyword)) {
                result = result || [];
                result.push(TypeScript.PullElementFlags.Exported);
            }
            if (TypeScript.SyntaxUtilities.containsToken(modifiers, TypeScript.SyntaxKind.DeclareKeyword)) {
                result = result || [];
                result.push(TypeScript.PullElementFlags.Ambient);
            }
            if (TypeScript.SyntaxUtilities.containsToken(modifiers, TypeScript.SyntaxKind.StaticKeyword)) {
                result = result || [];
                result.push(TypeScript.PullElementFlags.Static);
            }
            if (TypeScript.SyntaxUtilities.containsToken(modifiers, TypeScript.SyntaxKind.PublicKeyword)) {
                result = result || [];
                result.push(TypeScript.PullElementFlags.Public);
            }
            if (TypeScript.SyntaxUtilities.containsToken(modifiers, TypeScript.SyntaxKind.PrivateKeyword)) {
                result = result || [];
                result.push(TypeScript.PullElementFlags.Private);
            }
            return result || [];
        };
        SyntaxTreeToAstVisitor.prototype.visitInterfaceDeclaration = function (node) {
            var start = this.position;
            this.moveTo(node, node.identifier);
            var name = this.visitIdentifier(node.identifier);
            var typeParameters = this.visitTypeParameterList(node.typeParameterList);
            var heritageClauses = node.heritageClauses ? this.visitSyntaxList(node.heritageClauses) : null;
            var body = this.visitObjectType(node.body);
            var modifiers = this.visitModifiers(node.modifiers);
            var result = new TypeScript.InterfaceDeclaration(modifiers, name, typeParameters, heritageClauses, body);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitHeritageClause = function (node) {
            var start = this.position;
            this.movePast(node.extendsOrImplementsKeyword);
            var typeNames = this.visitSeparatedSyntaxList(node.typeNames);
            var result = new TypeScript.HeritageClause(node.extendsOrImplementsKeyword.tokenKind === TypeScript.SyntaxKind.ExtendsKeyword ? TypeScript.SyntaxKind.ExtendsHeritageClause : TypeScript.SyntaxKind.ImplementsHeritageClause, typeNames);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitModuleDeclaration = function (node) {
            var start = this.position;
            var modifiers = this.visitModifiers(node.modifiers);
            this.moveTo(node, node.moduleKeyword);
            this.movePast(node.moduleKeyword);
            var moduleName = node.name ? node.name.accept(this) : null;
            var stringLiteral = node.stringLiteral ? node.stringLiteral.accept(this) : null;
            this.movePast(node.openBraceToken);
            var moduleElements = this.visitSyntaxList(node.moduleElements);
            var closeBraceToken = this.createTokenSpan(this.position, node.closeBraceToken);
            this.movePast(node.closeBraceToken);
            var result = new TypeScript.ModuleDeclaration(modifiers, moduleName, stringLiteral, moduleElements, closeBraceToken);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitFunctionDeclaration = function (node) {
            var start = this.position;
            this.moveTo(node, node.identifier);
            var name = this.visitIdentifier(node.identifier);
            var callSignature = this.visitCallSignature(node.callSignature);
            var block = node.block ? this.visitBlock(node.block) : null;
            this.movePast(node.semicolonToken);
            var result = new TypeScript.FunctionDeclaration(this.visitModifiers(node.modifiers), name, callSignature, block);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitEnumDeclaration = function (node) {
            var start = this.position;
            this.moveTo(node, node.identifier);
            var identifier = this.visitIdentifier(node.identifier);
            this.movePast(node.openBraceToken);
            var enumElements = this.visitSeparatedSyntaxList(node.enumElements);
            this.movePast(node.closeBraceToken);
            var result = new TypeScript.EnumDeclaration(this.visitModifiers(node.modifiers), identifier, enumElements);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitEnumElement = function (node) {
            var start = this.position;
            var memberName = this.visitToken(node.propertyName);
            var value = node.equalsValueClause !== null ? this.visitEqualsValueClause(node.equalsValueClause) : null;
            var result = new TypeScript.EnumElement(memberName, value);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitImportDeclaration = function (node) {
            var start = this.position;
            this.moveTo(node, node.identifier);
            var name = this.visitIdentifier(node.identifier);
            this.movePast(node.equalsToken);
            var alias = node.moduleReference.accept(this);
            this.movePast(node.semicolonToken);
            var modifiers = this.visitModifiers(node.modifiers);
            var result = new TypeScript.ImportDeclaration(modifiers, name, alias);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitExportAssignment = function (node) {
            var start = this.position;
            this.moveTo(node, node.identifier);
            var name = this.visitIdentifier(node.identifier);
            this.movePast(node.semicolonToken);
            var result = new TypeScript.ExportAssignment(name);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitVariableStatement = function (node) {
            var start = this.position;
            this.moveTo(node, node.variableDeclaration);
            var declaration = node.variableDeclaration.accept(this);
            this.movePast(node.semicolonToken);
            var modifiers = this.visitModifiers(node.modifiers);
            var result = new TypeScript.VariableStatement(modifiers, declaration);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitVariableDeclaration = function (node) {
            var start = this.position;
            this.moveTo(node, node.variableDeclarators);
            var variableDecls = this.visitSeparatedSyntaxList(node.variableDeclarators);
            var result = new TypeScript.VariableDeclaration(variableDecls);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitVariableDeclarator = function (node) {
            var start = this.position;
            var propertyName = this.visitToken(node.propertyName);
            var typeExpr = this.visitTypeAnnotation(node.typeAnnotation);
            var init = node.equalsValueClause ? this.visitEqualsValueClause(node.equalsValueClause) : null;
            var result = new TypeScript.VariableDeclarator(propertyName, typeExpr, init);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitEqualsValueClause = function (node) {
            var start = this.position;
            var afterEqualsComments = this.convertTokenTrailingComments(node.equalsToken, this.position + node.equalsToken.leadingTriviaWidth() + node.equalsToken.width());
            this.movePast(node.equalsToken);
            var value = node.value.accept(this);
            value.setPreComments(this.mergeComments(afterEqualsComments, value.preComments()));
            var result = new TypeScript.EqualsValueClause(value);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            var start = this.position;
            this.movePast(node.operatorToken);
            var operand = node.operand.accept(this);
            var result = new TypeScript.PrefixUnaryExpression(node.kind(), operand);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitArrayLiteralExpression = function (node) {
            var start = this.position;
            var openStart = this.position + node.openBracketToken.leadingTriviaWidth();
            this.movePast(node.openBracketToken);
            var expressions = this.visitSeparatedSyntaxList(node.expressions);
            var closeStart = this.position + node.closeBracketToken.leadingTriviaWidth();
            this.movePast(node.closeBracketToken);
            var result = new TypeScript.ArrayLiteralExpression(expressions);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitOmittedExpression = function (node) {
            var start = this.position;
            var result = new TypeScript.OmittedExpression();
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitParenthesizedExpression = function (node) {
            var start = this.position;
            var openParenToken = node.openParenToken;
            var openParenTrailingComments = this.convertTokenTrailingComments(openParenToken, start + openParenToken.leadingTriviaWidth() + openParenToken.width());
            this.movePast(openParenToken);
            var expr = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            var result = new TypeScript.ParenthesizedExpression(openParenTrailingComments, expr);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            var start = this.position;
            var identifier = node.identifier.accept(this);
            this.movePast(node.equalsGreaterThanToken);
            var block = node.block ? this.visitBlock(node.block) : null;
            var expression = node.expression ? node.expression.accept(this) : null;
            var result = new TypeScript.SimpleArrowFunctionExpression(identifier, block, expression);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            var start = this.position;
            var callSignature = this.visitCallSignature(node.callSignature);
            this.movePast(node.equalsGreaterThanToken);
            var block = node.block ? this.visitBlock(node.block) : null;
            var expression = node.expression ? node.expression.accept(this) : null;
            var result = new TypeScript.ParenthesizedArrowFunctionExpression(callSignature, block, expression);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitType = function (type) {
            return type ? type.accept(this) : null;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeQuery = function (node) {
            var start = this.position;
            this.movePast(node.typeOfKeyword);
            var name = node.name.accept(this);
            var result = new TypeScript.TypeQuery(name);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitQualifiedName = function (node) {
            var start = this.position;
            var left = this.visitType(node.left);
            this.movePast(node.dotToken);
            var right = this.visitIdentifier(node.right);
            var result = new TypeScript.QualifiedName(left, right);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeArgumentList = function (node) {
            if (node === null) {
                return null;
            }
            var start = this.position;
            this.movePast(node.lessThanToken);
            var typeArguments = this.visitSeparatedSyntaxList(node.typeArguments);
            this.movePast(node.greaterThanToken);
            var result = new TypeScript.TypeArgumentList(typeArguments);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConstructorType = function (node) {
            var start = this.position;
            this.movePast(node.newKeyword);
            var typeParameters = this.visitTypeParameterList(node.typeParameterList);
            var parameters = this.visitParameterList(node.parameterList);
            this.movePast(node.equalsGreaterThanToken);
            var returnType = this.visitType(node.type);
            var result = new TypeScript.ConstructorType(typeParameters, parameters, returnType);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitFunctionType = function (node) {
            var start = this.position;
            var typeParameters = this.visitTypeParameterList(node.typeParameterList);
            var parameters = this.visitParameterList(node.parameterList);
            this.movePast(node.equalsGreaterThanToken);
            var returnType = this.visitType(node.type);
            var result = new TypeScript.FunctionType(typeParameters, parameters, returnType);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitObjectType = function (node) {
            var start = this.position;
            this.movePast(node.openBraceToken);
            var typeMembers = this.visitSeparatedSyntaxList(node.typeMembers);
            this.movePast(node.closeBraceToken);
            var result = new TypeScript.ObjectType(typeMembers);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitArrayType = function (node) {
            var start = this.position;
            var underlying = this.visitType(node.type);
            this.movePast(node.openBracketToken);
            this.movePast(node.closeBracketToken);
            var result = new TypeScript.ArrayType(underlying);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTupleType = function (node) {
            var start = this.position;
            var underlying = this.visitType(node.type);
            this.movePast(node.openBracketToken);
            this.movePast(node.closeBracketToken);
            var result = new TypeScript.TupleType(underlying);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitGenericType = function (node) {
            var start = this.position;
            var underlying = this.visitType(node.name);
            var typeArguments = this.visitTypeArgumentList(node.typeArgumentList);
            var result = new TypeScript.GenericType(underlying, typeArguments);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeAnnotation = function (node) {
            if (!node) {
                return null;
            }
            var start = this.position;
            this.movePast(node.colonToken);
            var type = this.visitType(node.type);
            var result = new TypeScript.TypeAnnotation(type);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitBlock = function (node) {
            if (!node) {
                return null;
            }
            var start = this.position;
            this.movePast(node.openBraceToken);
            var statements = this.visitSyntaxList(node.statements);
            var closeBracePosition = this.position;
            var closeBraceLeadingComments = this.convertTokenLeadingComments(node.closeBraceToken, this.position);
            var closeBraceToken = this.createTokenSpan(this.position, node.closeBraceToken);
            this.movePast(node.closeBraceToken);
            var result = new TypeScript.Block(statements, closeBraceLeadingComments, closeBraceToken);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitParameter = function (node) {
            var start = this.position;
            var dotDotDotToken = this.createTokenSpan(this.position, node.dotDotDotToken);
            this.moveTo(node, node.identifier);
            var identifier = this.visitIdentifier(node.identifier);
            var questionToken = this.createTokenSpan(this.position, node.questionToken);
            this.movePast(node.questionToken);
            var typeExpr = this.visitTypeAnnotation(node.typeAnnotation);
            var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;
            var modifiers = this.visitModifiers(node.modifiers);
            var result = new TypeScript.Parameter(dotDotDotToken, modifiers, identifier, questionToken, typeExpr, init);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitMemberAccessExpression = function (node) {
            var start = this.position;
            var expression = node.expression.accept(this);
            this.movePast(node.dotToken);
            var name = this.visitIdentifier(node.name);
            var result = new TypeScript.MemberAccessExpression(expression, name);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            var start = this.position;
            var operand = node.operand.accept(this);
            this.movePast(node.operatorToken);
            var result = new TypeScript.PostfixUnaryExpression(node.kind() === TypeScript.SyntaxKind.PostIncrementExpression ? TypeScript.SyntaxKind.PostIncrementExpression : TypeScript.SyntaxKind.PostDecrementExpression, operand);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitElementAccessExpression = function (node) {
            var start = this.position;
            var expression = node.expression.accept(this);
            this.movePast(node.openBracketToken);
            var argumentExpression = node.argumentExpression.accept(this);
            this.movePast(node.closeBracketToken);
            var result = new TypeScript.ElementAccessExpression(expression, argumentExpression);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitInvocationExpression = function (node) {
            var start = this.position;
            var expression = node.expression.accept(this);
            var argumentList = this.visitArgumentList(node.argumentList);
            var result = new TypeScript.InvocationExpression(expression, argumentList);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitArgumentList = function (node) {
            if (node === null) {
                return null;
            }
            var start = this.position;
            var typeArguments = this.visitTypeArgumentList(node.typeArgumentList);
            this.movePast(node.openParenToken);
            var args = this.visitSeparatedSyntaxList(node.args);
            if (node.args.fullWidth() === 0 && node.closeParenToken.fullWidth() === 0) {
                var openParenTokenEnd = start + node.openParenToken.leadingTriviaWidth() + node.openParenToken.width();
                this.setSpanExplicit(args, openParenTokenEnd, openParenTokenEnd + node.openParenToken.trailingTriviaWidth());
            }
            var closeParenToken = this.createTokenSpan(this.position, node.closeParenToken);
            this.movePast(node.closeParenToken);
            var result = new TypeScript.ArgumentList(typeArguments, args, closeParenToken);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitBinaryExpression = function (node) {
            var start = this.position;
            var left = node.left.accept(this);
            this.movePast(node.operatorToken);
            var right = node.right.accept(this);
            var result = new TypeScript.BinaryExpression(node.kind(), left, right);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConditionalExpression = function (node) {
            var start = this.position;
            var condition = node.condition.accept(this);
            this.movePast(node.questionToken);
            var whenTrue = node.whenTrue.accept(this);
            this.movePast(node.colonToken);
            var whenFalse = node.whenFalse.accept(this);
            var result = new TypeScript.ConditionalExpression(condition, whenTrue, whenFalse);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConstructSignature = function (node) {
            var start = this.position;
            this.movePast(node.newKeyword);
            var callSignature = this.visitCallSignature(node.callSignature);
            var result = new TypeScript.ConstructSignature(callSignature);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitMethodSignature = function (node) {
            var start = this.position;
            var name = this.visitToken(node.propertyName);
            var questionToken = this.createTokenSpan(this.position, node.questionToken);
            this.movePast(node.questionToken);
            var callSignature = this.visitCallSignature(node.callSignature);
            var result = new TypeScript.MethodSignature(name, questionToken, callSignature);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitIndexSignature = function (node) {
            var start = this.position;
            this.movePast(node.openBracketToken);
            var parameter = node.parameter.accept(this);
            this.movePast(node.closeBracketToken);
            var returnType = this.visitTypeAnnotation(node.typeAnnotation);
            var result = new TypeScript.IndexSignature(parameter, returnType);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitPropertySignature = function (node) {
            var start = this.position;
            var name = this.visitToken(node.propertyName);
            var questionToken = this.createTokenSpan(this.position, node.questionToken);
            this.movePast(node.questionToken);
            var typeExpr = this.visitTypeAnnotation(node.typeAnnotation);
            var result = new TypeScript.PropertySignature(name, questionToken, typeExpr);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitParameterList = function (node) {
            if (!node) {
                return null;
            }
            var start = this.position;
            var openParenToken = node.openParenToken;
            this.previousTokenTrailingComments = this.convertTokenTrailingComments(openParenToken, start + openParenToken.leadingTriviaWidth() + openParenToken.width());
            var openParenTrailingComments = null;
            if (node.parameters.childCount() === 0) {
                openParenTrailingComments = this.previousTokenTrailingComments;
                this.previousTokenTrailingComments = null;
            }
            this.movePast(node.openParenToken);
            var parameters = this.visitSeparatedSyntaxList(node.parameters);
            this.movePast(node.closeParenToken);
            var result = new TypeScript.ParameterList(openParenTrailingComments, parameters);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitCallSignature = function (node) {
            var start = this.position;
            var typeParameters = this.visitTypeParameterList(node.typeParameterList);
            var parameters = this.visitParameterList(node.parameterList);
            var returnType = this.visitTypeAnnotation(node.typeAnnotation);
            var result = new TypeScript.CallSignature(typeParameters, parameters, returnType);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeParameterList = function (node) {
            if (!node) {
                return null;
            }
            var start = this.position;
            this.movePast(node.lessThanToken);
            var typeParameters = this.visitSeparatedSyntaxList(node.typeParameters);
            this.movePast(node.greaterThanToken);
            var result = new TypeScript.TypeParameterList(typeParameters);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeParameter = function (node) {
            var start = this.position;
            var identifier = this.visitIdentifier(node.identifier);
            var constraint = node.constraint ? node.constraint.accept(this) : null;
            var result = new TypeScript.TypeParameter(identifier, constraint);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConstraint = function (node) {
            var start = this.position;
            this.movePast(node.extendsKeyword);
            var type = this.visitType(node.type);
            var result = new TypeScript.Constraint(type);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitIfStatement = function (node) {
            var start = this.position;
            this.moveTo(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var thenBod = node.statement.accept(this);
            var elseBod = node.elseClause ? node.elseClause.accept(this) : null;
            var result = new TypeScript.IfStatement(condition, thenBod, elseBod);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitElseClause = function (node) {
            var start = this.position;
            this.movePast(node.elseKeyword);
            var statement = node.statement.accept(this);
            var result = new TypeScript.ElseClause(statement);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitExpressionStatement = function (node) {
            var start = this.position;
            var preComments = this.convertTokenLeadingComments(node.firstToken(), start);
            var expression = node.expression.accept(this);
            var semicolonPosition = this.position;
            var postComments = this.convertComments(node.semicolonToken.trailingTrivia(), this.position + node.semicolonToken.leadingTriviaWidth() + node.semicolonToken.width());
            this.movePast(node.semicolonToken);
            var result = new TypeScript.ExpressionStatement(expression);
            this.setSpan(result, start, node);
            result.setPreComments(preComments);
            result.setPostComments(postComments);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConstructorDeclaration = function (node) {
            var start = this.position;
            this.moveTo(node, node.parameterList);
            var parameters = this.visitParameterList(node.parameterList);
            var block = node.block ? node.block.accept(this) : null;
            this.movePast(node.semicolonToken);
            var result = new TypeScript.ConstructorDeclaration(parameters, block);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitIndexMemberDeclaration = function (node) {
            var start = this.position;
            this.moveTo(node, node.indexSignature);
            var indexSignature = node.indexSignature.accept(this);
            this.movePast(node.semicolonToken);
            var result = new TypeScript.IndexMemberDeclaration(indexSignature);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            var start = this.position;
            this.moveTo(node, node.propertyName);
            var name = this.visitToken(node.propertyName);
            var callSignature = this.visitCallSignature(node.callSignature);
            var block = node.block ? this.visitBlock(node.block) : null;
            this.movePast(node.semicolonToken);
            var result = new TypeScript.MemberFunctionDeclaration(this.visitModifiers(node.modifiers), name, callSignature, block);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitGetAccessor = function (node) {
            var start = this.position;
            this.moveTo(node, node.propertyName);
            var name = this.visitToken(node.propertyName);
            var parameters = this.visitParameterList(node.parameterList);
            var returnType = this.visitTypeAnnotation(node.typeAnnotation);
            var block = node.block ? node.block.accept(this) : null;
            var result = new TypeScript.GetAccessor(this.visitModifiers(node.modifiers), name, parameters, returnType, block);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSetAccessor = function (node) {
            var start = this.position;
            this.moveTo(node, node.propertyName);
            var name = this.visitToken(node.propertyName);
            var parameters = this.visitParameterList(node.parameterList);
            var block = node.block ? node.block.accept(this) : null;
            var result = new TypeScript.SetAccessor(this.visitModifiers(node.modifiers), name, parameters, block);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            var start = this.position;
            this.moveTo(node, node.variableDeclarator);
            var variableDeclarator = node.variableDeclarator.accept(this);
            this.movePast(node.semicolonToken);
            var modifiers = this.visitModifiers(node.modifiers);
            var result = new TypeScript.MemberVariableDeclaration(modifiers, variableDeclarator);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitThrowStatement = function (node) {
            var start = this.position;
            this.movePast(node.throwKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.semicolonToken);
            var result = new TypeScript.ThrowStatement(expression);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitReturnStatement = function (node) {
            var start = this.position;
            this.movePast(node.returnKeyword);
            var expression = node.expression ? node.expression.accept(this) : null;
            this.movePast(node.semicolonToken);
            var result = new TypeScript.ReturnStatement(expression);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitObjectCreationExpression = function (node) {
            var start = this.position;
            this.movePast(node.newKeyword);
            var expression = node.expression.accept(this);
            var argumentList = this.visitArgumentList(node.argumentList);
            var result = new TypeScript.ObjectCreationExpression(expression, argumentList);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSwitchStatement = function (node) {
            var start = this.position;
            this.movePast(node.switchKeyword);
            this.movePast(node.openParenToken);
            var expression = node.expression.accept(this);
            var closeParenToken = this.createTokenSpan(this.position, node.closeParenToken);
            this.movePast(node.closeParenToken);
            this.movePast(node.openBraceToken);
            var switchClauses = this.visitSyntaxList(node.switchClauses);
            this.movePast(node.closeBraceToken);
            var result = new TypeScript.SwitchStatement(expression, closeParenToken, switchClauses);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitCaseSwitchClause = function (node) {
            var start = this.position;
            this.movePast(node.caseKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.colonToken);
            var statements = this.visitSyntaxList(node.statements);
            var result = new TypeScript.CaseSwitchClause(expression, statements);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitDefaultSwitchClause = function (node) {
            var start = this.position;
            this.movePast(node.defaultKeyword);
            this.movePast(node.colonToken);
            var statements = this.visitSyntaxList(node.statements);
            var result = new TypeScript.DefaultSwitchClause(statements);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitBreakStatement = function (node) {
            var start = this.position;
            this.movePast(node.breakKeyword);
            var identifier = node.identifier ? node.identifier.accept(this) : null;
            this.movePast(node.semicolonToken);
            var result = new TypeScript.BreakStatement(identifier);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitContinueStatement = function (node) {
            var start = this.position;
            this.movePast(node.continueKeyword);
            var identifier = node.identifier ? node.identifier.accept(this) : null;
            this.movePast(node.semicolonToken);
            var result = new TypeScript.ContinueStatement(identifier);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitForStatement = function (node) {
            var start = this.position;
            this.movePast(node.forKeyword);
            this.movePast(node.openParenToken);
            var variableDeclaration = node.variableDeclaration ? node.variableDeclaration.accept(this) : null;
            var initializer = node.initializer ? node.initializer.accept(this) : null;
            this.movePast(node.firstSemicolonToken);
            var cond = node.condition ? node.condition.accept(this) : null;
            this.movePast(node.secondSemicolonToken);
            var incr = node.incrementor ? node.incrementor.accept(this) : null;
            this.movePast(node.closeParenToken);
            var body = node.statement.accept(this);
            var result = new TypeScript.ForStatement(variableDeclaration, initializer, cond, incr, body);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitForInStatement = function (node) {
            var start = this.position;
            this.movePast(node.forKeyword);
            this.movePast(node.openParenToken);
            var variableDeclaration = node.variableDeclaration ? node.variableDeclaration.accept(this) : null;
            var left = node.left ? node.left.accept(this) : null;
            this.movePast(node.inKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            var body = node.statement.accept(this);
            var result = new TypeScript.ForInStatement(variableDeclaration, left, expression, body);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitWhileStatement = function (node) {
            var start = this.position;
            this.moveTo(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var statement = node.statement.accept(this);
            var result = new TypeScript.WhileStatement(condition, statement);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitWithStatement = function (node) {
            var start = this.position;
            this.moveTo(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var statement = node.statement.accept(this);
            var result = new TypeScript.WithStatement(condition, statement);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitCastExpression = function (node) {
            var start = this.position;
            this.movePast(node.lessThanToken);
            var castTerm = this.visitType(node.type);
            this.movePast(node.greaterThanToken);
            var expression = node.expression.accept(this);
            var result = new TypeScript.CastExpression(castTerm, expression);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitObjectLiteralExpression = function (node) {
            var start = this.position;
            var openStart = this.position + node.openBraceToken.leadingTriviaWidth();
            this.movePast(node.openBraceToken);
            var propertyAssignments = this.visitSeparatedSyntaxList(node.propertyAssignments);
            var closeStart = this.position + node.closeBraceToken.leadingTriviaWidth();
            this.movePast(node.closeBraceToken);
            var result = new TypeScript.ObjectLiteralExpression(propertyAssignments);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            var start = this.position;
            var preComments = this.convertTokenLeadingComments(node.firstToken(), start);
            var postComments = this.convertNodeTrailingComments(node, node.lastToken(), start);
            var propertyName = node.propertyName.accept(this);
            var afterColonComments = this.convertTokenTrailingComments(node.colonToken, this.position + node.colonToken.leadingTriviaWidth() + node.colonToken.width());
            this.movePast(node.colonToken);
            var expression = node.expression.accept(this);
            expression.setPreComments(this.mergeComments(afterColonComments, expression.preComments()));
            var result = new TypeScript.SimplePropertyAssignment(propertyName, expression);
            this.setSpan(result, start, node);
            result.setPreComments(preComments);
            result.setPostComments(postComments);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitFunctionPropertyAssignment = function (node) {
            var start = this.position;
            var propertyName = node.propertyName.accept(this);
            var callSignature = this.visitCallSignature(node.callSignature);
            var block = this.visitBlock(node.block);
            var result = new TypeScript.FunctionPropertyAssignment(propertyName, callSignature, block);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitFunctionExpression = function (node) {
            var start = this.position;
            this.movePast(node.functionKeyword);
            var name = node.identifier === null ? null : this.visitIdentifier(node.identifier);
            var callSignature = this.visitCallSignature(node.callSignature);
            var block = node.block ? node.block.accept(this) : null;
            var result = new TypeScript.FunctionExpression(name, callSignature, block);
            this.setCommentsAndSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitEmptyStatement = function (node) {
            var start = this.position;
            this.movePast(node.semicolonToken);
            var result = new TypeScript.EmptyStatement();
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTryStatement = function (node) {
            var start = this.position;
            this.movePast(node.tryKeyword);
            var tryBody = node.block.accept(this);
            var catchClause = null;
            if (node.catchClause !== null) {
                catchClause = node.catchClause.accept(this);
            }
            var finallyBody = null;
            if (node.finallyClause !== null) {
                finallyBody = node.finallyClause.accept(this);
            }
            var result = new TypeScript.TryStatement(tryBody, catchClause, finallyBody);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitCatchClause = function (node) {
            var start = this.position;
            this.movePast(node.catchKeyword);
            this.movePast(node.openParenToken);
            var identifier = this.visitIdentifier(node.identifier);
            var typeAnnotation = this.visitTypeAnnotation(node.typeAnnotation);
            this.movePast(node.closeParenToken);
            var block = node.block.accept(this);
            var result = new TypeScript.CatchClause(identifier, typeAnnotation, block);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitFinallyClause = function (node) {
            var start = this.position;
            this.movePast(node.finallyKeyword);
            var block = node.block.accept(this);
            var result = new TypeScript.FinallyClause(block);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitLabeledStatement = function (node) {
            var start = this.position;
            var identifier = this.visitIdentifier(node.identifier);
            this.movePast(node.colonToken);
            var statement = node.statement.accept(this);
            var result = new TypeScript.LabeledStatement(identifier, statement);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitDoStatement = function (node) {
            var start = this.position;
            this.movePast(node.doKeyword);
            var statement = node.statement.accept(this);
            var whileKeyword = this.createTokenSpan(this.position, node.whileKeyword);
            this.movePast(node.whileKeyword);
            this.movePast(node.openParenToken);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            this.movePast(node.semicolonToken);
            var result = new TypeScript.DoStatement(statement, whileKeyword, condition);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeOfExpression = function (node) {
            var start = this.position;
            this.movePast(node.typeOfKeyword);
            var expression = node.expression.accept(this);
            var result = new TypeScript.TypeOfExpression(expression);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitDeleteExpression = function (node) {
            var start = this.position;
            this.movePast(node.deleteKeyword);
            var expression = node.expression.accept(this);
            var result = new TypeScript.DeleteExpression(expression);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitVoidExpression = function (node) {
            var start = this.position;
            this.movePast(node.voidKeyword);
            var expression = node.expression.accept(this);
            var result = new TypeScript.VoidExpression(expression);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitDebuggerStatement = function (node) {
            var start = this.position;
            this.movePast(node.debuggerKeyword);
            this.movePast(node.semicolonToken);
            var result = new TypeScript.DebuggerStatement();
            this.setSpan(result, start, node);
            return result;
        };
        return SyntaxTreeToAstVisitor;
    }());
    TypeScript.SyntaxTreeToAstVisitor = SyntaxTreeToAstVisitor;
    function applyDelta(ast, delta) {
        if (ast) {
            if (ast._start !== -1) {
                ast._start += delta;
            }
            if (ast._end !== -1) {
                ast._end += delta;
            }
        }
    }
    function applyDeltaToComments(comments, delta) {
        if (comments && comments.length > 0) {
            for (var i = 0; i < comments.length; i++) {
                var comment = comments[i];
                applyDelta(comment, delta);
            }
        }
    }
    var SyntaxTreeToIncrementalAstVisitor = (function (_super) {
        __extends(SyntaxTreeToIncrementalAstVisitor, _super);
        function SyntaxTreeToIncrementalAstVisitor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SyntaxTreeToIncrementalAstVisitor.prototype.applyDelta = function (ast, delta) {
            if (delta === 0) {
                return;
            }
            var pre = function (cur) {
                applyDelta(cur, delta);
                applyDeltaToComments(cur.preComments(), delta);
                applyDeltaToComments(cur.postComments(), delta);
                switch (cur.kind()) {
                    case TypeScript.SyntaxKind.Block:
                        applyDelta(cur.closeBraceToken, delta);
                        break;
                    case TypeScript.SyntaxKind.ArgumentList:
                        applyDelta(cur.closeParenToken, delta);
                        break;
                    case TypeScript.SyntaxKind.ModuleDeclaration:
                        applyDelta(cur.endingToken, delta);
                        break;
                    case TypeScript.SyntaxKind.ClassDeclaration:
                        applyDelta(cur.closeBraceToken, delta);
                        break;
                    case TypeScript.SyntaxKind.DoStatement:
                        applyDelta(cur.whileKeyword, delta);
                        break;
                    case TypeScript.SyntaxKind.SwitchStatement:
                        applyDelta(cur.closeParenToken, delta);
                        break;
                }
            };
            TypeScript.getAstWalkerFactory().simpleWalk(ast, pre);
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.setSpanExplicit = function (span, start, end) {
            if (span._start !== -1) {
                var delta = start - span._start;
                this.applyDelta(span, delta);
                span._end = end;
            }
            else {
                _super.prototype.setSpanExplicit.call(this, span, start, end);
            }
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.getAndMovePastAST = function (element) {
            if (this.previousTokenTrailingComments !== null) {
                return null;
            }
            var result = element._ast;
            if (!result) {
                return null;
            }
            var start = this.position;
            this.movePast(element);
            this.setSpan(result, start, element);
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.setAST = function (element, ast) {
            element._ast = ast;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitSyntaxList = function (list) {
            var result = this.getAndMovePastAST(list);
            if (!result) {
                result = _super.prototype.visitSyntaxList.call(this, list);
                if (list.childCount() > 0) {
                    this.setAST(list, result);
                }
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitSeparatedSyntaxList = function (list) {
            var result = this.getAndMovePastAST(list);
            if (!result) {
                result = _super.prototype.visitSeparatedSyntaxList.call(this, list);
                if (list.childCount() > 0) {
                    this.setAST(list, result);
                }
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitToken = function (token) {
            var result = this.getAndMovePastAST(token);
            if (!result) {
                result = _super.prototype.visitToken.call(this, token);
                this.setAST(token, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitClassDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitClassDeclaration.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitInterfaceDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitInterfaceDeclaration.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitHeritageClause = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitHeritageClause.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitModuleDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitModuleDeclaration.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitFunctionDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitFunctionDeclaration.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitImportDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitImportDeclaration.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitExportAssignment = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitExportAssignment.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitPrefixUnaryExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitArrayLiteralExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitArrayLiteralExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitOmittedExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitOmittedExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitParenthesizedExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitParenthesizedExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitSimpleArrowFunctionExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitParenthesizedArrowFunctionExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitQualifiedName = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                var result = _super.prototype.visitQualifiedName.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitConstructorType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitConstructorType.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitFunctionType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitFunctionType.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitObjectType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitObjectType.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitArrayType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitArrayType.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitTupleType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitTupleType.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitGenericType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitGenericType.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitBlock = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitBlock.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitParameter = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitParameter.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitMemberAccessExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMemberAccessExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitPostfixUnaryExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitElementAccessExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitElementAccessExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitInvocationExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitInvocationExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitBinaryExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitBinaryExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitConditionalExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitConditionalExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitConstructSignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitConstructSignature.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitMethodSignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMethodSignature.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitIndexSignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitIndexSignature.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitPropertySignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitPropertySignature.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitCallSignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitCallSignature.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitTypeParameter = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitTypeParameter.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitIfStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitIfStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitExpressionStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitExpressionStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitConstructorDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitConstructorDeclaration.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMemberFunctionDeclaration.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitGetAccessor = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitGetAccessor.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitSetAccessor = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitSetAccessor.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMemberVariableDeclaration.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitThrowStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitThrowStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitReturnStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitReturnStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitObjectCreationExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitObjectCreationExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitSwitchStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitSwitchStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitCaseSwitchClause = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitCaseSwitchClause.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitDefaultSwitchClause = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitDefaultSwitchClause.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitBreakStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitBreakStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitContinueStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitContinueStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitForStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitForStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitForInStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitForInStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitWhileStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitWhileStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitWithStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitWithStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitCastExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitCastExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitObjectLiteralExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitObjectLiteralExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitSimplePropertyAssignment.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitFunctionPropertyAssignment = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitFunctionPropertyAssignment.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitFunctionExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitFunctionExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitEmptyStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitEmptyStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitTryStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitTryStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitCatchClause = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitCatchClause.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitLabeledStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitLabeledStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitDoStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitDoStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitTypeOfExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitTypeOfExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitDeleteExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitDeleteExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitVoidExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitVoidExpression.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        SyntaxTreeToIncrementalAstVisitor.prototype.visitDebuggerStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitDebuggerStatement.call(this, node);
                this.setAST(node, result);
            }
            return result;
        };
        return SyntaxTreeToIncrementalAstVisitor;
    }(SyntaxTreeToAstVisitor));
})(TypeScript || (TypeScript = {}));
if (Error)
    Error.stackTraceLimit = 1000;
var TypeScript;
(function (TypeScript) {
    TypeScript.fileResolutionTime = 0;
    TypeScript.fileResolutionIOTime = 0;
    TypeScript.fileResolutionScanImportsTime = 0;
    TypeScript.fileResolutionImportFileSearchTime = 0;
    TypeScript.fileResolutionGetDefaultLibraryTime = 0;
    TypeScript.sourceCharactersCompiled = 0;
    TypeScript.syntaxTreeParseTime = 0;
    TypeScript.syntaxDiagnosticsTime = 0;
    TypeScript.astTranslationTime = 0;
    TypeScript.typeCheckTime = 0;
    TypeScript.soundTypeCheckTime = 0;
    TypeScript.compilerResolvePathTime = 0;
    TypeScript.compilerDirectoryNameTime = 0;
    TypeScript.compilerDirectoryExistsTime = 0;
    TypeScript.compilerFileExistsTime = 0;
    TypeScript.emitTime = 0;
    TypeScript.emitWriteFileTime = 0;
    TypeScript.declarationEmitTime = 0;
    TypeScript.declarationEmitIsExternallyVisibleTime = 0;
    TypeScript.declarationEmitTypeSignatureTime = 0;
    TypeScript.declarationEmitGetBoundDeclTypeTime = 0;
    TypeScript.declarationEmitIsOverloadedCallSignatureTime = 0;
    TypeScript.declarationEmitFunctionDeclarationGetSymbolTime = 0;
    TypeScript.declarationEmitGetBaseTypeTime = 0;
    TypeScript.declarationEmitGetAccessorFunctionTime = 0;
    TypeScript.declarationEmitGetTypeParameterSymbolTime = 0;
    TypeScript.declarationEmitGetImportDeclarationSymbolTime = 0;
    TypeScript.ioHostResolvePathTime = 0;
    TypeScript.ioHostDirectoryNameTime = 0;
    TypeScript.ioHostCreateDirectoryStructureTime = 0;
    TypeScript.ioHostWriteFileTime = 0;
    var EmitOutput = (function () {
        function EmitOutput() {
            this.outputFiles = [];
            this.diagnostics = [];
        }
        return EmitOutput;
    }());
    TypeScript.EmitOutput = EmitOutput;
    var OutputFileType;
    (function (OutputFileType) {
        OutputFileType[OutputFileType["JavaScript"] = 0] = "JavaScript";
        OutputFileType[OutputFileType["SourceMap"] = 1] = "SourceMap";
        OutputFileType[OutputFileType["Declaration"] = 2] = "Declaration";
    })(OutputFileType = TypeScript.OutputFileType || (TypeScript.OutputFileType = {}));
    var OutputFile = (function () {
        function OutputFile(name, writeByteOrderMark, text, fileType, sourceMapEntries) {
            if (sourceMapEntries === void 0) { sourceMapEntries = []; }
            this.name = name;
            this.writeByteOrderMark = writeByteOrderMark;
            this.text = text;
            this.fileType = fileType;
            this.sourceMapEntries = sourceMapEntries;
        }
        return OutputFile;
    }());
    TypeScript.OutputFile = OutputFile;
    var CompileResult = (function () {
        function CompileResult() {
            this.diagnostics = [];
            this.outputFiles = [];
        }
        CompileResult.fromDiagnostics = function (diagnostics) {
            var result = new CompileResult();
            result.diagnostics = diagnostics;
            return result;
        };
        CompileResult.fromOutputFiles = function (outputFiles) {
            var result = new CompileResult();
            result.outputFiles = outputFiles;
            return result;
        };
        return CompileResult;
    }());
    TypeScript.CompileResult = CompileResult;
    var TypeScriptCompiler = (function () {
        function TypeScriptCompiler(logger, _settings) {
            if (logger === void 0) { logger = new TypeScript.NullLogger(); }
            if (_settings === void 0) { _settings = TypeScript.ImmutableCompilationSettings.defaultSettings(); }
            this.logger = logger;
            this._settings = _settings;
            this.semanticInfoChain = null;
            this.semanticInfoChain = new TypeScript.SemanticInfoChain(this, logger);
        }
        TypeScriptCompiler.prototype.compilationSettings = function () {
            return this._settings;
        };
        TypeScriptCompiler.prototype.setCompilationSettings = function (newSettings) {
            var oldSettings = this._settings;
            this._settings = newSettings;
            if (!compareDataObjects(oldSettings, newSettings)) {
                this.semanticInfoChain.invalidate(oldSettings, newSettings);
            }
        };
        TypeScriptCompiler.prototype.getDocument = function (fileName) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            return this.semanticInfoChain.getDocument(fileName);
        };
        TypeScriptCompiler.prototype.cleanupSemanticCache = function () {
            this.semanticInfoChain.invalidate();
        };
        TypeScriptCompiler.prototype.addFile = function (fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles) {
            if (referencedFiles === void 0) { referencedFiles = []; }
            fileName = TypeScript.switchToForwardSlashes(fileName);
            TypeScript.sourceCharactersCompiled += scriptSnapshot.getLength();
            var document = TypeScript.Document.create(this, this.semanticInfoChain, fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles);
            this.semanticInfoChain.addDocument(document);
        };
        TypeScriptCompiler.prototype.updateFile = function (fileName, scriptSnapshot, version, isOpen, textChangeRange) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var document = this.getDocument(fileName);
            var updatedDocument = document.update(scriptSnapshot, version, isOpen, textChangeRange);
            this.semanticInfoChain.addDocument(updatedDocument);
        };
        TypeScriptCompiler.prototype.removeFile = function (fileName) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            this.semanticInfoChain.removeDocument(fileName);
        };
        TypeScriptCompiler.prototype._isDynamicModuleCompilation = function () {
            var fileNames = this.fileNames();
            for (var i = 0, n = fileNames.length; i < n; i++) {
                var document = this.getDocument(fileNames[i]);
                if (!document.isDeclareFile() && document.isExternalModule()) {
                    return true;
                }
            }
            return false;
        };
        TypeScriptCompiler.prototype.mapOutputFileName = function (document, emitOptions, extensionChanger) {
            if (document.emitToOwnOutputFile()) {
                var updatedFileName = document.fileName;
                if (emitOptions.outputDirectory() !== "") {
                    updatedFileName = document.fileName.replace(emitOptions.commonDirectoryPath(), "");
                    updatedFileName = emitOptions.outputDirectory() + updatedFileName;
                }
                return extensionChanger(updatedFileName, false);
            }
            else {
                return extensionChanger(emitOptions.sharedOutputFile(), true);
            }
        };
        TypeScriptCompiler.prototype.writeByteOrderMarkForDocument = function (document) {
            var printReason = false;
            if (document.emitToOwnOutputFile()) {
                var result = document.byteOrderMark !== TypeScript.ByteOrderMark.None;
                if (printReason) {
                    TypeScript.Environment.standardOut.WriteLine("Emitting byte order mark because of: " + document.fileName);
                }
                return result;
            }
            else {
                var fileNames = this.fileNames();
                var result = false;
                for (var i = 0, n = fileNames.length; i < n; i++) {
                    var document = this.getDocument(fileNames[i]);
                    if (document.isExternalModule()) {
                        continue;
                    }
                    if (document.byteOrderMark !== TypeScript.ByteOrderMark.None) {
                        if (printReason) {
                            TypeScript.Environment.standardOut.WriteLine("Emitting byte order mark because of: " + document.fileName);
                            result = true;
                        }
                        else {
                            return true;
                        }
                    }
                }
                return result;
            }
        };
        TypeScriptCompiler.mapToDTSFileName = function (fileName, wholeFileNameReplaced) {
            return TypeScript.getDeclareFilePath(fileName);
        };
        TypeScriptCompiler.prototype._shouldEmit = function (document) {
            return !document.isDeclareFile();
        };
        TypeScriptCompiler.prototype._shouldEmitDeclarations = function (document) {
            if (!this.compilationSettings().generateDeclarationFiles()) {
                return false;
            }
            return this._shouldEmit(document);
        };
        TypeScriptCompiler.prototype.emitDocumentDeclarationsWorker = function (document, emitOptions, declarationEmitter) {
            var sourceUnit = document.sourceUnit();
            TypeScript.Debug.assert(this._shouldEmitDeclarations(document));
            if (declarationEmitter) {
                declarationEmitter.document = document;
            }
            else {
                var declareFileName = this.mapOutputFileName(document, emitOptions, function (fn, wnr) { return TypeScriptCompiler.mapToDTSFileName(fn, wnr); });
                declarationEmitter = new DeclarationEmitter(declareFileName, document, this, emitOptions, this.semanticInfoChain);
            }
            declarationEmitter.emitDeclarations(sourceUnit);
            return declarationEmitter;
        };
        TypeScriptCompiler.prototype._emitDocumentDeclarations = function (document, emitOptions, onSingleFileEmitComplete, sharedEmitter) {
            if (this._shouldEmitDeclarations(document)) {
                if (document.emitToOwnOutputFile()) {
                    var singleEmitter = this.emitDocumentDeclarationsWorker(document, emitOptions);
                    if (singleEmitter) {
                        onSingleFileEmitComplete(singleEmitter.getOutputFile());
                    }
                }
                else {
                    sharedEmitter = this.emitDocumentDeclarationsWorker(document, emitOptions, sharedEmitter);
                }
            }
            return sharedEmitter;
        };
        TypeScriptCompiler.prototype.emitAllDeclarations = function (resolvePath) {
            var start = new Date().getTime();
            var emitOutput = new EmitOutput();
            var emitOptions = new TypeScript.EmitOptions(this, resolvePath);
            if (emitOptions.diagnostic()) {
                emitOutput.diagnostics.push(emitOptions.diagnostic());
                return emitOutput;
            }
            var sharedEmitter = null;
            var fileNames = this.fileNames();
            for (var i = 0, n = fileNames.length; i < n; i++) {
                var fileName = fileNames[i];
                var document = this.getDocument(fileNames[i]);
                sharedEmitter = this._emitDocumentDeclarations(document, emitOptions, function (file) { emitOutput.outputFiles.push(file); }, sharedEmitter);
            }
            if (sharedEmitter) {
                emitOutput.outputFiles.push(sharedEmitter.getOutputFile());
            }
            TypeScript.declarationEmitTime += new Date().getTime() - start;
            return emitOutput;
        };
        TypeScriptCompiler.prototype.emitDeclarations = function (fileName, resolvePath) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var emitOutput = new EmitOutput();
            var emitOptions = new TypeScript.EmitOptions(this, resolvePath);
            if (emitOptions.diagnostic()) {
                emitOutput.diagnostics.push(emitOptions.diagnostic());
                return emitOutput;
            }
            var document = this.getDocument(fileName);
            if (document.emitToOwnOutputFile()) {
                this._emitDocumentDeclarations(document, emitOptions, function (file) { emitOutput.outputFiles.push(file); }, null);
                return emitOutput;
            }
            else {
                return this.emitAllDeclarations(resolvePath);
            }
        };
        TypeScriptCompiler.mapToFileNameExtension = function (extension, fileName, wholeFileNameReplaced) {
            if (wholeFileNameReplaced) {
                return fileName;
            }
            else {
                var splitFname = fileName.split(".");
                splitFname.pop();
                return splitFname.join(".") + extension;
            }
        };
        TypeScriptCompiler.mapToJSFileName = function (fileName, wholeFileNameReplaced) {
            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);
        };
        TypeScriptCompiler.prototype.emitDocumentWorker = function (document, emitOptions, emitter) {
            var sourceUnit = document.sourceUnit();
            TypeScript.Debug.assert(this._shouldEmit(document));
            var typeScriptFileName = document.fileName;
            if (!emitter) {
                var javaScriptFileName = this.mapOutputFileName(document, emitOptions, function (fn, wnr) { return TypeScriptCompiler.mapToJSFileName(fn, wnr); });
                var outFile = new TextWriter(javaScriptFileName, this.writeByteOrderMarkForDocument(document), OutputFileType.JavaScript);
                emitter = new TypeScript.Emitter(javaScriptFileName, outFile, emitOptions, this.semanticInfoChain);
                if (this.compilationSettings().mapSourceFiles()) {
                    var sourceMapFile = new TextWriter(javaScriptFileName + TypeScript.SourceMapper.MapFileExtension, false, OutputFileType.SourceMap);
                    emitter.createSourceMapper(document, javaScriptFileName, outFile, sourceMapFile, emitOptions.resolvePath);
                }
            }
            else if (this.compilationSettings().mapSourceFiles()) {
                emitter.setSourceMapperNewSourceFile(document);
            }
            emitter.setDocument(document);
            emitter.emitJavascript(sourceUnit, false);
            return emitter;
        };
        TypeScriptCompiler.prototype._emitDocument = function (document, emitOptions, onSingleFileEmitComplete, sharedEmitter) {
            if (this._shouldEmit(document)) {
                if (document.emitToOwnOutputFile()) {
                    var singleEmitter = this.emitDocumentWorker(document, emitOptions);
                    if (singleEmitter) {
                        onSingleFileEmitComplete(singleEmitter.getOutputFiles());
                    }
                }
                else {
                    sharedEmitter = this.emitDocumentWorker(document, emitOptions, sharedEmitter);
                }
            }
            return sharedEmitter;
        };
        TypeScriptCompiler.prototype.emitAll = function (resolvePath) {
            var start = new Date().getTime();
            var emitOutput = new EmitOutput();
            var emitOptions = new TypeScript.EmitOptions(this, resolvePath);
            if (emitOptions.diagnostic()) {
                emitOutput.diagnostics.push(emitOptions.diagnostic());
                return emitOutput;
            }
            var fileNames = this.fileNames();
            var sharedEmitter = null;
            for (var i = 0, n = fileNames.length; i < n; i++) {
                var fileName = fileNames[i];
                var document = this.getDocument(fileName);
                sharedEmitter = this._emitDocument(document, emitOptions, function (files) { return RT.applyVariadic(emitOutput.outputFiles, "push", files); }, sharedEmitter);
            }
            if (sharedEmitter) {
                RT.applyVariadic(emitOutput.outputFiles, "push", sharedEmitter.getOutputFiles());
            }
            TypeScript.emitTime += new Date().getTime() - start;
            return emitOutput;
        };
        TypeScriptCompiler.prototype.emit = function (fileName, resolvePath) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var emitOutput = new EmitOutput();
            var emitOptions = new TypeScript.EmitOptions(this, resolvePath);
            if (emitOptions.diagnostic()) {
                emitOutput.diagnostics.push(emitOptions.diagnostic());
                return emitOutput;
            }
            var document = this.getDocument(fileName);
            if (document.emitToOwnOutputFile()) {
                this._emitDocument(document, emitOptions, function (files) { return RT.applyVariadic(emitOutput.outputFiles, "push", files); }, null);
                return emitOutput;
            }
            else {
                return this.emitAll(resolvePath);
            }
        };
        TypeScriptCompiler.prototype.compile = function (resolvePath, continueOnDiagnostics) {
            if (continueOnDiagnostics === void 0) { continueOnDiagnostics = false; }
            return new CompilerIterator(this, resolvePath, continueOnDiagnostics);
        };
        TypeScriptCompiler.prototype.getSyntacticDiagnostics = function (fileName) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            return this.getDocument(fileName).diagnostics();
        };
        TypeScriptCompiler.prototype.getSyntaxTree = function (fileName) {
            return this.getDocument(fileName).syntaxTree();
        };
        TypeScriptCompiler.prototype.getSourceUnit = function (fileName) {
            return this.getDocument(fileName).sourceUnit();
        };
        TypeScriptCompiler.prototype.processDiagnostics = function (errors) {
            errors = TypeScript.ArrayUtilities.distinct(errors, function (d1, d2) { return TypeScript.Diagnostic.equals(d1, d2); });
            errors.sort(function (d1, d2) {
                if (d1.fileName() < d2.fileName()) {
                    return -1;
                }
                else if (d1.fileName() > d2.fileName()) {
                    return 1;
                }
                if (d1.start() < d2.start()) {
                    return -1;
                }
                else if (d1.start() > d2.start()) {
                    return 1;
                }
                var code1 = TypeScript.diagnosticInformationMap[d1.diagnosticKey()].code;
                var code2 = TypeScript.diagnosticInformationMap[d2.diagnosticKey()].code;
                if (code1 < code2) {
                    return -1;
                }
                else if (code1 > code2) {
                    return 1;
                }
                return 0;
            });
            return errors;
        };
        TypeScriptCompiler.prototype.getSoundSemanticDiagnostics = function (fileName) {
            var _this = this;
            fileName = TypeScript.switchToForwardSlashes(fileName);
            if (!this.compilationSettings().shouldInstrument(fileName)) {
                return [];
            }
            var document = this.getDocument(fileName);
            var startTime = (new Date()).getTime();
            var errors = TypeScript.SoundTypeChecker.check(this.compilationSettings(), this.semanticInfoChain, document);
            TypeScript.soundTypeCheckTime += (new Date()).getTime() - startTime;
            errors = this.processDiagnostics(errors);
            errors.forEach(function (d) { return _this.semanticInfoChain.addDiagnostic(d); });
            return errors;
        };
        TypeScriptCompiler.prototype.getSemanticDiagnostics = function (fileName) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var document = this.getDocument(fileName);
            var startTime = (new Date()).getTime();
            TypeScript.PullTypeResolver.typeCheck(this.compilationSettings(), this.semanticInfoChain, document);
            var endTime = (new Date()).getTime();
            TypeScript.typeCheckTime += endTime - startTime;
            var diags = this.semanticInfoChain.getDiagnostics(fileName);
            return this.processDiagnostics(diags);
        };
        TypeScriptCompiler.prototype.buildSignature = function (fileName) {
            return TypeScript.SoundTypeChecker.buildSignature(this.compilationSettings(), this.semanticInfoChain, this.getDocument(fileName));
        };
        TypeScriptCompiler.prototype.resolveAllFiles = function () {
            var _this = this;
            var fileNames = this.fileNames();
            for (var i = 0, n = fileNames.length; i < n; i++) {
                this.getSemanticDiagnostics(fileNames[i]);
            }
            if (this.compilationSettings().safe() || this.compilationSettings().secure()) {
                if (this.compilationSettings().serviceMode()) {
                    var allFiles = this.semanticInfoChain.fileNames();
                    allFiles.forEach(function (fn) {
                        var sn = fn.substring(fn.lastIndexOf("/") + 1);
                        if (sn === "lib.d.ts") {
                            console.log("TRYING TO CHECK lib.d.ts!");
                            var libDoc = _this.semanticInfoChain.getDocument(fn);
                            TypeScript.PullTypeResolver.typeCheck(_this.compilationSettings(), _this.semanticInfoChain, libDoc);
                            _this.buildSignature(fn);
                        }
                    });
                }
                fileNames.forEach(function (fn) { _this.buildSignature(fn); });
                fileNames.forEach(function (fn) {
                    _this.getSoundSemanticDiagnostics(fileNames[i]);
                });
            }
        };
        TypeScriptCompiler.prototype.getSymbolOfDeclaration = function (decl) {
            if (!decl) {
                return null;
            }
            var resolver = this.semanticInfoChain.getResolver();
            var ast = this.semanticInfoChain.getASTForDecl(decl);
            if (!ast) {
                return null;
            }
            var enclosingDecl = resolver.getEnclosingDecl(decl);
            if (ast.kind() === TypeScript.SyntaxKind.GetAccessor || ast.kind() === TypeScript.SyntaxKind.SetAccessor) {
                return this.getSymbolOfDeclaration(enclosingDecl);
            }
            return resolver.resolveAST(ast, false, new TypeScript.PullTypeResolutionContext(resolver));
        };
        TypeScriptCompiler.prototype.extractResolutionContextFromAST = function (resolver, ast, document, propagateContextualTypes) {
            var scriptName = document.fileName;
            var enclosingDecl = null;
            var enclosingDeclAST = null;
            var inContextuallyTypedAssignment = false;
            var inWithBlock = false;
            var resolutionContext = new TypeScript.PullTypeResolutionContext(resolver);
            if (!ast) {
                return null;
            }
            var path = this.getASTPath(ast);
            for (var i = 0, n = path.length; i < n; i++) {
                var current = path[i];
                switch (current.kind()) {
                    case TypeScript.SyntaxKind.FunctionExpression:
                    case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
                    case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                        if (propagateContextualTypes) {
                            resolver.resolveAST(current, true, resolutionContext);
                        }
                        break;
                    case TypeScript.SyntaxKind.MemberVariableDeclaration:
                        var memberVariable = current;
                        inContextuallyTypedAssignment = memberVariable.variableDeclarator.typeAnnotation !== null;
                        this.extractResolutionContextForVariable(inContextuallyTypedAssignment, propagateContextualTypes, resolver, resolutionContext, enclosingDecl, memberVariable, memberVariable.variableDeclarator.equalsValueClause);
                        break;
                    case TypeScript.SyntaxKind.VariableDeclarator:
                        var variableDeclarator = current;
                        inContextuallyTypedAssignment = variableDeclarator.typeAnnotation !== null;
                        this.extractResolutionContextForVariable(inContextuallyTypedAssignment, propagateContextualTypes, resolver, resolutionContext, enclosingDecl, variableDeclarator, variableDeclarator.equalsValueClause);
                        break;
                    case TypeScript.SyntaxKind.InvocationExpression:
                    case TypeScript.SyntaxKind.ObjectCreationExpression:
                        if (propagateContextualTypes) {
                            var isNew = current.kind() === TypeScript.SyntaxKind.ObjectCreationExpression;
                            var callExpression = current;
                            var contextualType = null;
                            if ((i + 2 < n) && callExpression.argumentList === path[i + 1] && callExpression.argumentList.args === path[i + 2]) {
                                var args = callExpression.argumentList.args;
                                var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();
                                if (isNew) {
                                    resolver.resolveObjectCreationExpression(callExpression, resolutionContext, callResolutionResults);
                                }
                                else {
                                    resolver.resolveInvocationExpression(callExpression, resolutionContext, callResolutionResults);
                                }
                                if (callResolutionResults.actualParametersContextTypeSymbols) {
                                    var argExpression = path[i + 3];
                                    if (argExpression) {
                                        for (var j = 0, m = callExpression.argumentList.args.nonSeparatorCount(); j < m; j++) {
                                            if (callExpression.argumentList.args.nonSeparatorAt(j) === argExpression) {
                                                var callContextualType = callResolutionResults.actualParametersContextTypeSymbols[j];
                                                if (callContextualType) {
                                                    contextualType = callContextualType;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                if (isNew) {
                                    resolver.resolveObjectCreationExpression(callExpression, resolutionContext);
                                }
                                else {
                                    resolver.resolveInvocationExpression(callExpression, resolutionContext);
                                }
                            }
                            resolutionContext.pushContextualType(contextualType, false, null);
                        }
                        break;
                    case TypeScript.SyntaxKind.ArrayLiteralExpression:
                        if (propagateContextualTypes) {
                            var contextualType = null;
                            var currentContextualType = resolutionContext.getContextualType();
                            if (currentContextualType && currentContextualType.isArrayNamedTypeReference()) {
                                contextualType = currentContextualType.getElementType();
                            }
                            resolutionContext.pushContextualType(contextualType, false, null);
                        }
                        break;
                    case TypeScript.SyntaxKind.ObjectLiteralExpression:
                        if (propagateContextualTypes) {
                            var objectLiteralExpression = current;
                            var objectLiteralResolutionContext = new TypeScript.PullAdditionalObjectLiteralResolutionData();
                            resolver.resolveObjectLiteralExpression(objectLiteralExpression, inContextuallyTypedAssignment, resolutionContext, objectLiteralResolutionContext);
                            var memeberAST = (path[i + 1] && path[i + 1].kind() === TypeScript.SyntaxKind.SeparatedList) ? path[i + 2] : path[i + 1];
                            if (memeberAST) {
                                var contextualType = null;
                                var memberDecls = objectLiteralExpression.propertyAssignments;
                                if (memberDecls && objectLiteralResolutionContext.membersContextTypeSymbols) {
                                    for (var j = 0, m = memberDecls.nonSeparatorCount(); j < m; j++) {
                                        if (memberDecls.nonSeparatorAt(j) === memeberAST) {
                                            var memberContextualType = objectLiteralResolutionContext.membersContextTypeSymbols[j];
                                            if (memberContextualType) {
                                                contextualType = memberContextualType;
                                                break;
                                            }
                                        }
                                    }
                                }
                                resolutionContext.pushContextualType(contextualType, false, null);
                            }
                        }
                        break;
                    case TypeScript.SyntaxKind.AssignmentExpression:
                        if (propagateContextualTypes) {
                            var assignmentExpression = current;
                            var contextualType = null;
                            if (path[i + 1] && path[i + 1] === assignmentExpression.right) {
                                var leftType = resolver.resolveAST(assignmentExpression.left, inContextuallyTypedAssignment, resolutionContext).type;
                                if (leftType) {
                                    inContextuallyTypedAssignment = true;
                                    contextualType = leftType;
                                }
                            }
                            resolutionContext.pushContextualType(contextualType, false, null);
                        }
                        break;
                    case TypeScript.SyntaxKind.ReturnStatement:
                        if (propagateContextualTypes) {
                            var returnStatement = current;
                            var contextualType = null;
                            if (enclosingDecl && (enclosingDecl.kind & TypeScript.PullElementKind.SomeFunction)) {
                                var typeAnnotation = TypeScript.getType(enclosingDeclAST);
                                if (typeAnnotation) {
                                    var returnTypeSymbol = resolver.resolveTypeReference(typeAnnotation, resolutionContext);
                                    if (returnTypeSymbol) {
                                        inContextuallyTypedAssignment = true;
                                        contextualType = returnTypeSymbol;
                                    }
                                }
                                else {
                                    var currentContextualType = resolutionContext.getContextualType();
                                    if (currentContextualType && currentContextualType.isFunction()) {
                                        var currentContextualTypeSignatureSymbol = currentContextualType.getDeclarations()[0].getSignatureSymbol();
                                        var currentContextualTypeReturnTypeSymbol = currentContextualTypeSignatureSymbol.returnType;
                                        if (currentContextualTypeReturnTypeSymbol) {
                                            inContextuallyTypedAssignment = true;
                                            contextualType = currentContextualTypeReturnTypeSymbol;
                                        }
                                    }
                                }
                            }
                            resolutionContext.pushContextualType(contextualType, false, null);
                        }
                        break;
                    case TypeScript.SyntaxKind.ObjectType:
                        if (propagateContextualTypes && TypeScript.isTypesOnlyLocation(current)) {
                            resolver.resolveAST(current, false, resolutionContext);
                        }
                        break;
                    case TypeScript.SyntaxKind.WithStatement:
                        inWithBlock = true;
                        break;
                }
                var decl = this.semanticInfoChain.getDeclForAST(current);
                if (decl) {
                    enclosingDecl = decl;
                    enclosingDeclAST = current;
                }
            }
            if (ast && ast.parent && ast.kind() === TypeScript.SyntaxKind.IdentifierName) {
                if (ast.parent.kind() === TypeScript.SyntaxKind.MemberAccessExpression) {
                    if (ast.parent.name === ast) {
                        ast = ast.parent;
                    }
                }
                else if (ast.parent.kind() === TypeScript.SyntaxKind.QualifiedName) {
                    if (ast.parent.right === ast) {
                        ast = ast.parent;
                    }
                }
            }
            return {
                ast: ast,
                enclosingDecl: enclosingDecl,
                resolutionContext: resolutionContext,
                inContextuallyTypedAssignment: inContextuallyTypedAssignment,
                inWithBlock: inWithBlock
            };
        };
        TypeScriptCompiler.prototype.extractResolutionContextForVariable = function (inContextuallyTypedAssignment, propagateContextualTypes, resolver, resolutionContext, enclosingDecl, assigningAST, init) {
            if (inContextuallyTypedAssignment) {
                if (propagateContextualTypes) {
                    resolver.resolveAST(assigningAST, false, resolutionContext);
                    var varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST);
                    var contextualType = null;
                    if (varSymbol && inContextuallyTypedAssignment) {
                        contextualType = varSymbol.type;
                    }
                    resolutionContext.pushContextualType(contextualType, false, null);
                    if (init) {
                        resolver.resolveAST(init, inContextuallyTypedAssignment, resolutionContext);
                    }
                }
            }
        };
        TypeScriptCompiler.prototype.getASTPath = function (ast) {
            var result = [];
            while (ast) {
                result.unshift(ast);
                ast = ast.parent;
            }
            return result;
        };
        TypeScriptCompiler.prototype.pullGetSymbolInformationFromAST = function (ast, document) {
            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, true);
            if (!context || context.inWithBlock) {
                return null;
            }
            ast = context.ast;
            var symbol = resolver.resolveAST(ast, context.inContextuallyTypedAssignment, context.resolutionContext);
            if (!symbol) {
                TypeScript.Debug.assert(ast.kind() == TypeScript.SyntaxKind.SourceUnit, "No symbol was found for ast and ast was not source unit. Ast Kind: " + TypeScript.SyntaxKind[ast.kind()]);
                return null;
            }
            if (symbol.isTypeReference()) {
                symbol = symbol.getReferencedTypeSymbol();
            }
            var aliasSymbol = this.semanticInfoChain.getAliasSymbolForAST(ast);
            return {
                symbol: symbol,
                aliasSymbol: aliasSymbol,
                ast: ast,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };
        TypeScriptCompiler.prototype.pullGetCallInformationFromAST = function (ast, document) {
            if (ast.kind() !== TypeScript.SyntaxKind.InvocationExpression && ast.kind() !== TypeScript.SyntaxKind.ObjectCreationExpression) {
                return null;
            }
            var isNew = ast.kind() === TypeScript.SyntaxKind.ObjectCreationExpression;
            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, true);
            if (!context || context.inWithBlock) {
                return null;
            }
            var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();
            if (isNew) {
                resolver.resolveObjectCreationExpression(ast, context.resolutionContext, callResolutionResults);
            }
            else {
                resolver.resolveInvocationExpression(ast, context.resolutionContext, callResolutionResults);
            }
            return {
                targetSymbol: callResolutionResults.targetSymbol,
                resolvedSignatures: callResolutionResults.resolvedSignatures,
                candidateSignature: callResolutionResults.candidateSignature,
                ast: ast,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl),
                isConstructorCall: isNew
            };
        };
        TypeScriptCompiler.prototype.pullGetVisibleMemberSymbolsFromAST = function (ast, document) {
            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, true);
            if (!context || context.inWithBlock) {
                return null;
            }
            var symbols = resolver.getVisibleMembersFromExpression(ast, context.enclosingDecl, context.resolutionContext);
            if (!symbols) {
                return null;
            }
            return {
                symbols: symbols,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };
        TypeScriptCompiler.prototype.pullGetVisibleDeclsFromAST = function (ast, document) {
            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, false);
            if (!context || context.inWithBlock) {
                return null;
            }
            return resolver.getVisibleDecls(context.enclosingDecl);
        };
        TypeScriptCompiler.prototype.pullGetContextualMembersFromAST = function (ast, document) {
            if (ast.kind() !== TypeScript.SyntaxKind.ObjectLiteralExpression) {
                return null;
            }
            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, true);
            if (!context || context.inWithBlock) {
                return null;
            }
            var members = resolver.getVisibleContextSymbols(context.enclosingDecl, context.resolutionContext);
            return {
                symbols: members,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };
        TypeScriptCompiler.prototype.pullGetDeclInformation = function (decl, ast, document) {
            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, true);
            if (!context || context.inWithBlock) {
                return null;
            }
            var astForDecl = decl.ast();
            if (!astForDecl) {
                return null;
            }
            var astForDeclContext = this.extractResolutionContextFromAST(resolver, astForDecl, this.getDocument(astForDecl.fileName()), true);
            if (!astForDeclContext) {
                return null;
            }
            var symbol = decl.getSymbol();
            resolver.resolveDeclaredSymbol(symbol, context.resolutionContext);
            symbol.setUnresolved();
            return {
                symbol: symbol,
                aliasSymbol: null,
                ast: ast,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };
        TypeScriptCompiler.prototype.topLevelDeclaration = function (fileName) {
            return this.semanticInfoChain.topLevelDecl(fileName);
        };
        TypeScriptCompiler.prototype.getDeclForAST = function (ast) {
            return this.semanticInfoChain.getDeclForAST(ast);
        };
        TypeScriptCompiler.prototype.fileNames = function () {
            return this.semanticInfoChain.fileNames();
        };
        TypeScriptCompiler.prototype.topLevelDecl = function (fileName) {
            return this.semanticInfoChain.topLevelDecl(fileName);
        };
        return TypeScriptCompiler;
    }());
    TypeScript.TypeScriptCompiler = TypeScriptCompiler;
    var CompilerPhase;
    (function (CompilerPhase) {
        CompilerPhase[CompilerPhase["Syntax"] = 0] = "Syntax";
        CompilerPhase[CompilerPhase["Semantics"] = 1] = "Semantics";
        CompilerPhase[CompilerPhase["SoundSemanticsSignature"] = 2] = "SoundSemanticsSignature";
        CompilerPhase[CompilerPhase["SoundSemantics"] = 3] = "SoundSemantics";
        CompilerPhase[CompilerPhase["EmitOptionsValidation"] = 4] = "EmitOptionsValidation";
        CompilerPhase[CompilerPhase["Emit"] = 5] = "Emit";
        CompilerPhase[CompilerPhase["DeclarationEmit"] = 6] = "DeclarationEmit";
    })(CompilerPhase || (CompilerPhase = {}));
    var CompilerIterator = (function () {
        function CompilerIterator(compiler, resolvePath, continueOnDiagnostics, startingPhase) {
            if (startingPhase === void 0) { startingPhase = CompilerPhase.Syntax; }
            this.compiler = compiler;
            this.resolvePath = resolvePath;
            this.continueOnDiagnostics = continueOnDiagnostics;
            this.index = -1;
            this.fileNames = null;
            this._current = null;
            this._emitOptions = null;
            this._sharedEmitter = null;
            this._sharedDeclarationEmitter = null;
            this.hadSyntacticDiagnostics = false;
            this.hadSemanticDiagnostics = false;
            this.hadEmitDiagnostics = false;
            this.fileNames = compiler.fileNames();
            this.compilerPhase = startingPhase;
        }
        CompilerIterator.prototype.current = function () {
            return this._current;
        };
        CompilerIterator.prototype.moveNext = function () {
            this._current = null;
            while (this.moveNextInternal()) {
                if (this._current) {
                    return true;
                }
            }
            return false;
        };
        CompilerIterator.prototype.moveNextInternal = function () {
            this.index++;
            while (this.shouldMoveToNextPhase()) {
                this.index = 0;
                this.compilerPhase++;
            }
            if (this.compilerPhase > CompilerPhase.DeclarationEmit) {
                return false;
            }
            switch (this.compilerPhase) {
                case CompilerPhase.Syntax:
                    return this.moveNextSyntaxPhase();
                case CompilerPhase.Semantics:
                    return this.moveNextSemanticsPhase();
                case CompilerPhase.SoundSemanticsSignature:
                    return this.moveNextSoundSemanticsSignaturePhase();
                case CompilerPhase.SoundSemantics:
                    return this.moveNextSoundSemanticsPhase();
                case CompilerPhase.EmitOptionsValidation:
                    return this.moveNextEmitOptionsValidationPhase();
                case CompilerPhase.Emit:
                    return this.moveNextEmitPhase();
                case CompilerPhase.DeclarationEmit:
                    return this.moveNextDeclarationEmitPhase();
            }
        };
        CompilerIterator.prototype.shouldMoveToNextPhase = function () {
            switch (this.compilerPhase) {
                case CompilerPhase.EmitOptionsValidation:
                    return this.index === 1;
                case CompilerPhase.Syntax:
                case CompilerPhase.Semantics:
                case CompilerPhase.SoundSemanticsSignature:
                case CompilerPhase.SoundSemantics:
                    return this.index == this.fileNames.length;
                case CompilerPhase.Emit:
                case CompilerPhase.DeclarationEmit:
                    return this.index == (this.fileNames.length + 1);
            }
            return false;
        };
        CompilerIterator.prototype.moveNextSyntaxPhase = function () {
            TypeScript.Debug.assert(this.index >= 0 && this.index < this.fileNames.length);
            var fileName = this.fileNames[this.index];
            var diagnostics = this.compiler.getSyntacticDiagnostics(fileName);
            if (diagnostics.length) {
                if (!this.continueOnDiagnostics) {
                    this.hadSyntacticDiagnostics = true;
                }
                this._current = CompileResult.fromDiagnostics(diagnostics);
            }
            return true;
        };
        CompilerIterator.prototype.moveNextSemanticsPhase = function () {
            if (this.hadSyntacticDiagnostics) {
                return false;
            }
            TypeScript.Debug.assert(this.index >= 0 && this.index < this.fileNames.length);
            var fileName = this.fileNames[this.index];
            var diagnostics = this.compiler.getSemanticDiagnostics(fileName);
            if (diagnostics.length) {
                if (!this.continueOnDiagnostics) {
                    this.hadSemanticDiagnostics = true;
                }
                this._current = CompileResult.fromDiagnostics(diagnostics);
            }
            return true;
        };
        CompilerIterator.prototype.moveNextSoundSemanticsSignaturePhase = function () {
            if (this.hadSemanticDiagnostics) {
                return false;
            }
            if (this.compiler.compilationSettings().safe() || this.compiler.compilationSettings().secure()) {
                var diagnostics = this.compiler.buildSignature(this.fileNames[this.index]);
                if (diagnostics.length) {
                    this._current = CompileResult.fromDiagnostics(diagnostics);
                }
            }
            return true;
        };
        CompilerIterator.prototype.moveNextSoundSemanticsPhase = function () {
            if (this.hadSemanticDiagnostics) {
                return false;
            }
            if (this.compiler.compilationSettings().safe() || this.compiler.compilationSettings().secure()) {
                var diagnostics = this.compiler.getSoundSemanticDiagnostics(this.fileNames[this.index]);
                if (diagnostics.length) {
                    this._current = CompileResult.fromDiagnostics(diagnostics);
                }
            }
            return true;
        };
        CompilerIterator.prototype.moveNextEmitOptionsValidationPhase = function () {
            TypeScript.Debug.assert(!this.hadSyntacticDiagnostics);
            if (!this._emitOptions) {
                this._emitOptions = new TypeScript.EmitOptions(this.compiler, this.resolvePath);
            }
            if (this._emitOptions.diagnostic()) {
                if (!this.continueOnDiagnostics) {
                    this.hadEmitDiagnostics = true;
                }
                this._current = CompileResult.fromDiagnostics([this._emitOptions.diagnostic()]);
            }
            return true;
        };
        CompilerIterator.prototype.moveNextEmitPhase = function () {
            var _this = this;
            TypeScript.Debug.assert(!this.hadSyntacticDiagnostics);
            TypeScript.Debug.assert(this._emitOptions);
            if (this.hadEmitDiagnostics) {
                return false;
            }
            TypeScript.Debug.assert(this.index >= 0 && this.index <= this.fileNames.length);
            if (this.index < this.fileNames.length) {
                var fileName = this.fileNames[this.index];
                var document = this.compiler.getDocument(fileName);
                this._sharedEmitter = this.compiler._emitDocument(document, this._emitOptions, function (outputFiles) { _this._current = CompileResult.fromOutputFiles(outputFiles); }, this._sharedEmitter);
                return true;
            }
            if (this.index === this.fileNames.length && this._sharedEmitter) {
                this._current = CompileResult.fromOutputFiles(this._sharedEmitter.getOutputFiles());
            }
            return true;
        };
        CompilerIterator.prototype.moveNextDeclarationEmitPhase = function () {
            var _this = this;
            TypeScript.Debug.assert(!this.hadSyntacticDiagnostics);
            TypeScript.Debug.assert(!this.hadEmitDiagnostics);
            if (this.hadSemanticDiagnostics) {
                return false;
            }
            if (!this.compiler.compilationSettings().generateDeclarationFiles()) {
                return false;
            }
            TypeScript.Debug.assert(this.index >= 0 && this.index <= this.fileNames.length);
            if (this.index < this.fileNames.length) {
                var fileName = this.fileNames[this.index];
                var document = this.compiler.getDocument(fileName);
                this._sharedDeclarationEmitter = this.compiler._emitDocumentDeclarations(document, this._emitOptions, function (file) { _this._current = CompileResult.fromOutputFiles([file]); }, this._sharedDeclarationEmitter);
                return true;
            }
            if (this.index === this.fileNames.length && this._sharedDeclarationEmitter) {
                this._current = CompileResult.fromOutputFiles([this._sharedDeclarationEmitter.getOutputFile()]);
            }
            return true;
        };
        return CompilerIterator;
    }());
    function compareDataObjects(dst, src) {
        for (var e in dst) {
            if (typeof dst[e] == "object") {
                if (!compareDataObjects(dst[e], src[e]))
                    return false;
            }
            else if (typeof dst[e] != "function") {
                if (dst[e] !== src[e])
                    return false;
            }
        }
        return true;
    }
    TypeScript.compareDataObjects = compareDataObjects;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function pair(s, t) {
        return { fst: s, snd: t };
    }
    TypeScript.pair = pair;
    function Inl(s) {
        return { left: s };
    }
    TypeScript.Inl = Inl;
    function Inr(t) {
        return { right: t };
    }
    TypeScript.Inr = Inr;
    function idOrStringText(a) {
        if (a instanceof TypeScript.Identifier) {
            return a.text();
        }
        else if (a instanceof TypeScript.StringLiteral) {
            return a.text();
        }
        else {
            throw "Impossible";
        }
    }
    TypeScript.idOrStringText = idOrStringText;
    function scriptNameFromFileName(fn) {
        return fn.substring(fn.lastIndexOf("/") + 1);
    }
    TypeScript.scriptNameFromFileName = scriptNameFromFileName;
    var MkAST = (function () {
        function MkAST() {
        }
        MkAST.boolConst = function (b) {
            return b ? MkAST.ttConst() : MkAST.ffConst();
        };
        MkAST.getRtti = function (o) {
            if (TypeScript.SoundTypeChecker.compilationSettings.weakMaps()) {
                return MkAST.callRT("getRtti", [o]);
            }
            return MkAST.fieldAccess(o, "__rtti__");
        };
        MkAST.setRtti = function (o, t) {
            if (TypeScript.SoundTypeChecker.compilationSettings.weakMaps()) {
                return MkAST.callRT("setRtti", [o, t]);
            }
            return new TypeScript.BinaryExpression(TypeScript.SyntaxKind.AssignmentExpression, MkAST.fieldAccess(o, "__rtti__"), t);
        };
        MkAST.fieldAccess = function (o, f) {
            return new TypeScript.MemberAccessExpression(o, new TypeScript.Identifier(f));
        };
        MkAST.fieldOfRT = function (fname) {
            var f = MkAST.fieldAccess(new TypeScript.Identifier("RT"), fname);
            return f;
        };
        MkAST.argList = function (args) {
            return new TypeScript.ISeparatedSyntaxList2(TcUtil.currentFile(), args, args.length - 1);
        };
        MkAST.callExpr = function (f, args) {
            return new TypeScript.InvocationExpression(f, new TypeScript.ArgumentList(null, MkAST.argList(args), new TypeScript.ASTSpan(0, 0)));
        };
        MkAST.callRT = function (m, args) {
            return MkAST.callExpr(MkAST.fieldOfRT(m), args);
        };
        MkAST.mkCleanArray = function (args) {
            return new TypeScript.ArrayLiteralExpression(MkAST.argList(args), TypeScript.NewLineMode.Suppress);
        };
        MkAST.mkObjLit = function (args) {
            var argL = args.map(function (p) {
                return new TypeScript.SimplePropertyAssignment(MkAST.stringConst(p.fst), p.snd);
            });
            return new TypeScript.ObjectLiteralExpression(MkAST.argList(argL), TypeScript.NewLineMode.Force);
        };
        MkAST.stringConst = function (s) {
            return new TypeScript.StringLiteral("\"" + s + "\"", s);
        };
        MkAST.numberConst = function (n) {
            return new TypeScript.NumericLiteral(n, n.toString(), n.toString());
        };
        MkAST.ttConst = function () { return new TypeScript.LiteralExpression(TypeScript.SyntaxKind.TrueKeyword, "true", "true"); };
        MkAST.ffConst = function () { return new TypeScript.LiteralExpression(TypeScript.SyntaxKind.FalseKeyword, "false", "false"); };
        MkAST.undefConst = function () { return new TypeScript.Identifier("undefined"); };
        MkAST.nullConst = function () {
            return new TypeScript.LiteralExpression(TypeScript.SyntaxKind.NullKeyword, "null", "null");
        };
        MkAST.unsafe = function (e) {
            var x = MkAST.callExpr(MkAST.fieldOfRT("__UNSAFE__"), [e]);
            x.soundType = e.soundType;
            return x;
        };
        MkAST.id = function (s) { return new TypeScript.Identifier(s); };
        return MkAST;
    }());
    TypeScript.MkAST = MkAST;
    var TcUtil;
    (function (TcUtil) {
        var _currentFile = null;
        var _currentScript;
        TcUtil.zeroDelta = undefined;
        function currentFile() {
            return _currentFile;
        }
        TcUtil.currentFile = currentFile;
        ;
        function setCurrentFile(f) {
            _currentFile = f;
            _currentScript = scriptNameFromFileName(f);
        }
        TcUtil.setCurrentFile = setCurrentFile;
        ;
        function isCurrentScriptRT() {
            return _currentScript === "rt.ts";
        }
        TcUtil.isCurrentScriptRT = isCurrentScriptRT;
        ;
        function isCurrentScriptLib_d_ts() {
            return _currentScript === "lib.d.ts";
        }
        TcUtil.isCurrentScriptLib_d_ts = isCurrentScriptLib_d_ts;
        ;
        function unFree(t) {
            return true;
        }
        TcUtil.unFree = unFree;
        ;
        function isPrimitive(t) {
            t = t.unfold();
            if (t.isArray() || t.isCheckedArray() || t.typeName === TypeScript.TypeName.Bool || t.typeName === TypeScript.TypeName.String || t.typeName === TypeScript.TypeName.Number) {
                return true;
            }
            if (t instanceof TypeScript.NamedType) {
                var n = t;
                switch (n.name) {
                    case "Array":
                    case "Object":
                    case "Boolean":
                    case "Number":
                    case "String":
                    case "Error":
                    case "TypeError":
                    case "RegExp": return true;
                    default: return false;
                }
            }
            return false;
        }
        TcUtil.isPrimitive = isPrimitive;
        function markAsVirtual(tif) {
            return isCurrentScriptLib_d_ts()
                && !isPrimitive(tif);
        }
        TcUtil.markAsVirtual = markAsVirtual;
        function markAsNominal(tif) {
            return isCurrentScriptLib_d_ts()
                && isPrimitive(tif);
        }
        TcUtil.markAsNominal = markAsNominal;
        function shallowTag(sc, a, ta) {
            if (sc.fst && sc.snd) {
                var aa = MkAST.callRT("shallowTag", [a, sc.snd.toRTTI()]);
                aa.soundType = ta;
                return aa;
            }
            return a;
        }
        TcUtil.shallowTag = shallowTag;
        ;
        function checkAndTag(v, tv, texpected) {
            return MkAST.callRT("checkAndTag", [v, tv.toRTTI(), texpected.toRTTI()]);
        }
        TcUtil.checkAndTag = checkAndTag;
        function mkTypeParamName(ns, id) {
            return ns.join(".") + ".'" + id;
        }
        TcUtil.mkTypeParamName = mkTypeParamName;
        function mkArrayType(tcenv, elt) {
            var a = tcenv.lookupType({ dottedName: "Array" });
            if (a && a.typeName === TypeScript.TypeName.Poly) {
                return new TypeScript.TInst(a, [elt]);
            }
            TcUtil.Logger.warn("Type Array not found");
            return TypeScript.TConstant.Any;
        }
        TcUtil.mkArrayType = mkArrayType;
        function mkCheckedArrayType(tcenv, elt) {
            var a = tcenv.lookupType({ dottedName: "CheckedArray" });
            if (a && a.typeName === TypeScript.TypeName.Poly) {
                return new TypeScript.TInst(a, [elt]);
            }
            TcUtil.Logger.warn("Type CheckedArray not found");
            return TypeScript.TConstant.Any;
        }
        TcUtil.mkCheckedArrayType = mkCheckedArrayType;
        function force(t, a) {
            if (a.soundType && a.soundType.typeName === t.typeName) {
                return a;
            }
            switch (t.typeName) {
                case TypeScript.TypeName.Enum:
                case TypeScript.TypeName.Number: return new TypeScript.PrefixUnaryExpression(TypeScript.SyntaxKind.PlusExpression, a);
                case TypeScript.TypeName.String: return new TypeScript.BinaryExpression(TypeScript.SyntaxKind.AddExpression, a, MkAST.stringConst(""));
                case TypeScript.TypeName.Bool: return new TypeScript.ConditionalExpression(a, MkAST.boolConst(true), MkAST.boolConst(false));
                default: throw new Error("Unknown force type " + t.toString());
            }
        }
        TcUtil.force = force;
        ;
        function zip(a, b) {
            if (a.length !== b.length) {
                throw new Error("Zip with unequal lengths");
            }
            return a.map(function (x, i, a) { return ({ fst: x, snd: b[i] }); });
        }
        TcUtil.zip = zip;
        function withType(a, t) {
            a.soundType = t;
            return a;
        }
        TcUtil.withType = withType;
        ;
        function NYI(msg) {
            throw new Error(msg ? (msg + " not supported in [--secure|--safe] mode") : "Not yet implemented");
        }
        TcUtil.NYI = NYI;
        ;
        function reservedName(x) {
            switch (x) {
                case "__rtti__": return true;
                default: return false;
            }
        }
        TcUtil.reservedName = reservedName;
        ;
        function syntaxListMembers(l) {
            var elts = [];
            for (var i = 0; l && i < l.childCount(); i++) {
                elts.push(l.childAt(i));
            }
            return elts;
        }
        TcUtil.syntaxListMembers = syntaxListMembers;
        function sepListMembers(l) {
            var out = [];
            for (var i = 0; i < l.nonSeparatorCount(); i++) {
                out.push(l.nonSeparatorAt(i));
            }
            return out;
        }
        TcUtil.sepListMembers = sepListMembers;
        function mapSepList2(l, f) {
            var out = [];
            for (var i = 0; i < l.nonSeparatorCount(); i++) {
                out.push(f(l.nonSeparatorAt(i)));
            }
            return out;
        }
        TcUtil.mapSepList2 = mapSepList2;
        function mapSepList2WithIndex(l, f) {
            var out = [];
            for (var i = 0; i < l.nonSeparatorCount(); i++) {
                out.push(f(l.nonSeparatorAt(i), i));
            }
            return out;
        }
        TcUtil.mapSepList2WithIndex = mapSepList2WithIndex;
        function callSigTypeParamBindings(callSig) {
            if (callSig && callSig.typeParameterList) {
                return TcUtil.mapSepList2(callSig.typeParameterList.typeParameters, function (a) {
                    var n = a.identifier.text();
                    return { fst: n, snd: new TypeScript.TVar(n, n) };
                });
            }
            return [];
        }
        TcUtil.callSigTypeParamBindings = callSigTypeParamBindings;
        function typeParameterListBindings(tps, fullName) {
            if (fullName === void 0) { fullName = []; }
            if (tps && tps.typeParameters.nonSeparatorCount() !== 0) {
                return TcUtil.mapSepList2(tps.typeParameters, function (t) { return t.soundType.asBinder(fullName); });
            }
            return [];
        }
        TcUtil.typeParameterListBindings = typeParameterListBindings;
        function classDeclTypeParams(cd, tcenv) {
            if (cd.typeParameterList) {
                var fullName = tcenv.curNamespace();
                fullName.push(cd.identifier.text());
                return TcUtil.mapSepList2(cd.typeParameterList.typeParameters, function (t) {
                    var n = t.identifier.text();
                    return { fst: n, snd: new TypeScript.TVar(TcUtil.mkTypeParamName(fullName, n), n) };
                });
            }
            return [];
        }
        TcUtil.classDeclTypeParams = classDeclTypeParams;
        function isClassType(t) {
            var z = null;
            return t.isObject()
                && t.getMembers().some(function (s) { return s.name === "prototype" && s.anyDeclHasFlag(TypeScript.PullElementFlags.Static); })
                && (z = t.getConstructSignatures(), (z && z.length !== 0));
        }
        TcUtil.isClassType = isClassType;
        function getClassName(t) {
            var sig = t.getConstructSignatures()[0];
            return sig.returnType.name;
        }
        TcUtil.getClassName = getClassName;
        function tvarsInScopeForClassElement(elt, tcenv) {
            switch (elt.kind()) {
                case TypeScript.SyntaxKind.IndexMemberDeclaration:
                    return true;
                case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                    return !TypeScript.hasModifier(elt.modifiers, TypeScript.PullElementFlags.Static);
                case TypeScript.SyntaxKind.MemberVariableDeclaration:
                    return !TypeScript.hasModifier(elt.modifiers, TypeScript.PullElementFlags.Static);
                case TypeScript.SyntaxKind.ConstructorDeclaration:
                    return true;
                case TypeScript.SyntaxKind.SetAccessor:
                    return !TypeScript.hasModifier(elt.modifiers, TypeScript.PullElementFlags.Static);
                case TypeScript.SyntaxKind.GetAccessor:
                    return !TypeScript.hasModifier(elt.modifiers, TypeScript.PullElementFlags.Static);
                default:
                    TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Unexpected_class_element, [kind2string(elt.kind())], elt);
                    return false;
            }
        }
        TcUtil.tvarsInScopeForClassElement = tvarsInScopeForClassElement;
        function mkVariableBinding(a, name, type) {
            return { ast: a, name: name, type: type };
        }
        TcUtil.mkVariableBinding = mkVariableBinding;
        function gatherFunctionBindings(elts) {
            var bs = [];
            for (var i = 0; i < elts.childCount(); i++) {
                var a = elts.childAt(i);
                switch (a.kind()) {
                    case TypeScript.SyntaxKind.FunctionDeclaration:
                        var fd = a;
                        if (!TypeScript.TcEnv.currentEnv.symbol(a).anyDeclHasFlag(TypeScript.PullElementFlags.Ambient)) {
                            var signature = TypeScript.TcEnv.currentEnv.symbol(a);
                            bs.push({
                                ast: a,
                                name: fd.identifier.text(),
                                type: TypeScript.TranslateTypes.translateType(signature.type, TypeScript.TcEnv.currentEnv)
                            });
                        }
                        break;
                    default:
                        break;
                }
            }
            ;
            return bs;
        }
        TcUtil.gatherFunctionBindings = gatherFunctionBindings;
        function isArray(i) {
            if (i.typeName === TypeScript.TypeName.Inst) {
                var t = i.t1;
                return (t.body.typeName === TypeScript.TypeName.Interface && (t.body.name === "Array"));
            }
            return i.isArray();
        }
        TcUtil.isArray = isArray;
        function arrayElementType(i) {
            if (i.typeName === TypeScript.TypeName.Inst) {
                return i.args[0];
            }
            else if (i.typeName === TypeScript.TypeName.Interface) {
                return i.arrayElementType();
            }
            return undefined;
        }
        TcUtil.arrayElementType = arrayElementType;
        TcUtil.fcNeither = { fresh: false, captureFree: false };
        function allowDeepSubtyping(a) {
            if (!a)
                return TcUtil.fcNeither;
            return { fresh: fresh(a), captureFree: captureFree(a) };
            function fresh(a) {
                switch (a.kind()) {
                    case TypeScript.SyntaxKind.FunctionExpression:
                    case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
                    case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                    case TypeScript.SyntaxKind.NumericLiteral:
                    case TypeScript.SyntaxKind.StringLiteral:
                    case TypeScript.SyntaxKind.NullKeyword:
                    case TypeScript.SyntaxKind.TrueKeyword:
                    case TypeScript.SyntaxKind.FalseKeyword:
                    case TypeScript.SyntaxKind.VoidExpression:
                    case TypeScript.SyntaxKind.RegularExpressionLiteral:
                    case TypeScript.SyntaxKind.ObjectCreationExpression:
                    case TypeScript.SyntaxKind.ObjectLiteralExpression:
                    case TypeScript.SyntaxKind.ArrayLiteralExpression:
                        return true;
                    case TypeScript.SyntaxKind.EqualsValueClause:
                        return fresh(a.value);
                    case TypeScript.SyntaxKind.ParenthesizedExpression:
                        return fresh(a.expression);
                    default:
                        return false;
                }
            }
            function captureFree(a) {
                if (!a)
                    return true;
                switch (a.kind()) {
                    case TypeScript.SyntaxKind.FunctionExpression:
                    case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
                    case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                    case TypeScript.SyntaxKind.NumericLiteral:
                    case TypeScript.SyntaxKind.StringLiteral:
                    case TypeScript.SyntaxKind.NullKeyword:
                    case TypeScript.SyntaxKind.TrueKeyword:
                    case TypeScript.SyntaxKind.FalseKeyword:
                    case TypeScript.SyntaxKind.VoidExpression:
                    case TypeScript.SyntaxKind.RegularExpressionLiteral:
                        return true;
                    case TypeScript.SyntaxKind.ObjectCreationExpression:
                        return true;
                    case TypeScript.SyntaxKind.SimplePropertyAssignment:
                        return captureFree(a.expression);
                    case TypeScript.SyntaxKind.FunctionPropertyAssignment:
                        return true;
                    case TypeScript.SyntaxKind.ObjectLiteralExpression:
                        var o = a;
                        return TcUtil.sepListMembers(o.propertyAssignments).every(captureFree);
                    case TypeScript.SyntaxKind.ArrayLiteralExpression:
                        var ar = a;
                        return TcUtil.sepListMembers(ar.expressions).every(captureFree);
                    case TypeScript.SyntaxKind.EqualsValueClause:
                        return captureFree(a.value);
                    case TypeScript.SyntaxKind.ConditionalExpression:
                        return captureFree(a.whenTrue)
                            && captureFree(a.whenFalse);
                    case TypeScript.SyntaxKind.ParenthesizedExpression:
                        return captureFree(a.expression);
                    case TypeScript.SyntaxKind.NotEqualsWithTypeConversionExpression:
                    case TypeScript.SyntaxKind.EqualsWithTypeConversionExpression:
                    case TypeScript.SyntaxKind.EqualsExpression:
                    case TypeScript.SyntaxKind.NotEqualsExpression:
                    case TypeScript.SyntaxKind.LessThanExpression:
                    case TypeScript.SyntaxKind.LessThanOrEqualExpression:
                    case TypeScript.SyntaxKind.GreaterThanOrEqualExpression:
                    case TypeScript.SyntaxKind.GreaterThanExpression:
                    case TypeScript.SyntaxKind.AddExpression:
                    case TypeScript.SyntaxKind.SubtractExpression:
                    case TypeScript.SyntaxKind.MultiplyExpression:
                    case TypeScript.SyntaxKind.DivideExpression:
                    case TypeScript.SyntaxKind.ModuloExpression:
                    case TypeScript.SyntaxKind.BitwiseOrExpression:
                    case TypeScript.SyntaxKind.BitwiseAndExpression:
                    case TypeScript.SyntaxKind.LeftShiftExpression:
                    case TypeScript.SyntaxKind.SignedRightShiftExpression:
                    case TypeScript.SyntaxKind.UnsignedRightShiftExpression:
                    case TypeScript.SyntaxKind.BitwiseExclusiveOrExpression:
                    case TypeScript.SyntaxKind.LogicalAndExpression:
                    case TypeScript.SyntaxKind.LogicalNotExpression:
                    case TypeScript.SyntaxKind.PlusExpression:
                    case TypeScript.SyntaxKind.NegateExpression:
                    case TypeScript.SyntaxKind.BitwiseNotExpression:
                    case TypeScript.SyntaxKind.PreIncrementExpression:
                    case TypeScript.SyntaxKind.PreDecrementExpression:
                    case TypeScript.SyntaxKind.PostIncrementExpression:
                    case TypeScript.SyntaxKind.PostDecrementExpression:
                    case TypeScript.SyntaxKind.TypeOfExpression:
                    case TypeScript.SyntaxKind.InstanceOfExpression:
                        return true;
                    case TypeScript.SyntaxKind.LogicalOrExpression:
                        var b = a;
                        return captureFree(b.left) && captureFree(b.right);
                    case TypeScript.SyntaxKind.CommaExpression:
                        return captureFree(a.right);
                    default:
                        return false;
                }
            }
        }
        TcUtil.allowDeepSubtyping = allowDeepSubtyping;
        function varInScopeForInitializer(a) {
            switch (a.value.kind()) {
                case TypeScript.SyntaxKind.FunctionExpression:
                case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
                case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression: return true;
                default: return false;
            }
        }
        TcUtil.varInScopeForInitializer = varInScopeForInitializer;
        function safeTopLevelInitializer(a) {
            return invocationFree(a.value);
        }
        TcUtil.safeTopLevelInitializer = safeTopLevelInitializer;
        function invocationFree(a) {
            switch (a.kind()) {
                case TypeScript.SyntaxKind.FunctionPropertyAssignment:
                case TypeScript.SyntaxKind.IdentifierName:
                case TypeScript.SyntaxKind.QualifiedName:
                case TypeScript.SyntaxKind.GetAccessor:
                case TypeScript.SyntaxKind.SetAccessor:
                case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                case TypeScript.SyntaxKind.FunctionExpression:
                case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
                case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                case TypeScript.SyntaxKind.NumericLiteral:
                case TypeScript.SyntaxKind.StringLiteral:
                case TypeScript.SyntaxKind.NullKeyword:
                case TypeScript.SyntaxKind.TrueKeyword:
                case TypeScript.SyntaxKind.FalseKeyword:
                case TypeScript.SyntaxKind.VoidExpression:
                case TypeScript.SyntaxKind.RegularExpressionLiteral:
                    return true;
                case TypeScript.SyntaxKind.List:
                    return TcUtil.syntaxListMembers(a).every(invocationFree);
                case TypeScript.SyntaxKind.SeparatedList:
                    return TcUtil.sepListMembers(a).every(invocationFree);
                case TypeScript.SyntaxKind.ObjectLiteralExpression:
                    return invocationFree(a.propertyAssignments);
                case TypeScript.SyntaxKind.SimplePropertyAssignment:
                    return invocationFree(a.expression);
                case TypeScript.SyntaxKind.MemberAccessExpression:
                    return invocationFree(a.expression);
                case TypeScript.SyntaxKind.ArrayLiteralExpression:
                    return invocationFree(a.expressions);
                case TypeScript.SyntaxKind.CastExpression:
                    return invocationFree(a.expression);
                case TypeScript.SyntaxKind.ElementAccessExpression:
                    return invocationFree(a.expression)
                        && invocationFree(a.argumentExpression);
                case TypeScript.SyntaxKind.TypeOfExpression:
                    return invocationFree(a.expression);
                case TypeScript.SyntaxKind.DeleteExpression:
                    return invocationFree(a.expression);
                case TypeScript.SyntaxKind.ConditionalExpression:
                    return invocationFree(a.condition)
                        && invocationFree(a.whenTrue)
                        && invocationFree(a.whenFalse);
                case TypeScript.SyntaxKind.ParenthesizedExpression:
                    return invocationFree(a.expression);
                default:
                    if (a instanceof TypeScript.BinaryExpression) {
                        return invocationFree(a.left) && invocationFree(a.right);
                    }
                    else if (a instanceof TypeScript.PrefixUnaryExpression) {
                        return invocationFree(a.operand);
                    }
                    else if (a instanceof TypeScript.PostfixUnaryExpression) {
                        return invocationFree(a.operand);
                    }
                    else {
                        return false;
                    }
            }
        }
        function close(binders, t) {
            if (binders.length === 0)
                return t;
            else
                return new TypeScript.TPoly(binders.map(function (xt) { return xt.snd; }), t);
        }
        TcUtil.close = close;
        function argumentListTypeArgs(tcenv, args, inferredTypeArgs) {
            if (inferredTypeArgs === void 0) { inferredTypeArgs = []; }
            if (args.typeArgumentList && args.typeArgumentList.typeArguments) {
                return TcUtil.mapSepList2(args.typeArgumentList.typeArguments, function (t) { return t.soundType; });
            }
            else if (inferredTypeArgs && inferredTypeArgs.length !== 0) {
                return inferredTypeArgs.map(function (t) { return TypeScript.TranslateTypes.translateType(t, tcenv); });
            }
            else {
                return null;
            }
        }
        TcUtil.argumentListTypeArgs = argumentListTypeArgs;
        function instantiateType(tcenv, t, args, inferredTypeArgs, overload) {
            if (inferredTypeArgs === void 0) { inferredTypeArgs = []; }
            if (overload === void 0) { overload = 0; }
            var targs = TcUtil.argumentListTypeArgs(tcenv, args, inferredTypeArgs);
            if (targs && targs.length !== 0) {
                if (t.typeName !== TypeScript.TypeName.Poly) {
                    TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Unexpected_type_arguments, [t.toString(), overload.toString(), targs.map(function (t) { return t.toString(); }).join(", ")]);
                    return t;
                }
                return new TypeScript.TInst(t, targs);
                var tpoly = t;
                if (tpoly.bvars.length !== targs.length) {
                    TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Unexpected_type_arguments, [t.toString(), overload.toString(), targs.map(function (t) { return t.toString(); }).join(", ")]);
                    return t;
                }
                targs.forEach(function (t, i) {
                    if ((!tpoly.checkInstantiation(i, t))) {
                        TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_type_instantiation_not_subtype_constraint, [t.toString(), tpoly.bvars[i].toString()]);
                    }
                });
                return new TypeScript.TInst(tpoly, targs);
            }
            else if (t.typeName === TypeScript.TypeName.Poly) {
                var default_targs = t.bvars.map(function (a) { return TypeScript.TConstant.Any; });
                TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Could_not_infer_type_arguments, []);
                return new TypeScript.TInst(t, default_targs);
            }
            else {
                return t;
            }
        }
        TcUtil.instantiateType = instantiateType;
        function btoa(s) {
            return new Buffer(s).toString('base64');
        }
        TcUtil.btoa = btoa;
        function isGenerics(msg) {
            switch (msg) {
                case TypeScript.DiagnosticCode.SEC_Unexpected_type_arguments:
                case TypeScript.DiagnosticCode.SEC_Generic_types_unsupported: return true;
                default: return false;
            }
        }
        var Logger;
        (function (Logger) {
            var _settings = null;
            var diags = {};
            var lineMaps = {};
            var currentNode = null;
            Logger.reportWarnings = false;
            function setSettings(i) {
                _settings = i;
            }
            Logger.setSettings = setSettings;
            function settings() {
                return _settings;
            }
            Logger.settings = settings;
            function startLogForDocument(doc) {
                Logger.currentFileName = doc.fileName;
                TcUtil.setCurrentFile(Logger.currentFileName);
                lineMaps[Logger.currentFileName] = doc.lineMap();
                diags[Logger.currentFileName] = new Array();
            }
            Logger.startLogForDocument = startLogForDocument;
            function setCurrentNode(a) {
                currentNode = a;
            }
            Logger.setCurrentNode = setCurrentNode;
            function withCurrentNode(a, f) {
                var old = currentNode;
                currentNode = a;
                var res = f();
                currentNode = old;
                return res;
            }
            Logger.withCurrentNode = withCurrentNode;
            function diagnostics() {
                return diags[Logger.currentFileName];
            }
            Logger.diagnostics = diagnostics;
            function addDiag(d) {
                diags[Logger.currentFileName].push(d);
            }
            function lineNumber(ast) {
                var lineCol = { file: ast.fileName(), line: NaN, character: NaN };
                var lm = lineMaps[ast.fileName()];
                if (lm) {
                    lm.fillLineAndCharacterFromPosition(ast.start(), lineCol);
                }
                lineCol.line++;
                return lineCol;
            }
            function pos(ast) {
                if (ast === void 0) { ast = currentNode; }
                if (!ast) {
                    return "<unknown>";
                }
                var p = lineNumber(ast);
                return (p.file + ":(" + p.line + ", " + p.character + ")");
            }
            Logger.pos = pos;
            function error(msg, args, ast) {
                if (ast === void 0) { ast = currentNode; }
                if (isGenerics(msg) && !settings().generics()) {
                    return;
                }
                addDiag(new TypeScript.Diagnostic(Logger.currentFileName, lineMaps[Logger.currentFileName], ast.start(), ast.width(), msg, args));
            }
            Logger.error = error;
            function warning(msg, args, ast) {
                if (ast === void 0) { ast = currentNode; }
                if (isGenerics(msg) && !settings().generics()) {
                    return;
                }
                addDiag(new TypeScript.Diagnostic(Logger.currentFileName, lineMaps[Logger.currentFileName], ast.start(), ast.width(), msg, args));
            }
            Logger.warning = warning;
            function warn(msg) {
                if (Logger.reportWarnings) {
                    console.log("At " + pos() + ":: " + msg);
                }
            }
            Logger.warn = warn;
        })(Logger = TcUtil.Logger || (TcUtil.Logger = {}));
    })(TcUtil = TypeScript.TcUtil || (TypeScript.TcUtil = {}));
    function kind2string(k) {
        switch (k) {
            case TypeScript.SyntaxKind.None: return "None";
            case TypeScript.SyntaxKind.List: return "List";
            case TypeScript.SyntaxKind.SeparatedList: return "SeparatedList";
            case TypeScript.SyntaxKind.TriviaList: return "TriviaList";
            case TypeScript.SyntaxKind.WhitespaceTrivia: return "WhitespaceTrivia";
            case TypeScript.SyntaxKind.NewLineTrivia: return "NewLineTrivia";
            case TypeScript.SyntaxKind.MultiLineCommentTrivia: return "MultiLineCommentTrivia";
            case TypeScript.SyntaxKind.SingleLineCommentTrivia: return "SingleLineCommentTrivia";
            case TypeScript.SyntaxKind.SkippedTokenTrivia: return "SkippedTokenTrivia";
            case TypeScript.SyntaxKind.ErrorToken: return "ErrorToken";
            case TypeScript.SyntaxKind.EndOfFileToken: return "EndOfFileToken";
            case TypeScript.SyntaxKind.IdentifierName: return "IdentifierName";
            case TypeScript.SyntaxKind.RegularExpressionLiteral: return "RegularExpressionLiteral";
            case TypeScript.SyntaxKind.NumericLiteral: return "NumericLiteral";
            case TypeScript.SyntaxKind.StringLiteral: return "StringLiteral";
            case TypeScript.SyntaxKind.BreakKeyword: return "BreakKeyword";
            case TypeScript.SyntaxKind.CaseKeyword: return "CaseKeyword";
            case TypeScript.SyntaxKind.CatchKeyword: return "CatchKeyword";
            case TypeScript.SyntaxKind.ContinueKeyword: return "ContinueKeyword";
            case TypeScript.SyntaxKind.DebuggerKeyword: return "DebuggerKeyword";
            case TypeScript.SyntaxKind.DefaultKeyword: return "DefaultKeyword";
            case TypeScript.SyntaxKind.DeleteKeyword: return "DeleteKeyword";
            case TypeScript.SyntaxKind.DoKeyword: return "DoKeyword";
            case TypeScript.SyntaxKind.ElseKeyword: return "ElseKeyword";
            case TypeScript.SyntaxKind.FalseKeyword: return "FalseKeyword";
            case TypeScript.SyntaxKind.FinallyKeyword: return "FinallyKeyword";
            case TypeScript.SyntaxKind.ForKeyword: return "ForKeyword";
            case TypeScript.SyntaxKind.FunctionKeyword: return "FunctionKeyword";
            case TypeScript.SyntaxKind.IfKeyword: return "IfKeyword";
            case TypeScript.SyntaxKind.InKeyword: return "InKeyword";
            case TypeScript.SyntaxKind.InstanceOfKeyword: return "InstanceOfKeyword";
            case TypeScript.SyntaxKind.NewKeyword: return "NewKeyword";
            case TypeScript.SyntaxKind.NullKeyword: return "NullKeyword";
            case TypeScript.SyntaxKind.ReturnKeyword: return "ReturnKeyword";
            case TypeScript.SyntaxKind.SwitchKeyword: return "SwitchKeyword";
            case TypeScript.SyntaxKind.ThisKeyword: return "ThisKeyword";
            case TypeScript.SyntaxKind.ThrowKeyword: return "ThrowKeyword";
            case TypeScript.SyntaxKind.TrueKeyword: return "TrueKeyword";
            case TypeScript.SyntaxKind.TryKeyword: return "TryKeyword";
            case TypeScript.SyntaxKind.TypeOfKeyword: return "TypeOfKeyword";
            case TypeScript.SyntaxKind.VarKeyword: return "VarKeyword";
            case TypeScript.SyntaxKind.VoidKeyword: return "VoidKeyword";
            case TypeScript.SyntaxKind.WhileKeyword: return "WhileKeyword";
            case TypeScript.SyntaxKind.WithKeyword: return "WithKeyword";
            case TypeScript.SyntaxKind.ClassKeyword: return "ClassKeyword";
            case TypeScript.SyntaxKind.ConstKeyword: return "ConstKeyword";
            case TypeScript.SyntaxKind.EnumKeyword: return "EnumKeyword";
            case TypeScript.SyntaxKind.ExportKeyword: return "ExportKeyword";
            case TypeScript.SyntaxKind.ExtendsKeyword: return "ExtendsKeyword";
            case TypeScript.SyntaxKind.ImportKeyword: return "ImportKeyword";
            case TypeScript.SyntaxKind.SuperKeyword: return "SuperKeyword";
            case TypeScript.SyntaxKind.ImplementsKeyword: return "ImplementsKeyword";
            case TypeScript.SyntaxKind.InterfaceKeyword: return "InterfaceKeyword";
            case TypeScript.SyntaxKind.LetKeyword: return "LetKeyword";
            case TypeScript.SyntaxKind.PackageKeyword: return "PackageKeyword";
            case TypeScript.SyntaxKind.PrivateKeyword: return "PrivateKeyword";
            case TypeScript.SyntaxKind.ProtectedKeyword: return "ProtectedKeyword";
            case TypeScript.SyntaxKind.PublicKeyword: return "PublicKeyword";
            case TypeScript.SyntaxKind.StaticKeyword: return "StaticKeyword";
            case TypeScript.SyntaxKind.YieldKeyword: return "YieldKeyword";
            case TypeScript.SyntaxKind.AnyKeyword: return "AnyKeyword";
            case TypeScript.SyntaxKind.BooleanKeyword: return "BooleanKeyword";
            case TypeScript.SyntaxKind.ConstructorKeyword: return "ConstructorKeyword";
            case TypeScript.SyntaxKind.DeclareKeyword: return "DeclareKeyword";
            case TypeScript.SyntaxKind.GetKeyword: return "GetKeyword";
            case TypeScript.SyntaxKind.ModuleKeyword: return "ModuleKeyword";
            case TypeScript.SyntaxKind.RequireKeyword: return "RequireKeyword";
            case TypeScript.SyntaxKind.NumberKeyword: return "NumberKeyword";
            case TypeScript.SyntaxKind.SetKeyword: return "SetKeyword";
            case TypeScript.SyntaxKind.StringKeyword: return "StringKeyword";
            case TypeScript.SyntaxKind.OpenBraceToken: return "OpenBraceToken";
            case TypeScript.SyntaxKind.CloseBraceToken: return "CloseBraceToken";
            case TypeScript.SyntaxKind.OpenParenToken: return "OpenParenToken";
            case TypeScript.SyntaxKind.CloseParenToken: return "CloseParenToken";
            case TypeScript.SyntaxKind.OpenBracketToken: return "OpenBracketToken";
            case TypeScript.SyntaxKind.CloseBracketToken: return "CloseBracketToken";
            case TypeScript.SyntaxKind.DotToken: return "DotToken";
            case TypeScript.SyntaxKind.DotDotDotToken: return "DotDotDotToken";
            case TypeScript.SyntaxKind.SemicolonToken: return "SemicolonToken";
            case TypeScript.SyntaxKind.CommaToken: return "CommaToken";
            case TypeScript.SyntaxKind.LessThanToken: return "LessThanToken";
            case TypeScript.SyntaxKind.GreaterThanToken: return "GreaterThanToken";
            case TypeScript.SyntaxKind.LessThanEqualsToken: return "LessThanEqualsToken";
            case TypeScript.SyntaxKind.GreaterThanEqualsToken: return "GreaterThanEqualsToken";
            case TypeScript.SyntaxKind.EqualsEqualsToken: return "EqualsEqualsToken";
            case TypeScript.SyntaxKind.EqualsGreaterThanToken: return "EqualsGreaterThanToken";
            case TypeScript.SyntaxKind.ExclamationEqualsToken: return "ExclamationEqualsToken";
            case TypeScript.SyntaxKind.EqualsEqualsEqualsToken: return "EqualsEqualsEqualsToken";
            case TypeScript.SyntaxKind.ExclamationEqualsEqualsToken: return "ExclamationEqualsEqualsToken";
            case TypeScript.SyntaxKind.PlusToken: return "PlusToken";
            case TypeScript.SyntaxKind.MinusToken: return "MinusToken";
            case TypeScript.SyntaxKind.AsteriskToken: return "AsteriskToken";
            case TypeScript.SyntaxKind.PercentToken: return "PercentToken";
            case TypeScript.SyntaxKind.PlusPlusToken: return "PlusPlusToken";
            case TypeScript.SyntaxKind.MinusMinusToken: return "MinusMinusToken";
            case TypeScript.SyntaxKind.LessThanLessThanToken: return "LessThanLessThanToken";
            case TypeScript.SyntaxKind.GreaterThanGreaterThanToken: return "GreaterThanGreaterThanToken";
            case TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanToken: return "GreaterThanGreaterThanGreaterThanToken";
            case TypeScript.SyntaxKind.AmpersandToken: return "AmpersandToken";
            case TypeScript.SyntaxKind.BarToken: return "BarToken";
            case TypeScript.SyntaxKind.CaretToken: return "CaretToken";
            case TypeScript.SyntaxKind.ExclamationToken: return "ExclamationToken";
            case TypeScript.SyntaxKind.TildeToken: return "TildeToken";
            case TypeScript.SyntaxKind.AmpersandAmpersandToken: return "AmpersandAmpersandToken";
            case TypeScript.SyntaxKind.BarBarToken: return "BarBarToken";
            case TypeScript.SyntaxKind.QuestionToken: return "QuestionToken";
            case TypeScript.SyntaxKind.ColonToken: return "ColonToken";
            case TypeScript.SyntaxKind.EqualsToken: return "EqualsToken";
            case TypeScript.SyntaxKind.PlusEqualsToken: return "PlusEqualsToken";
            case TypeScript.SyntaxKind.MinusEqualsToken: return "MinusEqualsToken";
            case TypeScript.SyntaxKind.AsteriskEqualsToken: return "AsteriskEqualsToken";
            case TypeScript.SyntaxKind.PercentEqualsToken: return "PercentEqualsToken";
            case TypeScript.SyntaxKind.LessThanLessThanEqualsToken: return "LessThanLessThanEqualsToken";
            case TypeScript.SyntaxKind.GreaterThanGreaterThanEqualsToken: return "GreaterThanGreaterThanEqualsToken";
            case TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken: return "GreaterThanGreaterThanGreaterThanEqualsToken";
            case TypeScript.SyntaxKind.AmpersandEqualsToken: return "AmpersandEqualsToken";
            case TypeScript.SyntaxKind.BarEqualsToken: return "BarEqualsToken";
            case TypeScript.SyntaxKind.CaretEqualsToken: return "CaretEqualsToken";
            case TypeScript.SyntaxKind.SlashToken: return "SlashToken";
            case TypeScript.SyntaxKind.SlashEqualsToken: return "SlashEqualsToken";
            case TypeScript.SyntaxKind.SourceUnit: return "SourceUnit";
            case TypeScript.SyntaxKind.QualifiedName: return "QualifiedName";
            case TypeScript.SyntaxKind.ObjectType: return "ObjectType";
            case TypeScript.SyntaxKind.FunctionType: return "FunctionType";
            case TypeScript.SyntaxKind.ArrayType: return "ArrayType";
            case TypeScript.SyntaxKind.TupleType: return "TupleType";
            case TypeScript.SyntaxKind.ConstructorType: return "ConstructorType";
            case TypeScript.SyntaxKind.GenericType: return "GenericType";
            case TypeScript.SyntaxKind.TypeQuery: return "TypeQuery";
            case TypeScript.SyntaxKind.InterfaceDeclaration: return "InterfaceDeclaration";
            case TypeScript.SyntaxKind.FunctionDeclaration: return "FunctionDeclaration";
            case TypeScript.SyntaxKind.ModuleDeclaration: return "ModuleDeclaration";
            case TypeScript.SyntaxKind.ClassDeclaration: return "ClassDeclaration";
            case TypeScript.SyntaxKind.EnumDeclaration: return "EnumDeclaration";
            case TypeScript.SyntaxKind.ImportDeclaration: return "ImportDeclaration";
            case TypeScript.SyntaxKind.ExportAssignment: return "ExportAssignment";
            case TypeScript.SyntaxKind.MemberFunctionDeclaration: return "MemberFunctionDeclaration";
            case TypeScript.SyntaxKind.MemberVariableDeclaration: return "MemberVariableDeclaration";
            case TypeScript.SyntaxKind.ConstructorDeclaration: return "ConstructorDeclaration";
            case TypeScript.SyntaxKind.IndexMemberDeclaration: return "IndexMemberDeclaration";
            case TypeScript.SyntaxKind.GetAccessor: return "GetAccessor";
            case TypeScript.SyntaxKind.SetAccessor: return "SetAccessor";
            case TypeScript.SyntaxKind.PropertySignature: return "PropertySignature";
            case TypeScript.SyntaxKind.CallSignature: return "CallSignature";
            case TypeScript.SyntaxKind.ConstructSignature: return "ConstructSignature";
            case TypeScript.SyntaxKind.IndexSignature: return "IndexSignature";
            case TypeScript.SyntaxKind.MethodSignature: return "MethodSignature";
            case TypeScript.SyntaxKind.Block: return "Block";
            case TypeScript.SyntaxKind.IfStatement: return "IfStatement";
            case TypeScript.SyntaxKind.VariableStatement: return "VariableStatement";
            case TypeScript.SyntaxKind.ExpressionStatement: return "ExpressionStatement";
            case TypeScript.SyntaxKind.ReturnStatement: return "ReturnStatement";
            case TypeScript.SyntaxKind.SwitchStatement: return "SwitchStatement";
            case TypeScript.SyntaxKind.BreakStatement: return "BreakStatement";
            case TypeScript.SyntaxKind.ContinueStatement: return "ContinueStatement";
            case TypeScript.SyntaxKind.ForStatement: return "ForStatement";
            case TypeScript.SyntaxKind.ForInStatement: return "ForInStatement";
            case TypeScript.SyntaxKind.EmptyStatement: return "EmptyStatement";
            case TypeScript.SyntaxKind.ThrowStatement: return "ThrowStatement";
            case TypeScript.SyntaxKind.WhileStatement: return "WhileStatement";
            case TypeScript.SyntaxKind.TryStatement: return "TryStatement";
            case TypeScript.SyntaxKind.LabeledStatement: return "LabeledStatement";
            case TypeScript.SyntaxKind.DoStatement: return "DoStatement";
            case TypeScript.SyntaxKind.DebuggerStatement: return "DebuggerStatement";
            case TypeScript.SyntaxKind.WithStatement: return "WithStatement";
            case TypeScript.SyntaxKind.PlusExpression: return "PlusExpression";
            case TypeScript.SyntaxKind.NegateExpression: return "NegateExpression";
            case TypeScript.SyntaxKind.BitwiseNotExpression: return "BitwiseNotExpression";
            case TypeScript.SyntaxKind.LogicalNotExpression: return "LogicalNotExpression";
            case TypeScript.SyntaxKind.PreIncrementExpression: return "PreIncrementExpression";
            case TypeScript.SyntaxKind.PreDecrementExpression: return "PreDecrementExpression";
            case TypeScript.SyntaxKind.DeleteExpression: return "DeleteExpression";
            case TypeScript.SyntaxKind.TypeOfExpression: return "TypeOfExpression";
            case TypeScript.SyntaxKind.VoidExpression: return "VoidExpression";
            case TypeScript.SyntaxKind.CommaExpression: return "CommaExpression";
            case TypeScript.SyntaxKind.AssignmentExpression: return "AssignmentExpression";
            case TypeScript.SyntaxKind.AddAssignmentExpression: return "AddAssignmentExpression";
            case TypeScript.SyntaxKind.SubtractAssignmentExpression: return "SubtractAssignmentExpression";
            case TypeScript.SyntaxKind.MultiplyAssignmentExpression: return "MultiplyAssignmentExpression";
            case TypeScript.SyntaxKind.DivideAssignmentExpression: return "DivideAssignmentExpression";
            case TypeScript.SyntaxKind.ModuloAssignmentExpression: return "ModuloAssignmentExpression";
            case TypeScript.SyntaxKind.AndAssignmentExpression: return "AndAssignmentExpression";
            case TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression: return "ExclusiveOrAssignmentExpression";
            case TypeScript.SyntaxKind.OrAssignmentExpression: return "OrAssignmentExpression";
            case TypeScript.SyntaxKind.LeftShiftAssignmentExpression: return "LeftShiftAssignmentExpression";
            case TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression: return "SignedRightShiftAssignmentExpression";
            case TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression: return "UnsignedRightShiftAssignmentExpression";
            case TypeScript.SyntaxKind.ConditionalExpression: return "ConditionalExpression";
            case TypeScript.SyntaxKind.LogicalOrExpression: return "LogicalOrExpression";
            case TypeScript.SyntaxKind.LogicalAndExpression: return "LogicalAndExpression";
            case TypeScript.SyntaxKind.BitwiseOrExpression: return "BitwiseOrExpression";
            case TypeScript.SyntaxKind.BitwiseExclusiveOrExpression: return "BitwiseExclusiveOrExpression";
            case TypeScript.SyntaxKind.BitwiseAndExpression: return "BitwiseAndExpression";
            case TypeScript.SyntaxKind.EqualsWithTypeConversionExpression: return "EqualsWithTypeConversionExpression";
            case TypeScript.SyntaxKind.NotEqualsWithTypeConversionExpression: return "NotEqualsWithTypeConversionExpression";
            case TypeScript.SyntaxKind.EqualsExpression: return "EqualsExpression";
            case TypeScript.SyntaxKind.NotEqualsExpression: return "NotEqualsExpression";
            case TypeScript.SyntaxKind.LessThanExpression: return "LessThanExpression";
            case TypeScript.SyntaxKind.GreaterThanExpression: return "GreaterThanExpression";
            case TypeScript.SyntaxKind.LessThanOrEqualExpression: return "LessThanOrEqualExpression";
            case TypeScript.SyntaxKind.GreaterThanOrEqualExpression: return "GreaterThanOrEqualExpression";
            case TypeScript.SyntaxKind.InstanceOfExpression: return "InstanceOfExpression";
            case TypeScript.SyntaxKind.InExpression: return "InExpression";
            case TypeScript.SyntaxKind.LeftShiftExpression: return "LeftShiftExpression";
            case TypeScript.SyntaxKind.SignedRightShiftExpression: return "SignedRightShiftExpression";
            case TypeScript.SyntaxKind.UnsignedRightShiftExpression: return "UnsignedRightShiftExpression";
            case TypeScript.SyntaxKind.MultiplyExpression: return "MultiplyExpression";
            case TypeScript.SyntaxKind.DivideExpression: return "DivideExpression";
            case TypeScript.SyntaxKind.ModuloExpression: return "ModuloExpression";
            case TypeScript.SyntaxKind.AddExpression: return "AddExpression";
            case TypeScript.SyntaxKind.SubtractExpression: return "SubtractExpression";
            case TypeScript.SyntaxKind.PostIncrementExpression: return "PostIncrementExpression";
            case TypeScript.SyntaxKind.PostDecrementExpression: return "PostDecrementExpression";
            case TypeScript.SyntaxKind.MemberAccessExpression: return "MemberAccessExpression";
            case TypeScript.SyntaxKind.InvocationExpression: return "InvocationExpression";
            case TypeScript.SyntaxKind.ArrayLiteralExpression: return "ArrayLiteralExpression";
            case TypeScript.SyntaxKind.ObjectLiteralExpression: return "ObjectLiteralExpression";
            case TypeScript.SyntaxKind.ObjectCreationExpression: return "ObjectCreationExpression";
            case TypeScript.SyntaxKind.ParenthesizedExpression: return "ParenthesizedExpression";
            case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression: return "ParenthesizedArrowFunctionExpression";
            case TypeScript.SyntaxKind.SimpleArrowFunctionExpression: return "SimpleArrowFunctionExpression";
            case TypeScript.SyntaxKind.CastExpression: return "CastExpression";
            case TypeScript.SyntaxKind.ElementAccessExpression: return "ElementAccessExpression";
            case TypeScript.SyntaxKind.FunctionExpression: return "FunctionExpression";
            case TypeScript.SyntaxKind.OmittedExpression: return "OmittedExpression";
            case TypeScript.SyntaxKind.VariableDeclaration: return "VariableDeclaration";
            case TypeScript.SyntaxKind.VariableDeclarator: return "VariableDeclarator";
            case TypeScript.SyntaxKind.ArgumentList: return "ArgumentList";
            case TypeScript.SyntaxKind.ParameterList: return "ParameterList";
            case TypeScript.SyntaxKind.TypeArgumentList: return "TypeArgumentList";
            case TypeScript.SyntaxKind.TypeParameterList: return "TypeParameterList";
            case TypeScript.SyntaxKind.ExtendsHeritageClause: return "ExtendsHeritageClause";
            case TypeScript.SyntaxKind.ImplementsHeritageClause: return "ImplementsHeritageClause";
            case TypeScript.SyntaxKind.EqualsValueClause: return "EqualsValueClause";
            case TypeScript.SyntaxKind.CaseSwitchClause: return "CaseSwitchClause";
            case TypeScript.SyntaxKind.DefaultSwitchClause: return "DefaultSwitchClause";
            case TypeScript.SyntaxKind.ElseClause: return "ElseClause";
            case TypeScript.SyntaxKind.CatchClause: return "CatchClause";
            case TypeScript.SyntaxKind.FinallyClause: return "FinallyClause";
            case TypeScript.SyntaxKind.TypeParameter: return "TypeParameter";
            case TypeScript.SyntaxKind.Constraint: return "Constraint";
            case TypeScript.SyntaxKind.SimplePropertyAssignment: return "SimplePropertyAssignment";
            case TypeScript.SyntaxKind.FunctionPropertyAssignment: return "FunctionPropertyAssignment";
            case TypeScript.SyntaxKind.Parameter: return "Parameter";
            case TypeScript.SyntaxKind.EnumElement: return "EnumElement";
            case TypeScript.SyntaxKind.TypeAnnotation: return "TypeAnnotation";
            case TypeScript.SyntaxKind.ExternalModuleReference: return "ExternalModuleReference";
            case TypeScript.SyntaxKind.ModuleNameModuleReference: return "ModuleNameModuleReference";
            default: return "Unknown syntax kind";
        }
    }
    TypeScript.kind2string = kind2string;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function substType(s, descend) {
        return function (t) { return TypeScript.pair(t.fst.subst(s, descend), t.snd); };
    }
    var TUVar = (function (_super) {
        __extends(TUVar, _super);
        function TUVar() {
            return _super.call(this, TypeScript.TypeName.UVar) || this;
        }
        TUVar.prototype.isResolved = function () {
            return this.resolved ? true : false;
        };
        TUVar.prototype.resolve = function (t) {
            if (this.resolved) {
                throw new Error("Unification variable is already set");
            }
            this.resolved = t;
        };
        TUVar.prototype.unfold = function () {
            if (this.resolved) {
                return this.resolved.unfold();
            }
            return this;
        };
        TUVar.prototype.equals = function (u) {
            if (this.isResolved()) {
                return this.resolved.equals(u);
            }
            return this === u;
        };
        TUVar.prototype.unFree = function () {
            if (this.resolved) {
                return this.resolved.unFree();
            }
            return false;
        };
        TUVar.prototype.toString = function () {
            return "UVAR";
        };
        TUVar.prototype.toRTTI = function () {
            console.log(TypeScript.TcUtil.Logger.pos() + ": uvar escapes to RTTI");
            return TypeScript.MkAST.stringConst("UVAR");
        };
        return TUVar;
    }(TypeScript.SoundType));
    TypeScript.TUVar = TUVar;
    var TConstant = (function (_super) {
        __extends(TConstant, _super);
        function TConstant(t) {
            return _super.call(this, t) || this;
        }
        TConstant.prototype.equals = function (t) {
            return this.typeName === t.unfold().typeName;
        };
        TConstant.prototype.unFree = function () {
            return this.typeName !== TypeScript.TypeName.Un;
        };
        TConstant.prototype.toString = function () {
            switch (this.typeName) {
                case TypeScript.TypeName.Any: return "any";
                case TypeScript.TypeName.Un: return "un";
                case TypeScript.TypeName.Number: return "number";
                case TypeScript.TypeName.Bool: return "boolean";
                case TypeScript.TypeName.String: return "string";
                case TypeScript.TypeName.Void: return "void";
                case TypeScript.TypeName.Null: return "null";
                default: return "unknown";
            }
        };
        TConstant.prototype.toRTTI = function () {
            switch (this.typeName) {
                case TypeScript.TypeName.Any: return TypeScript.MkAST.fieldOfRT("Any");
                case TypeScript.TypeName.Number: return TypeScript.MkAST.fieldOfRT("Num");
                case TypeScript.TypeName.Bool: return TypeScript.MkAST.fieldOfRT("Bool");
                case TypeScript.TypeName.String: return TypeScript.MkAST.fieldOfRT("Str");
                case TypeScript.TypeName.Void: return TypeScript.MkAST.fieldOfRT("Void");
                case TypeScript.TypeName.Un: return TypeScript.MkAST.fieldOfRT("Un");
                case TypeScript.TypeName.Null: return TypeScript.MkAST.fieldOfRT("Null");
                default: throw "Unexpected type name";
            }
        };
        TConstant.Any = new TConstant(TypeScript.TypeName.Any);
        TConstant.Number = new TConstant(TypeScript.TypeName.Number);
        TConstant.Bool = new TConstant(TypeScript.TypeName.Bool);
        TConstant.String = new TConstant(TypeScript.TypeName.String);
        TConstant.Void = new TConstant(TypeScript.TypeName.Void);
        TConstant.Un = new TConstant(TypeScript.TypeName.Un);
        TConstant.Null = new TConstant(TypeScript.TypeName.Null);
        return TConstant;
    }(TypeScript.SoundType));
    TypeScript.TConstant = TConstant;
    var TArg = (function () {
        function TArg(name, type, flags, variadic) {
            if (flags === void 0) { flags = []; }
            if (variadic === void 0) { variadic = false; }
            this.name = name;
            this.type = type;
            this.flags = flags;
            this.variadic = variadic;
        }
        TArg.prototype.toRTTI = function () {
            var args = [TypeScript.pair("type", this.type.toRTTI())];
            if (this.optional()) {
                args.push(TypeScript.pair("optional", TypeScript.MkAST.ttConst()));
            }
            return TypeScript.MkAST.mkObjLit(args);
        };
        TArg.prototype.subst = function (s, descend) {
            return new TArg(this.name, this.type.subst(s, descend), this.flags, this.variadic);
        };
        TArg.prototype.isField = function () {
            return TypeScript.hasModifier(this.flags, TypeScript.PullElementFlags.PropertyParameter);
        };
        TArg.prototype.optional = function () {
            return TypeScript.hasModifier(this.flags, TypeScript.PullElementFlags.Optional);
        };
        TArg.prototype.accessibility = function () {
            if (!TypeScript.hasModifier(this.flags, TypeScript.PullElementFlags.PropertyParameter)) {
                return "";
            }
            if (TypeScript.hasModifier(this.flags, TypeScript.PullElementFlags.Public)) {
                return "public";
            }
            if (TypeScript.hasModifier(this.flags, TypeScript.PullElementFlags.Private)) {
                return "private";
            }
            return "";
        };
        TArg.prototype.toString = function () {
            return (this.variadic ? "..." : "")
                + this.accessibility()
                + " "
                + this.name
                + (this.optional() ? "?: " : ": ")
                + this.type.toString();
        };
        return TArg;
    }());
    TypeScript.TArg = TArg;
    var TIndexMap = (function (_super) {
        __extends(TIndexMap, _super);
        function TIndexMap(indexType, elt) {
            var _this = _super.call(this, TypeScript.TypeName.IndexMap) || this;
            _this.indexType = indexType;
            _this.elt = elt;
            return _this;
        }
        TIndexMap.prototype.isIndexable = function () { return true; };
        TIndexMap.prototype.toRTTI = function () {
            return TypeScript.MkAST.callExpr(TypeScript.MkAST.fieldOfRT("IndexMapType"), [this.indexType.toRTTI(), this.elt.toRTTI()]);
        };
        TIndexMap.prototype.equals = function (t) {
            t = t.unfold();
            if (t.typeName !== this.typeName)
                return false;
            var a = t;
            return this.indexType.equals(a.indexType) && this.elt.equals(a.elt);
        };
        TIndexMap.prototype.unFree = function () {
            return this.elt.unFree();
        };
        TIndexMap.prototype.toString = function () {
            return "{[x:" + this.indexType.toString() + "] : " + this.elt.toString() + "}";
        };
        TIndexMap.prototype.subst = function (s, descend) {
            return new TIndexMap(this.indexType.subst(s, descend), this.elt.subst(s, descend));
        };
        return TIndexMap;
    }(TypeScript.SoundType));
    TypeScript.TIndexMap = TIndexMap;
    function Field(name, type, optional) {
        if (optional === void 0) { optional = false; }
        return { name: name, type: type, optional: optional, mutable: true };
    }
    TypeScript.Field = Field;
    function substField(s, descend) {
        if (descend === void 0) { descend = false; }
        return function (f) { return Field(f.name, f.type.subst(s, descend), f.optional); };
    }
    var fieldToRtti = function (f) {
        var field = [{ fst: "name", snd: TypeScript.MkAST.stringConst(f.name) }, { fst: "type", snd: f.type.toRTTI() }];
        if (f.optional) {
            field.push({ fst: "optional", snd: TypeScript.MkAST.ttConst() });
        }
        return TypeScript.MkAST.mkObjLit(field);
    };
    TypeScript.toFieldTable = function (flds) { return TypeScript.MkAST.mkObjLit(flds.map(function (f) { return TypeScript.pair(f.name, f.type.toRTTI()); })); };
    var TArrow = (function (_super) {
        __extends(TArrow, _super);
        function TArrow(args, result) {
            var _this = _super.call(this, TypeScript.TypeName.Arrow) || this;
            _this.args = args;
            _this.result = result;
            return _this;
        }
        TArrow.prototype.subst = function (s, descend) {
            return new TArrow(this.args.map(function (a) { return a.subst(s, descend); }), this.result.subst(s, descend));
        };
        TArrow.prototype.toRTTI = function () {
            var mandatory = 0;
            var args = TypeScript.MkAST.mkCleanArray(this.args.map(function (e) {
                if (!e.optional())
                    mandatory++;
                return e.type.toRTTI();
            }));
            args.newLineMode = TypeScript.NewLineMode.Suppress;
            var elts = [args, this.result.toRTTI()];
            var varargs = this.args.filter(function (a) { return a.variadic; });
            if (varargs && varargs.length !== 0) {
                elts.push(varargs[0].toRTTI());
            }
            else {
                elts.push(TypeScript.MkAST.undefConst());
            }
            if (mandatory < this.args.length) {
                elts.push(TypeScript.MkAST.numberConst(mandatory));
            }
            return TypeScript.MkAST.callExpr(TypeScript.MkAST.fieldOfRT("ArrowType"), elts);
        };
        TArrow.prototype.equals = function (t) {
            t = t.unfold();
            if (t.typeName !== TypeScript.TypeName.Arrow)
                return false;
            var f = t;
            if (this.args.length !== f.args.length)
                return false;
            for (var i = 0; i < this.args.length; i++) {
                if (!this.args[i].type.equals(f.args[i].type))
                    return false;
            }
            return this.result.equals(f.result);
        };
        TArrow.prototype.unFree = function () {
            return this.result.unFree() &&
                this.args.every(function (t) {
                    return t.type.unFree();
                });
        };
        TArrow.prototype.toString = function () {
            return "("
                + this.args.map(function (t) {
                    return t.toString();
                }).join(", ")
                + ") => " + this.result.toString();
        };
        return TArrow;
    }(TypeScript.SoundType));
    TypeScript.TArrow = TArrow;
    function substMethod(s, descend) {
        if (descend === void 0) { descend = false; }
        return function (m) { return Method(m.name, m.type.subst(s, descend)); };
    }
    TypeScript.substMethod = substMethod;
    function Method(name, type) {
        return { name: name, type: type };
    }
    TypeScript.Method = Method;
    var methodToRtti = function (m) {
        var field = [{ fst: "name", snd: TypeScript.MkAST.stringConst(m.name) }, { fst: "type", snd: m.type.toRTTI() }];
        return TypeScript.MkAST.mkObjLit(field);
    };
    TypeScript.toMethodTable = function (methods) {
        return TypeScript.MkAST.mkObjLit(methods.map(function (m) { return TypeScript.pair(m.name, m.type.toRTTI()); }));
    };
    var StructuredType = (function (_super) {
        __extends(StructuredType, _super);
        function StructuredType(tn, fields, methods, types) {
            if (fields === void 0) { fields = []; }
            if (methods === void 0) { methods = []; }
            if (types === void 0) { types = []; }
            var _this = _super.call(this, tn) || this;
            _this.fields = fields;
            _this.methods = methods;
            _this.types = types;
            _this.unfree = true;
            _this.typesMap = RT.createEmptyMap();
            _this.fieldMap = RT.createEmptyMap();
            _this.methodMap = RT.createEmptyMap();
            _this.fieldsToString = function (fields) {
                return fields.map(function (f) { return f.name + (f.optional ? "?" : "") + " : " + f.type.toString(); }).join("; ");
            };
            _this.types.forEach(function (t) {
                _this.typesMap[t.fst.name] = TypeScript.pair(t.fst, t.snd);
            });
            _this.fields.forEach(function (f) { return _this.addToFieldMap(f); });
            _this.methods.forEach(function (m) { return _this.addToMethodMap(m); });
            _this.unfree =
                _this.fields.every(function (f) { return f.type.unFree(); })
                    && _this.methods.every(function (f) { return f.type.unFree(); });
            return _this;
        }
        StructuredType.prototype.exposeFields = function () { return this.fields; };
        StructuredType.prototype.exposeMethods = function () { return this.methods; };
        StructuredType.prototype.exposeTypes = function () { return this.types; };
        StructuredType.prototype.addToFieldMap = function (f) {
            if (this.fieldMap[f.name]) {
                this.fieldMap[f.name].push(f);
            }
            else {
                this.fieldMap[f.name] = [f];
            }
        };
        StructuredType.prototype.addToMethodMap = function (m) {
            if (this.methodMap[m.name]) {
                this.methodMap[m.name].push(m);
            }
            else {
                this.methodMap[m.name] = [m];
            }
        };
        StructuredType.prototype.addField = function (f) {
            this.addToFieldMap(f);
            this.fields.push(f);
            this.unfree = f.type.unFree() && this.unfree;
        };
        StructuredType.prototype.addMethod = function (m) {
            this.addToMethodMap(m);
            this.methods.push(m);
            this.unfree = m.type.unFree() && this.unfree;
        };
        StructuredType.prototype.lookupMethodOrField = function (map, f, overload) {
            if (overload === void 0) { overload = 0; }
            var x = map[f];
            if (x) {
                if (overload < 0) {
                    return x[x.length - 1];
                }
                else {
                    return x[overload];
                }
            }
            return undefined;
        };
        StructuredType.prototype.lookupField = function (f, overload) {
            if (overload === void 0) { overload = 0; }
            return this.lookupMethodOrField(this.fieldMap, f, overload);
        };
        StructuredType.prototype.lookupMethod = function (f, overload) {
            if (overload === void 0) { overload = 0; }
            return this.lookupMethodOrField(this.methodMap, f, overload);
        };
        StructuredType.prototype.getField = function (f, overload) {
            if (overload === void 0) { overload = 0; }
            return this.lookupField(f, overload);
        };
        StructuredType.prototype.hasField = function (f) {
            return this.getField(f, 0) ? true : false;
        };
        StructuredType.prototype.getMethod = function (f, overload) {
            if (overload === void 0) { overload = 0; }
            var m = this.lookupMethod(f, overload);
            if (m) {
                return m;
            }
            var fld = this.getField(f, overload);
            if (fld && fld.type.typeName === TypeScript.TypeName.Arrow) {
                return fld;
            }
            return undefined;
        };
        StructuredType.prototype.hasMethod = function (f) {
            return this.getMethod(f) ? true : false;
        };
        StructuredType.prototype.getMethodType = function (m, overload) {
            if (overload === void 0) { overload = 0; }
            var meth = this.getMethod(m, overload);
            if (meth) {
                return meth.type;
            }
            return undefined;
        };
        StructuredType.prototype.unFree = function () {
            return this.unfree;
        };
        StructuredType.prototype.toString = function () {
            return "{ FIELDS= "
                + this.fieldsToString(this.fields)
                + (this.methods.length !== 0
                    ? "; METHODS= " + this.fieldsToString(this.methods) : "")
                + "}";
        };
        StructuredType.prototype.updateType = function (n, t, ast) {
            if (ast === void 0) { ast = null; }
            this.typesMap[n] = { fst: t, snd: ast };
        };
        StructuredType.prototype.addType = function (n, t, ast) {
            if (ast === void 0) { ast = null; }
            if (this.typesMap[n]) {
                throw new Error("Type " + n + " is already defined in module " + this["name"]);
            }
            this.typesMap[n] = { fst: t, snd: ast };
        };
        StructuredType.prototype.lookupType = function (n) {
            var t = this.typesMap[n];
            return t ? t.fst : null;
        };
        StructuredType.prototype.lookupTypeDecl = function (n) {
            var t = this.typesMap[n];
            return t ? t.snd : null;
        };
        StructuredType.prototype.getFieldType = function (f, overload) {
            var g = this.lookupField(f, overload);
            if (g) {
                return g.type;
            }
            else {
                return null;
            }
        };
        StructuredType.prototype.callSignature = function (overload) {
            if (overload === void 0) { overload = 0; }
            var m = this.getMethod("<call>", overload);
            if (m) {
                return m.type;
            }
            return undefined;
        };
        StructuredType.prototype.addCallSignature = function (t) {
            this.addMethod(Method("<call>", t));
        };
        StructuredType.prototype.indexSignature = function (overload) {
            if (overload === void 0) { overload = 0; }
            return this.getFieldType("<index>", overload);
        };
        StructuredType.prototype.addIndexSignature = function (t) {
            this.addField(Field("<index>", t, false));
        };
        StructuredType.prototype.constructSignature = function (overload) {
            if (overload === void 0) { overload = 0; }
            return this.getMethodType("<new>", overload);
        };
        StructuredType.prototype.addConstructSignature = function (t) {
            this.addMethod(Method("<new>", t));
        };
        StructuredType.prototype.substBase = function (s, skel, descend) {
            var fields = this.fields.map(substField(s, descend));
            var methods = this.methods.map(substMethod(s, descend));
            var types = this.types.map(substType(s, descend));
            fields.forEach(function (f) { return skel.addField(f); });
            methods.forEach(function (f) { return skel.addMethod(f); });
            types.forEach(function (t) { return skel.addType(t.fst.name, t.fst, t.snd); });
            return skel;
        };
        StructuredType.prototype.removeExtraneousFields = function () {
            if (this.indexSignature() && this instanceof TRecord) {
                var t = new TRecord([]);
                t.addIndexSignature(this.indexSignature());
                return t;
            }
            return this;
        };
        return StructuredType;
    }(TypeScript.SoundType));
    TypeScript.StructuredType = StructuredType;
    var JustType = (function (_super) {
        __extends(JustType, _super);
        function JustType(repr) {
            var _this = _super.call(this, TypeScript.TypeName.Just) || this;
            _this.repr = repr;
            if (_this.repr instanceof StructuredType) {
                _this.structRepr = _this.repr;
            }
            return _this;
        }
        JustType.prototype.equals = function (t) {
            var t = t.unfold();
            return this.typeName === t.typeName && (this.repr.equals(t.repr));
        };
        JustType.prototype.unFree = function () {
            return this.repr.unFree();
        };
        JustType.prototype.toString = function () {
            return "Just<" + this.repr.toString() + ">";
        };
        JustType.prototype.toRTTI = function () {
            return TypeScript.MkAST.callRT("JustType", []);
        };
        JustType.prototype.isVirtual = function () {
            return true;
        };
        JustType.prototype.isNominal = function () {
            return this.nominal || this.repr.isNominal();
        };
        JustType.prototype.impos = function (msg) {
            throw new Error(msg + " is not available on a JustType");
        };
        JustType.prototype.exposeFields = function () {
            return this.structRepr ? this.structRepr.exposeFields() : [];
        };
        JustType.prototype.exposeMethods = function () {
            return this.structRepr ? this.structRepr.exposeMethods() : [];
        };
        JustType.prototype.exposeTypes = function () {
            return this.impos("exposeTypes");
        };
        JustType.prototype.addField = function (f) {
            return this.impos("addField");
        };
        JustType.prototype.addMethod = function (m) {
            return this.impos("addMethod");
        };
        JustType.prototype.getField = function (f, overload) {
            if (overload === void 0) { overload = 0; }
            if (this.structRepr)
                return this.structRepr.getField(f, overload);
            return undefined;
        };
        JustType.prototype.hasField = function (f) {
            if (this.structRepr)
                return this.structRepr.hasField(f);
            return false;
        };
        JustType.prototype.getMethod = function (f, overload) {
            if (overload === void 0) { overload = 0; }
            if (this.structRepr)
                return this.structRepr.getMethod(f, overload);
            return undefined;
        };
        JustType.prototype.hasMethod = function (f) {
            if (this.structRepr)
                return this.structRepr.hasMethod(f);
            return false;
        };
        JustType.prototype.getMethodType = function (m, overload) {
            if (overload === void 0) { overload = 0; }
            if (this.structRepr)
                return this.structRepr.getMethodType(m, overload);
            return undefined;
        };
        JustType.prototype.updateType = function (n, t, ast) {
            if (ast === void 0) { ast = null; }
            return this.impos("updateType");
        };
        JustType.prototype.addType = function (n, t, ast) {
            if (ast === void 0) { ast = null; }
            return this.impos("addType");
        };
        JustType.prototype.lookupType = function (n) {
            return this.impos("lookupType");
        };
        JustType.prototype.lookupTypeDecl = function (n) {
            return this.impos("lookupTypeDecl");
        };
        JustType.prototype.callSignature = function (overload) {
            if (overload === void 0) { overload = 0; }
            if (this.structRepr)
                return this.structRepr.callSignature(overload);
            return undefined;
        };
        JustType.prototype.addCallSignature = function (t) {
            return this.impos("addCallSignature");
        };
        JustType.prototype.indexSignature = function (overload) {
            if (overload === void 0) { overload = 0; }
            if (this.structRepr)
                return this.indexSignature(overload);
            return undefined;
        };
        JustType.prototype.addIndexSignature = function (t) {
            this.addField(Field("<index>", t, false));
        };
        JustType.prototype.constructSignature = function (overload) {
            if (overload === void 0) { overload = 0; }
            return this.getMethodType("<new>", overload);
        };
        JustType.prototype.addConstructSignature = function (t) {
            this.addMethod(Method("<new>", t));
        };
        JustType.prototype.substBase = function (s, skel, descend) {
            if (this.structRepr) {
                return this.structRepr.substBase(s, skel, descend);
            }
        };
        return JustType;
    }(StructuredType));
    TypeScript.JustType = JustType;
    var TRecord = (function (_super) {
        __extends(TRecord, _super);
        function TRecord(fields, methods) {
            if (methods === void 0) { methods = []; }
            return _super.call(this, TypeScript.TypeName.Record, fields, methods) || this;
        }
        TRecord.prototype.toRTTI = function () {
            if (this.isVirtual()) {
                return TypeScript.MkAST.callRT("JustType", [TypeScript.MkAST.stringConst("record type")]);
            }
            var r = TypeScript.MkAST.callExpr(TypeScript.MkAST.fieldOfRT("StructuredType"), [TypeScript.toMethodTable(this.exposeMethods()), TypeScript.toFieldTable(this.exposeFields())]);
            return r;
        };
        TRecord.prototype.equals = function (t) {
            if (this === t)
                return true;
            t = t.unfold();
            var checkFields = function (fs1, fs2, flip) {
                return fs1.every(function (f) {
                    var gs = fs2.filter(function (f2) { return f2.name === f.name; });
                    return gs.some(function (g) { return flip || (g.mutable === f.mutable && g.type.equals(f.type)); });
                });
            };
            switch (t.typeName) {
                case TypeScript.TypeName.Record:
                    var tt = t;
                    var myFields = this.exposeFields();
                    var ttFields = tt.exposeFields();
                    var myMethods = this.exposeMethods();
                    var ttMethods = tt.exposeMethods();
                    return checkFields(myFields, ttFields, false)
                        && checkFields(ttFields, myFields, true)
                        && checkFields(myMethods, ttMethods, false)
                        && checkFields(ttMethods, myMethods, true);
                default: return false;
            }
        };
        TRecord.prototype.subst = function (s, descend) {
            return this.substBase(s, new TRecord([], []), descend);
        };
        return TRecord;
    }(StructuredType));
    TypeScript.TRecord = TRecord;
    function getCallSignature(t, overload) {
        if (overload === void 0) { overload = 0; }
        if (t.typeName === TypeScript.TypeName.Record) {
            return t.callSignature(overload);
        }
        return undefined;
    }
    TypeScript.getCallSignature = getCallSignature;
    function functionType(t) {
        var r = new TRecord([], []);
        r.addCallSignature(t);
        return r;
    }
    TypeScript.functionType = functionType;
    function mkFunctionType(args, result) {
        return functionType(new TArrow(args, result));
    }
    TypeScript.mkFunctionType = mkFunctionType;
    function isFunctionType(t) {
        return t.typeName === TypeScript.TypeName.Record && (t.callSignature() ? true : false);
    }
    TypeScript.isFunctionType = isFunctionType;
    var NamedType = (function (_super) {
        __extends(NamedType, _super);
        function NamedType(tn, name, members, methods, types, extendsC, implementsI) {
            if (members === void 0) { members = []; }
            if (methods === void 0) { methods = []; }
            if (types === void 0) { types = []; }
            if (extendsC === void 0) { extendsC = []; }
            if (implementsI === void 0) { implementsI = []; }
            var _this = _super.call(this, tn, members, methods, types) || this;
            _this.name = name;
            _this.extendsC = extendsC;
            _this.implementsI = implementsI;
            if (!extendsC.every(isNamedType)) {
                throw new Error("Got heritage from a non-named types : " + extendsC.map(function (u) { return u.toString(); }).join(", "));
            }
            _this.unfree = _this.unfree && _this.extendsC ? _this.extendsC.every(function (t) { return t.unFree(); }) : true;
            _this.unfree = _this.unfree && _this.implementsI ? _this.implementsI.every(function (t) { return t.unFree(); }) : true;
            return _this;
        }
        NamedType.prototype.toRecord = function (forRTTI) {
            var _this = this;
            if (forRTTI === void 0) { forRTTI = false; }
            var r = this.toRecordAux(forRTTI);
            var findDups = function (mfs, msg) {
                var dups = RT.createEmptyMap();
                var hasDup = false;
                mfs.forEach(function (mf1, i) {
                    if (!dups[mf1.name]) {
                        mfs.forEach(function (mf2, j) {
                            if (i !== j && mf1.name === mf2.name) {
                                hasDup = true;
                                if (dups[mf1.name]) {
                                    dups[mf1.name].push(mf2);
                                }
                                else {
                                    dups[mf1.name] = [mf1, mf2];
                                }
                            }
                        });
                    }
                });
                if (hasDup) {
                    console.log(_this.toString() + " has duplicate " + msg + "s");
                    for (var x in dups) {
                        console.log(msg + " " + x);
                        for (var i = 0; i < dups[x].length; i++) {
                            console.log("\t" + dups[x][i].type.toString());
                        }
                    }
                }
            };
            return r;
        };
        NamedType.prototype.toRecordAux = function (forRTTI) {
            if (forRTTI === void 0) { forRTTI = false; }
            var fields = new Array().concat(this.exposeFields());
            var methods = new Array().concat(this.exposeMethods());
            if (this.extendsC) {
                var supFields = [];
                var supMethods = [];
                for (var i = 0; i < this.extendsC.length; i++) {
                    var st = this.extendsC[i].unfold();
                    if (st instanceof NamedType) {
                        var rec = st.toRecord(forRTTI);
                        supFields = supFields.concat(rec.exposeFields());
                        supMethods = supMethods.concat(rec.exposeMethods());
                    }
                    else if (st instanceof StructuredType) {
                        var struct = st;
                        supFields = supFields.concat(struct.exposeFields());
                        supMethods = supMethods.concat(struct.exposeMethods());
                    }
                    fields = fields.concat(supFields.filter(function (f) { return fields.every(function (g) { return g.name !== f.name; }); }));
                    methods = methods.concat(supMethods.filter(function (m) { return methods.every(function (n) { return m.name !== n.name; }); }));
                    supFields = [];
                    supMethods = [];
                }
                return new TRecord(fields, methods);
            }
            else {
                return new TRecord(fields, methods);
            }
        };
        NamedType.prototype.substBase = function (s, skel, descend) {
            var res = _super.prototype.substBase.call(this, s, skel, descend);
            res.extendsC = this.extendsC.map(function (t) { return t.subst(s, descend); });
            res.implementsI = this.implementsI.map(function (t) { return t.subst(s, descend); });
            return res;
        };
        NamedType.prototype.equals = function (t) {
            t = t.unfold();
            return t.typeName === this.typeName && this.name === t.name;
        };
        NamedType.prototype.addExtension = function (ext) {
            if (this.extendsC.some(function (t) { return t.equals(ext); })) {
                return;
            }
            this.extendsC.push(ext);
            this.unfree = this.unfree && ext.unFree();
        };
        NamedType.prototype.getMethodOrField = function (meth, f, overload) {
            if (overload === void 0) { overload = 0; }
            var x = meth ? _super.prototype.getMethod.call(this, f, overload) : _super.prototype.getField.call(this, f, overload);
            if (!x && this.extendsC) {
                var g = null;
                this.extendsC.some(function (t) {
                    var nt = t.unfold();
                    g = meth ? nt.getMethod(f, overload) : nt.getField(f, overload);
                    if (g)
                        return true;
                    return false;
                });
                return g;
            }
            return x;
        };
        NamedType.prototype.getField = function (f, overload) {
            if (overload === void 0) { overload = 0; }
            return this.getMethodOrField(false, f, overload);
        };
        NamedType.prototype.getMethod = function (f, overload) {
            if (overload === void 0) { overload = 0; }
            return this.getMethodOrField(true, f, overload);
        };
        NamedType.prototype.isCircular = function (x) {
            return false;
        };
        return NamedType;
    }(StructuredType));
    TypeScript.NamedType = NamedType;
    function isNamedType(t) {
        return t instanceof NamedType;
    }
    TypeScript.isNamedType = isNamedType;
    var TModule = (function (_super) {
        __extends(TModule, _super);
        function TModule(mname, fields, methods, types) {
            if (fields === void 0) { fields = []; }
            if (methods === void 0) { methods = []; }
            if (types === void 0) { types = []; }
            var _this = _super.call(this, TypeScript.TypeName.Module, mname, fields, methods, types) || this;
            _this.memberDeclMap = {};
            return _this;
        }
        TModule.prototype.toString = function () {
            return "typeof " + this.name;
        };
        TModule.prototype.addMemberDecl = function (name, a, circular) {
            this.memberDeclMap[name] = { fst: a, snd: circular };
        };
        TModule.prototype.getMemberDecl = function (name) {
            return this.memberDeclMap[name];
        };
        TModule.prototype.getMember = function (f, overload, circularOk) {
            if (overload === void 0) { overload = 0; }
            if (circularOk === void 0) { circularOk = false; }
            circularOk = circularOk || TypeScript.TcEnv.currentEnv.inFunctionScope();
            var g = _super.prototype.getField.call(this, f, overload);
            if (g && !circularOk && this.isCircular(f)) {
                var md = this.getMemberDecl(f).fst;
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Unsafe_circular_dependence_on_variable, [this.name + "." + f, TypeScript.TcUtil.Logger.pos(md)]);
            }
            return g;
        };
        TModule.prototype.isCircular = function (x) {
            var md = this.getMemberDecl(x);
            return (md && md.snd);
        };
        TModule.prototype.toRTTI = function () {
            return TypeScript.MkAST.callRT("JustType", [TypeScript.MkAST.stringConst(this.name)]);
        };
        TModule.prototype.unFree = function () {
            return true;
        };
        TModule.prototype.callSignature = function () {
            return null;
        };
        TModule.prototype.subst = function (s, descend) {
            if (descend) {
                var skel = new TModule(this.name);
                return this.substBase(s, skel, false);
            }
            return this;
        };
        TModule.prototype.isVirtual = function () {
            return true;
        };
        return TModule;
    }(NamedType));
    TypeScript.TModule = TModule;
    var TEnum = (function (_super) {
        __extends(TEnum, _super);
        function TEnum(name, elements) {
            var _this = _super.call(this, TypeScript.TypeName.Enum, name) || this;
            _this.elements = elements;
            return _this;
        }
        TEnum.prototype.toString = function () {
            return this.name;
        };
        TEnum.prototype.toRTTI = function () {
            return TConstant.Number.toRTTI();
        };
        TEnum.prototype.unFree = function () {
            return true;
        };
        TEnum.prototype.subst = function (s, descend) {
            if (descend) {
                var skel = new TEnum(this.name, this.elements);
                return this.substBase(s, skel, false);
            }
            return this;
        };
        return TEnum;
    }(NamedType));
    TypeScript.TEnum = TEnum;
    var TObject = (function (_super) {
        __extends(TObject, _super);
        function TObject(name, members, methods, extendsC, implementsI) {
            if (members === void 0) { members = []; }
            if (methods === void 0) { methods = []; }
            if (extendsC === void 0) { extendsC = []; }
            if (implementsI === void 0) { implementsI = []; }
            return _super.call(this, TypeScript.TypeName.Object, name, members, methods, [], extendsC, implementsI) || this;
        }
        TObject.prototype.toString = function () {
            var suffix = "";
            var ext = this.extendsC.map(function (t) { return t.toString(); }).join(", ");
            var impl = this.implementsI.map(function (t) { return t.toString(); }).join(", ");
            if (ext !== "") {
                suffix += " extends " + ext;
            }
            if (impl !== "") {
                suffix += " implements " + impl;
            }
            return this.name;
        };
        TObject.prototype.isNominal = function () {
            return true;
        };
        TObject.prototype.isVirtual = function () {
            return (this.virtual
                || this.extendsC.some(function (t) { return t.isVirtual(); })
                || this.implementsI.some(function (t) { return t.isVirtual(); }));
        };
        TObject.prototype.toRTTI = function () {
            if (this.isVirtual()) {
                return TypeScript.MkAST.callRT("JustType", [TypeScript.MkAST.stringConst(this.name)]);
            }
            return TypeScript.MkAST.callExpr(TypeScript.MkAST.fieldOfRT("InstanceType"), [TypeScript.MkAST.stringConst(this.name)]);
        };
        TObject.prototype.subst = function (s, descend) {
            if (descend) {
                var skel = new TObject(this.name);
                skel.virtual = this.virtual;
                return this.substBase(s, skel, false);
            }
            return this;
        };
        TObject.prototype.getMethod = function (m, overload) {
            if (overload === void 0) { overload = 0; }
            return _super.prototype.getMethod.call(this, m, overload);
        };
        return TObject;
    }(NamedType));
    TypeScript.TObject = TObject;
    var TInterface = (function (_super) {
        __extends(TInterface, _super);
        function TInterface(name, members, methods, extendsC) {
            if (members === void 0) { members = []; }
            if (methods === void 0) { methods = []; }
            if (extendsC === void 0) { extendsC = []; }
            var _this = _super.call(this, TypeScript.TypeName.Interface, name, members, methods, [], extendsC, []) || this;
            _this._isArray = false;
            _this._isCheckedArray = false;
            _this._isArray = (_this.name === "Array");
            _this._isCheckedArray = (_this.name === "CheckedArray");
            return _this;
        }
        TInterface.prototype.isNominal = function () {
            if (this.nominal)
                return true;
            if (this.name === "Nominal") {
                return true;
            }
            return this.extendsC.some(function (t) { return t.isNominal(); });
        };
        TInterface.prototype.isUn = function () {
            return this.name === "Un";
        };
        TInterface.prototype.isVirtual = function () {
            if (this.virtual || this.name === "Virtual") {
                return true;
            }
            return this.extendsC.some(function (t) { return t.isVirtual(); });
        };
        TInterface.prototype.isArray = function () {
            return this._isArray;
        };
        TInterface.prototype.isCheckedArray = function () {
            return this._isCheckedArray;
        };
        TInterface.prototype.arrayElementType = function () {
            if (this.isArray() || this.isCheckedArray()) {
                return this.indexSignature().elt;
            }
            return null;
        };
        TInterface.prototype.toRecord = function (forRTTI) {
            if (forRTTI === void 0) { forRTTI = false; }
            if (forRTTI &&
                (this.isArray()
                    || this.isCheckedArray()
                    || this.name === "String"
                    || this.name === "Object"
                    || this.name === "Number"
                    || this.name === "Boolean")) {
                return new TRecord([], []);
            }
            return _super.prototype.toRecord.call(this, forRTTI);
        };
        TInterface.prototype.toString = function () {
            return this.name;
        };
        TInterface.prototype.toRTTI = function () {
            if (this.isArray()) {
                return TypeScript.MkAST.callRT("ArrayType", [this.arrayElementType().toRTTI()]);
            }
            else if (this.isVirtual()) {
                return TypeScript.MkAST.callRT("JustType", [TypeScript.MkAST.stringConst(this.name)]);
            }
            else if (this.instantiated) {
                return this.toRecord(true).toRTTI();
            }
            else {
                return TypeScript.MkAST.callExpr(TypeScript.MkAST.fieldOfRT("InterfaceType"), [TypeScript.MkAST.stringConst(this.name)]);
            }
        };
        TInterface.prototype.subst = function (s, descend) {
            if (descend) {
                var skel = new TInterface(this.name);
                skel.virtual = this.virtual;
                return this.substBase(s, skel, false);
            }
            return this;
        };
        return TInterface;
    }(NamedType));
    TypeScript.TInterface = TInterface;
    var TClass = (function (_super) {
        __extends(TClass, _super);
        function TClass(name, constr, staticMembers) {
            var _this = _super.call(this, TypeScript.TypeName.Class, name, staticMembers) || this;
            if (constr)
                _this.addConstructSignature(constr);
            return _this;
        }
        TClass.prototype.toString = function () {
            return this.name + ".class";
        };
        TClass.prototype.toRTTI = function () {
            if (this.isVirtual()) {
                return TypeScript.MkAST.callRT("JustType", [TypeScript.MkAST.stringConst(this.name)]);
            }
            return TypeScript.MkAST.callRT("ClassType", [TypeScript.MkAST.stringConst(this.name)]);
        };
        TClass.prototype.hasStaticField = function (f) {
            return this.hasField(f);
        };
        TClass.prototype.getStaticField = function (f) {
            return this.getField(f);
        };
        TClass.prototype.objectType = function () {
            var constr = this.constructSignature();
            switch (constr.typeName) {
                case TypeScript.TypeName.Arrow:
                    return constr.result;
                case TypeScript.TypeName.Poly:
                    var pconstr = constr;
                    var result = pconstr.body.result;
                    return new TPoly(pconstr.bvars, result);
                default:
                    throw new Error("Unexpected constructor type for class " + this.name + " :: " + constr.toString());
            }
        };
        TClass.prototype.subst = function (s, descend) {
            if (descend) {
                var skel = new TClass(this.name);
                skel.virtual = this.virtual;
                return this.substBase(s, skel, false);
            }
            return this;
        };
        TClass.prototype.constructSignature = function (overload) {
            if (overload === void 0) { overload = 0; }
            return _super.prototype.constructSignature.call(this, overload);
        };
        return TClass;
    }(NamedType));
    TypeScript.TClass = TClass;
    var TVar = (function (_super) {
        __extends(TVar, _super);
        function TVar(name, ppname, constraint) {
            var _this = _super.call(this, TypeScript.TypeName.Variable) || this;
            _this.name = name;
            _this.ppname = ppname;
            _this.constraint = constraint;
            return _this;
        }
        TVar.prototype.isVirtual = function () {
            return false;
        };
        TVar.prototype.equals = function (t) {
            return t.typeName === this.typeName && t.name === this.name;
        };
        TVar.prototype.subst = function (s, descend) {
            var _this = this;
            var found = s.filter(function (xt) { return xt.fst.name === _this.name; });
            if (found && found.length >= 1) {
                return found[0].snd;
            }
            return this;
        };
        TVar.prototype.toString = function () {
            return this.name;
        };
        TVar.prototype.unFree = function () {
            return true;
        };
        TVar.prototype.toRTTI = function () {
            console.log(TypeScript.TcUtil.Logger.pos() + ": tvar escapes to RTTI");
            return TypeScript.MkAST.stringConst("TVAR");
        };
        TVar.prototype.asBinder = function (fullName) {
            if (fullName && fullName.length !== 0) {
                return { fst: this.ppname, snd: new TVar(TypeScript.TcUtil.mkTypeParamName(fullName, this.ppname), this.ppname) };
            }
            return { fst: this.ppname, snd: this };
        };
        TVar.prototype.getConstraint = function () {
            return this.constraint;
        };
        return TVar;
    }(TypeScript.SoundType));
    TypeScript.TVar = TVar;
    var TPoly = (function (_super) {
        __extends(TPoly, _super);
        function TPoly(bvars, body, qualifiedStubName) {
            var _this = _super.call(this, TypeScript.TypeName.Poly) || this;
            _this.bvars = bvars;
            _this.body = body;
            _this.qualifiedStubName = qualifiedStubName;
            return _this;
        }
        TPoly.prototype.isVirtual = function () {
            return true;
        };
        TPoly.prototype.resolveStub = function () {
            if (this.qualifiedStubName) {
                var t = TypeScript.TcEnv.currentEnv.lookupType({ fullName: this.qualifiedStubName });
                if (t && t.typeName === TypeScript.TypeName.Poly) {
                    return t;
                }
                else {
                    throw new Error("Could not resolve type " + this.qualifiedStubName.join("."));
                }
            }
            return null;
        };
        TPoly.prototype.subst = function (s, descend) {
            var _this = this;
            var t = this.resolveStub();
            if (t) {
                return t.subst(s, descend);
            }
            var ss = s.filter(function (xt) { return !_this.bvars.some(function (y) { return y.equals(xt.fst); }); });
            return new TPoly(this.bvars, this.body.subst(ss, false));
        };
        TPoly.prototype.checkInstantiation = function (i, t) {
            if (i >= this.bvars.length) {
                return false;
            }
            var cons = this.bvars[i].getConstraint();
            return (cons ? TypeScript.TypeRelations.isSubtype(t, cons) : true);
        };
        TPoly.prototype.instantiate = function (args, descend) {
            var _this = this;
            if (descend === void 0) { descend = true; }
            var tt = this.resolveStub();
            if (tt) {
                return tt.instantiate(args, descend);
            }
            if (args.length !== this.bvars.length) {
                throw new Error("Arity mismatch!");
            }
            var s = args.map(function (t, i) { return ({ fst: _this.bvars[i], snd: t }); });
            var t = this.body.subst(s, descend);
            if (t instanceof NamedType) {
                var n = t;
                var body = this.body;
                n.name = body.name + "<" + args.map(function (t) { return t.toString(); }).join(", ") + ">";
            }
            return t;
        };
        TPoly.prototype.unFree = function () {
            return this.body.unFree();
        };
        TPoly.prototype.toString = function () {
            return this.body.toString();
        };
        TPoly.prototype.toRecord = function (forRTTI) {
            if (forRTTI === void 0) { forRTTI = false; }
            return this.body.toRecord(forRTTI);
        };
        TPoly.prototype.equals = function (t) {
            if (t.typeName === this.typeName) {
                var q = t;
                return this.body.equals(q.body) && this.bvars.length === q.bvars.length && this.bvars.every(function (t, i) { return t.equals(q.bvars[i]); });
            }
            return false;
        };
        TPoly.prototype.toRTTI = function () {
            console.log(TypeScript.TcUtil.Logger.pos() + ": polytype escapes to RTTI");
            return TypeScript.MkAST.stringConst("PolyType");
        };
        return TPoly;
    }(TypeScript.SoundType));
    TypeScript.TPoly = TPoly;
    var TInst = (function (_super) {
        __extends(TInst, _super);
        function TInst(t1, args) {
            var _this = _super.call(this, TypeScript.TypeName.Inst) || this;
            _this.t1 = t1;
            _this.args = args;
            if (_this.t1.body.typeName === TypeScript.TypeName.Inst) {
                var inner = _this.t1.instantiate(_this.args, false);
                if (inner.typeName === TypeScript.TypeName.Inst) {
                    _this.t1 = inner.t1;
                    _this.args = inner.args;
                }
                else {
                    throw new Error("Impossible");
                }
            }
            return _this;
        }
        TInst.prototype.unfold = function () {
            var t = this.t1.instantiate(this.args, true);
            if (t.typeName === TypeScript.TypeName.Inst) {
                return t.unfold();
            }
            t.instantiated = true;
            return t;
        };
        TInst.prototype.subst = function (s, descend) {
            return new TInst(this.t1.subst(s, false), this.args.map(function (t) { return t.subst(s, false); }));
        };
        TInst.prototype.unFree = function () {
            return this.t1.unFree() && this.args.every(function (a) { return a.unFree(); });
        };
        TInst.prototype.toString = function () {
            var inst = this.args.map(function (t) { return t.toString(); }).join(", ");
            return this.t1.toString() + "<" + inst + ">";
        };
        TInst.prototype.equals = function (t) {
            if (t.typeName === this.typeName) {
                var s = t;
                return this.t1.equals(s.t1) && this.args.length === s.args.length && this.args.every(function (t, i) { return t.equals(s.args[i]); });
            }
            var u = this.unfold();
            return u.typeName === t.typeName && u.equals(t);
        };
        TInst.prototype.toRTTI = function () {
            return this.unfold().toRTTI();
        };
        return TInst;
    }(TypeScript.SoundType));
    TypeScript.TInst = TInst;
    function callSignature(tcenv, ast, type, overload) {
        if (overload === void 0) { overload = 0; }
        type = type.unfold();
        if (!type.isVirtual() && !TypeScript.TcUtil.isPrimitive(type)) {
            overload = -1;
        }
        switch (type.typeName) {
            case TypeScript.TypeName.Arrow: return type;
            case TypeScript.TypeName.Object:
                if (ast.kind() === TypeScript.SyntaxKind.SuperKeyword) {
                    var to = type;
                    var ct = tcenv.lookup(to.name);
                    if (ct) {
                        return ct.constructSignature(overload);
                    }
                }
            default:
                return type.callSignature(overload);
        }
    }
    TypeScript.callSignature = callSignature;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TranslateTypes;
    (function (TranslateTypes) {
        function unexpectedSymbol(t) {
            throw new Error(TypeScript.TcUtil.Logger.pos()
                + ": Unrecognized PullSymbol: " + t.toString()
                + " :: isType " + t.isType()
                + ", name " + t.name
                + " fullName :: " + t.fullName()
                + " :: kind " + t.kind);
        }
        function translate(t, tcenv, debug) {
            if (debug === void 0) { debug = false; }
            if (t.isType())
                return translateType(t, tcenv, debug);
            return unexpectedSymbol(t);
        }
        TranslateTypes.translate = translate;
        function translateType(t, tcenv, debug) {
            if (debug === void 0) { debug = false; }
            var ts = translateTypeInternal(t, tcenv, debug);
            if (tcenv.inBuildPhase)
                tcenv.flushLocalTypes();
            return ts;
        }
        TranslateTypes.translateType = translateType;
        function translateTypeOrSig(t, tcenv, debug) {
            if (debug === void 0) { debug = false; }
            if (t.isType())
                return translateType(t, tcenv, debug);
            else if (t.isSignature()) {
                if (t.kind === TypeScript.PullElementKind.IndexSignature) {
                    return signatureToIndexMap(t, tcenv, debug);
                }
                else if (t.kind === TypeScript.PullElementKind.CallSignature) {
                    return signatureToPolyArrow(t, tcenv, debug);
                }
                else if (t.kind === TypeScript.PullElementKind.ConstructSignature) {
                    return constructSignatureToPolyArrow(t, tcenv, debug);
                }
            }
            return unexpectedSymbol(t);
        }
        TranslateTypes.translateTypeOrSig = translateTypeOrSig;
        function translateTypeInternal(t, tcenv, debug) {
            if (debug === void 0) { debug = false; }
            if (t._translatedSymbol)
                return t._translatedSymbol;
            var ts = translateTypeBody(t, tcenv, debug);
            t._translatedSymbol = ts;
            return ts;
        }
        function translateTypeBody(t, tcenv, debug) {
            if (debug === void 0) { debug = false; }
            var log = debug ? function (msg) { return console.log(msg); } : function (msg) { };
            if (!t) {
                console.log(TypeScript.TcUtil.Logger.pos() + ": Warning: TypeScript inferred an undefined type; mapping it to 'any'");
                return TypeScript.TConstant.Any;
            }
            var typeOfSym = t.getTypeOfSymbol();
            if (typeOfSym) {
                var res = tcenv.lookupFullName({ dottedName: typeOfSym.fullName() }, true);
                if (res) {
                    return res;
                }
            }
            if (t.kind === TypeScript.PullElementKind.FunctionType) {
                var ft = new TypeScript.TRecord([]);
                addMembersAndMethods(t, ft, tcenv, debug);
                return ft;
            }
            else if (TypeScript.TcUtil.isClassType(t)) {
                var tc = new TypeScript.TClass(TypeScript.TcUtil.getClassName(t));
                addMembersAndMethods(t, tc, tcenv, debug);
                return tc;
            }
            else if (!t.name || t.name === "" || t.name === "{}") {
                var s = new TypeScript.TRecord([]);
                addMembersAndMethods(t, s, tcenv, debug);
                return s;
            }
            else {
                switch (t.name) {
                    case "boolean": return TypeScript.TConstant.Bool;
                    case "string": return TypeScript.TConstant.String;
                    case "number": return TypeScript.TConstant.Number;
                    case "un": return TypeScript.TConstant.Un;
                    case "null": return TypeScript.TConstant.Null;
                    case "any": return TypeScript.TConstant.Any;
                    case "void": return TypeScript.TConstant.Void;
                    default:
                        return translateNamedType(t, tcenv, debug);
                }
            }
            return unexpectedSymbol(t);
        }
        function addMembersAndMethods(t, r, tcenv, debug) {
            if (debug === void 0) { debug = false; }
            var log = debug ? function (msg) { return console.log(msg); } : function (msg) { };
            if (t.getCallSignatures()) {
                t.getCallSignatures().map(function (callSig) {
                    return r.addCallSignature(signatureToPolyArrow(callSig, tcenv, debug));
                });
            }
            if (t.getIndexSignatures()) {
                t.getIndexSignatures().map(function (indexSig) {
                    return r.addIndexSignature(signatureToIndexMap(indexSig, tcenv, debug));
                });
            }
            if (t.getConstructSignatures()) {
                t.getConstructSignatures().map(function (constructSig) {
                    return r.addConstructSignature(constructSignatureToPolyArrow(constructSig, tcenv, debug));
                });
            }
            var mems = t.getMembers();
            for (var i = 0; mems && i < mems.length; i++) {
                if (mems[i].isMethod() || mems[i].kind === TypeScript.PullElementKind.FunctionExpression) {
                    var callSigs = mems[i].type.getCallSignatures();
                    callSigs.forEach(function (s) {
                        return r.addMethod(TypeScript.Method(mems[i].name, signatureToPolyArrow(s, tcenv, debug)));
                    });
                }
                else {
                    r.addField(TypeScript.Field(mems[i].name, translateTypeInternal(mems[i].type, tcenv, debug), mems[i].isOptional));
                }
            }
        }
        function fullNameAndParams(t, tcenv, debug) {
            if (debug === void 0) { debug = false; }
            var emptyBinders = [];
            if (t.isTypeParameter()) {
                return {
                    fullName: [t.name],
                    binders: emptyBinders
                };
            }
            var fullName = t.fullQualifiedName();
            if (tcenv.compilationSettings.generics() && t.isGeneric()) {
                if (t.getTypeArguments()) {
                    var targs = t.getTypeArguments().map(function (t) { return translateTypeInternal(t, tcenv, debug); });
                    return {
                        fullName: fullName,
                        targs: targs,
                        binders: emptyBinders
                    };
                }
                else {
                    var binders = [];
                    var tparams = t.getTypeParameters().map(function (ptps) {
                        var tv = new TypeScript.TVar(TypeScript.TcUtil.mkTypeParamName(fullName, ptps.name), ptps.name);
                        binders.push({ fst: ptps.name, snd: tv });
                        return tv;
                    });
                    return {
                        fullName: fullName,
                        targs: tparams.map(function (t) { return t; }),
                        tparams: tparams,
                        binders: binders
                    };
                }
            }
            else {
                return {
                    fullName: fullName,
                    binders: emptyBinders
                };
            }
        }
        function translateNamedType(t, tcenv, debug) {
            if (debug === void 0) { debug = false; }
            var log = debug ? function (msg) { return console.log(msg); } : function (msg) { };
            var nameAndArgs = fullNameAndParams(t, tcenv, debug);
            return tcenv.withLocalTypes(nameAndArgs.binders, function () {
                var cachedType = tcenv.lookupType(nameAndArgs);
                if (cachedType) {
                    if (nameAndArgs.targs) {
                        if (nameAndArgs.tparams && nameAndArgs.tparams.length !== 0 && tcenv.inBuildPhase) {
                            throw new Error("Unexpected nested binding occurrence");
                        }
                        else if (nameAndArgs.tparams) {
                            return cachedType;
                        }
                        return new TypeScript.TInst(cachedType, nameAndArgs.targs);
                    }
                    return cachedType;
                }
                if (t.isEnum()) {
                    return new TypeScript.TEnum(t.name, []);
                }
                else if (t.isTypeParameter()) {
                    if (tcenv.compilationSettings.generics() && !tcenv.inBuildPhase) {
                        console.log(TypeScript.TcUtil.Logger.pos() + " type variable " + nameAndArgs.fullName + " not found; defaulting to 'any'");
                    }
                    return TypeScript.TConstant.Any;
                }
                var mkT = (t.isInterface() ? function () { return new TypeScript.TInterface(t.name); }
                    : function () { return new TypeScript.TObject(t.name); });
                if (nameAndArgs.targs && !nameAndArgs.tparams) {
                    return new TypeScript.TInst(new TypeScript.TPoly([], mkT(), nameAndArgs.fullName), nameAndArgs.targs);
                }
                var iot = null;
                var tscheme = null;
                if (nameAndArgs.tparams && nameAndArgs.tparams.length !== 0) {
                    iot = mkT();
                    tscheme = new TypeScript.TPoly(nameAndArgs.tparams, iot);
                }
                else {
                    iot = mkT();
                    tscheme = iot;
                }
                var buildScheme = function () {
                    iot.extendsC = t.getExtendedTypes().map(function (pts) { return translateTypeInternal(pts, tcenv, debug); });
                    iot.implementsI = t.getImplementedTypes().map(function (pts) { return translateTypeInternal(pts, tcenv, debug); });
                    addMembersAndMethods(t, iot, tcenv, debug);
                    return tscheme;
                };
                if (tcenv.inBuildPhase) {
                    return tcenv.pushLocalType(nameAndArgs, tscheme, buildScheme);
                }
                else {
                    return tcenv.withLocalType(nameAndArgs, tscheme, buildScheme);
                }
            });
        }
        function signatureToPolyArrow(f, tcenv, debug) {
            if (debug === void 0) { debug = false; }
            var translateArgs = function (f) {
                var args = [];
                for (var i = 0; i < f.parameters.length; i++) {
                    var flags = f.parameters[i].getDeclarations().map(function (d) { return d.flags; });
                    args.push(new TypeScript.TArg(f.parameters[i].name, translateTypeInternal(f.parameters[i].type, tcenv, debug), flags, f.parameters[i].isVarArg));
                }
                return args;
            };
            var resolveConstraint = function (f) {
                if (!f) {
                    return undefined;
                }
                var t = translateTypeInternal(f, tcenv, debug);
                if ((!t) || t.typeName === TypeScript.TypeName.Variable) {
                    throw new Error("Variable constraints are not yet supported");
                }
                return t;
            };
            var binders = !f.typeParameters
                ? []
                : f.typeParameters.map(function (tp) {
                    var t = tcenv.lookupType({ dottedName: tp.name });
                    if (t && t.typeName === TypeScript.TypeName.Variable) {
                        var x = t.asBinder();
                        x["push"] = false;
                        return x;
                    }
                    else {
                        var constraint = resolveConstraint(tp.getConstraint());
                        t = new TypeScript.TVar(tp.name, tp.name, constraint);
                        var x = t.asBinder();
                        x["push"] = true;
                        return x;
                    }
                });
            var arr = tcenv.withLocalTypes(binders.filter(function (f) { return f["push"]; }), function () { return new TypeScript.TArrow(translateArgs(f), translateTypeInternal(f.returnType, tcenv, debug)); });
            return TypeScript.TcUtil.close(binders, arr);
        }
        function signatureToIndexMap(i, tcenv, debug) {
            if (debug === void 0) { debug = false; }
            if (i.kind !== TypeScript.PullElementKind.IndexSignature)
                return unexpectedSymbol(i);
            var indexType = translateTypeInternal(i.parameters[0].type, tcenv, debug);
            var elementType = translateTypeInternal(i.returnType, tcenv, debug);
            return new TypeScript.TIndexMap(indexType, elementType);
        }
        function constructSignatureToPolyArrow(t, tcenv, debug) {
            if (debug === void 0) { debug = false; }
            var constr_t = signatureToPolyArrow(t, tcenv, debug);
            if (constr_t.typeName === TypeScript.TypeName.Poly) {
                var tfun = constr_t.body;
                if (!tfun || tfun.typeName !== TypeScript.TypeName.Arrow) {
                    throw new Error("Impossible");
                }
                var tarrow = tfun;
                if (tarrow.result.typeName === TypeScript.TypeName.Poly) {
                    var f2 = new TypeScript.TArrow(tarrow.args, new TypeScript.TInst(tarrow.result, constr_t.bvars.map(function (t) { return t; })));
                    constr_t = new TypeScript.TPoly(constr_t.bvars, f2);
                }
            }
            return constr_t;
        }
    })(TranslateTypes = TypeScript.TranslateTypes || (TypeScript.TranslateTypes = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ScopeType;
    (function (ScopeType) {
        ScopeType[ScopeType["RegularBlock"] = 0] = "RegularBlock";
        ScopeType[ScopeType["FunctionBlock"] = 1] = "FunctionBlock";
        ScopeType[ScopeType["NamespaceBlock"] = 2] = "NamespaceBlock";
    })(ScopeType = TypeScript.ScopeType || (TypeScript.ScopeType = {}));
    var ScopeStack;
    (function (ScopeStack) {
        function newBinding(b) {
            var bindings = new Array(3);
            bindings[0] = b;
            return {
                bindings: bindings,
                top: 0
            };
        }
        function peekBinding(m) {
            return m.bindings[m.top];
        }
        function pushBinding(m, b) {
            if (m.top < m.bindings.length - 1) {
                m.top++;
                m.bindings[m.top] = b;
            }
            else {
                m.bindings.push(b);
                m.top++;
            }
        }
        function popBinding(m) {
            if (m.top >= 0)
                m.top--;
            else
                throw new Error("Popping empty multibinding");
        }
        function mkScope(scopeType) {
            if (scopeType === void 0) { scopeType = ScopeType.RegularBlock; }
            return {
                gamma: RT.createEmptyMap(),
                scopeType: scopeType
            };
        }
        function empty(t) {
            return t.top < 0;
        }
        function push(t, s) {
            if (t.top < t.scopes.length - 1) {
                t.top++;
                t.scopes[t.top] = s;
            }
            else {
                t.top++;
                t.scopes.push(s);
            }
            return t;
        }
        function peek(t) {
            if (empty(t))
                return null;
            return t.scopes[t.top];
        }
        function mkT() {
            return newScope({
                scopes: new Array(10),
                top: -1
            }, ScopeType.RegularBlock);
        }
        ScopeStack.mkT = mkT;
        function lookupVariable(t, x, stopAtBlockTypes) {
            if (stopAtBlockTypes === void 0) { stopAtBlockTypes = []; }
            for (var i = t.top; i >= 0; i--) {
                var s = t.scopes[i];
                var gx = s.gamma[x];
                if (gx) {
                    return peekBinding(gx);
                }
                if (stopAtBlockTypes.some(function (v) { return v === s.scopeType; })) {
                    break;
                }
            }
            return null;
        }
        ScopeStack.lookupVariable = lookupVariable;
        function newScope(t, scopeType) {
            return push(t, mkScope(scopeType));
        }
        ScopeStack.newScope = newScope;
        function popScope(t) {
            if (empty(t)) {
                throw new Error("Popping empty stack");
            }
            t.top--;
            return t;
        }
        ScopeStack.popScope = popScope;
        function pushVariable(s, a, x, t, allowShadowing) {
            if (allowShadowing === void 0) { allowShadowing = false; }
            if (x === "arguments") {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Arguments_is_a_reserved_name, [], a);
            }
            var old = lookupVariable(s, x, [ScopeType.NamespaceBlock, ScopeType.FunctionBlock]);
            if (!allowShadowing && old) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Variable_shadowing, [x, TypeScript.TcUtil.Logger.pos(old.snd)], a);
            }
            var sc = peek(s);
            var gx = sc.gamma[x];
            if (gx) {
                pushBinding(gx, { fst: t, snd: a });
            }
            else {
                sc.gamma[x] = newBinding({ fst: t, snd: a });
            }
        }
        ScopeStack.pushVariable = pushVariable;
        function popVariable(s, x) {
            var sc = peek(s);
            var gx = sc.gamma[x];
            if (gx) {
                popBinding(gx);
                if (gx.top < 0)
                    sc.gamma[x] = null;
            }
        }
        ScopeStack.popVariable = popVariable;
    })(ScopeStack || (ScopeStack = {}));
    var NSType;
    (function (NSType) {
        NSType[NSType["Module"] = 0] = "Module";
        NSType[NSType["Class"] = 1] = "Class";
    })(NSType || (NSType = {}));
    var TcEnv = (function () {
        function TcEnv(semanticInfoChain, compilationSettings) {
            this.semanticInfoChain = semanticInfoChain;
            this.compilationSettings = compilationSettings;
            this.inBuildPhase = false;
            this.staticScope = false;
            this._withoutThis = false;
            TypeScript.TcUtil.Logger.setSettings(compilationSettings);
            this.scopes = ScopeStack.mkT();
            this.global = new TypeScript.TModule("<global>");
            this.global.addField(TypeScript.Field("undefined", TypeScript.TConstant.Void));
            this.openNamespaces = [this.global];
            this.localTypeNames = RT.createEmptyMap();
        }
        TcEnv.prototype.symbol = function (a) {
            return this.semanticInfoChain.getSymbolForAST(a);
        };
        TcEnv.prototype.inFunctionScope = function () {
            return this.scopes.scopes.some(function (s) { return s.scopeType === ScopeType.FunctionBlock; });
        };
        TcEnv.prototype.curNamespace = function (stopAtClass) {
            if (stopAtClass === void 0) { stopAtClass = false; }
            var ns = [];
            this.openNamespaces.forEach(function (t) {
                if (t.name !== "<global>" && !(t.typeName === TypeScript.TypeName.Class && stopAtClass)) {
                    ns.push(t.name);
                }
            });
            return ns;
        };
        TcEnv.prototype.lookupHelper = function (x, stopAtBlockTypes, circularOk) {
            if (stopAtBlockTypes === void 0) { stopAtBlockTypes = []; }
            if (circularOk === void 0) { circularOk = false; }
            circularOk = circularOk || this.inFunctionScope();
            var b = ScopeStack.lookupVariable(this.scopes, x, stopAtBlockTypes);
            if (b)
                return b;
            if (stopAtBlockTypes.some(function (v) { return v === ScopeType.NamespaceBlock; })) {
                return null;
                undefined;
            }
            for (var i = this.openNamespaces.length - 1; i >= 0; i--) {
                var ns = this.openNamespaces[i];
                var f = ns.getField(x);
                if (f) {
                    if (!circularOk && ns.isCircular(x)) {
                        var md = ns.getMemberDecl(x).fst;
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Unsafe_circular_dependence_on_variable, [ns.name + "." + x, TypeScript.TcUtil.Logger.pos(md)]);
                    }
                    return { fst: f.type, snd: null };
                }
            }
            return null;
        };
        TcEnv.prototype.lookup = function (x) {
            var b = this.lookupHelper(x);
            if (b)
                return b.fst;
            return null;
        };
        TcEnv.prototype.lookupFullName = function (q, circularOk) {
            if (circularOk === void 0) { circularOk = false; }
            if (!q.fullName && !q.dottedName)
                return null;
            circularOk = circularOk || this.inFunctionScope();
            var x = q.fullName;
            if (!x) {
                x = q.dottedName.split(".");
            }
            if (x.length === 1) {
                var res = this.lookupHelper(x[0], [ScopeType.NamespaceBlock], circularOk);
                if (res) {
                    return res.fst;
                }
            }
            var ns = this.global;
            for (var i = 0; i < x.length - 1; i++) {
                var next = ns.getMember(x[i]);
                if (!next || next.type.typeName !== TypeScript.TypeName.Module) {
                    TypeScript.TcUtil.Logger.warn("Module " + x[i] + " not found; full name is " + x.join("."));
                    return null;
                }
                ns = next.type;
            }
            var f = ns.getMember(x[x.length - 1], 0, circularOk);
            if (f) {
                return f.type;
            }
            return null;
        };
        TcEnv.prototype.lookupType = function (q) {
            var xx = q.dottedName;
            if (!xx) {
                xx = q.fullName.join(".");
            }
            if (this.localTypeNames[xx]) {
                return this.localTypeNames[xx];
            }
            var x = q.fullName;
            if (!x) {
                x = xx.split(".");
            }
            var ns = this.global;
            for (var i = 0; i < x.length - 1; i++) {
                var next = ns.getMember(x[i]);
                if (!next) {
                    next = TypeScript.Field(x[i], new TypeScript.TModule(x[i]), false);
                    ns.addField(next);
                }
                if (next.type.typeName !== TypeScript.TypeName.Module) {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Module_name_clash, [xx]);
                    return null;
                }
                ns = next.type;
            }
            return ns.lookupType(x[x.length - 1]);
        };
        TcEnv.prototype.lookupTypeInCurrentScope = function (x) {
            var ns = this.curNamespace();
            ns.push(x);
            return this.lookupType({ fullName: ns });
        };
        TcEnv.prototype.mkName = function (x) {
            if (x.dottedName)
                return x.dottedName;
            return x.fullName.join(".");
        };
        TcEnv.prototype.pushLocalType = function (x, t, f) {
            var n = this.mkName(x);
            this.localTypeNames[n] = t;
            t.fullName = x.fullName;
            return f();
        };
        TcEnv.prototype.withLocalType = function (x, t, f) {
            var n = this.mkName(x);
            var oldx = this.localTypeNames[n];
            this.localTypeNames[n] = t;
            var res = f();
            this.localTypeNames[n] = oldx;
            t.fullName = x.fullName;
            return res;
        };
        TcEnv.prototype.withLocalTypes = function (ts, f, i) {
            var _this = this;
            if (i === void 0) { i = 0; }
            if (i < ts.length) {
                return this.withLocalType({ dottedName: ts[i].fst }, ts[i].snd, function () { return _this.withLocalTypes(ts, f, i + 1); });
            }
            else {
                return f();
            }
        };
        TcEnv.prototype.flushLocalTypes = function () {
            this.localTypeNames = {};
        };
        TcEnv.prototype.isShadowed = function (x) {
            return this.lookupHelper(x, [ScopeType.NamespaceBlock, ScopeType.FunctionBlock]) ? true : false;
        };
        TcEnv.prototype.push = function (scopeType) {
            if (scopeType === void 0) { scopeType = ScopeType.RegularBlock; }
            this.scopes = ScopeStack.newScope(this.scopes, scopeType);
        };
        TcEnv.prototype.pushVariable = function (a, x, t, allowShadowing) {
            if (allowShadowing === void 0) { allowShadowing = false; }
            ScopeStack.pushVariable(this.scopes, a, x, t, allowShadowing);
        };
        TcEnv.prototype.withVariable = function (a, x, t, allowShadowing) {
            var _this = this;
            if (allowShadowing === void 0) { allowShadowing = false; }
            return function (f) {
                ScopeStack.pushVariable(_this.scopes, a, x, t, allowShadowing);
                var result = f();
                ScopeStack.popVariable(_this.scopes, x);
                return result;
            };
        };
        TcEnv.prototype.withVariables = function (bindings, allowShadowing) {
            var _this = this;
            if (allowShadowing === void 0) { allowShadowing = false; }
            var clear = function () {
                bindings.reverse().map(function (b) {
                    ScopeStack.popVariable(_this.scopes, b.name);
                });
            };
            return function (f) {
                bindings.map(function (b) {
                    ScopeStack.pushVariable(_this.scopes, b.ast, b.name, b.type, allowShadowing);
                });
                var result = f();
                clear();
                return result;
            };
        };
        TcEnv.prototype.withNS = function (ns) {
            var _this = this;
            return function (f) {
                _this.openNamespaces.push(ns);
                var result = f();
                _this.openNamespaces.pop();
                return result;
            };
        };
        TcEnv.prototype.nsTip = function () {
            return this.openNamespaces[this.openNamespaces.length - 1];
        };
        TcEnv.prototype.withModule = function (x) {
            var tip = this.nsTip();
            var tmod = tip.getField(x);
            if (tmod && tmod.type.typeName === TypeScript.TypeName.Module) {
                return this.withNS(tmod.type);
            }
            else {
                throw new Error("Unexpected module " + x + " in scope " + tip.name);
            }
        };
        TcEnv.prototype.withClass = function (x) {
            var _this = this;
            var tip = this.nsTip();
            var tclass = tip.lookupType(x + ".Class");
            if (tclass && tclass.typeName === TypeScript.TypeName.Class) {
                return function (f) { return _this.withNS(tclass)(function () { return _this.newScope(f); }); };
            }
            else {
                throw new Error("Unexpected class " + x + " in scope " + tip.name);
            }
        };
        TcEnv.prototype.currentClassName = function () {
            for (var i = this.openNamespaces.length - 1; i >= 0; i--) {
                if (this.openNamespaces[i].typeName === TypeScript.TypeName.Class) {
                    return this.openNamespaces[i].name;
                }
            }
            return null;
        };
        TcEnv.prototype.newScope = function (f, scopeType) {
            if (scopeType === void 0) { scopeType = ScopeType.RegularBlock; }
            ScopeStack.newScope(this.scopes, scopeType);
            var result = f();
            ScopeStack.popScope(this.scopes);
            return result;
        };
        TcEnv.prototype.inStaticScope = function (f) {
            var old = this.staticScope;
            this.staticScope = true;
            var res = f();
            this.staticScope = old;
            return res;
        };
        TcEnv.prototype.withoutThis = function (f) {
            var old = this._withoutThis;
            this._withoutThis = true;
            var res = f();
            this._withoutThis = old;
            return res;
        };
        TcEnv.prototype.withThisType = function (t, f) {
            var old = this._thisType;
            var oldw = this._withoutThis;
            this._thisType = t;
            this._withoutThis = false;
            var a = f();
            this._thisType = old;
            this._withoutThis = oldw;
            return a;
        };
        TcEnv.prototype.thisType = function () {
            if (this._withoutThis) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_This_not_in_scope, []);
                return TypeScript.TConstant.Any;
            }
            var cn = this.currentClassName();
            if (cn) {
                var ct = this.lookup(cn);
                if (!ct || ct.typeName !== TypeScript.TypeName.Class) {
                    throw ("Class " + cn + " has type " + ct);
                }
                if (this.staticScope)
                    return ct;
                var t = ct.objectType();
                switch (t.typeName) {
                    case TypeScript.TypeName.Poly:
                        return t.body;
                    case TypeScript.TypeName.Object:
                    case TypeScript.TypeName.Interface:
                        return t;
                    default:
                        throw new Error("impossible!: class has an object of type " + t.toString());
                }
                return;
            }
            if (this._thisType) {
                return this._thisType;
            }
            return TypeScript.TConstant.Any;
        };
        TcEnv.prototype.addModuleMember = function (b, scope, fieldName, fieldType) {
            var ns = this.global;
            var fullPath = this.curNamespace().concat(scope.map(function (i) { return i.text(); }));
            for (var i = 0; i < fullPath.length; i++) {
                var f = ns.getMember(fullPath[i]);
                if (!f) {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Variable_not_found, [fullPath[i]], b);
                    return;
                }
                if (f.type.typeName !== TypeScript.TypeName.Module) {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Module_name_clash, [fullPath[i]], b);
                    return;
                }
                ns = f.type;
            }
            if (ns.hasField(fieldName)) {
                var decl = ns.getMemberDecl(fieldName);
                if (decl && !decl.snd) {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Module_overlapping_field, [ns.name, fieldName, TypeScript.TcUtil.Logger.pos(decl.fst)], b);
                }
                decl.snd = false;
            }
            else {
                ns.addField(TypeScript.Field(fieldName, fieldType));
            }
        };
        TcEnv.prototype.buildSignature = function (elts, currentModule) {
            if (currentModule === void 0) { currentModule = this.global; }
            TcEnv.currentEnv = this;
            this.inBuildPhase = true;
            this.buildSignatureAux(elts, currentModule);
            this.inBuildPhase = false;
        };
        TcEnv.prototype.getModuleNames = function (md) {
            if (md.stringLiteral) {
                return [new TypeScript.Identifier(md.stringLiteral.text())];
            }
            else {
                return TypeScript.getModuleNames(md.name);
            }
        };
        TcEnv.prototype.buildSignatureAux = function (elts, currentModule) {
            var _this = this;
            if (currentModule === void 0) { currentModule = this.global; }
            var tryAddType = function (mod, a, id, t) {
                if (mod.lookupType(id)) {
                    var decl = mod.lookupTypeDecl(id);
                    var pos = decl ? TypeScript.TcUtil.Logger.pos(decl) : "<unknown>";
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Variable_shadowing, [id, pos], a);
                }
                else {
                    mod.addType(id, t, a);
                }
            };
            var tryMergeType = function (mod, a, id, t) {
                var merge = function (name, i1, i2) {
                    return i1.concat(i2.filter(function (f2) {
                        if (i1.some(function (f1) { return f1.name === f2.name; })) {
                            TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Interface_overlapping_field, [name, f2.name], a);
                            return false;
                        }
                        return true;
                    }));
                };
                var old_t = mod.lookupType(id);
                if (old_t && old_t.typeName === TypeScript.TypeName.Interface && t.typeName === TypeScript.TypeName.Interface) {
                    var i1 = old_t;
                    var i2 = t;
                    var fields = merge(i1.name, i1.exposeFields(), i2.exposeFields());
                    var methods = merge(i1.name, i1.exposeMethods(), i2.exposeMethods());
                    var extendsClause = i1.extendsC.concat(i2.extendsC.filter(function (t2) { return !i1.extendsC.some(function (t1) { return t1.equals(t2); }); }));
                    var tif = new TypeScript.TInterface(i1.name, fields, methods, extendsClause);
                    tif.virtual = old_t.virtual || t.virtual;
                    mod.updateType(i1.name, tif);
                }
                else {
                    tryAddType(mod, a, id, t);
                }
            };
            var tryAddMember = function (mod, a, id, t, circular) {
                if (circular === void 0) { circular = false; }
                if (mod.getMember(id)) {
                    var decl = mod.getMemberDecl(id);
                    if (decl) {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Variable_shadowing, [id, TypeScript.TcUtil.Logger.pos(decl.fst)], a);
                    }
                }
                else {
                    mod.addField(TypeScript.Field(id, t));
                    mod.addMemberDecl(id, a, circular);
                }
            };
            TypeScript.TcUtil.syntaxListMembers(elts).forEach(function (a) {
                TypeScript.TcUtil.Logger.setCurrentNode(a);
                switch (a.kind()) {
                    case TypeScript.SyntaxKind.ModuleDeclaration:
                        var md = a;
                        var names = _this.getModuleNames(md);
                        var withNames = function (currentModule, i) {
                            var nextModuleField = currentModule.getMember(names[i].text());
                            if (!nextModuleField) {
                                nextModuleField = TypeScript.Field(names[i].text(), new TypeScript.TModule(names[i].text()));
                                tryAddMember(currentModule, a, nextModuleField.name, nextModuleField.type);
                            }
                            if (nextModuleField.type.typeName !== TypeScript.TypeName.Module) {
                                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Module_name_clash, [names[i].text()], a);
                                nextModuleField = TypeScript.Field(names[i].text(), new TypeScript.TModule(names[i].text()));
                            }
                            _this.withModule(nextModuleField.name)(function () {
                                if (i === names.length - 1) {
                                    _this.buildSignatureAux(md.moduleElements, nextModuleField.type);
                                }
                                else {
                                    withNames(nextModuleField.type, i + 1);
                                }
                            });
                        };
                        withNames(currentModule, 0);
                        break;
                    case TypeScript.SyntaxKind.ClassDeclaration:
                        var cd = a;
                        var constructorType = _this.symbol(a).type.getConstructorMethod().type;
                        var classType = _this.withLocalTypes(TypeScript.TcUtil.classDeclTypeParams(cd, _this), function () { return TypeScript.TranslateTypes.translateType(constructorType, _this); });
                        if (classType && classType.typeName === TypeScript.TypeName.Class) {
                            var obj_t = classType.objectType();
                            if (TypeScript.TcUtil.Logger.currentFileName === "classes.ts") {
                                console.log("Translated " + cd.identifier.text() + " to instance type " + obj_t.toString());
                            }
                            obj_t.virtual = TypeScript.hasModifier(cd.modifiers, TypeScript.PullElementFlags.Ambient);
                            tryAddType(currentModule, a, cd.identifier.text(), obj_t);
                            tryAddType(currentModule, a, cd.identifier.text() + ".Class", classType);
                            tryAddMember(currentModule, a, cd.identifier.text(), classType);
                        }
                        else {
                            throw new Error("Unexpected translation of " + cd.identifier.text() + " to a non-class type: " + classType);
                        }
                        break;
                    case TypeScript.SyntaxKind.InterfaceDeclaration:
                        var id = a;
                        if (!currentModule.lookupType(id.identifier.text())) {
                            var interfaceType = TypeScript.TranslateTypes.translateType(_this.symbol(a).type, _this);
                            if (interfaceType &&
                                (interfaceType.typeName === TypeScript.TypeName.Interface
                                    || (interfaceType.typeName === TypeScript.TypeName.Poly && interfaceType.body.typeName === TypeScript.TypeName.Interface)
                                    || interfaceType.typeName === TypeScript.TypeName.Un)) {
                                interfaceType.virtual = TypeScript.TcUtil.markAsVirtual(interfaceType);
                                interfaceType.nominal = TypeScript.TcUtil.markAsNominal(interfaceType);
                                tryMergeType(currentModule, a, id.identifier.text(), interfaceType);
                            }
                            else {
                                throw new Error("Unexpected translation of " + id.identifier.text() + " to a non-interface type: " + interfaceType);
                            }
                        }
                        break;
                    case TypeScript.SyntaxKind.EnumDeclaration:
                        var ed = a;
                        var enumType = TypeScript.TranslateTypes.translateType(_this.symbol(a).type, _this);
                        var fields = TypeScript.TcUtil.mapSepList2(ed.enumElements, function (a) {
                            var en = a;
                            return TypeScript.Field(en.propertyName.text(), enumType, false);
                        });
                        if (enumType && enumType.typeName === TypeScript.TypeName.Enum) {
                            tryAddType(currentModule, a, ed.identifier.text(), enumType);
                            var enumContainer = new TypeScript.TRecord(fields);
                            enumContainer.addIndexSignature(new TypeScript.TIndexMap(enumType, TypeScript.TConstant.String));
                            tryAddMember(currentModule, a, ed.identifier.text(), enumContainer);
                        }
                        else {
                            throw new Error("Unexpected translation of " + ed.identifier.text() + " to a non-enum type: " + enumType);
                        }
                        break;
                    case TypeScript.SyntaxKind.FunctionDeclaration:
                        var fd = a;
                        var ftype = _this.symbol(a).type;
                        if (ftype) {
                            var ftyp = TypeScript.TranslateTypes.translateType(ftype, _this);
                            if (ftyp && (ftyp.typeName === TypeScript.TypeName.Arrow || ftyp.typeName === TypeScript.TypeName.Poly || ftyp.callSignature())) {
                                tryAddMember(currentModule, a, fd.identifier.text(), ftyp);
                            }
                            else {
                                throw new Error("Unexpected translation of " + fd.identifier.text() + " to a non-arrow type: " + ftyp);
                            }
                        }
                        break;
                    case TypeScript.SyntaxKind.VariableStatement:
                        var vs = a;
                        if (TypeScript.hasModifier(vs.modifiers, TypeScript.PullElementFlags.Ambient) || TypeScript.hasModifier(vs.modifiers, TypeScript.PullElementFlags.Exported)) {
                            TypeScript.TcUtil.mapSepList2(vs.declaration.declarators, function (b) {
                                var vdr = b;
                                var var_x = vdr.propertyName.text();
                                if (vdr.inferredType.isType()) {
                                    var var_t = TypeScript.TranslateTypes.translateType(vdr.inferredType, _this);
                                    if (TypeScript.hasModifier(vs.modifiers, TypeScript.PullElementFlags.Ambient) && !TypeScript.TcUtil.isPrimitive(var_t)) {
                                        var_t = new TypeScript.JustType(var_t);
                                    }
                                    tryAddMember(currentModule, b, var_x, var_t, !TypeScript.hasModifier(vs.modifiers, TypeScript.PullElementFlags.Ambient));
                                }
                                else {
                                    throw new Error("Type inferred for " + var_x + " is not a type");
                                }
                            });
                        }
                        break;
                    default:
                        break;
                }
            });
        };
        TcEnv.currentEnv = null;
        return TcEnv;
    }());
    TypeScript.TcEnv = TcEnv;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TypeRelations;
    (function (TypeRelations) {
        var zero = undefined;
        var fail = { fst: false, snd: undefined };
        var success = function (delta) { return TypeScript.pair(true, delta); };
        function toStructuredType(t1) {
            t1 = t1.unfold();
            if (t1 instanceof TypeScript.NamedType) {
                return t1.toRecord();
            }
            if (t1 instanceof TypeScript.StructuredType) {
                return t1;
            }
            return;
        }
        function missingOptionalFields(t1, t2) {
            var r1 = toStructuredType(t1);
            var r2 = toStructuredType(t2);
            if (r1 && r2) {
                var f1 = r1.exposeFields();
                var f2 = r2.exposeFields();
                return f2.every(function (f) { return f.optional || f1.some(function (g) { return g.name === f.name; }); });
            }
            return false;
        }
        function assignable(t1, t2) {
            return (t1.unFree() && (!t1.isUn()) && t2.typeName === TypeScript.TypeName.Any)
                || (!t1.isVirtual() && missingOptionalFields(t2, t1))
                || t1.equals(t2);
        }
        TypeRelations.assignable = assignable;
        ;
        function typeEquality(t1, t2, cycles, debug) {
            if (t1.equals(t2))
                return true;
            t1 = t1.unfold();
            t2 = t2.unfold();
            if (TypeScript.TcUtil.isArray(t1) && TypeScript.TcUtil.isArray(t2)) {
                return typeEquality(TypeScript.TcUtil.arrayElementType(t1), TypeScript.TcUtil.arrayElementType(t2), cycles, debug);
            }
            switch (t1.typeName) {
                case TypeScript.TypeName.UVar:
                    var u = t1;
                    if (u.isResolved()) {
                        return typeEquality(u.unfold(), t2, cycles, debug);
                    }
                    else {
                        u.resolve(t2);
                        return true;
                    }
                case TypeScript.TypeName.IndexMap:
                    if (t2.typeName === TypeScript.TypeName.IndexMap) {
                        var i1 = t1;
                        var i2 = t2;
                        return typeEquality(i1.elt, i2.elt, cycles, debug) && typeEquality(i1.indexType, i2.indexType, cycles, debug);
                    }
                    return false;
                case TypeScript.TypeName.Interface:
                    if (t2.typeName === TypeScript.TypeName.Record) {
                        return typeEquality(t1.toRecord(), t2, cycles, debug);
                    }
                    if (t2.typeName === TypeScript.TypeName.Interface) {
                        return typeEquality(t1.toRecord(), t2.toRecord(), cycles, debug);
                    }
                    return false;
                case TypeScript.TypeName.Record:
                    if (t2.typeName === TypeScript.TypeName.Interface) {
                        return typeEquality(t1, t2.toRecord(), cycles, debug);
                    }
                    return false;
                default:
                    return false;
            }
            return false;
        }
        ;
        function deepArrayOrMapSubtyping(t1, t2, fc, cycles, debug) {
            var sub = fc.captureFree ? isSubtype : subtypeZ;
            if (TypeScript.TcUtil.isArray(t1) && TypeScript.TcUtil.isArray(t2)) {
                return sub(TypeScript.TcUtil.arrayElementType(t1), TypeScript.TcUtil.arrayElementType(t2), fc, cycles, debug);
            }
            else if (t1.typeName === TypeScript.TypeName.IndexMap
                && t2.typeName === TypeScript.TypeName.IndexMap) {
                var i1 = t1;
                var i2 = t2;
                return sub(i2.indexType, i1.indexType, fc, cycles, debug)
                    && sub(i1.elt, i2.elt, fc, cycles, debug);
            }
            return false;
        }
        function arrowSubtyping(a1, a2, cycles, debug) {
            for (var i = 0; i < a1.args.length; i++) {
                if (i >= a2.args.length) {
                    if (!a1.args[i].optional()) {
                        return false;
                    }
                    else {
                        continue;
                    }
                }
                if (a2.args[i].variadic && !a1.args[i].variadic) {
                    if (!a1.args[i].optional()) {
                        return false;
                    }
                    var elt_t = a2.args[i].type.unfold();
                    if (!elt_t.isArray() || !subtypeZ(elt_t.arrayElementType(), a1.args[i].type, TypeScript.TcUtil.fcNeither, cycles, debug)) {
                        return false;
                    }
                }
                else if (!subtypeZ(a2.args[i].type, a1.args[i].type, TypeScript.TcUtil.fcNeither, cycles, debug)) {
                    return false;
                }
            }
            return subtypeZ(a1.result, a2.result, TypeScript.TcUtil.fcNeither, cycles, debug);
        }
        function recordSubtyping(t1, t2, fc, cycles, debug) {
            if (cycles === void 0) { cycles = []; }
            var r1 = t1;
            var r2 = t2;
            var isDefaultIndexSignature = function (f, f1s, fc) {
                var sub = fc.captureFree ? isSubtype : subtypeZ;
                if (f.type.typeName === TypeScript.TypeName.IndexMap
                    && f.type.indexType.typeName === TypeScript.TypeName.String) {
                    return f1s.every(function (f1) { return sub(f1.type, f.type.elt, fc, cycles, debug); });
                }
                return false;
            };
            var checkInclusion = function (f1s, f2s, isField) {
                var difference = [];
                var res = f2s.every(function (f2) {
                    var matches = f1s.filter(function (f1) { return f1.name === f2.name; });
                    if (matches.length >= 1) {
                        var f1 = matches[0];
                        if (isField) {
                            if (f1.optional && !f2.optional)
                                return false;
                            if (f1.mutable !== f2.mutable)
                                return false;
                            if (!f1.mutable || fc.captureFree) {
                                return isSubtype(f1.type, f2.type, fc, cycles, debug);
                            }
                            if (fc.fresh) {
                                return subtypeZ(f1.type, f2.type, fc, cycles, debug);
                            }
                            return typeEquality(f1.type, f2.type, cycles, debug);
                        }
                        else {
                            if (typeEquality(f1.type, f2.type, cycles, debug)) {
                                return true;
                            }
                            else if (f1.type.typeName === TypeScript.TypeName.Arrow
                                && f2.type.typeName === TypeScript.TypeName.Arrow
                                && arrowSubtyping(f1.type, f2.type, cycles, debug)) {
                                difference.push(f1);
                                return true;
                            }
                            return false;
                        }
                    }
                    else {
                        return f2.optional && fc.fresh;
                    }
                });
                f1s.forEach(function (f1) {
                    if (!f2s.some(function (f2) { return f2.name === f1.name; })) {
                        difference.push(f1);
                    }
                });
                return { fst: res, snd: difference };
            };
            if (fc.fresh || fc.captureFree) {
                var f2 = r2.exposeFields().filter(function (f2) { return f2.type.typeName === TypeScript.TypeName.IndexMap; });
                if (f2.length === 1
                    && isDefaultIndexSignature(f2[0], r1.exposeFields(), fc)
                    && r1.exposeMethods().length === 0
                    && r2.exposeMethods().length === 0) {
                    return success(zero);
                }
            }
            var result = checkInclusion(r1.exposeFields(), r2.exposeFields(), true);
            if (!result.fst)
                return fail;
            var df = result.snd;
            result = checkInclusion(r1.exposeMethods(), r2.exposeMethods(), false);
            if (!result.fst)
                return fail;
            var dm = result.snd;
            var delta = (df.length === 0 && dm.length === 0) || (TypeScript.SoundTypeChecker.compilationSettings.tsstarTagging()) ? zero : new TypeScript.TRecord(df, dm);
            return success(delta);
        }
        function subtypeZ(t1, t2, fc, cycles, debug) {
            if (fc === void 0) { fc = TypeScript.TcUtil.fcNeither; }
            if (cycles === void 0) { cycles = []; }
            var r = subtype(t1, t2, fc, cycles, debug);
            return r.fst && !r.snd;
        }
        TypeRelations.subtypeZ = subtypeZ;
        function isSubtype(t1, t2, fc, cycles, debug) {
            if (fc === void 0) { fc = TypeScript.TcUtil.fcNeither; }
            if (cycles === void 0) { cycles = []; }
            return subtype(t1, t2, fc, cycles, debug).fst;
        }
        TypeRelations.isSubtype = isSubtype;
        function subTypeOrSig(t1, t2, fc, cycles, debug) {
            if (cycles === void 0) { cycles = []; }
            if (t1.typeName === TypeScript.TypeName.Arrow && t2.typeName === TypeScript.TypeName.Arrow) {
                if (arrowSubtyping(t1, t2, cycles, debug)) {
                    return success(zero);
                }
                return fail;
            }
            else if (t1.typeName !== TypeScript.TypeName.Arrow && t2.typeName !== TypeScript.TypeName.Arrow) {
                return subtype(t1, t2, fc, cycles, debug);
            }
            else if (t1.typeName == TypeScript.TypeName.Arrow) {
                return subtype(TypeScript.functionType(t1), t2, fc, cycles, debug);
            }
            else {
                return subtype(t1, TypeScript.functionType(t2), fc, cycles, debug);
            }
        }
        TypeRelations.subTypeOrSig = subTypeOrSig;
        function subtype(t1, t2, fc, cycles, debug) {
            if (fc === void 0) { fc = TypeScript.TcUtil.fcNeither; }
            if (cycles === void 0) { cycles = []; }
            var log = function (msg) {
                if (debug)
                    console.log(msg);
            };
            var tag = function (t) { return function (a) {
                var res = TypeScript.MkAST.callExpr(TypeScript.MkAST.fieldOfRT("tagValue"), [a, t.toRTTI()]);
                res.soundType = t;
                return res;
            }; };
            var inHierarchy = function (t, h) {
                return h.some(function (s) {
                    if (typeEquality(s, t, cycles, debug))
                        return true;
                    var ss = s.unfold();
                    if (ss instanceof TypeScript.NamedType) {
                        return (t.typeName === TypeScript.TypeName.Interface && inHierarchy(t, ss.implementsI))
                            || inHierarchy(t, ss.extendsC);
                    }
                    return false;
                });
            };
            if (!t1 || !t2)
                return fail;
            if (t1.isVirtual() && !t2.isVirtual())
                return fail;
            if (t1.equals(t2)
                || cycles.some(function (s1s2) { return s1s2.fst.equals(t1) && s1s2.snd.equals(t2); })) {
                return success(zero);
            }
            if (t1.isUn() || t2.isUn()) {
                return fail;
            }
            if ((fc.captureFree && deepArrayOrMapSubtyping(t1, t2, fc, cycles, debug))
                || typeEquality(t1, t2, cycles, debug)) {
                if (TypeScript.SoundTypeChecker.compilationSettings.tsstarTagging()
                    && TypeScript.TcUtil.isArray(t2) && TypeScript.TcUtil.isArray(t1) && TypeScript.TcUtil.arrayElementType(t1).typeName === TypeScript.TypeName.UVar) {
                    return success(t2);
                }
                return success(zero);
            }
            t1 = t1.unfold();
            t2 = t2.unfold();
            switch (t1.typeName) {
                case TypeScript.TypeName.UVar:
                    var u = t1;
                    if (u.isResolved()) {
                        return subtype(u.unfold(), t2, fc, cycles, debug);
                    }
                    else {
                        u.resolve(t2);
                        return success(zero);
                    }
                case TypeScript.TypeName.Null:
                    if (TypeScript.SoundTypeChecker.compilationSettings.relaxNullChecks()) {
                        return success(zero);
                    }
                    else {
                        if (t2.typeName === TypeScript.TypeName.Any)
                            return success(zero);
                        return fail;
                    }
                case TypeScript.TypeName.Void:
                    return success(zero);
                case TypeScript.TypeName.Variable:
                    if (t1.typeName === t2.typeName || t2.typeName === TypeScript.TypeName.Any) {
                        return success(zero);
                    }
                    var cons = t1.getConstraint();
                    return (cons ? subtype(cons, t2, fc, cycles, debug) : fail);
                case TypeScript.TypeName.String:
                case TypeScript.TypeName.Bool:
                    switch (t2.typeName) {
                        case TypeScript.TypeName.Any:
                            return success(zero);
                        default:
                            return fail;
                    }
                case TypeScript.TypeName.Number:
                    switch (t2.typeName) {
                        case TypeScript.TypeName.Enum:
                        case TypeScript.TypeName.Any:
                            return success(zero);
                        default:
                            return fail;
                    }
                case TypeScript.TypeName.Record:
                    switch (t2.typeName) {
                        case TypeScript.TypeName.Any:
                            if (t1.unFree()) {
                                if (TypeScript.SoundTypeChecker.compilationSettings.tsstarTagging()) {
                                    return success(zero);
                                }
                                else {
                                    return success(t1);
                                }
                            }
                            return fail;
                        case TypeScript.TypeName.Record:
                            return recordSubtyping(t1, t2, fc, cycles, debug);
                        case TypeScript.TypeName.Interface:
                            if (t2.isNominal()) {
                                return fail;
                            }
                            return subtype(t1, t2.toRecord(), fc, cycles, debug);
                        case TypeScript.TypeName.Just:
                            return subtype(t1, t2.repr, fc, cycles, debug);
                        case TypeScript.TypeName.Arrow:
                            throw new Error("Impossible: Arrow types should never be outside a structure");
                        default: return fail;
                    }
                case TypeScript.TypeName.Interface:
                    if (t2.typeName === TypeScript.TypeName.Any && t1.unFree() && !t1.isVirtual()) {
                        if (t1.isNominal()) {
                            return success(zero);
                        }
                        if (TypeScript.SoundTypeChecker.compilationSettings.tsstarTagging()) {
                            if (t1.isArray()) {
                                return success(t1);
                            }
                            else {
                                return success(zero);
                            }
                        }
                        else {
                            return success(t1);
                        }
                    }
                    else if (t2 instanceof TypeScript.NamedType && inHierarchy(t2, t1.extendsC)) {
                        if (t1.isNominal()) {
                            return success(zero);
                        }
                        if (TypeScript.SoundTypeChecker.compilationSettings.tsstarTagging()) {
                            return success(zero);
                        }
                        else {
                            return success(t1);
                        }
                    }
                    else {
                        switch (t2.typeName) {
                            case TypeScript.TypeName.Interface:
                                if (t1.isArray() && t2.isCheckedArray()) {
                                    var e1 = t1.arrayElementType();
                                    var e2 = t2.arrayElementType();
                                    if (isSubtype(e1, e2, fc, cycles, debug)) {
                                        return success(t1);
                                    }
                                    else {
                                        return fail;
                                    }
                                }
                                else if (!t2.isNominal()) {
                                    var res = subtype(t1.toRecord(), t2, fc, cycles.concat([TypeScript.pair(t1, t2)]), debug);
                                    if (res.fst && !TypeScript.SoundTypeChecker.compilationSettings.tsstarTagging()) {
                                        res.snd = t1;
                                    }
                                    if (res.fst && t1.isNominal()) {
                                        return success(zero);
                                    }
                                    return res;
                                }
                                else {
                                    return fail;
                                }
                            case TypeScript.TypeName.Record:
                                var res = subtype(t1.toRecord(), t2, fc, cycles, debug);
                                if (res.fst && !TypeScript.SoundTypeChecker.compilationSettings.tsstarTagging()) {
                                    if (t1.isNominal()) {
                                        res.snd = zero;
                                    }
                                    else {
                                        res.snd = t1;
                                    }
                                }
                                return res;
                            case TypeScript.TypeName.Just:
                                if (isSubtype(t1, t2.repr, fc, cycles, debug)) {
                                    return success(zero);
                                }
                                return fail;
                            default:
                                return fail;
                        }
                    }
                case TypeScript.TypeName.Object:
                    var o = t1;
                    if (t2.typeName === TypeScript.TypeName.Any && t1.unFree()) {
                        return success(zero);
                    }
                    else if (t2.typeName === TypeScript.TypeName.Object && inHierarchy(t2, o.extendsC)) {
                        return success(zero);
                    }
                    else {
                        switch (t2.typeName) {
                            case TypeScript.TypeName.Interface:
                                if (inHierarchy(t2, o.implementsI) || o.extendsC.some(function (t) { return isSubtype(t, t2, fc, cycles, debug); })) {
                                    return success(zero);
                                }
                                else if (isSubtype(t1.toRecord(), t2.toRecord(), fc, cycles.concat([TypeScript.pair(t1, t2)]), debug)) {
                                    return success(zero);
                                }
                                return fail;
                            case TypeScript.TypeName.Record:
                                if (isSubtype(t1.toRecord(), t2, fc, cycles, debug)) {
                                    return success(zero);
                                }
                                return fail;
                            case TypeScript.TypeName.Just:
                                if (isSubtype(t1, t2.repr, fc, cycles, debug)) {
                                    return success(zero);
                                }
                                return fail;
                            default:
                                return fail;
                        }
                    }
                case TypeScript.TypeName.Just:
                    var undotSubtype = function (t1, t2) {
                        if (t2.typeName === TypeScript.TypeName.Just) {
                            t2 = t2.repr;
                        }
                        if (isSubtype(t1.repr, t2, fc, cycles, debug)) {
                            return success(zero);
                        }
                        return fail;
                    };
                    switch (t1.repr.typeName) {
                        case TypeScript.TypeName.Bool:
                        case TypeScript.TypeName.Number:
                        case TypeScript.TypeName.String:
                        case TypeScript.TypeName.Void:
                            if (t2.equals(t1.repr)) {
                                return success(zero);
                            }
                            if (t2.typeName === TypeScript.TypeName.Any) {
                                return success(zero);
                            }
                            return undotSubtype(t1, t2);
                        default:
                            return undotSubtype(t1, t2);
                    }
                case TypeScript.TypeName.Class:
                    if (t2.typeName === TypeScript.TypeName.Any && t1.unFree()) {
                        return success(zero);
                    }
                    else {
                        switch (t2.typeName) {
                            case TypeScript.TypeName.Interface:
                                return subtype(t1.toRecord(), t2, fc, cycles.concat([TypeScript.pair(t1, t2)]), debug);
                            case TypeScript.TypeName.Record:
                                return subtype(t1.toRecord(), t2, fc, cycles, debug);
                            case TypeScript.TypeName.Just:
                                if (isSubtype(t1, t2.repr, fc, cycles, debug)) {
                                    return success(zero);
                                }
                                return fail;
                            default:
                                return fail;
                        }
                    }
                case TypeScript.TypeName.Enum:
                    if (t2.typeName === TypeScript.TypeName.Number || t2.typeName === TypeScript.TypeName.Any) {
                        return success(zero);
                    }
                    return fail;
                case TypeScript.TypeName.Poly:
                    var q1 = t1;
                    if (t2.typeName === TypeScript.TypeName.Poly) {
                        var q2 = t2;
                        if (q1.bvars.length === q2.bvars.length && q1.bvars.every(function (t, i) { return t.equals(q2.bvars[i]); })) {
                            if (isSubtype(q1.body, q2.body, fc, cycles, debug)) {
                                return success(zero);
                            }
                        }
                    }
                    return fail;
                case TypeScript.TypeName.Variable:
                case TypeScript.TypeName.Module:
                case TypeScript.TypeName.IndexMap:
                case TypeScript.TypeName.Null:
                case TypeScript.TypeName.Un:
                case TypeScript.TypeName.Any:
                    return fail;
                default: throw new Error("Unexpected type name t1 = " + t1 + ", t2 = " + t2 + ", :: debug= " + debug);
            }
        }
        TypeRelations.subtype = subtype;
    })(TypeRelations = TypeScript.TypeRelations || (TypeScript.TypeRelations = {}));
    ;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SoundTypeChecker = (function () {
        function SoundTypeChecker(tcenv, scriptName, compilationSettings, semanticInfoChain, doc, rewriteSource) {
            this.tcenv = tcenv;
            this.scriptName = scriptName;
            this.compilationSettings = compilationSettings;
            this.semanticInfoChain = semanticInfoChain;
            this.doc = doc;
            this.rewriteSource = rewriteSource;
            this.result_t = null;
            this.rewriteSource = this.rewriteSource && !compilationSettings.noRuntimeChecks();
        }
        SoundTypeChecker.buildSignature = function (compilationSettings, semanticInfoChain, doc) {
            var tcEnv = null;
            TypeScript.TcUtil.Logger.startLogForDocument(doc);
            if (TypeScript.TcUtil.isCurrentScriptRT()) {
                return [];
            }
            this.compilationSettings = compilationSettings;
            if (SoundTypeChecker.globalEnv) {
                tcEnv = SoundTypeChecker.globalEnv;
            }
            else {
                tcEnv = new TypeScript.TcEnv(semanticInfoChain, compilationSettings);
            }
            tcEnv.buildSignature(doc.sourceUnit().moduleElements);
            SoundTypeChecker.globalEnv = tcEnv;
            return [];
        };
        SoundTypeChecker.check = function (compilationSettings, semanticInfoChain, doc) {
            this.compilationSettings = compilationSettings;
            var scriptName = doc.fileName.substring(doc.fileName.lastIndexOf("/") + 1);
            TypeScript.TcUtil.Logger.setSettings(compilationSettings);
            var checker = new SoundTypeChecker(SoundTypeChecker.globalEnv, scriptName, compilationSettings, semanticInfoChain, doc, true);
            TypeScript.TcUtil.Logger.startLogForDocument(doc);
            TypeScript.TcEnv.currentEnv = SoundTypeChecker.globalEnv;
            checker.tc(doc.sourceUnit());
            return TypeScript.TcUtil.Logger.diagnostics();
        };
        SoundTypeChecker.prototype.emitBaseClassHierarchy = function () {
            SoundTypeChecker.emittedBaseClassHierarchy = true;
            var emit = function (tname, name) {
                var ot = TypeScript.TcEnv.currentEnv.lookupType({ dottedName: tname });
                if (!ot) {
                    return TypeScript.MkAST.stringConst(name + " missing");
                }
                var st = ot.toRecord(false);
                return new TypeScript.ExpressionStatement(TypeScript.MkAST.callRT("registerType", [TypeScript.MkAST.callRT("InterfaceRepr", [TypeScript.MkAST.stringConst(name),
                        TypeScript.toMethodTable(st.exposeMethods()),
                        TypeScript.toFieldTable(st.exposeFields()),
                        TypeScript.MkAST.mkCleanArray([])])]));
            };
            return [emit("Object", "Object"),
                emit("String", "String"),
                emit("Number", "Number"),
                emit("Boolean", "Boolean"),
                emit("Error", "Error"),
                emit("TypeError", "TypeError"),
                emit("RegExp", "RegExp")];
        };
        SoundTypeChecker.prototype.emitInterfaceRegistration = function (ast) {
            var t = this.tcenv.lookupTypeInCurrentScope(ast.identifier.text());
            if (!t || t["emitted"] || t.isVirtual() || !(t instanceof TypeScript.TInterface)) {
                return;
            }
            var it = t;
            it["emitted"] = true;
            var st = it.toRecord(true);
            var reduceFn = function (accum, curr, index, a) {
                if (curr instanceof TypeScript.NamedType) {
                    var nt = curr;
                    return (nt.extendsC ? accum.concat(nt.extendsC.reduce(reduceFn, [curr])) : [curr]);
                }
                else {
                    accum.push(curr);
                    return accum;
                }
            };
            var extendsList = it.extendsC ? it.extendsC.reduce(reduceFn, []) : [];
            return new TypeScript.ExpressionStatement(TypeScript.MkAST.callRT("registerType", [TypeScript.MkAST.callRT("InterfaceRepr", [TypeScript.MkAST.stringConst(ast.identifier.text()),
                    TypeScript.toMethodTable(st.exposeMethods()),
                    TypeScript.toFieldTable(st.exposeFields()),
                    TypeScript.MkAST.mkCleanArray(extendsList.map(function (t) { return TypeScript.MkAST.stringConst(t.toString()); })),
                    TypeScript.MkAST.boolConst(it.isNominal())])]));
        };
        SoundTypeChecker.prototype.emitClassRtti = function (ast) {
            var t = this.tcenv.lookupTypeInCurrentScope(ast.identifier.text());
            if (!t || t.isVirtual()) {
                return;
            }
            var a = new TypeScript.ExpressionStatement(new TypeScript.BinaryExpression(TypeScript.SyntaxKind.AssignmentExpression, new TypeScript.MemberAccessExpression(new TypeScript.MemberAccessExpression(ast.identifier, new TypeScript.Identifier("prototype")), new TypeScript.Identifier("__rtti__")), TypeScript.MkAST.callRT("InstanceType", [TypeScript.MkAST.stringConst(ast.identifier.text())])));
            return a;
        };
        SoundTypeChecker.prototype.emitFunctionRtti = function (ast) {
            var t = ast.soundType;
            if (!t || t.isVirtual()) {
                return;
            }
            return new TypeScript.ExpressionStatement(TypeScript.MkAST.setRtti(ast.identifier, t.toRTTI()));
        };
        SoundTypeChecker.prototype.symbol = function (a) {
            return this.semanticInfoChain.getSymbolForAST(a);
        };
        SoundTypeChecker.prototype.tc = function (ast) {
            return this.tcaux(ast).fst;
        };
        SoundTypeChecker.prototype.tcWithResult = function (r, a) {
            var old = this.result_t;
            this.result_t = r;
            try {
                var res = this.tcaux(a);
                switch (r.typeName) {
                    case TypeScript.TypeName.Void:
                    case TypeScript.TypeName.Any:
                    case TypeScript.TypeName.Un: break;
                    default:
                        if (!res.snd) {
                            TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Missing_return, [], a);
                        }
                }
                this.result_t = old;
                return res.fst;
            }
            catch (e) {
                this.result_t = old;
                throw (e);
            }
        };
        SoundTypeChecker.prototype.tcaux = function (ast) {
            var _this = this;
            return TypeScript.TcUtil.Logger.withCurrentNode(ast, function () {
                var res = _this.tcMain(ast);
                if (TypeScript.TcUtil.Logger.reportWarnings) {
                    var expected_t;
                    if (ast.inferredType) {
                        expected_t = TypeScript.TranslateTypes.translateTypeOrSig(ast.inferredType, _this.tcenv);
                    }
                    if (expected_t) {
                        var sc = TypeScript.TypeRelations.subTypeOrSig(res.fst.soundType, expected_t, TypeScript.TcUtil.allowDeepSubtyping(ast));
                        if (!sc.fst) {
                            TypeScript.TcUtil.Logger.warn("Inferred type incompatible for " + TypeScript.kind2string(ast.kind()));
                            TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Inferred_type_incompatible_with_sound_type, [expected_t.toString(), res.fst.soundType.toString()], ast);
                        }
                    }
                }
                return res;
            });
        };
        SoundTypeChecker.prototype.pkg = function (orig, checked, t, returns) {
            if (t === void 0) { t = TypeScript.TConstant.Void; }
            if (returns === void 0) { returns = false; }
            var astDecl = this.semanticInfoChain.getDeclForAST(orig);
            if (astDecl) {
                this.semanticInfoChain.setDeclForAST(checked, astDecl);
            }
            checked._start = orig._start;
            checked._end = orig._end;
            checked.setPreComments(orig.preComments());
            checked.setPostComments(orig.postComments());
            this.semanticInfoChain.setSymbolForAST(checked, this.symbol(orig));
            this.semanticInfoChain.setAliasSymbolForAST(checked, this.semanticInfoChain.getAliasSymbolForAST(orig));
            checked._trailingTriviaWidth = orig._trailingTriviaWidth;
            checked.soundType = t;
            return { fst: checked, snd: returns };
        };
        SoundTypeChecker.prototype.tcMain = function (ast) {
            if (!ast) {
                throw new Error("Unexpected null AST");
            }
            var nodeType = ast.kind();
            switch (nodeType) {
                case TypeScript.SyntaxKind.AnyKeyword:
                case TypeScript.SyntaxKind.BooleanKeyword:
                case TypeScript.SyntaxKind.NumericLiteral:
                case TypeScript.SyntaxKind.NumberKeyword:
                case TypeScript.SyntaxKind.StringKeyword:
                case TypeScript.SyntaxKind.VoidKeyword:
                case TypeScript.SyntaxKind.ArrayType:
                case TypeScript.SyntaxKind.TupleType:
                case TypeScript.SyntaxKind.GenericType:
                case TypeScript.SyntaxKind.ObjectType:
                case TypeScript.SyntaxKind.TypeQuery:
                case TypeScript.SyntaxKind.ConstructorType:
                case TypeScript.SyntaxKind.FunctionType:
                    try {
                        var tsStarType = this.computeType(ast);
                        return this.pkg(ast, ast, tsStarType);
                    }
                    catch (e) {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Feature_not_supported, ["Type reference"], ast);
                        return this.pkg(ast, ast, TypeScript.TConstant.Any);
                    }
                case TypeScript.SyntaxKind.List:
                    return this.tcList(ast);
                case TypeScript.SyntaxKind.SeparatedList:
                    return this.tcSeparatedList(ast);
                case TypeScript.SyntaxKind.SourceUnit:
                    return this.tcSourceUnit(ast);
                case TypeScript.SyntaxKind.EnumDeclaration:
                    return this.tcEnumDeclaration(ast);
                case TypeScript.SyntaxKind.ModuleDeclaration:
                    return this.tcModuleDeclaration(ast);
                case TypeScript.SyntaxKind.InterfaceDeclaration:
                    return this.tcInterfaceDeclaration(ast);
                case TypeScript.SyntaxKind.ClassDeclaration:
                    return this.tcClassDeclaration(ast);
                case TypeScript.SyntaxKind.VariableDeclaration:
                    return this.tcVariableDeclarationList(ast);
                case TypeScript.SyntaxKind.MemberVariableDeclaration:
                    return this.tcMemberVariableDeclaration(ast);
                case TypeScript.SyntaxKind.VariableDeclarator:
                    var vd = ast;
                    if (this.scriptName === "lib.d.ts" && vd.propertyName.text() === "Array") {
                        return { fst: vd, snd: false };
                    }
                    return this.tcVariableDeclarator(ast);
                case TypeScript.SyntaxKind.PropertySignature:
                    return this.tcPropertySignature(ast);
                case TypeScript.SyntaxKind.ParameterList:
                    return this.tcParameterList(ast);
                case TypeScript.SyntaxKind.Parameter:
                    return this.tcParameter(ast);
                case TypeScript.SyntaxKind.EnumElement:
                    return this.tcEnumElement(ast);
                case TypeScript.SyntaxKind.EqualsValueClause:
                    return this.tcEqualsValueClause(ast);
                case TypeScript.SyntaxKind.TypeParameter:
                    return this.tcTypeParameterDeclaration(ast);
                case TypeScript.SyntaxKind.Constraint:
                    return this.tcConstraint(ast);
                case TypeScript.SyntaxKind.ImportDeclaration:
                    return this.tcImportDeclaration(ast);
                case TypeScript.SyntaxKind.ObjectLiteralExpression:
                    return this.tcObjectLiteralExpression(ast);
                case TypeScript.SyntaxKind.SimplePropertyAssignment:
                    return this.tcSimplePropertyAssignment(ast);
                case TypeScript.SyntaxKind.FunctionPropertyAssignment:
                    return this.tcFunctionPropertyAssignment(ast);
                case TypeScript.SyntaxKind.IdentifierName:
                    if (TypeScript.isTypesOnlyLocation(ast)) {
                        return this.tcTypeNameExpression(ast);
                    }
                    else {
                        return this.tcNameExpression(ast);
                    }
                case TypeScript.SyntaxKind.MemberAccessExpression:
                    return this.tcMemberAccessExpression(ast);
                case TypeScript.SyntaxKind.QualifiedName:
                    return this.tcQualifiedName(ast);
                case TypeScript.SyntaxKind.ConstructorDeclaration:
                    return this.tcConstructorDeclaration(ast);
                case TypeScript.SyntaxKind.GetAccessor:
                    return this.tcGetAccessor(ast);
                case TypeScript.SyntaxKind.SetAccessor:
                    return this.tcSetAccessor(ast);
                case TypeScript.SyntaxKind.IndexMemberDeclaration:
                    return this.tcIndexMemberDeclaration(ast);
                case TypeScript.SyntaxKind.IndexSignature:
                    return this.tcIndexSignature(ast);
                case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                    return this.tcMemberFunctionDeclaration(ast);
                case TypeScript.SyntaxKind.CallSignature:
                    return this.tcCallSignature(ast);
                case TypeScript.SyntaxKind.ConstructSignature:
                    return this.tcConstructSignature(ast);
                case TypeScript.SyntaxKind.MethodSignature:
                    return this.tcMethodSignature(ast);
                case TypeScript.SyntaxKind.FunctionDeclaration:
                    return this.tcAnyFunctionDeclaration(ast);
                case TypeScript.SyntaxKind.FunctionExpression:
                    return this.tcFunctionExpression(ast);
                case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
                    return this.tcSimpleArrowFunctionExpression(ast);
                case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                    return this.tcParenthesizedArrowFunctionExpression(ast);
                case TypeScript.SyntaxKind.ArrayLiteralExpression:
                    return this.tcArrayLiteralExpression(ast);
                case TypeScript.SyntaxKind.ThisKeyword:
                    return this.tcThisExpression(ast);
                case TypeScript.SyntaxKind.SuperKeyword:
                    return this.tcSuperExpression(ast);
                case TypeScript.SyntaxKind.InvocationExpression:
                    var ie = ast;
                    switch (ie.expression.kind()) {
                        case TypeScript.SyntaxKind.IdentifierName:
                            var id = ie.expression;
                            switch (id.text()) {
                                case "wrap": return this.tcWrapOrCanTagInvocation(ie, "wrap");
                                case "canTag": return this.tcWrapOrCanTagInvocation(ie, "canTag");
                                default: break;
                            }
                            break;
                        case TypeScript.SyntaxKind.MemberAccessExpression:
                            var mae = ie.expression;
                            if (mae.expression.kind() === TypeScript.SyntaxKind.IdentifierName && mae.expression.text() === "RT" && mae.name.text() === "forceCheckedArray") {
                                return this.tcForceCheckedArrayInvocation(ie);
                            }
                            break;
                        default: break;
                    }
                    return this.tcInvocationExpression(ast);
                case TypeScript.SyntaxKind.ObjectCreationExpression:
                    return this.tcObjectCreationExpression(ast);
                case TypeScript.SyntaxKind.CastExpression:
                    return this.tcCastExpression(ast);
                case TypeScript.SyntaxKind.TypeAnnotation:
                    return this.tcTypeAnnotation(ast);
                case TypeScript.SyntaxKind.ExportAssignment:
                    return this.tcExportAssignmentStatement(ast);
                case TypeScript.SyntaxKind.NumericLiteral:
                    return this.pkg(ast, ast, TypeScript.TConstant.Number, false);
                case TypeScript.SyntaxKind.StringLiteral:
                    return this.pkg(ast, ast, TypeScript.TConstant.String, false);
                case TypeScript.SyntaxKind.NullKeyword:
                    return this.pkg(ast, ast, TypeScript.TConstant.Null, false);
                case TypeScript.SyntaxKind.TrueKeyword:
                case TypeScript.SyntaxKind.FalseKeyword:
                    return this.pkg(ast, ast, TypeScript.TConstant.Bool, false);
                case TypeScript.SyntaxKind.VoidExpression:
                    return this.tcVoidExpression(ast);
                case TypeScript.SyntaxKind.AssignmentExpression:
                case TypeScript.SyntaxKind.AddAssignmentExpression:
                case TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression:
                case TypeScript.SyntaxKind.LeftShiftAssignmentExpression:
                case TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression:
                case TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression:
                case TypeScript.SyntaxKind.SubtractAssignmentExpression:
                case TypeScript.SyntaxKind.MultiplyAssignmentExpression:
                case TypeScript.SyntaxKind.DivideAssignmentExpression:
                case TypeScript.SyntaxKind.ModuloAssignmentExpression:
                case TypeScript.SyntaxKind.OrAssignmentExpression:
                case TypeScript.SyntaxKind.AndAssignmentExpression:
                    return this.tcAssignmentExpression(ast);
                case TypeScript.SyntaxKind.NotEqualsWithTypeConversionExpression:
                case TypeScript.SyntaxKind.EqualsWithTypeConversionExpression:
                case TypeScript.SyntaxKind.EqualsExpression:
                case TypeScript.SyntaxKind.NotEqualsExpression:
                case TypeScript.SyntaxKind.LessThanExpression:
                case TypeScript.SyntaxKind.LessThanOrEqualExpression:
                case TypeScript.SyntaxKind.GreaterThanOrEqualExpression:
                case TypeScript.SyntaxKind.GreaterThanExpression:
                case TypeScript.SyntaxKind.AddExpression:
                case TypeScript.SyntaxKind.SubtractExpression:
                case TypeScript.SyntaxKind.MultiplyExpression:
                case TypeScript.SyntaxKind.DivideExpression:
                case TypeScript.SyntaxKind.ModuloExpression:
                case TypeScript.SyntaxKind.BitwiseOrExpression:
                case TypeScript.SyntaxKind.BitwiseAndExpression:
                case TypeScript.SyntaxKind.LeftShiftExpression:
                case TypeScript.SyntaxKind.SignedRightShiftExpression:
                case TypeScript.SyntaxKind.UnsignedRightShiftExpression:
                case TypeScript.SyntaxKind.BitwiseExclusiveOrExpression:
                case TypeScript.SyntaxKind.LogicalAndExpression:
                    return this.tcBinOp(ast);
                case TypeScript.SyntaxKind.LogicalOrExpression:
                    return this.tcLogicalOrExpression(ast);
                case TypeScript.SyntaxKind.LogicalNotExpression:
                case TypeScript.SyntaxKind.PlusExpression:
                case TypeScript.SyntaxKind.NegateExpression:
                case TypeScript.SyntaxKind.BitwiseNotExpression:
                    return this.tcUnaryOperation(ast);
                case TypeScript.SyntaxKind.PreIncrementExpression:
                case TypeScript.SyntaxKind.PreDecrementExpression:
                    return this.tcPrefixUnaryOpWithAssignment(ast);
                case TypeScript.SyntaxKind.PostIncrementExpression:
                case TypeScript.SyntaxKind.PostDecrementExpression:
                    return this.tcPostfixUnaryOpWithAssignment(ast);
                case TypeScript.SyntaxKind.ElementAccessExpression:
                    return this.tcElementAccessExpression(ast);
                case TypeScript.SyntaxKind.TypeOfExpression:
                    return this.tcTypeOfExpression(ast);
                case TypeScript.SyntaxKind.ThrowStatement:
                    return this.tcThrowStatement(ast);
                case TypeScript.SyntaxKind.DeleteExpression:
                    return this.tcDeleteExpression(ast);
                case TypeScript.SyntaxKind.ConditionalExpression:
                    return this.tcConditionalExpression(ast);
                case TypeScript.SyntaxKind.RegularExpressionLiteral:
                    return this.tcRegularExpressionLiteral(ast);
                case TypeScript.SyntaxKind.ParenthesizedExpression:
                    return this.tcParenthesizedExpression(ast);
                case TypeScript.SyntaxKind.ExpressionStatement:
                    return this.tcExpressionStatement(ast);
                case TypeScript.SyntaxKind.InstanceOfExpression:
                    return this.tcInstanceOfExpression(ast);
                case TypeScript.SyntaxKind.CommaExpression:
                    return this.tcCommaExpression(ast);
                case TypeScript.SyntaxKind.InExpression:
                    return this.tcInExpression(ast);
                case TypeScript.SyntaxKind.ForStatement:
                    return this.tcForStatement(ast);
                case TypeScript.SyntaxKind.ForInStatement:
                    return this.tcForInStatement(ast);
                case TypeScript.SyntaxKind.WhileStatement:
                    return this.tcWhileStatement(ast);
                case TypeScript.SyntaxKind.DoStatement:
                    return this.tcDoStatement(ast);
                case TypeScript.SyntaxKind.IfStatement:
                    return this.tcIfStatement(ast);
                case TypeScript.SyntaxKind.ElseClause:
                    return this.tcElseClause(ast);
                case TypeScript.SyntaxKind.Block:
                    return this.tcBlock(ast);
                case TypeScript.SyntaxKind.VariableStatement:
                    return this.tcVariableStatement(ast);
                case TypeScript.SyntaxKind.WithStatement:
                    return this.tcWithStatement(ast);
                case TypeScript.SyntaxKind.TryStatement:
                    return this.tcTryStatement(ast);
                case TypeScript.SyntaxKind.CatchClause:
                    return this.tcCatchClause(ast);
                case TypeScript.SyntaxKind.FinallyClause:
                    return this.tcFinallyClause(ast);
                case TypeScript.SyntaxKind.ReturnStatement:
                    return this.tcReturnStatement(ast);
                case TypeScript.SyntaxKind.SwitchStatement:
                    return this.tcSwitchStatement(ast);
                case TypeScript.SyntaxKind.ContinueStatement:
                    return this.tcContinueStatement(ast);
                case TypeScript.SyntaxKind.BreakStatement:
                    return this.tcBreakStatement(ast);
                case TypeScript.SyntaxKind.LabeledStatement:
                    return this.tcLabeledStatement(ast);
                case TypeScript.SyntaxKind.ArgumentList:
                    return this.tcArgumentList(ast);
                case TypeScript.SyntaxKind.CaseSwitchClause:
                    return this.tcCaseSwitchClause(ast);
                case TypeScript.SyntaxKind.DefaultSwitchClause:
                    return this.tcDefaultSwitchClause(ast);
                case TypeScript.SyntaxKind.ExtendsHeritageClause:
                case TypeScript.SyntaxKind.ImplementsHeritageClause:
                    return this.tcHeritageClause(ast);
                case TypeScript.SyntaxKind.EmptyStatement:
                    return this.pkg(ast, ast, TypeScript.TConstant.Void);
                case TypeScript.SyntaxKind.TypeParameterList:
                    return this.tcTypeParameterList(ast);
                case TypeScript.SyntaxKind.TypeArgumentList:
                    return this.tcTypeArgumentList(ast);
                default:
                    return TypeScript.TcUtil.NYI("Unexpected ast kind " + (TypeScript.kind2string(nodeType)));
            }
        };
        SoundTypeChecker.prototype.tcList = function (ast) {
            var checked;
            if (!SoundTypeChecker.emittedBaseClassHierarchy) {
                checked = this.emitBaseClassHierarchy();
            }
            else {
                checked = [];
            }
            var returns = false;
            for (var i = 0; i < ast.childCount(); i++) {
                var c = this.tcaux(ast.childAt(i));
                checked.push(c.fst);
                if (c.fst.kind() === TypeScript.SyntaxKind.InterfaceDeclaration) {
                    var ireg = this.emitInterfaceRegistration(c.fst);
                    if (ireg) {
                        checked.push(ireg);
                    }
                }
                if (c.fst.kind() === TypeScript.SyntaxKind.ClassDeclaration) {
                    var creg = this.emitClassRtti(c.fst);
                    if (creg) {
                        checked.push(creg);
                    }
                }
                if (c.fst.kind() === TypeScript.SyntaxKind.FunctionDeclaration && this.compilationSettings.tsstarTagging()) {
                    var f = this.emitFunctionRtti(c.fst);
                    if (f) {
                        checked.push(f);
                    }
                }
                returns = returns || c.snd;
            }
            var res = new TypeScript.ISyntaxList2(this.doc.fileName, checked);
            return this.pkg(ast, res, TypeScript.TConstant.Void, returns);
        };
        SoundTypeChecker.prototype.tcSeparatedList = function (ast) {
            var checked = [];
            var returns = false;
            for (var i = 0; i < ast.nonSeparatorCount(); i++) {
                var c = this.tcaux(ast.nonSeparatorAt(i));
                checked.push(c.fst);
                returns = returns || c.snd;
            }
            var res = new TypeScript.ISeparatedSyntaxList2(this.doc.fileName, checked, ast.separatorCount());
            return this.pkg(ast, res, TypeScript.TConstant.Void, returns);
        };
        SoundTypeChecker.prototype.tcSourceUnit = function (ast) {
            var elts = this.tc(ast.moduleElements);
            if (this.rewriteSource) {
                ast.rewrittenModuleElements = elts;
                elts.parent = ast;
                return this.pkg(ast, ast);
            }
            return { fst: ast, snd: false };
        };
        SoundTypeChecker.prototype.tcEnumDeclaration = function (ast) {
            var t = new TypeScript.TEnum(ast.identifier.text(), TypeScript.TcUtil.mapSepList2(ast.enumElements, function (a) {
                return a.propertyName.text();
            }));
            TypeScript.TcUtil.mapSepList2(ast.enumElements, function (a) {
                a.soundType = t;
            });
            return this.pkg(ast, ast);
        };
        SoundTypeChecker.prototype.tcModuleDeclaration = function (ast) {
            var _this = this;
            if (TypeScript.hasModifier(ast.modifiers, TypeScript.PullElementFlags.Ambient)) {
                return this.pkg(ast, ast);
            }
            var names = TypeScript.getModuleNames(ast.name);
            var withNames = function (i) {
                if (i === names.length - 1) {
                    return _this.tcenv.withModule(names[i].text())(function () { return _this.tcenv.newScope(function () { return _this.tc(ast.moduleElements); }, TypeScript.ScopeType.NamespaceBlock); });
                }
                else {
                    return _this.tcenv.withModule(names[i].text())(function () { return withNames(i + 1); });
                }
            };
            TypeScript.TcUtil.syntaxListMembers(ast.moduleElements).forEach(function (v) {
                switch (v.kind()) {
                    case TypeScript.SyntaxKind.VariableStatement:
                        var vs = v;
                        TypeScript.TcUtil.mapSepList2(vs.declaration.declarators, function (b) {
                            var vdr = b;
                            if (vdr.equalsValueClause && !TypeScript.TcUtil.safeTopLevelInitializer(vdr.equalsValueClause)) {
                                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Initializer_may_rely_on_uninitialized_top_level_names, [], vdr);
                            }
                        });
                        break;
                    default:
                        break;
                }
            });
            var members = withNames(0);
            TypeScript.TcUtil.syntaxListMembers(members).forEach(function (v) {
                switch (v.kind()) {
                    case TypeScript.SyntaxKind.VariableStatement:
                        var vs = v;
                        if (TypeScript.hasModifier(vs.modifiers, TypeScript.PullElementFlags.Exported)) {
                            TypeScript.TcUtil.mapSepList2(vs.declaration.declarators, function (b) {
                                var vdr = b;
                                var var_x = vdr.propertyName.text();
                                var ns = _this.tcenv.curNamespace();
                                _this.tcenv.addModuleMember(b, names, var_x, vdr.soundType);
                            });
                        }
                        break;
                    default:
                        break;
                }
            });
            var mod = new TypeScript.ModuleDeclaration(ast.modifiers, ast.name, ast.stringLiteral, members, ast.endingToken);
            return this.pkg(ast, mod);
        };
        SoundTypeChecker.prototype.tcObjectType = function (ast) {
            var members = this.tc(ast.typeMembers);
            var mems = TypeScript.TcUtil.mapSepList2(members, function (a) { return a; });
            var fields = [];
            var methods = [];
            var callSigs = [];
            var constructSigs = [];
            var indexSig = null;
            mems.forEach(function (a) {
                switch (a.kind()) {
                    case TypeScript.SyntaxKind.PropertySignature:
                        var ps = a;
                        fields.push(TypeScript.Field(ps.propertyName.text(), ps.soundType));
                        break;
                    case TypeScript.SyntaxKind.MemberVariableDeclaration:
                        var mvd = a;
                        fields.push(TypeScript.Field(mvd.variableDeclarator.propertyName.text(), mvd.variableDeclarator.soundType));
                        break;
                    case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                        var mfd = a;
                        fields.push(TypeScript.Field(mfd.propertyName.text(), mfd.soundType));
                        break;
                    case TypeScript.SyntaxKind.MethodSignature:
                        var ms = a;
                        methods.push(TypeScript.Field(ms.propertyName.text(), ms.soundType));
                        break;
                    case TypeScript.SyntaxKind.IndexMemberDeclaration:
                        if (!indexSig) {
                            indexSig = a.soundType;
                        }
                        else {
                            TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Feature_not_supported, ["Multiple index signatures"], a);
                        }
                        break;
                    case TypeScript.SyntaxKind.ConstructSignature:
                        constructSigs.push(a.soundType);
                        break;
                    case TypeScript.SyntaxKind.CallSignature:
                        callSigs.push(a.soundType);
                        break;
                }
            });
            var t = new TypeScript.TRecord(fields, methods);
            callSigs.forEach(function (s) { return t.addCallSignature(s); });
            constructSigs.forEach(function (s) { return t.addConstructSignature(s); });
            if (indexSig)
                t.addIndexSignature(indexSig);
            return this.pkg(ast, new TypeScript.ObjectType(members), t);
        };
        SoundTypeChecker.prototype.tcTypeParameterList = function (ast) {
            var _this = this;
            TypeScript.TcUtil.mapSepList2(ast.typeParameters, function (a) {
                var tp = a;
                if (tp.kind() !== TypeScript.SyntaxKind.TypeParameter)
                    throw new Error("Impossible!");
                var name = tp.identifier.text();
                if (ast.parent.kind() === TypeScript.SyntaxKind.ClassDeclaration) {
                    var ns = _this.tcenv.curNamespace();
                    ns.push(ast.parent.identifier.text());
                    name = TypeScript.TcUtil.mkTypeParamName(ns, name);
                }
                else if (ast.parent.kind() === TypeScript.SyntaxKind.InterfaceDeclaration) {
                    var ns = _this.tcenv.curNamespace();
                    ns.push(ast.parent.identifier.text());
                    name = TypeScript.TcUtil.mkTypeParamName(ns, name);
                }
                var tv = new TypeScript.TVar(name, tp.identifier.text());
                tp.soundType = tv;
            });
            return this.pkg(ast, ast);
        };
        SoundTypeChecker.prototype.tcTypeArgumentList = function (ast) {
            var _this = this;
            TypeScript.TcUtil.mapSepList2(ast.typeArguments, function (t) {
                _this.tc(t);
            });
            return this.pkg(ast, ast);
        };
        SoundTypeChecker.prototype.tcInterfaceDeclaration = function (ast) {
            var _this = this;
            var log = function (msg) {
                if (_this.scriptName !== "lib.d.ts") {
                    console.log(msg);
                }
            };
            var tglobal = this.tcenv.lookupTypeInCurrentScope(ast.identifier.text());
            if (!tglobal) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Variable_not_found, [ast.identifier.text()], ast);
                return this.pkg(ast, ast);
            }
            var tps = ast.typeParameterList ? this.tc(ast.typeParameterList) : ast.typeParameterList;
            var ns = this.tcenv.curNamespace();
            ns.push(ast.identifier.text());
            var tparmBinders = TypeScript.TcUtil.typeParameterListBindings(tps);
            var idecl = this.tcenv.withLocalTypes(tparmBinders, function () {
                var heritageClauses = _this.tc(ast.heritageClauses);
                var extendsList = [];
                TypeScript.TcUtil.syntaxListMembers(heritageClauses).forEach(function (a) {
                    TypeScript.TcUtil.mapSepList2(a.typeNames, function (a) { return extendsList.push(a.soundType); });
                });
                var body = _this.tcObjectType(ast.body);
                var trec = body.fst.soundType;
                var tif = new TypeScript.TInterface(ast.identifier.text(), [], [], extendsList.filter(TypeScript.isNamedType));
                trec.exposeFields().forEach(function (f) { return tif.addField(f); });
                trec.exposeMethods().forEach(function (f) { return tif.addMethod(f); });
                return {
                    fst: new TypeScript.InterfaceDeclaration(ast.modifiers, ast.identifier, tps, heritageClauses, body.fst),
                    snd: tif
                };
            });
            var tscheme = TypeScript.TcUtil.close(tparmBinders, idecl.snd);
            if (TypeScript.TypeRelations.subtype(tglobal, tscheme).fst) {
                return this.pkg(ast, idecl.fst, tscheme);
            }
            TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Interface_declaration_mismatch, [ast.identifier.text(), tscheme.toString(), tglobal.toString()], ast);
            return this.pkg(ast, idecl.fst, tglobal);
        };
        SoundTypeChecker.prototype.checkHeritageClauses = function (members, heritageClauses) {
        };
        SoundTypeChecker.prototype.tcClassDeclaration = function (ast) {
            var _this = this;
            var cd = ast;
            if (TypeScript.hasModifier(ast.modifiers, TypeScript.PullElementFlags.Ambient)) {
                return this.pkg(ast, ast);
            }
            var tparms = TypeScript.TcUtil.classDeclTypeParams(cd, this.tcenv);
            var classDecl = this.semanticInfoChain.getDeclForAST(ast);
            var members = this.tcenv.withClass(cd.identifier.text())(function () {
                var elements = TypeScript.TcUtil.syntaxListMembers(cd.classElements).map(function (elt) {
                    if (TypeScript.TcUtil.tvarsInScopeForClassElement(elt, _this.tcenv)) {
                        return _this.tcenv.withLocalTypes(tparms, function () { return _this.tc(elt); });
                    }
                    else {
                        return _this.tc(elt);
                    }
                });
                return _this.pkg(cd.classElements, new TypeScript.ISyntaxList2(_this.doc.fileName, elements)).fst;
            });
            var heritageClauses = this.tcenv.withLocalTypes(tparms, function () { return _this.tc(cd.heritageClauses); });
            var extendsClause = heritageClauses
                ? heritageClauses.firstOrDefault(function (a, i) { return a.kind() === TypeScript.SyntaxKind.ExtendsHeritageClause; })
                : null;
            if (extendsClause) {
                var et = extendsClause.typeNames.nonSeparatorAt(0).soundType;
                if (et.typeName !== TypeScript.TypeName.Object && et.typeName !== TypeScript.TypeName.Inst) {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Invalid_extends_clause, [et.toString() + " is not a class"], cd.heritageClauses);
                }
            }
            this.checkHeritageClauses(members, heritageClauses);
            var constructorDecl = members.firstOrDefault(function (a, i) { return a.kind() === TypeScript.SyntaxKind.ConstructorDeclaration; });
            var class_t = this.tcenv.lookup(cd.identifier.text());
            var obj_t = class_t.objectType();
            if (obj_t.isVirtual()) {
                var cd1 = new TypeScript.ClassDeclaration(cd.modifiers, cd.identifier, cd.typeParameterList, heritageClauses, members, cd.closeBraceToken);
                return this.pkg(ast, cd1, class_t);
            }
            if (obj_t.typeName !== TypeScript.TypeName.Object) {
                throw new Error(TypeScript.TcUtil.Logger.pos(ast) + ": Unexpected object type : " + obj_t.toString());
            }
            var object_t = obj_t;
            var rttiSym = new TypeScript.PullSymbol("__rtti__", TypeScript.PullElementKind.Property);
            var extendsC = object_t.extendsC && object_t.extendsC.length === 1 ? object_t.extendsC[0].unfold() : null;
            var classArgs = [TypeScript.MkAST.stringConst(class_t.name),
                TypeScript.toMethodTable(object_t.toRecord(true).exposeMethods()),
                TypeScript.toFieldTable(object_t.toRecord(true).exposeFields()),
                extendsC ? TypeScript.MkAST.stringConst(extendsC.name) : TypeScript.MkAST.undefConst(),
                TypeScript.MkAST.mkCleanArray(object_t.implementsI.map(function (i) { return TypeScript.MkAST.stringConst(i.toString()); })),
                TypeScript.toMethodTable(class_t.toRecord(true).exposeMethods()),
                TypeScript.toFieldTable(class_t.toRecord(true).exposeFields()),
                class_t.constructSignature().toRTTI(),
                cd.identifier];
            var classRtti = new TypeScript.MemberVariableDeclaration([TypeScript.PullElementFlags.Static, TypeScript.PullElementFlags.Public], new TypeScript.VariableDeclarator(TypeScript.MkAST.id("__rtti__"), null, new TypeScript.EqualsValueClause(TypeScript.MkAST.callRT("registerClass", classArgs))));
            this.semanticInfoChain.setDeclForAST(classRtti, new TypeScript.NormalPullDecl("__rtti__", "__rtti__", TypeScript.PullElementKind.Property, TypeScript.PullElementFlags.Public | TypeScript.PullElementFlags.Static, classDecl, new TypeScript.TextSpan(0, 0)));
            this.semanticInfoChain.setSymbolForAST(classRtti, rttiSym);
            var allMembers = new TypeScript.ISyntaxList2(this.doc.fileName, TypeScript.TcUtil.syntaxListMembers(members).concat([classRtti]));
            var cd2 = new TypeScript.ClassDeclaration(cd.modifiers, cd.identifier, cd.typeParameterList, heritageClauses, allMembers, cd.closeBraceToken);
            return this.pkg(ast, cd2, class_t);
        };
        SoundTypeChecker.prototype.tcVariableDeclarationList = function (ast) {
            var decls = this.tc(ast.declarators);
            return this.pkg(ast, new TypeScript.VariableDeclaration(decls));
        };
        SoundTypeChecker.prototype.tcMemberVariableDeclaration = function (ast) {
            var _this = this;
            if (ast.inferredType) {
                ast.variableDeclarator.inferredType = ast.inferredType;
            }
            var vd = this.tcenv.newScope(function () { return _this.tc(ast.variableDeclarator); }, TypeScript.ScopeType.FunctionBlock);
            return this.pkg(ast, new TypeScript.MemberVariableDeclaration(ast.modifiers, vd));
        };
        SoundTypeChecker.prototype.tcVariableDeclarator = function (ast) {
            var _this = this;
            var texpected = ast.typeAnnotation
                ? this.computeType(ast.typeAnnotation.type)
                : ast.inferredType
                    ? TypeScript.TranslateTypes.translateTypeOrSig(ast.inferredType, this.tcenv)
                    : TypeScript.TConstant.Any;
            var vdinit = ast.equalsValueClause
                ? (TypeScript.TcUtil.varInScopeForInitializer(ast.equalsValueClause)
                    ? this.tcenv.withVariable(ast, ast.propertyName.text(), texpected)(function () { return _this.tc(ast.equalsValueClause); })
                    : this.tc(ast.equalsValueClause))
                : null;
            var sym = this.symbol(ast);
            var computedType = vdinit
                ? vdinit.soundType : (sym
                ? TypeScript.TranslateTypes.translateType(sym.type, this.tcenv)
                : TypeScript.TranslateTypes.translateTypeOrSig(ast.inferredType, this.tcenv));
            var ambient = sym && sym.anyDeclHasFlag(TypeScript.PullElementFlags.Ambient);
            if (!ambient && !vdinit && texpected.typeName !== TypeScript.TypeName.Any && texpected.typeName !== TypeScript.TypeName.Un) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Uninitialized_variable, [texpected.toString()], ast);
            }
            if (vdinit) {
                var sc = TypeScript.TypeRelations.subtype(computedType, texpected, TypeScript.TcUtil.allowDeepSubtyping(ast.equalsValueClause));
                if (sc.fst) {
                    vdinit = new TypeScript.EqualsValueClause(TypeScript.TcUtil.shallowTag(sc, vdinit.value, texpected));
                }
                else {
                    if (TypeScript.TypeRelations.assignable(texpected, computedType)) {
                        vdinit = new TypeScript.EqualsValueClause(TypeScript.TcUtil.checkAndTag(vdinit.value, computedType, texpected));
                        TypeScript.TcUtil.Logger.warning(TypeScript.DiagnosticCode.SEC_Implicit_coercion, [computedType.toString(), texpected.toString()], ast.equalsValueClause);
                    }
                    else {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Variable_assignment_incompatible_type, [ast.propertyName.text(), texpected.toString(), vdinit.soundType.toString()], ast.equalsValueClause);
                    }
                }
                vdinit.soundType = texpected;
            }
            this.tcenv.pushVariable(ast, ast.propertyName.text(), texpected);
            return this.pkg(ast, new TypeScript.VariableDeclarator(ast.propertyName, ast.typeAnnotation, vdinit), texpected);
        };
        SoundTypeChecker.prototype.tcPropertySignature = function (ast) {
            var t = this.tc(ast.typeAnnotation);
            var field = TypeScript.Field(ast.propertyName.text(), t.soundType);
            return this.pkg(ast, new TypeScript.PropertySignature(ast.propertyName, ast.questionToken, t), t.soundType);
        };
        SoundTypeChecker.prototype.tcParameterList = function (ast) {
            return TypeScript.TcUtil.NYI("ParameterList");
        };
        SoundTypeChecker.prototype.tcParameter = function (ast) {
            var name = ast.identifier.text();
            var type = this.tc(ast.typeAnnotation).soundType;
            ast.soundType = type;
            return { fst: ast, snd: false };
        };
        SoundTypeChecker.prototype.tcEnumElement = function (ast) {
            return TypeScript.TcUtil.NYI("EnumElement");
        };
        SoundTypeChecker.prototype.tcEqualsValueClause = function (ast) {
            var val = this.tc(ast.value);
            var t = val.soundType;
            return this.pkg(ast, new TypeScript.EqualsValueClause(val), t);
        };
        SoundTypeChecker.prototype.tcTypeParameterDeclaration = function (ast) {
            return TypeScript.TcUtil.NYI("TypeParameter");
        };
        SoundTypeChecker.prototype.tcConstraint = function (ast) {
            return TypeScript.TcUtil.NYI("Constraint");
        };
        SoundTypeChecker.prototype.tcImportDeclaration = function (ast) {
            var id = ast.identifier;
            var mref = ast.moduleReference;
            switch (mref.kind()) {
                case TypeScript.SyntaxKind.ExternalModuleReference:
                    var ref = mref.stringLiteral.text();
                    var mod = this.tcenv.lookup(ref);
                    if (!mod) {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Variable_not_found, ["module " + ref]);
                        mod = TypeScript.TConstant.Any;
                    }
                    this.tcenv.pushVariable(id, id.text(), mod);
                    break;
                default:
                    return TypeScript.TcUtil.NYI("ImportDeclaration with a module reference of kind " + TypeScript.kind2string(mref.kind()));
            }
            return this.pkg(ast, ast);
        };
        SoundTypeChecker.prototype.tcObjectLiteralExpression = function (ast) {
            var _this = this;
            var this_t = TypeScript.TConstant.Any;
            if (ast.inferredType) {
                this_t = TypeScript.TranslateTypes.translateTypeOrSig(ast.inferredType, this.tcenv).unfold();
                if (this_t instanceof TypeScript.StructuredType) {
                    this_t = this_t.removeExtraneousFields();
                }
            }
            var fields = [];
            var methods = [];
            var unquote = function (s) {
                if (s.charAt(0) === '"') {
                    return s.substring(1, s.length - 1);
                }
                return s;
            };
            var props = TypeScript.TcUtil.mapSepList2(ast.propertyAssignments, function (p) {
                if (p.kind() === TypeScript.SyntaxKind.SimplePropertyAssignment) {
                    var spa = _this.tc(p);
                    fields.push({
                        name: TypeScript.idOrStringText(spa.propertyName),
                        mutable: true,
                        type: spa.expression.soundType,
                        expr: spa.expression
                    });
                    return spa;
                }
                else if (p.kind() === TypeScript.SyntaxKind.GetAccessor) {
                    var ga = _this.tcenv.withThisType(this_t, function () { return _this.tc(p); });
                    fields.push({
                        name: ga.propertyName.text(),
                        mutable: false,
                        type: ga.soundType,
                        expr: ga.block
                    });
                    return ga;
                }
                else if (p.kind() === TypeScript.SyntaxKind.SetAccessor) {
                    var sa = _this.tcenv.withThisType(this_t, function () { return _this.tc(p); });
                    fields.forEach(function (f) {
                        if (f.name === sa.propertyName.text()) {
                            f.mutable = true;
                        }
                    });
                    return sa;
                }
                else if (p.kind() === TypeScript.SyntaxKind.FunctionPropertyAssignment) {
                    var fpa = _this.tcenv.withThisType(this_t, function () { return _this.tc(p); });
                    methods.push({
                        name: fpa.propertyName.text(),
                        mutable: false,
                        type: fpa.soundType,
                        expr: fpa
                    });
                    return fpa;
                }
                else {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Unexpected_property_assignment, [TypeScript.kind2string(p.kind())], p);
                    return p;
                }
            });
            var propertyAssignments = new TypeScript.ISeparatedSyntaxList2(this.doc.fileName, props, ast.propertyAssignments.separatorCount());
            this.pkg(ast.propertyAssignments, propertyAssignments, TypeScript.TConstant.Void);
            var trec = new TypeScript.TRecord(fields.map(function (f) { return TypeScript.Field(unquote(f.name), f.type); }), methods.map(function (m) { return TypeScript.Method(unquote(m.name), m.type); }));
            var sc = TypeScript.TypeRelations.subtype(trec, this_t, TypeScript.TcUtil.allowDeepSubtyping(ast));
            if (!sc.fst) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Object_literal_type_mismatch, [this_t.toString(), trec.toString()], ast);
            }
            var newObj;
            if (this.compilationSettings.secure()) {
                newObj = TypeScript.MkAST.callExpr(TypeScript.MkAST.fieldOfRT("create"), [TypeScript.MkAST.nullConst()]);
                fields.forEach(function (f) {
                    newObj = TypeScript.MkAST.callExpr(TypeScript.MkAST.fieldOfRT("setField"), [newObj, TypeScript.MkAST.stringConst(f.name), f.expr]);
                });
                return this.pkg(ast, TypeScript.TcUtil.shallowTag(sc, newObj, this_t), this_t);
            }
            else if (this.compilationSettings.tsstarTagging()) {
                newObj = TypeScript.MkAST.callRT("setTag", [new TypeScript.ObjectLiteralExpression(propertyAssignments), this_t.toRTTI()]);
                return this.pkg(ast, newObj, this_t);
            }
            else {
                return this.pkg(ast, new TypeScript.ObjectLiteralExpression(propertyAssignments), this_t);
            }
        };
        SoundTypeChecker.prototype.tcSimplePropertyAssignment = function (ast) {
            var e = this.tc(ast.expression);
            if (TypeScript.TcUtil.reservedName(TypeScript.idOrStringText(ast.propertyName))) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Reserved_name, [TypeScript.idOrStringText(ast.propertyName)], ast);
            }
            return this.pkg(ast, new TypeScript.SimplePropertyAssignment(ast.propertyName, e), e.soundType);
        };
        SoundTypeChecker.prototype.tcFunctionPropertyAssignment = function (ast) {
            var blockT = this.auxTcBlockFunction(ast, TypeScript.TcUtil.callSigTypeParamBindings(ast.callSignature), this.symbol(ast).type.getCallSignatures()[0], ast.block);
            return this.pkg(ast, new TypeScript.FunctionPropertyAssignment(ast.propertyName, ast.callSignature, blockT.fst), blockT.snd);
        };
        SoundTypeChecker.prototype.tcTypeNameExpression = function (ast) {
            ast.soundType = TypeScript.TranslateTypes.translate(this.symbol(ast), this.tcenv);
            return { fst: ast, snd: false };
        };
        SoundTypeChecker.prototype.tcNameExpression = function (ast) {
            var typ = this.tcenv.lookup(ast.text());
            if (typ) {
                return this.pkg(ast, ast, typ);
            }
            else {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Variable_not_found, [ast.text()], ast);
                return this.pkg(ast, TypeScript.MkAST.unsafe(ast), TypeScript.TConstant.Any);
            }
        };
        SoundTypeChecker.prototype.auxMemberOrMethodType = function (t, name, overload, methodsOk) {
            if (methodsOk === void 0) { methodsOk = false; }
            if (!t.isVirtual() && !TypeScript.TcUtil.isPrimitive(t)) {
                overload = -1;
            }
            switch (t.typeName) {
                case TypeScript.TypeName.Any:
                    return null;
                case TypeScript.TypeName.Class:
                case TypeScript.TypeName.Module:
                case TypeScript.TypeName.Object:
                case TypeScript.TypeName.Interface:
                case TypeScript.TypeName.Record:
                case TypeScript.TypeName.Just:
                    var st = t;
                    var fld = st.getField(name, overload);
                    if (!fld && methodsOk) {
                        fld = st.getMethod(name, overload);
                    }
                    if (!fld) {
                        var ot = TypeScript.TcEnv.currentEnv.lookupType({ dottedName: "Object" });
                        if (ot) {
                            fld = ot.getField(name, overload);
                            if (!fld && methodsOk) {
                                fld = ot.getMethod(name, overload);
                            }
                        }
                    }
                    return fld;
                case TypeScript.TypeName.IndexMap:
                    return null;
                case TypeScript.TypeName.Enum:
                case TypeScript.TypeName.Number:
                    var numClass = this.tcenv.lookupType({ dottedName: "Number" });
                    if (numClass) {
                        return this.auxMemberOrMethodType(numClass, name, overload, methodsOk);
                    }
                    return null;
                case TypeScript.TypeName.String:
                    var strClass = this.tcenv.lookupType({ dottedName: "String" });
                    if (strClass) {
                        return this.auxMemberOrMethodType(strClass, name, overload, methodsOk);
                    }
                    return null;
                case TypeScript.TypeName.Variable:
                    var cons = t.getConstraint();
                    return (cons ? this.auxMemberOrMethodType(cons, name, overload, methodsOk) : null);
                default:
                    return null;
            }
        };
        SoundTypeChecker.prototype.tcMemberAccessExpression = function (ast, methodsOk) {
            var _this = this;
            if (methodsOk === void 0) { methodsOk = false; }
            var o = this.tc(ast.expression);
            var f = ast.name.text();
            var mkProj = function (fld) {
                var proj = new TypeScript.MemberAccessExpression(o, ast.name);
                if (!fld) {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Projecting_nonexistent_field, [f, o.soundType.toString()], ast);
                    return _this.pkg(ast, TypeScript.MkAST.unsafe(proj), TypeScript.TConstant.Any);
                }
                return _this.pkg(ast, proj, fld.type);
            };
            var t = o.soundType.unfold();
            switch (t.typeName) {
                case TypeScript.TypeName.Any:
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Implicit_coercion, [TypeScript.TConstant.Any.toString(), "{" + f + ":any}"], ast);
                    var id = function (s) {
                        return new TypeScript.Identifier(s);
                    };
                    var mem = function (o, id) {
                        return new TypeScript.MemberAccessExpression(o, id);
                    };
                    if (this.isPure(o)) {
                        var ft_lookup = mem(mem(TypeScript.MkAST.getRtti(o), id("fieldTable")), ast.name);
                        var mt_lookup = mem(mem(TypeScript.MkAST.getRtti(o), id("methodTable")), ast.name);
                        var ob_lookup = mem(TypeScript.MkAST.fieldOfRT("objectMethods"), ast.name);
                        var or_exp = new TypeScript.BinaryExpression(TypeScript.SyntaxKind.LogicalOrExpression, new TypeScript.BinaryExpression(TypeScript.SyntaxKind.LogicalOrExpression, ft_lookup, mt_lookup), ob_lookup);
                        var new_ast = TypeScript.MkAST.callRT("shallowTagSwap", [TypeScript.MkAST.callRT("getFieldTypeOptim", [or_exp, o, TypeScript.MkAST.stringConst(ast.name.text())]),
                            new TypeScript.MemberAccessExpression(o, ast.name)]);
                        return this.pkg(ast, new_ast, TypeScript.TConstant.Any);
                    }
                    else {
                        return this.pkg(ast, TypeScript.MkAST.callRT("readField", [o, o.soundType.toRTTI(), TypeScript.MkAST.stringConst(f)]), TypeScript.TConstant.Any);
                    }
                default:
                    var fld = this.auxMemberOrMethodType(t, f, 0);
                    return mkProj(fld);
            }
        };
        SoundTypeChecker.prototype.tcQualifiedName = function (ast) {
            if (TypeScript.isTypesOnlyLocation(ast)) {
                ast.soundType = TypeScript.TranslateTypes.translate(this.symbol(ast), this.tcenv);
                return { fst: ast, snd: false };
            }
            else {
                var fullName = [ast.right.text()];
                var pushNames = function (ast) {
                    switch (ast.kind()) {
                        case TypeScript.SyntaxKind.IdentifierName:
                            fullName.push(ast.text());
                            return;
                        case TypeScript.SyntaxKind.QualifiedName:
                            fullName.push(ast.right.text());
                            return pushNames(ast.left);
                        default: return TypeScript.TcUtil.NYI("Unexpected qualifiedName: " + ast + " at " + TypeScript.TcUtil.Logger.pos(ast));
                    }
                };
                pushNames(ast);
                fullName = fullName.reverse();
                var t = this.tcenv.lookupType({ fullName: fullName });
                return this.pkg(ast, ast, t);
            }
        };
        SoundTypeChecker.prototype.tcConstructorDeclaration = function (ast) {
            var _this = this;
            var signature = this.symbol(ast);
            var class_t = this.tcenv.lookup(this.tcenv.currentClassName());
            if (!class_t || class_t.typeName !== TypeScript.TypeName.Class) {
                throw new Error("die!");
            }
            var ct = class_t.constructSignature();
            var err = function (msg) {
                throw ("Non-trivial constructor bodies are not yet supported in [--safe|--secure] mode: got a body with " + msg);
                return null;
            };
            var super_t = [];
            var checkBody = function (constr, c) {
                if (c.extendsC && c.extendsC[0]) {
                    var super_c = c.extendsC[0];
                    var cc = _this.tcenv.lookup(super_c.unfold().name);
                    if (super_c.typeName === TypeScript.TypeName.Inst) {
                        super_t = [TypeScript.TcUtil.mkVariableBinding(ast, "__super__", new TypeScript.TInst(cc.constructSignature(), super_c.args))];
                    }
                    else {
                        super_t = [TypeScript.TcUtil.mkVariableBinding(ast, "__super__", cc.constructSignature())];
                    }
                }
                var declPath = _this.tcenv.curNamespace();
                var sym = _this.semanticInfoChain.findSymbol(declPath, TypeScript.PullElementKind.All);
                if (!sym) {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Variable_not_found, [declPath.join(".")], ast);
                    return _this.pkg(ast, ast);
                }
                else {
                    var classAST = _this.semanticInfoChain.getASTForDecl(sym.getDeclarations()[0]);
                    var initialized = c.exposeFields().every(function (f) {
                        var initialized = constr.args.some(function (t) { return t.name === f.name && t.isField(); })
                            || (c.extendsC && c.extendsC.some(function (u) { return u.unfold().hasField(f.name); }))
                            || classAST.classElements.any(function (m) {
                                switch (m.kind()) {
                                    case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                                        return m.propertyName.text() === f.name;
                                    case TypeScript.SyntaxKind.MemberVariableDeclaration:
                                        var vd = m;
                                        return (vd.variableDeclarator.equalsValueClause && vd.variableDeclarator.propertyName.text() === f.name);
                                    default:
                                        return false;
                                }
                            });
                        if (!initialized) {
                            TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Uninitialized_member, [f.name], ast);
                        }
                        return initialized;
                    });
                }
            };
            var tparms = [];
            switch (ct.typeName) {
                case TypeScript.TypeName.Poly:
                    var constr = ct.body;
                    tparms = ct.bvars.map(function (bv) { return bv.asBinder(); });
                    var failed = checkBody(constr, constr.result.unfold());
                    if (failed)
                        return failed;
                    break;
                case TypeScript.TypeName.Arrow:
                    var failed2 = checkBody(ct, (ct.result.unfold()));
                    if (failed2)
                        return failed2;
                    break;
                default:
                    throw new Error("Unexpected constructor type");
            }
            var blockT = this.tcenv.withVariables(super_t)(function () {
                var csigs = signature.type.getConstructSignatures();
                return _this.auxTcBlockFunction(ast, tparms, csigs[csigs.length - 1], ast.block, true);
            });
            var cd = new TypeScript.ConstructorDeclaration(ast.parameterList, blockT.fst);
            return this.pkg(ast, cd, blockT.snd);
        };
        SoundTypeChecker.prototype.tcGetAccessor = function (ast) {
            var block;
            if (this.compilationSettings.noGetters()) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_noGetter_flag_getter_found, []);
                return TypeScript.pair(TypeScript.MkAST.unsafe(ast), true);
            }
            var t = TypeScript.TranslateTypes.translateTypeOrSig(ast.inferredType, this.tcenv);
            var block = this.tcWithResult(t, ast.block);
            return this.pkg(ast, new TypeScript.GetAccessor(ast.modifiers, ast.propertyName, ast.parameterList, ast.typeAnnotation, block), t);
        };
        SoundTypeChecker.prototype.tcSetAccessor = function (ast) {
            var _this = this;
            var t = TypeScript.TranslateTypes.translateTypeOrSig(ast.inferredType, this.tcenv);
            var bindings = TypeScript.TcUtil.mapSepList2(ast.parameterList.parameters, function (a) {
                return TypeScript.TcUtil.mkVariableBinding(a, a.identifier.text(), t);
            });
            var block = this.tcenv.newScope(function () {
                return _this.tcenv.withVariables(bindings)(function () {
                    return _this.tcWithResult(TypeScript.TConstant.Void, ast.block);
                });
            }, TypeScript.ScopeType.FunctionBlock);
            return this.pkg(ast, new TypeScript.SetAccessor(ast.modifiers, ast.propertyName, ast.parameterList, block), t);
        };
        SoundTypeChecker.prototype.tcIndexMemberDeclaration = function (ast) {
            var index = this.tc(ast.indexSignature.parameter.typeAnnotation);
            var result = this.tc(ast.indexSignature.typeAnnotation);
            var isig = new TypeScript.TIndexMap(index.soundType, result.soundType);
            return this.pkg(ast, ast, isig);
        };
        SoundTypeChecker.prototype.tcIndexSignature = function (ast) {
            return { fst: ast, snd: false };
        };
        SoundTypeChecker.prototype.tcCallSignature = function (ast) {
            var _this = this;
            var binders = TypeScript.TcUtil.callSigTypeParamBindings(ast);
            var t = this.tcenv.withLocalTypes(binders, function () {
                var parms = _this.tc(ast.parameterList.parameters);
                var result = _this.computeType(ast.typeAnnotation.type);
                var t = new TypeScript.TArrow(TypeScript.TcUtil.mapSepList2(parms, function (a) {
                    var p = a;
                    var decl = _this.semanticInfoChain.getDeclForAST(p);
                    var flags = decl.flags;
                    var variadic = p.dotDotDotToken ? true : false;
                    var targ = new TypeScript.TArg(p.identifier.text(), p.soundType, [flags], variadic);
                    return targ;
                }), result);
                return t;
            });
            t = TypeScript.TcUtil.close(binders, t);
            ast.soundType = t;
            return { fst: ast, snd: false };
        };
        SoundTypeChecker.prototype.tcConstructSignature = function (ast) {
            return { fst: ast, snd: false };
        };
        SoundTypeChecker.prototype.tcMethodSignature = function (ast) {
            var cs = this.tcCallSignature(ast.callSignature);
            ast.soundType = cs.fst.soundType;
            return { fst: ast, snd: false };
        };
        SoundTypeChecker.prototype.auxMkFunctionBodyBindings = function (ast, tparms, signature, block) {
            var _this = this;
            var bindings = this.tcenv.withLocalTypes(tparms, function () {
                var bindings = signature.parameters.map(function (p) {
                    return ({
                        ast: ast,
                        name: p.name,
                        type: TypeScript.TranslateTypes.translateType(p.type, _this.tcenv)
                    });
                });
                if (block) {
                    bindings = bindings.concat(TypeScript.TcUtil.gatherFunctionBindings(block.statements));
                }
                return bindings;
            });
            var t = TypeScript.TranslateTypes.translateTypeOrSig(signature, this.tcenv);
            var arrowType = null;
            switch (t.typeName) {
                case TypeScript.TypeName.Arrow:
                    arrowType = t;
                    break;
                case TypeScript.TypeName.Poly:
                    arrowType = (new TypeScript.TInst(t, tparms.map(function (xt) { return xt.snd; }))).unfold();
                    break;
                default:
                    throw new Error(TypeScript.TcUtil.Logger.pos(ast) + " Unexpected type for function " + t.toString());
            }
            return { fst: bindings, snd: arrowType, third: tparms };
        };
        SoundTypeChecker.prototype.auxTcBlockFunction = function (ast, tparms, signature, block, voidOk) {
            var _this = this;
            if (voidOk === void 0) { voidOk = false; }
            var bindingsT = this.auxMkFunctionBodyBindings(ast, tparms, signature, block);
            block = !block
                ? null
                : this.tcenv.newScope(function () {
                    return _this.tcenv.withVariables(bindingsT.fst)(function () {
                        return _this.tcenv.withLocalTypes(bindingsT.third, function () {
                            return _this.tcWithResult(voidOk ? TypeScript.TConstant.Void : bindingsT.snd.result, block);
                        });
                    });
                }, TypeScript.ScopeType.FunctionBlock);
            return { fst: block, snd: TypeScript.TcUtil.close(bindingsT.third, bindingsT.snd) };
        };
        SoundTypeChecker.prototype.auxTcArrowFunction = function (ast, callSig, signature, block, body) {
            var _this = this;
            if (block && !body) {
                var blockT = this.auxTcBlockFunction(ast, TypeScript.TcUtil.callSigTypeParamBindings(callSig), signature, block);
                return { block: blockT.fst, body: body, type: blockT.snd };
            }
            else if (body && !block) {
                var bindingsT = this.auxMkFunctionBodyBindings(ast, TypeScript.TcUtil.callSigTypeParamBindings(callSig), signature);
                var expr = this.tcenv.newScope(function () { return _this.tcenv.withVariables(bindingsT.fst, true)(function () { return _this.tc(body); }); });
                var expected_t = bindingsT.snd.result ? bindingsT.snd.result : TypeScript.TConstant.Any;
                var sc = TypeScript.TypeRelations.subtype(expr.soundType, expected_t, TypeScript.TcUtil.allowDeepSubtyping(body));
                if (!sc.fst) {
                    if (TypeScript.TypeRelations.assignable(expected_t, expr.soundType)) {
                        TypeScript.TcUtil.Logger.warning(TypeScript.DiagnosticCode.SEC_Implicit_coercion, [expr.soundType.toString(), expected_t.toString()], body);
                        expr = TypeScript.TcUtil.checkAndTag(expr, expr.soundType, expected_t);
                    }
                    else {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Function_return_type, [expected_t.toString(), expr.soundType.toString()], ast);
                        expr = TypeScript.MkAST.unsafe(expr);
                        expr.soundType = expected_t;
                    }
                }
                else {
                    expr = TypeScript.TcUtil.shallowTag(sc, expr, expected_t);
                }
                return { block: block, body: expr, type: bindingsT.snd };
            }
            else {
                throw TypeScript.TcUtil.NYI("Unexpected both block and expression in arrow function: " + TypeScript.TcUtil.Logger.pos(ast));
            }
        };
        SoundTypeChecker.prototype.tcMemberFunctionDeclaration = function (ast) {
            var _this = this;
            var callSigs = ast.inferredType.getCallSignatures();
            var checkBody = function () {
                var blockT = _this.auxTcBlockFunction(ast, TypeScript.TcUtil.callSigTypeParamBindings(ast.callSignature), callSigs[callSigs.length - 1], ast.block);
                return _this.pkg(ast, new TypeScript.MemberFunctionDeclaration(ast.modifiers, ast.propertyName, ast.callSignature, blockT.fst), blockT.snd);
            };
            if (TypeScript.hasModifier(ast.modifiers, TypeScript.PullElementFlags.Static)) {
                return this.tcenv.inStaticScope(checkBody);
            }
            else {
                return checkBody();
            }
        };
        SoundTypeChecker.prototype.tcAnyFunctionDeclaration = function (ast) {
            var _this = this;
            var callSigs = this.symbol(ast).type.getCallSignatures();
            var callSig = callSigs ? callSigs[callSigs.length - 1] : null;
            var blockT = this.tcenv.withoutThis(function () { return _this.auxTcBlockFunction(ast, TypeScript.TcUtil.callSigTypeParamBindings(ast.callSignature), callSig, ast.block); });
            var f = new TypeScript.FunctionDeclaration(ast.modifiers, ast.identifier, ast.callSignature, blockT.fst);
            return this.pkg(ast, f, TypeScript.functionType(blockT.snd));
        };
        SoundTypeChecker.prototype.tcFunctionExpression = function (ast) {
            var _this = this;
            var callSigs = this.symbol(ast).type.getCallSignatures();
            var callSig = callSigs ? callSigs[callSigs.length - 1] : null;
            var blockT = this.tcenv.withoutThis(function () { return _this.auxTcBlockFunction(ast, TypeScript.TcUtil.callSigTypeParamBindings(ast.callSignature), callSig, ast.block); });
            var f = new TypeScript.FunctionExpression(ast.identifier, ast.callSignature, blockT.fst);
            var new_t = TypeScript.functionType(blockT.snd);
            if (this.compilationSettings.tsstarTagging()) {
                var newFun = TypeScript.MkAST.callRT("setTag", [f, new_t.toRTTI()]);
                return this.pkg(ast, newFun, new_t);
            }
            else {
                return this.pkg(ast, f, new_t);
            }
        };
        SoundTypeChecker.prototype.tcSimpleArrowFunctionExpression = function (ast) {
            var bet = this.auxTcArrowFunction(ast, null, this.symbol(ast).type.getCallSignatures()[0], ast.block, ast.expression);
            var f = new TypeScript.SimpleArrowFunctionExpression(ast.identifier, bet.block, bet.body);
            var new_t = TypeScript.functionType(bet.type);
            if (this.compilationSettings.tsstarTagging()) {
                var newFun = TypeScript.MkAST.callRT("setTag", [f, new_t.toRTTI()]);
                return this.pkg(ast, newFun, new_t);
            }
            else {
                return this.pkg(ast, f, new_t);
            }
        };
        SoundTypeChecker.prototype.tcParenthesizedArrowFunctionExpression = function (ast) {
            var bet = this.auxTcArrowFunction(ast, ast.callSignature, this.symbol(ast).type.getCallSignatures()[0], ast.block, ast.expression);
            var f = new TypeScript.ParenthesizedArrowFunctionExpression(ast.callSignature, bet.block, bet.body);
            var new_t = TypeScript.functionType(bet.type);
            if (this.compilationSettings.tsstarTagging()) {
                var newFun = TypeScript.MkAST.callRT("setTag", [f, new_t.toRTTI()]);
                return this.pkg(ast, newFun, new_t);
            }
            else {
                return this.pkg(ast, f, new_t);
            }
        };
        SoundTypeChecker.prototype.tcArrayLiteralExpression = function (ast) {
            var expected_t = null;
            if (ast.expressions.nonSeparatorCount() === 0) {
                expected_t = new TypeScript.TUVar();
            }
            else {
                var at = TypeScript.TranslateTypes.translateType(this.symbol(ast).type, this.tcenv);
                if (TypeScript.TcUtil.isArray(at)) {
                    expected_t = TypeScript.TcUtil.arrayElementType(at);
                }
            }
            var elts = ast.expressions;
            var out = [];
            var err = false;
            for (var i = 0; i < elts.nonSeparatorCount(); i++) {
                var elt = this.tc(elts.nonSeparatorAt(i));
                if (!expected_t) {
                    expected_t = elt.soundType;
                }
                else {
                    var sc = TypeScript.TypeRelations.subtype(elt.soundType, expected_t, TypeScript.TcUtil.allowDeepSubtyping(ast));
                    if (sc.fst) {
                        out.push(TypeScript.TcUtil.shallowTag(sc, elt, expected_t));
                    }
                    else {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Array_element_type, [expected_t.toString(), elt.soundType.toString()], elt);
                        err = true;
                        out.push(TypeScript.TcUtil.shallowTag(sc, elt, expected_t));
                    }
                }
            }
            if (!expected_t) {
                expected_t = TypeScript.TConstant.Any;
            }
            var elements = new TypeScript.ISeparatedSyntaxList2(elts.fileName(), out, elts.separatorCount());
            var arr = new TypeScript.ArrayLiteralExpression(elements);
            var res_t = TypeScript.TcUtil.mkArrayType(this.tcenv, expected_t);
            arr.soundType = res_t;
            var res = null;
            if (this.compilationSettings.secure()) {
                res = TypeScript.MkAST.callExpr(TypeScript.MkAST.fieldOfRT("newArray"), [expected_t.toRTTI(), arr]);
                res.soundType = res_t;
                res = err ? TypeScript.MkAST.unsafe(res) : res;
            }
            else if (this.compilationSettings.tsstarTagging() && expected_t.typeName !== TypeScript.TypeName.UVar) {
                res = err ? TypeScript.MkAST.unsafe(arr) : TypeScript.MkAST.callRT("setTag", [arr, res_t.toRTTI()]);
            }
            else {
                res = err ? TypeScript.MkAST.unsafe(arr) : arr;
            }
            return this.pkg(ast, res, res_t);
        };
        SoundTypeChecker.prototype.tcThisExpression = function (ast) {
            var this_t = this.tcenv.thisType();
            if (!this_t) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_This_not_in_scope, [], ast);
                ast.soundType = TypeScript.TConstant.Any;
                return { fst: TypeScript.MkAST.unsafe(ast), snd: false };
            }
            if (this_t.equals(TypeScript.TConstant.Any)) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_This_not_in_scope, [], ast);
            }
            ast.soundType = this_t;
            return { fst: ast, snd: false };
        };
        SoundTypeChecker.prototype.tcSuperExpression = function (ast) {
            var sup = this.tcenv.lookup("__super__");
            if (sup) {
                ast.soundType = sup;
                return { fst: ast, snd: false };
            }
            var this_t = this.tcenv.thisType();
            if (!this_t) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Super_not_in_scope, [], ast);
                ast.soundType = TypeScript.TConstant.Any;
                return { fst: TypeScript.MkAST.unsafe(ast), snd: false };
            }
            if (this_t.typeName === TypeScript.TypeName.Inst) {
                this_t = this_t.unfold();
                if (!(this_t instanceof TypeScript.NamedType)) {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Super_not_in_scope, [], ast);
                    ast.soundType = TypeScript.TConstant.Any;
                    return { fst: TypeScript.MkAST.unsafe(ast), snd: false };
                }
            }
            var super_t = this_t.extendsC[0];
            ast.soundType = super_t;
            return { fst: ast, snd: false };
        };
        SoundTypeChecker.prototype.tcArgumentList = function (ast) {
            var targs = ast.typeArgumentList ? this.tc(ast.typeArgumentList) : null;
            var args = this.tc(ast.args);
            return this.pkg(ast, new TypeScript.ArgumentList(targs, args, ast.closeParenToken));
        };
        SoundTypeChecker.prototype.auxTcArgumentList = function (untyped_args, typed_args, t, default_t) {
            var newargs = [];
            var formal = null;
            var actual = null;
            var i = 0;
            for (; i < typed_args.args.nonSeparatorCount(); i++) {
                actual = typed_args.args.nonSeparatorAt(i);
                if (i >= t.args.length) {
                    if (!formal) {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Arity_mismatch, [t.args.length.toString(), typed_args.args.nonSeparatorCount().toString()], typed_args);
                        formal = new TypeScript.TArg("dummy", TypeScript.TConstant.Any);
                    }
                }
                else if (!formal) {
                    formal = t.args[i];
                }
                var type = formal.type;
                if (formal.variadic) {
                    var ft = formal.type.unfold();
                    if (!ft.isArray()) {
                        throw ("Impossible:  got a variadic argument type " + (formal.type.toString()));
                    }
                    type = ft.arrayElementType();
                }
                var sc = TypeScript.TypeRelations.subtype(actual.soundType, type, TypeScript.TcUtil.allowDeepSubtyping(untyped_args.args.nonSeparatorAt(i)));
                if (!sc.fst) {
                    if (default_t && default_t.typeName === TypeScript.TypeName.Arrow) {
                        return this.auxTcArgumentList(untyped_args, typed_args, default_t);
                    }
                    if (TypeScript.TypeRelations.assignable(type, actual.soundType)) {
                        TypeScript.TcUtil.Logger.warning(TypeScript.DiagnosticCode.SEC_Implicit_coercion, [actual.soundType.toString(), type.toString()], actual);
                        newargs.push(TypeScript.TcUtil.checkAndTag(actual, actual.soundType, type));
                    }
                    else {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Argument_type_mismatch, [type.toString(), actual.soundType.toString()], actual);
                        newargs.push(TypeScript.MkAST.unsafe(actual));
                    }
                }
                else {
                    newargs.push(TypeScript.TcUtil.shallowTag(sc, actual, type));
                }
                if (!formal.variadic) {
                    formal = null;
                }
            }
            for (; i < t.args.length; i++) {
                if (!t.args[i].optional()) {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Missing_argument, [t.args[i].name, t.args[i].type.toString()], typed_args);
                }
            }
            var argsList = new TypeScript.ISeparatedSyntaxList2(typed_args.args.fileName(), newargs, typed_args.args.separatorCount());
            return new TypeScript.ArgumentList(typed_args.typeArgumentList, argsList, typed_args.closeParenToken);
        };
        SoundTypeChecker.prototype.isPure = function (ast) {
            if (!this.compilationSettings.optimizePure()) {
                return false;
            }
            switch (ast.kind()) {
                case TypeScript.SyntaxKind.FalseKeyword:
                case TypeScript.SyntaxKind.IdentifierName:
                case TypeScript.SyntaxKind.NullKeyword:
                case TypeScript.SyntaxKind.NumericLiteral:
                case TypeScript.SyntaxKind.StringLiteral:
                case TypeScript.SyntaxKind.TrueKeyword:
                case TypeScript.SyntaxKind.ThisKeyword:
                    return true;
                case TypeScript.SyntaxKind.MemberAccessExpression:
                    return this.compilationSettings.noGetters() || this.isPure(ast.expression);
                case TypeScript.SyntaxKind.ParenthesizedExpression:
                    return this.isPure(ast.expression);
                default:
                    return false;
            }
        };
        SoundTypeChecker.prototype.auxTcInvocationTarget = function (ast, preArgs, inferredTypeArgs, overload) {
            var _this = this;
            var mkArgList = function (receiver, args) {
                var typeArgs = args.typeArgumentList;
                var argsArray = TypeScript.TcUtil.mapSepList2(args.args, function (a) { return a; });
                var targs = TypeScript.TcUtil.mapSepList2(args.args, function (a) { return a.soundType.toRTTI(); });
                return receiver.concat(argsArray).concat(targs);
            };
            var default_t = undefined;
            var nargs = function (args) { return args.args.nonSeparatorCount(); };
            var instantiate = function (t) {
                switch (t.typeName) {
                    case TypeScript.TypeName.Arrow:
                    case TypeScript.TypeName.Any:
                        return TypeScript.pair(t, default_t);
                    case TypeScript.TypeName.Poly:
                        var tt = TypeScript.TcUtil.instantiateType(_this.tcenv, t, preArgs, inferredTypeArgs, overload);
                        if (tt) {
                            tt = tt.unfold();
                        }
                        if (!tt || (tt.typeName !== TypeScript.TypeName.Arrow && tt.typeName !== TypeScript.TypeName.Any)) {
                            TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Cannot_apply_a_non_function, [t.toString()], ast);
                            return TypeScript.pair(TypeScript.TConstant.Any, default_t);
                        }
                        return TypeScript.pair(tt, default_t);
                    default:
                        var callSig = TypeScript.callSignature(_this.tcenv, ast, t, overload);
                        var defaultSig = TypeScript.callSignature(_this.tcenv, ast, t, -1);
                        var instCall = function (sig, warn) {
                            if (sig) {
                                var tcall = TypeScript.TcUtil.instantiateType(_this.tcenv, sig, preArgs, inferredTypeArgs, overload);
                                if (tcall) {
                                    tcall = tcall.unfold();
                                }
                                if (!tcall || (tcall.typeName !== TypeScript.TypeName.Arrow && tcall.typeName !== TypeScript.TypeName.Any)) {
                                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Cannot_apply_a_non_function, [t.toString()], ast);
                                    return TypeScript.TConstant.Any;
                                }
                                return tcall;
                            }
                            else {
                                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Cannot_apply_a_non_function, [t.toString()], ast);
                                return TypeScript.TConstant.Any;
                            }
                        };
                        return TypeScript.pair(instCall(callSig, true), (defaultSig === callSig ? default_t : instCall(defaultSig, false)));
                }
            };
            switch (ast.kind()) {
                case TypeScript.SyntaxKind.MemberAccessExpression:
                    var mae = ast;
                    var receiver = this.tc(mae.expression);
                    var name = mae.name.text();
                    var t = receiver.soundType.unfold();
                    switch (t.typeName) {
                        case TypeScript.TypeName.Any:
                            TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Implicit_coercion, [TypeScript.TConstant.Any.toString(), "{" + name + ":any}"], ast);
                            var callMethod = function (args) {
                                var allPure = _this.isPure(receiver) && TypeScript.TcUtil.sepListMembers(args.args).every(function (x) {
                                    return _this.isPure(x);
                                });
                                if (!allPure) {
                                    return TypeScript.MkAST.callRT("callMethod" + nargs(args), mkArgList([receiver, receiver.soundType.toRTTI(), TypeScript.MkAST.stringConst(name)], args));
                                }
                                else {
                                    return TypeScript.MkAST.callRT("shallowTagSwap", [TypeScript.MkAST.callRT("checkMethodArgs" + nargs(args), mkArgList([receiver, receiver.soundType.toRTTI(), TypeScript.MkAST.stringConst(name)], args)),
                                        new TypeScript.InvocationExpression(new TypeScript.MemberAccessExpression(receiver, mae.name), args)]);
                                }
                            };
                            return {
                                fst: instantiate(TypeScript.TConstant.Any),
                                snd: callMethod
                            };
                        default:
                            var fld = this.auxMemberOrMethodType(t, name, overload, true);
                            var default_f = this.auxMemberOrMethodType(t, name, -1, true);
                            var mkCall = function (args) {
                                return new TypeScript.InvocationExpression(new TypeScript.MemberAccessExpression(receiver, mae.name), args);
                            };
                            if (!fld) {
                                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Projecting_nonexistent_field, [name, t.toString()], ast);
                                return {
                                    fst: instantiate(TypeScript.TConstant.Any),
                                    snd: function (args) { return TypeScript.MkAST.unsafe(mkCall(args)); }
                                };
                            }
                            else {
                                return {
                                    fst: TypeScript.pair(instantiate(fld.type).fst, default_f === fld ? undefined : instantiate(default_f.type).fst),
                                    snd: mkCall
                                };
                            }
                    }
                case TypeScript.SyntaxKind.ElementAccessExpression:
                    var eae = ast;
                    var receiver2 = this.tc(eae.expression);
                    var methodName = this.tc(eae.argumentExpression);
                    return {
                        fst: instantiate(TypeScript.TConstant.Any),
                        snd: function (args) { return TypeScript.MkAST.callRT("callMethod" + nargs(args), mkArgList([receiver2, receiver2.soundType.toRTTI(), methodName], args)); }
                    };
                default:
                    var receiver3 = this.tc(ast);
                    var t3 = receiver3.soundType.unfold();
                    switch (t3.typeName) {
                        case TypeScript.TypeName.Any:
                            TypeScript.TcUtil.Logger.warning(TypeScript.DiagnosticCode.SEC_Implicit_coercion, [t3.toString(), "call signature"], ast);
                            return {
                                fst: instantiate(TypeScript.TConstant.Any),
                                snd: function (args) { return TypeScript.MkAST.callRT("callFunction" + nargs(args), mkArgList([receiver3, receiver3.soundType.toRTTI()], args)); }
                            };
                        default:
                            var tarr = instantiate(t3);
                            var mkCall = function (args) { return new TypeScript.InvocationExpression(receiver3, args); };
                            return {
                                fst: tarr,
                                snd: mkCall
                            };
                    }
            }
        };
        SoundTypeChecker.prototype.tcForceCheckedArrayInvocation = function (ast) {
            var targs = this.tc(ast.argumentList.typeArgumentList.typeArguments);
            var args = this.tc(ast.argumentList.args);
            var source_t = null, target_t = null;
            if (targs.nonSeparatorCount() !== 2) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Arity_mismatch, ["2 type", targs.nonSeparatorCount() + " type"], ast);
                source_t = TypeScript.TConstant.Any;
                target_t = TypeScript.TConstant.Any;
            }
            else {
                source_t = TypeScript.TcUtil.mkCheckedArrayType(this.tcenv, targs.nonSeparatorAt(0).soundType);
                target_t = targs.nonSeparatorAt(1).soundType;
            }
            if (args.nonSeparatorCount() !== 1) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Arity_mismatch, ["1", targs.nonSeparatorCount().toString()], ast);
                return this.pkg(ast, TypeScript.MkAST.unsafe(ast), TypeScript.TConstant.Any);
            }
            var arg = args.nonSeparatorAt(0);
            var sc = TypeScript.TypeRelations.subtype(arg.soundType, source_t, TypeScript.TcUtil.allowDeepSubtyping(ast.argumentList.args.nonSeparatorAt(0)));
            if (!sc.fst) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Argument_type_mismatch, [source_t.toString(), arg.soundType.toString()], ast);
                return this.pkg(ast, TypeScript.MkAST.unsafe(ast), TypeScript.TConstant.Any);
            }
            var call = TypeScript.MkAST.callRT("__forceCheckedArray", [TypeScript.TcUtil.shallowTag(sc, arg, source_t), target_t.toRTTI()]);
            return this.pkg(ast, call, TypeScript.TcUtil.mkArrayType(this.tcenv, target_t));
        };
        SoundTypeChecker.prototype.tcWrapOrCanTagInvocation = function (ast, wrapOrCanTag) {
            var targs = this.tc(ast.argumentList.typeArgumentList.typeArguments);
            var args = this.tc(ast.argumentList.args);
            var source_t = null, target_t = null;
            if (targs.nonSeparatorCount() !== 2) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Arity_mismatch, ["2 type", targs.nonSeparatorCount() + " type"], ast);
                source_t = TypeScript.TConstant.Any;
                target_t = TypeScript.TConstant.Any;
            }
            else {
                source_t = targs.nonSeparatorAt(0).soundType;
                target_t = targs.nonSeparatorAt(1).soundType;
            }
            if (args.nonSeparatorCount() !== 1) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Arity_mismatch, ["1", targs.nonSeparatorCount().toString()], ast);
                return this.pkg(ast, TypeScript.MkAST.unsafe(ast), TypeScript.TConstant.Any);
            }
            var arg = args.nonSeparatorAt(0);
            var sc = TypeScript.TypeRelations.subtype(arg.soundType, source_t, TypeScript.TcUtil.allowDeepSubtyping(ast.argumentList.args.nonSeparatorAt(0)));
            if (!sc.fst) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Argument_type_mismatch, [source_t.toString(), arg.soundType.toString()], ast);
                return this.pkg(ast, TypeScript.MkAST.unsafe(ast), TypeScript.TConstant.Any);
            }
            var callWrap = TypeScript.MkAST.callExpr(TypeScript.MkAST.fieldOfRT(wrapOrCanTag), [source_t.toRTTI(), target_t.toRTTI(), TypeScript.TcUtil.shallowTag(sc, arg, source_t)]);
            if (wrapOrCanTag === "wrap") {
                return this.pkg(ast, callWrap, target_t);
            }
            else {
                return this.pkg(ast, callWrap, TypeScript.TConstant.Bool);
            }
        };
        SoundTypeChecker.prototype.tcInvocationExpression = function (ast) {
            var typed_args = this.tc(ast.argumentList);
            var ttcall = this.auxTcInvocationTarget(ast.expression, typed_args, ast.inferredTypeArgs, ast.resolvedSignatureIndex);
            var tt = ttcall.fst.fst.unfold();
            var def_t = ttcall.fst.snd ? ttcall.fst.snd.unfold() : undefined;
            var call = ttcall.snd;
            switch (tt.typeName) {
                case TypeScript.TypeName.Arrow:
                    var tarr = tt;
                    var result = call(this.auxTcArgumentList(ast.argumentList, typed_args, tarr, def_t));
                    if (ast.expression.kind() === TypeScript.SyntaxKind.SuperKeyword) {
                        return this.pkg(ast, result, TypeScript.TConstant.Void);
                    }
                    else {
                        return this.pkg(ast, result, tarr.result);
                    }
                case TypeScript.TypeName.Any:
                    var argsSub = TypeScript.TcUtil.mapSepList2WithIndex(typed_args.args, function (a, i) {
                        var sc = TypeScript.TypeRelations.subtype(a.soundType, TypeScript.TConstant.Any, TypeScript.TcUtil.allowDeepSubtyping(ast.argumentList.args.nonSeparatorAt(i)));
                        if (!sc.fst)
                            TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Dynamic_call_with_un_typed_argument, [], a);
                        return TypeScript.TcUtil.shallowTag(sc, a, TypeScript.TConstant.Any);
                    });
                    var argList = new TypeScript.ArgumentList(typed_args.typeArgumentList, new TypeScript.ISeparatedSyntaxList2(this.doc.fileName, argsSub, argsSub.length - 1), typed_args.closeParenToken);
                    return this.pkg(ast, call(argList), TypeScript.TConstant.Any);
                default:
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Cannot_apply_a_non_function, [tt.toString()], ast);
                    return this.pkg(ast, TypeScript.MkAST.unsafe(call(typed_args)), TypeScript.TConstant.Any);
            }
        };
        SoundTypeChecker.prototype.tcObjectCreationExpression = function (ast) {
            var _this = this;
            var tgt = this.tc(ast.expression);
            var tgtType = tgt.soundType.unfold();
            var typed_args = this.tc(ast.argumentList);
            if (!(tgtType instanceof TypeScript.StructuredType) || !tgtType.constructSignature()) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Invalid_new_target, [tgt.soundType.toString()], ast.expression);
                tgtType = new TypeScript.TClass("Dummy", new TypeScript.TArrow(TypeScript.TcUtil.mapSepList2(typed_args.args, function (a) { return new TypeScript.TArg("", TypeScript.TConstant.Any); }), TypeScript.TConstant.Any), []);
            }
            var csig = tgtType.constructSignature(ast.resolvedSignatureIndex);
            var defSig = tgtType.constructSignature(-1);
            var inst = function (sig) {
                var ctype = TypeScript.TcUtil.instantiateType(_this.tcenv, sig, typed_args, ast.inferredTypeArgs).unfold();
                if (!ctype || ctype.typeName !== TypeScript.TypeName.Arrow) {
                    throw new Error("Unexpected constructor type " + ctype);
                }
                return ctype;
            };
            var ctype = inst(csig);
            var new_obj = new TypeScript.ObjectCreationExpression(tgt, this.auxTcArgumentList(ast.argumentList, typed_args, ctype, defSig === csig ? undefined : inst(defSig)));
            var result_t = ctype.result;
            if (this.compilationSettings.tsstarTagging() && TypeScript.TcUtil.isArray(result_t)) {
                new_obj = TypeScript.MkAST.callRT("setTag", [new_obj, result_t.toRTTI()]);
            }
            return this.pkg(ast, new_obj, result_t);
        };
        SoundTypeChecker.prototype.computeType = function (ast) {
            var _this = this;
            switch (ast.kind()) {
                case TypeScript.SyntaxKind.AnyKeyword: return TypeScript.TConstant.Any;
                case TypeScript.SyntaxKind.BooleanKeyword: return TypeScript.TConstant.Bool;
                case TypeScript.SyntaxKind.NumericLiteral:
                case TypeScript.SyntaxKind.NumberKeyword: return TypeScript.TConstant.Number;
                case TypeScript.SyntaxKind.StringLiteral:
                case TypeScript.SyntaxKind.StringKeyword: return TypeScript.TConstant.String;
                case TypeScript.SyntaxKind.VoidKeyword: return TypeScript.TConstant.Void;
                case TypeScript.SyntaxKind.ArrayType: return TypeScript.TcUtil.mkArrayType(this.tcenv, this.computeType(ast.type));
                case TypeScript.SyntaxKind.GenericType:
                    var gt = ast;
                    var nm = gt.name.text();
                    if (nm === "Array") {
                        return TypeScript.TcUtil.mkArrayType(this.tcenv, this.computeType(gt.typeArgumentList.typeArguments.nonSeparatorAt(0)));
                    }
                    else if (this.compilationSettings.generics()) {
                        var tt = TypeScript.TranslateTypes.translateTypeOrSig(this.symbol(gt.name), this.tcenv);
                        var targs = TypeScript.TcUtil.mapSepList2(gt.typeArgumentList.typeArguments, function (t) { return _this.computeType(t); });
                        var res = new TypeScript.TInst(tt, targs);
                        return res;
                    }
                    else {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Generic_types_unsupported, [nm], ast);
                        return TypeScript.TConstant.Any;
                    }
                default:
                    return TypeScript.TranslateTypes.translateType(this.symbol(ast), this.tcenv);
            }
        };
        SoundTypeChecker.prototype.tcCastExpression = function (ast) {
            var targ = this.computeType(ast.type);
            var arg = this.tc(ast.expression);
            var fc = TypeScript.TcUtil.allowDeepSubtyping(ast.expression);
            var sc = TypeScript.TypeRelations.subtype(arg.soundType, targ, fc);
            if (sc.fst) {
                if (fc.fresh) {
                    return this.pkg(ast, arg, targ);
                }
                return this.pkg(ast, TypeScript.TcUtil.shallowTag(sc, arg, targ), targ);
            }
            if (this.compilationSettings.inlineCasts() && targ.typeName === TypeScript.TypeName.Object && ast.expression.kind() === TypeScript.SyntaxKind.IdentifierName) {
                var tobj = targ;
                var nullGuard = new TypeScript.ParenthesizedExpression([], new TypeScript.BinaryExpression(TypeScript.SyntaxKind.LogicalOrExpression, new TypeScript.BinaryExpression(TypeScript.SyntaxKind.EqualsExpression, arg, TypeScript.MkAST.undefConst()), new TypeScript.BinaryExpression(TypeScript.SyntaxKind.EqualsExpression, arg, TypeScript.MkAST.nullConst())));
                var strEquals = new TypeScript.BinaryExpression(TypeScript.SyntaxKind.EqualsExpression, new TypeScript.MemberAccessExpression(TypeScript.MkAST.getRtti(arg), new TypeScript.Identifier("name")), TypeScript.MkAST.stringConst(tobj.name));
                var instanceOf = new TypeScript.BinaryExpression(TypeScript.SyntaxKind.InstanceOfExpression, arg, new TypeScript.Identifier(tobj.fullName.join(".")));
                var tm = new TypeScript.ConditionalExpression(new TypeScript.BinaryExpression(TypeScript.SyntaxKind.LogicalOrExpression, nullGuard, new TypeScript.ParenthesizedExpression([], new TypeScript.BinaryExpression(TypeScript.SyntaxKind.LogicalOrExpression, strEquals, instanceOf))), arg, TypeScript.MkAST.callRT("die", []));
                return this.pkg(ast, tm, targ);
            }
            else if (arg.soundType.isUn()) {
                return this.pkg(ast, TypeScript.MkAST.callRT("wrapFromUn", [arg, targ.toRTTI()]), targ);
            }
            else if (targ.isUn()) {
                return this.pkg(ast, TypeScript.MkAST.callRT("wrapToUn", [arg, arg.soundType.toRTTI()]), targ);
            }
            else {
                return this.pkg(ast, TypeScript.MkAST.callRT("checkAndTag", [arg, arg.soundType.toRTTI(), targ.toRTTI()]), targ);
            }
        };
        SoundTypeChecker.prototype.tcTypeAnnotation = function (ast) {
            ast.soundType = this.computeType(ast.type);
            return { fst: ast, snd: false };
        };
        SoundTypeChecker.prototype.tcExportAssignmentStatement = function (ast) {
            return TypeScript.TcUtil.NYI("ExportAssignment");
        };
        SoundTypeChecker.prototype.tcVoidExpression = function (ast) {
            ast.soundType = TypeScript.TConstant.Void;
            return { fst: ast, snd: false };
        };
        SoundTypeChecker.prototype.tcAssignIdentifier = function (ast, lhs, rhs, rhs_orig) {
            var sc = TypeScript.TypeRelations.subtype(rhs.soundType, lhs.soundType, TypeScript.TcUtil.allowDeepSubtyping(rhs_orig));
            if (!sc.fst) {
                if (TypeScript.TypeRelations.assignable(lhs.soundType, rhs.soundType)) {
                    TypeScript.TcUtil.Logger.warning(TypeScript.DiagnosticCode.SEC_Implicit_coercion, [rhs.soundType.toString(), lhs.soundType.toString()], lhs);
                    return this.pkg(ast, new TypeScript.BinaryExpression(ast.kind(), lhs, TypeScript.TcUtil.checkAndTag(rhs, rhs.soundType, lhs.soundType)), rhs.soundType);
                }
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Variable_assignment_incompatible_type, [ast.left.text(), lhs.soundType.toString(), rhs.soundType.toString()], ast.left);
                return this.pkg(ast, TypeScript.MkAST.unsafe(new TypeScript.BinaryExpression(ast.kind(), lhs, TypeScript.TcUtil.checkAndTag(rhs, rhs.soundType, lhs.soundType))), rhs.soundType);
            }
            return this.pkg(ast, new TypeScript.BinaryExpression(ast.kind(), lhs, TypeScript.TcUtil.shallowTag(sc, rhs, lhs.soundType)), rhs.soundType);
        };
        SoundTypeChecker.prototype.tcAssignMember = function (ast, o, fn, rhs, rhs_orig) {
            var _this = this;
            var safe = function (lhs, rhs, t) {
                return _this.pkg(ast, new TypeScript.BinaryExpression(ast.kind(), lhs, rhs), t);
            };
            var unsafe = function (lhs, rhs) {
                return _this.pkg(ast, TypeScript.MkAST.unsafe(new TypeScript.BinaryExpression(ast.kind(), lhs, rhs)), TypeScript.TConstant.Any);
            };
            var tcAssign = function (ft) {
                var mae = new TypeScript.MemberAccessExpression(o, fn);
                if (!ft) {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Assigning_to_nonexistent_field, [fn.text(), o.soundType.toString()], ast);
                    return unsafe(mae, rhs);
                }
                mae.soundType = ft.type;
                var sc = TypeScript.TypeRelations.subtype(rhs.soundType, ft.type, TypeScript.TcUtil.allowDeepSubtyping(rhs_orig));
                if (ft.mutable && sc.fst) {
                    return safe(mae, TypeScript.TcUtil.shallowTag(sc, rhs, ft.type), rhs.soundType);
                }
                else {
                    if (!ft.mutable) {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Assigning_to_immutable_field, [fn.text()], ast);
                        return unsafe(mae, TypeScript.TcUtil.shallowTag(sc, rhs, ft.type));
                    }
                    else {
                        if (TypeScript.TypeRelations.assignable(ft.type, rhs.soundType) && TypeScript.TypeRelations.isSubtype(o.soundType, TypeScript.TConstant.Any)) {
                            return safe(mae, TypeScript.MkAST.callRT("checkAndTag", [rhs, rhs.soundType.toRTTI(), ft.type.toRTTI()]), ft.type);
                        }
                        else {
                            TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Assigning_incompatible_value_to_field, [
                                fn.text(),
                                ft.type.toString(),
                                rhs.soundType.toString()
                            ], ast);
                            return unsafe(mae, TypeScript.TcUtil.shallowTag(sc, rhs, ft.type));
                        }
                    }
                }
            };
            var ot = o.soundType.unfold();
            switch (ot.typeName) {
                case TypeScript.TypeName.Any:
                    var sc = TypeScript.TypeRelations.subtype(rhs.soundType, TypeScript.TConstant.Any, TypeScript.TcUtil.allowDeepSubtyping(rhs_orig));
                    if (!sc.fst) {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Assigning_incompatible_value_to_field, [
                            fn.text(),
                            TypeScript.TConstant.Any.toString(),
                            rhs.soundType.toString()
                        ], ast);
                        return unsafe(new TypeScript.MemberAccessExpression(o, fn), rhs);
                    }
                    else {
                        if (this.isPure(o)) {
                            var id = function (s) {
                                return new TypeScript.Identifier(s);
                            };
                            var mem = function (o, id) {
                                return new TypeScript.MemberAccessExpression(o, id);
                            };
                            var ft_lookup = mem(mem(TypeScript.MkAST.getRtti(o), id("fieldTable")), fn);
                            var mt_lookup = mem(mem(TypeScript.MkAST.getRtti(o), id("methodTable")), fn);
                            var ob_lookup = mem(TypeScript.MkAST.fieldOfRT("objectMethods"), fn);
                            var or_exp = new TypeScript.BinaryExpression(TypeScript.SyntaxKind.LogicalOrExpression, new TypeScript.BinaryExpression(TypeScript.SyntaxKind.LogicalOrExpression, ft_lookup, mt_lookup), ob_lookup);
                            var new_rhs = TypeScript.MkAST.callRT("checkAndTag", [rhs, rhs.soundType.toRTTI(),
                                TypeScript.MkAST.callRT("getFieldTypeOptim", [or_exp, o, TypeScript.MkAST.stringConst(fn.text())])
                            ]);
                            return this.pkg(ast, new TypeScript.BinaryExpression(ast.kind(), new TypeScript.MemberAccessExpression(o, fn), new_rhs), TypeScript.TConstant.Any);
                        }
                        else {
                            var ce = TypeScript.MkAST.callRT("writeField", [o, o.soundType.toRTTI(), TypeScript.MkAST.stringConst(fn.text()), rhs, rhs.soundType.toRTTI()]);
                            return this.pkg(ast, ce, TypeScript.TConstant.Any);
                        }
                    }
                default:
                    if (ot instanceof TypeScript.StructuredType) {
                        return tcAssign(ot.getField(fn.text()));
                    }
                    if (ot instanceof TypeScript.TVar) {
                        var cons = ot.getConstraint();
                        if (cons && cons instanceof TypeScript.StructuredType) {
                            return tcAssign(cons.getField(fn.text()));
                        }
                    }
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Assigning_to_non_record, [fn.text(), o.soundType.toString()], o);
                    return unsafe(new TypeScript.MemberAccessExpression(o, fn), rhs);
            }
        };
        SoundTypeChecker.prototype.tcAssignElement = function (ast, o, key, rhs) {
            var _this = this;
            var safe = function (lhs, rhs, t) {
                return _this.pkg(ast, new TypeScript.BinaryExpression(ast.kind(), lhs, rhs), t);
            };
            var unsafe = function (lhs, rhs) {
                return _this.pkg(ast, TypeScript.MkAST.unsafe(new TypeScript.BinaryExpression(ast.kind(), lhs, rhs)), TypeScript.TConstant.Any);
            };
            if (o.soundType.unfold().isCheckedArray()) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Assignment_to_index_of_immutable_array_is_not_allowed, [o.soundType.toString()]);
                return unsafe(new TypeScript.ElementAccessExpression(o, key), rhs);
            }
            var assignee = function (o1, t) {
                var res = new TypeScript.ElementAccessExpression(o1, key);
                res.soundType = t;
                return res;
            };
            var t_o = o.soundType.unfold();
            if (t_o.indexSignature()) {
                var index = t_o.indexSignature();
                var eltSub = TypeScript.TypeRelations.subtype(rhs.soundType, index.elt, TypeScript.TcUtil.allowDeepSubtyping(ast.right));
                var indexSub = TypeScript.TypeRelations.subtype(key.soundType, index.indexType);
                if (!indexSub.fst) {
                    if (TypeScript.TypeRelations.assignable(index.indexType, key.soundType)) {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Implicit_coercion, [key.soundType.toString(), index.indexType.toString()]);
                        key = TypeScript.MkAST.callRT("checkAndTag", [key, key.soundType.toRTTI(), index.indexType.toRTTI()]);
                    }
                    else {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Index_map_key_type_mismatch, [index.indexType.toString(), key.soundType.toString()], ast);
                        key = TypeScript.MkAST.unsafe(key);
                    }
                }
                if (!eltSub.fst) {
                    if (TypeScript.TypeRelations.assignable(index.elt, rhs.soundType)) {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Implicit_coercion, [rhs.soundType.toString(), index.elt.toString()]);
                        rhs = TypeScript.MkAST.callRT("checkAndTag", [rhs, rhs.soundType.toRTTI(), index.elt.toRTTI()]);
                    }
                    else {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Index_map_elt_type_mismatch, [index.elt.toString(), rhs.soundType.toString()], ast);
                        rhs = TypeScript.MkAST.unsafe(rhs);
                    }
                }
                else {
                    rhs = TypeScript.TcUtil.shallowTag(eltSub, rhs, index.elt);
                }
                return safe(assignee(o, index.elt), rhs, index.elt);
            }
            else {
                var sc1 = TypeScript.TypeRelations.subtype(o.soundType, TypeScript.TConstant.Any);
                var sc2 = TypeScript.pair(true, TypeScript.TcUtil.zeroDelta);
                if (this.compilationSettings.secure()) {
                    sc2 = TypeScript.TypeRelations.subtype(key.soundType, TypeScript.TConstant.Any);
                }
                var scrhs = TypeScript.TypeRelations.subtype(rhs.soundType, TypeScript.TConstant.Any);
                if (sc1.fst && sc2.fst && scrhs.fst) {
                    var ce = TypeScript.MkAST.callRT("writeField", [o, o.soundType.toRTTI(), key, rhs, rhs.soundType.toRTTI()]);
                    return this.pkg(ast, ce, TypeScript.TConstant.Any);
                }
                else {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Dynamic_field_assignment_all_not_any, [o.soundType.toString(),
                        key.soundType.toString(),
                        rhs.soundType.toString()], ast);
                    return unsafe(assignee(o, TypeScript.TConstant.Any), TypeScript.TcUtil.shallowTag(scrhs, rhs, TypeScript.TConstant.Any));
                }
            }
        };
        SoundTypeChecker.prototype.getBinOpFromAssignment = function (aKind) {
            switch (aKind) {
                case TypeScript.SyntaxKind.AddAssignmentExpression: return TypeScript.SyntaxKind.AddExpression;
                case TypeScript.SyntaxKind.SubtractAssignmentExpression: return TypeScript.SyntaxKind.SubtractExpression;
                case TypeScript.SyntaxKind.MultiplyAssignmentExpression: return TypeScript.SyntaxKind.MultiplyExpression;
                case TypeScript.SyntaxKind.DivideAssignmentExpression: return TypeScript.SyntaxKind.DivideExpression;
                case TypeScript.SyntaxKind.ModuloAssignmentExpression: return TypeScript.SyntaxKind.ModuloExpression;
                case TypeScript.SyntaxKind.AndAssignmentExpression: return TypeScript.SyntaxKind.BitwiseAndExpression;
                case TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression: return TypeScript.SyntaxKind.BitwiseExclusiveOrExpression;
                case TypeScript.SyntaxKind.OrAssignmentExpression: return TypeScript.SyntaxKind.BitwiseOrExpression;
                case TypeScript.SyntaxKind.LeftShiftAssignmentExpression: return TypeScript.SyntaxKind.LeftShiftExpression;
                case TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression: return TypeScript.SyntaxKind.SignedRightShiftExpression;
                case TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression: return TypeScript.SyntaxKind.UnsignedRightShiftExpression;
                default:
                    throw new Error("getBinOpFromAssignment doesn't handle this case: " + aKind.toString());
            }
        };
        SoundTypeChecker.prototype.tcOpWithAssignment = function (orig, lhs_un, trhs, safe, rewrite) {
            var unsafe = function (lhs, f) { return TypeScript.MkAST.unsafe(safe(lhs, f)); };
            var tresult = TypeScript.TranslateTypes.translateTypeOrSig(orig.inferredType, this.tcenv);
            switch (lhs_un.kind()) {
                case TypeScript.SyntaxKind.IdentifierName:
                    var lhs = this.tc(lhs_un);
                    if (TypeScript.TypeRelations.subtypeZ(tresult, lhs.soundType)) {
                        return this.pkg(orig, safe(lhs), tresult);
                    }
                    else if (TypeScript.TypeRelations.assignable(lhs.soundType, tresult)) {
                        TypeScript.TcUtil.Logger.warning(TypeScript.DiagnosticCode.SEC_Implicit_coercion, [tresult.toString(), lhs.soundType.toString()], orig);
                        return this.pkg(orig, safe(lhs, undefined, lhs.soundType), lhs.soundType);
                    }
                    else {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Variable_assignment_incompatible_type, [lhs_un.text(), lhs.soundType.toString(), tresult.toString()]);
                        return this.pkg(orig, unsafe(lhs), tresult);
                    }
                case TypeScript.SyntaxKind.MemberAccessExpression:
                    var mae = lhs_un;
                    var o = this.tc(mae.expression);
                    var f = mae.name.text();
                    var t_o = o.soundType.unfold();
                    switch (t_o.typeName) {
                        case TypeScript.TypeName.Any:
                            if (TypeScript.TypeRelations.isSubtype(trhs, TypeScript.TConstant.Any)) {
                                return this.pkg(orig, rewrite(o, TypeScript.MkAST.stringConst(mae.name.text())), tresult);
                            }
                            else {
                                throw new Error("Got a term that should have been untypeable in TypeScript");
                            }
                        default:
                            if (t_o instanceof TypeScript.StructuredType) {
                                var tf = t_o.getField(f);
                                if (tf) {
                                    if (TypeScript.TypeRelations.subtypeZ(tresult, tf.type)) {
                                        return this.pkg(orig, safe(o, mae.name), tresult);
                                    }
                                    else if (TypeScript.TypeRelations.assignable(tf.type, tresult)) {
                                        TypeScript.TcUtil.Logger.warning(TypeScript.DiagnosticCode.SEC_Implicit_coercion, [tresult.toString(), tf.type.toString()], orig);
                                        return this.pkg(orig, safe(o, mae.name, tf.type), tf.type);
                                    }
                                    else {
                                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Assigning_incompatible_value_to_field, [f, tf.type.toString(), tresult.toString()]);
                                        return this.pkg(orig, unsafe(o, mae.name), tresult);
                                    }
                                }
                                else {
                                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Assigning_to_nonexistent_field, [f, o.soundType.toString()]);
                                    return this.pkg(orig, unsafe(o, mae.name), tresult);
                                }
                            }
                            else {
                                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Assigning_to_non_record, [f, o.soundType.toString()]);
                                return this.pkg(orig, unsafe(o, mae.name), tresult);
                            }
                    }
                case TypeScript.SyntaxKind.ElementAccessExpression:
                    var eae = lhs_un;
                    var o = this.tc(eae.expression);
                    var index = this.tc(eae.argumentExpression);
                    var t_o = o.soundType.unfold();
                    if (t_o.isCheckedArray()) {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Assignment_to_index_of_immutable_array_is_not_allowed, [o.soundType.toString()]);
                        return this.pkg(orig, unsafe(o, index), tresult);
                    }
                    if (t_o.isArray() && index.soundType === TypeScript.TConstant.Number && TypeScript.TypeRelations.subtypeZ(trhs, TypeScript.TcUtil.arrayElementType(t_o))) {
                        return this.pkg(orig, safe(o, index), TypeScript.TcUtil.arrayElementType(t_o));
                    }
                    if (TypeScript.TypeRelations.isSubtype(t_o, TypeScript.TConstant.Any)
                        && TypeScript.TypeRelations.isSubtype(trhs, TypeScript.TConstant.Any)) {
                        return this.pkg(orig, rewrite(o, index), tresult);
                    }
                    else {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Assignment_with_op_expects_undotted_arguments, [o.soundType.toString(), trhs.toString()]);
                        return this.pkg(orig, unsafe(o, index), tresult);
                    }
                default:
                    throw new Error("Got an unexpected l-value in assignment with op at " + TypeScript.TcUtil.Logger.pos(orig) + "\n kind is " + (TypeScript.kind2string(lhs_un.kind())));
            }
        };
        SoundTypeChecker.prototype.tcAssignmentExpression = function (ast) {
            var _this = this;
            var lhs = ast.left;
            var tresult = TypeScript.TranslateTypes.translateTypeOrSig(ast.inferredType, this.tcenv);
            var kind = ast.kind();
            var rhs_typed = this.tc(ast.right);
            var rewrite_with_op = function (e1, e2) {
                return TypeScript.MkAST.callRT("assignmentWithOp", [TypeScript.MkAST.stringConst(TypeScript.kind2string(ast.kind())),
                    e1, e1.soundType.toRTTI(),
                    e2,
                    rhs_typed]);
            };
            switch (lhs.kind()) {
                case TypeScript.SyntaxKind.IdentifierName:
                    switch (kind) {
                        case TypeScript.SyntaxKind.AssignmentExpression:
                            var lhs_typed = this.tc(lhs);
                            return this.tcAssignIdentifier(ast, lhs_typed, rhs_typed, ast.right);
                        default:
                            var rebuild_safe = function (o, fn, tagRhs) {
                                o = _this.pkg(lhs, o, TypeScript.TConstant.Any).fst;
                                if (tagRhs) {
                                    rhs_typed = _this.pkg(rhs_typed, TypeScript.TcUtil.checkAndTag(new TypeScript.BinaryExpression(_this.getBinOpFromAssignment(ast.kind()), lhs, rhs_typed), tresult, tagRhs), tagRhs).fst;
                                    kind = TypeScript.SyntaxKind.AssignmentExpression;
                                }
                                return new TypeScript.BinaryExpression(kind, o, rhs_typed);
                            };
                            return this.tcOpWithAssignment(ast, lhs, rhs_typed.soundType, rebuild_safe);
                    }
                case TypeScript.SyntaxKind.MemberAccessExpression:
                    switch (kind) {
                        case TypeScript.SyntaxKind.AssignmentExpression:
                            var ma = lhs;
                            var o = this.tc(ma.expression);
                            var fn = ma.name;
                            return this.tcAssignMember(ast, o, fn, rhs_typed, ast.right);
                        default:
                            var rebuild_safe = function (o, fn, tagRhs) {
                                var mae = _this.pkg(lhs, new TypeScript.MemberAccessExpression(o, fn), TypeScript.TConstant.Any).fst;
                                if (tagRhs) {
                                    rhs_typed = _this.pkg(rhs_typed, TypeScript.TcUtil.checkAndTag(new TypeScript.BinaryExpression(_this.getBinOpFromAssignment(ast.kind()), lhs, rhs_typed), tresult, tagRhs), tagRhs).fst;
                                    kind = TypeScript.SyntaxKind.AssignmentExpression;
                                }
                                return new TypeScript.BinaryExpression(kind, mae, rhs_typed);
                            };
                            return this.tcOpWithAssignment(ast, lhs, rhs_typed.soundType, rebuild_safe, rewrite_with_op);
                    }
                case TypeScript.SyntaxKind.ElementAccessExpression:
                    switch (kind) {
                        case TypeScript.SyntaxKind.AssignmentExpression:
                            var ea = lhs;
                            var o1 = this.tc(ea.expression);
                            var o2 = this.tc(ea.argumentExpression);
                            return this.tcAssignElement(ast, o1, o2, rhs_typed);
                        default:
                            var rebuild_safe_eae = function (o, fn, tagRhs) {
                                var eae = _this.pkg(lhs, new TypeScript.ElementAccessExpression(o, fn), TypeScript.TConstant.Any).fst;
                                return new TypeScript.BinaryExpression(ast.kind(), eae, rhs_typed);
                            };
                            return this.tcOpWithAssignment(ast, lhs, rhs_typed.soundType, rebuild_safe_eae, rewrite_with_op);
                    }
                default:
                    throw new Error("Unexpected LHS of assignment: " + rhs_typed.kind());
            }
        };
        SoundTypeChecker.prototype.rebuildUnary = function (operand, e, f) {
            var term;
            switch (operand.kind()) {
                case TypeScript.SyntaxKind.IdentifierName:
                    term = e;
                    break;
                case TypeScript.SyntaxKind.MemberAccessExpression:
                    term = new TypeScript.MemberAccessExpression(e, f);
                    break;
                case TypeScript.SyntaxKind.ElementAccessExpression:
                    term = new TypeScript.ElementAccessExpression(e, f);
                    break;
                default:
                    throw new Error("Impossible");
            }
            return this.pkg(operand, term, term.soundType).fst;
        };
        SoundTypeChecker.prototype.tcPostfixUnaryOpWithAssignment = function (ast) {
            var _this = this;
            var rewrite = function (e, f) {
                return TypeScript.MkAST.callRT("assignmentWithUnaryOp", [TypeScript.MkAST.stringConst(TypeScript.kind2string(ast.kind())), e, e.soundType.toRTTI(), f]);
            };
            var safe = function (e, f, tagRhs) {
                if (tagRhs) {
                    return rewrite(e, f);
                }
                else {
                    return new TypeScript.PostfixUnaryExpression(ast.kind(), _this.rebuildUnary(ast.operand, e, f));
                }
            };
            return this.tcOpWithAssignment(ast, ast.operand, TypeScript.TConstant.Number, safe, rewrite);
        };
        SoundTypeChecker.prototype.tcPrefixUnaryOpWithAssignment = function (ast) {
            var _this = this;
            var rewrite = function (e, f) {
                return TypeScript.MkAST.callRT("assignmentWithUnaryOp", [TypeScript.MkAST.stringConst(TypeScript.kind2string(ast.kind())), e, e.soundType.toRTTI(), f]);
            };
            var safe = function (e, f, tagRhs) {
                if (tagRhs) {
                    return rewrite(e, f);
                }
                else {
                    return new TypeScript.PrefixUnaryExpression(ast.kind(), _this.rebuildUnary(ast.operand, e, f));
                }
            };
            return this.tcOpWithAssignment(ast, ast.operand, TypeScript.TConstant.Number, safe, rewrite);
        };
        SoundTypeChecker.prototype.tcUnaryOperation = function (ast) {
            var e = this.tc(ast.operand);
            var res = new TypeScript.PrefixUnaryExpression(ast.kind(), e);
            if (this.compilationSettings.secure() && !TypeScript.TypeRelations.isSubtype(e.soundType, TypeScript.TConstant.Any)) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Unary_operator_expects_an_un_free_type, [e.soundType.toString()], ast);
                return this.pkg(ast, TypeScript.MkAST.unsafe(res), TypeScript.TConstant.Number);
            }
            var result_t = TypeScript.TranslateTypes.translateTypeOrSig(ast.inferredType, this.tcenv);
            return this.pkg(ast, res, result_t);
        };
        SoundTypeChecker.prototype.tcElementAccessExpression = function (ast) {
            var o = this.tc(ast.expression);
            var key = this.tc(ast.argumentExpression);
            var t_o = o.soundType.unfold();
            switch (t_o.typeName) {
                case TypeScript.TypeName.Null:
                case TypeScript.TypeName.Un:
                case TypeScript.TypeName.Number:
                case TypeScript.TypeName.Bool:
                case TypeScript.TypeName.Arrow:
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Projection_from_non_records, [o.soundType.toString()], ast);
                default:
                    if (this.compilationSettings.secure()) {
                        if (o.soundType.unfold().typeName === TypeScript.TypeName.String) {
                            return this.pkg(ast, TypeScript.MkAST.callExpr(TypeScript.MkAST.fieldOfRT("charAt"), [o, key]), TypeScript.TConstant.String);
                        }
                        else {
                            return this.pkg(ast, TypeScript.MkAST.callRT("readField", [o, o.soundType.toRTTI(), key]), TypeScript.TConstant.Any);
                        }
                    }
                    else {
                        switch (t_o.typeName) {
                            case TypeScript.TypeName.String:
                                return this.pkg(ast, new TypeScript.ElementAccessExpression(o, TypeScript.TcUtil.force(TypeScript.TConstant.Number, key)), TypeScript.TConstant.String);
                            default:
                                var imap = t_o.indexSignature();
                                if (imap) {
                                    return this.pkg(ast, new TypeScript.ElementAccessExpression(o, TypeScript.TcUtil.force(imap.indexType, key)), imap.elt);
                                }
                                if (!TypeScript.TypeRelations.isSubtype(o.soundType, TypeScript.TConstant.Any, TypeScript.TcUtil.allowDeepSubtyping(ast.expression))) {
                                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_ElementAccess_from_non_any, [o.soundType.toString(), key.soundType.toString()], ast);
                                }
                                return this.pkg(ast, TypeScript.MkAST.callRT("readField", [o, o.soundType.toRTTI(), key]), TypeScript.TConstant.Any);
                        }
                    }
            }
        };
        SoundTypeChecker.prototype.tcBinOp = function (ast) {
            var e1 = this.tc(ast.left);
            var e2 = this.tc(ast.right);
            var res = new TypeScript.BinaryExpression(ast.kind(), e1, e2);
            var expected_t = TypeScript.TranslateTypes.translate(ast.inferredType, this.tcenv);
            return this.pkg(ast, res, expected_t);
        };
        SoundTypeChecker.prototype.tcLogicalOrExpression = function (ast) {
            var e1 = this.tc(ast.left);
            var e2 = this.tc(ast.right);
            var expected_t = ast.inferredType ? TypeScript.TranslateTypes.translate(ast.inferredType, this.tcenv) : e1.soundType;
            var sc1 = TypeScript.TypeRelations.subtype(e1.soundType, expected_t, TypeScript.TcUtil.allowDeepSubtyping(ast.left));
            var sc2 = TypeScript.TypeRelations.subtype(e2.soundType, expected_t, TypeScript.TcUtil.allowDeepSubtyping(ast.right));
            if (!TypeScript.TypeRelations.isSubtype(e1.soundType, TypeScript.TConstant.Any, TypeScript.TcUtil.allowDeepSubtyping(ast.left))
                || !TypeScript.TypeRelations.isSubtype(e2.soundType, TypeScript.TConstant.Any, TypeScript.TcUtil.allowDeepSubtyping(ast.right))) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Binary_operator_expects_both_any, [e1.soundType.toString(), e2.soundType.toString()], ast);
                return this.pkg(ast, TypeScript.MkAST.unsafe(new TypeScript.BinaryExpression(ast.kind(), e1, e2)), TypeScript.TConstant.Bool);
            }
            if (sc1.fst && sc2.fst) {
                return this.pkg(ast, new TypeScript.BinaryExpression(ast.kind(), TypeScript.TcUtil.shallowTag(sc1, e1, TypeScript.TConstant.Any), TypeScript.TcUtil.shallowTag(sc2, e2, TypeScript.TConstant.Any)), expected_t);
            }
            else {
                return this.pkg(ast, TypeScript.TcUtil.force(TypeScript.TConstant.Bool, new TypeScript.BinaryExpression(ast.kind(), e1, e2)), TypeScript.TConstant.Bool);
            }
        };
        SoundTypeChecker.prototype.tcTypeOfExpression = function (ast) {
            var o = this.tc(ast.expression);
            if (o.soundType.unfold().typeName === TypeScript.TypeName.Un) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_TypeOf_un, [], ast);
            }
            return this.pkg(ast, new TypeScript.TypeOfExpression(o), TypeScript.TConstant.String);
        };
        SoundTypeChecker.prototype.tcThrowStatement = function (ast) {
            var ts = ast;
            var exn = this.tc(ts.expression);
            var sc = TypeScript.TypeRelations.subtype(exn.soundType, TypeScript.TConstant.Any, TypeScript.TcUtil.allowDeepSubtyping(ts.expression));
            if (!sc.fst) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Throw_not_any, [exn.soundType.toString()], ts.expression);
            }
            else {
                exn = TypeScript.TcUtil.shallowTag(sc, exn, TypeScript.TConstant.Any);
            }
            return this.pkg(ast, new TypeScript.ThrowStatement(exn), TypeScript.TConstant.Void, true);
        };
        SoundTypeChecker.prototype.tcDeleteExpression = function (ast) {
            var expression = this.tc(ast.expression);
            switch (expression.kind()) {
                case TypeScript.SyntaxKind.ElementAccessExpression:
                    var eae = expression;
                    var safeDelete = TypeScript.MkAST.callExpr(TypeScript.MkAST.fieldOfRT("deleteField"), [eae.expression, eae.argumentExpression]);
                    return this.pkg(ast, safeDelete);
                case TypeScript.SyntaxKind.MemberAccessExpression:
                    var mae = expression;
                    if (mae.soundType.unfold() !== TypeScript.TConstant.Any) {
                        TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Delete_operator_expects_any, [mae.soundType.toString()], ast);
                        return this.pkg(ast, TypeScript.MkAST.unsafe(new TypeScript.DeleteExpression(mae)));
                    }
                    else {
                        return this.pkg(ast, TypeScript.MkAST.callExpr(TypeScript.MkAST.fieldOfRT("deleteField"), [mae.expression, TypeScript.MkAST.stringConst(mae.name.text())]));
                    }
                default:
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Delete_operator_expects_member_or_element_access, [], ast);
                    return this.pkg(ast, TypeScript.MkAST.unsafe(new TypeScript.DeleteExpression(expression)));
            }
        };
        SoundTypeChecker.prototype.tcConditionalExpression = function (ast) {
            var cond = this.tc(ast.condition);
            var thenBod = this.tc(ast.whenTrue);
            var elseBod = this.tc(ast.whenFalse);
            var expected_t = TypeScript.TranslateTypes.translate(ast.inferredType, this.tcenv);
            if (expected_t.equals(TypeScript.TConstant.Null)) {
                if (thenBod.soundType.equals(TypeScript.TConstant.Null)) {
                    expected_t = elseBod.soundType;
                }
                else {
                    expected_t = thenBod.soundType;
                }
            }
            var bthen = TypeScript.TypeRelations.subtype(thenBod.soundType, expected_t, TypeScript.TcUtil.allowDeepSubtyping(ast.whenTrue));
            var belse = TypeScript.TypeRelations.subtype(elseBod.soundType, expected_t, TypeScript.TcUtil.allowDeepSubtyping(ast.whenFalse));
            var res = new TypeScript.ConditionalExpression(cond, TypeScript.TcUtil.shallowTag(bthen, thenBod, expected_t), TypeScript.TcUtil.shallowTag(belse, elseBod, expected_t));
            if (bthen.fst && belse.fst) {
                return this.pkg(ast, res, expected_t);
            }
            if (!bthen.fst) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Conditional_branch, [expected_t.toString(), thenBod.soundType.toString()], ast.whenTrue);
            }
            if (!belse.fst) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Conditional_branch, [expected_t.toString(), elseBod.soundType.toString()], ast.whenFalse);
            }
            return this.pkg(ast, TypeScript.MkAST.unsafe(res), expected_t);
        };
        SoundTypeChecker.prototype.tcRegularExpressionLiteral = function (ast) {
            var t = this.tcenv.lookupType({ dottedName: "RegExp" });
            if (t) {
                return this.pkg(ast, ast, t);
            }
            TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Variable_not_found, ["RegExp"], ast);
            return this.pkg(ast, ast, TypeScript.TConstant.Any);
        };
        SoundTypeChecker.prototype.tcParenthesizedExpression = function (ast) {
            var expr = this.tc(ast.expression);
            return this.pkg(ast, new TypeScript.ParenthesizedExpression(ast.openParenTrailingComments, expr), expr.soundType);
        };
        SoundTypeChecker.prototype.tcExpressionStatement = function (ast) {
            var expr = this.tc(ast.expression);
            return this.pkg(ast, new TypeScript.ExpressionStatement(expr), TypeScript.TConstant.Void);
        };
        SoundTypeChecker.prototype.tcCommaExpression = function (ast) {
            var e1 = this.tc(ast.left);
            var e2 = this.tc(ast.right);
            return this.pkg(ast, new TypeScript.BinaryExpression(TypeScript.SyntaxKind.CommaExpression, e1, e2), e2.soundType);
        };
        SoundTypeChecker.prototype.auxTcInInstanceOf = function (ast) {
            var x = this.tc(ast.left);
            var o = this.tc(ast.right);
            var res = new TypeScript.BinaryExpression(ast.kind(), x, o);
            return this.pkg(ast, res, TypeScript.TConstant.Bool);
        };
        SoundTypeChecker.prototype.tcInstanceOfExpression = function (ast) {
            return this.auxTcInInstanceOf(ast);
        };
        SoundTypeChecker.prototype.tcInExpression = function (ast) {
            return this.auxTcInInstanceOf(ast);
        };
        SoundTypeChecker.prototype.tcForStatement = function (ast) {
            var fs = ast;
            var vd = fs.variableDeclaration ? this.tc(fs.variableDeclaration) : null;
            var init = fs.initializer ? this.tc(fs.initializer) : null;
            var cond = fs.condition ? this.tc(fs.condition) : null;
            var incr = fs.incrementor ? this.tc(fs.incrementor) : null;
            var bodyR = fs.statement ? this.tcaux(fs.statement) : { fst: null, snd: false };
            var res = new TypeScript.ForStatement(vd, init, cond, incr, bodyR.fst);
            return this.pkg(ast, res, TypeScript.TConstant.Void, bodyR.snd);
        };
        SoundTypeChecker.prototype.tcForInStatement = function (ast) {
            var _this = this;
            var fis = ast;
            var rval = this.tc(fis.expression);
            var rvalAny = TypeScript.TypeRelations.subtype(rval.soundType, TypeScript.TConstant.Any, TypeScript.TcUtil.allowDeepSubtyping(fis.expression));
            if (!rvalAny.fst) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Property_iteration_on_non_any, [rval.soundType.toString()], fis.expression);
            }
            var unsafe = function (msg) {
                TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Invalid_lval_iteration, [msg], ast);
                var bodyR = _this.tcenv.newScope(function () { return _this.tcaux(fis.statement); });
                var res = new TypeScript.ForInStatement(fis.variableDeclaration, fis.left, rval, bodyR.fst);
                return _this.pkg(ast, res, TypeScript.TConstant.Void, bodyR.snd);
            };
            var guardBlock = function (id, stmt) {
                switch (stmt.kind()) {
                    case TypeScript.SyntaxKind.Block:
                        var b = stmt;
                        var body = TypeScript.TcUtil.syntaxListMembers(b.statements);
                        var rttiCheck = new TypeScript.IfStatement(new TypeScript.BinaryExpression(TypeScript.SyntaxKind.EqualsExpression, id, TypeScript.MkAST.stringConst("__rtti__")), new TypeScript.ContinueStatement(null), null);
                        body.unshift(rttiCheck);
                        var bodyL = new TypeScript.ISyntaxList2(TypeScript.TcUtil.currentFile(), body);
                        var block = new TypeScript.Block(bodyL, b.closeBraceLeadingComments, b.closeBraceToken);
                        return _this.pkg(fis.statement, block).fst;
                    default:
                        throw new Error("For/in loop without a block body ... it's a " + TypeScript.kind2string(stmt.kind()));
                }
            };
            if (fis.variableDeclaration && !fis.left) {
                var vd = fis.variableDeclaration;
                var decls = vd.declarators;
                if (decls.nonSeparatorCount() != 1) {
                    return unsafe(decls.nonSeparatorCount() + " variable declarators");
                }
                if (decls.nonSeparatorAt(0).equalsValueClause) {
                    return unsafe("unexpected initializer in 'for-in' loop");
                }
                var decl = decls.nonSeparatorAt(0);
                var iterVar = decl.propertyName;
                var bodyR = this.tcenv.newScope(function () {
                    return _this.tcenv.withVariable(decls, iterVar.text(), TypeScript.TConstant.String)(function () {
                        return _this.tcaux(fis.statement);
                    });
                });
                var res = new TypeScript.ForInStatement(vd, fis.left, rval, guardBlock(TypeScript.MkAST.id(iterVar.text()), bodyR.fst));
                return this.pkg(ast, res, TypeScript.TConstant.Void, bodyR.snd);
            }
            else if (!fis.variableDeclaration && fis.left && fis.left.kind() === TypeScript.SyntaxKind.IdentifierName) {
                var id = fis.left;
                var xt = this.tcenv.lookup(id.text());
                if (!xt || (xt.typeName !== TypeScript.TypeName.String && xt.typeName !== TypeScript.TypeName.Any)) {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Invalid_lval_iteration, ["Expected a string- or any-typed variable; got " + xt ? xt.toString() : "unknown"], fis.left);
                }
                var bodyR = this.tcenv.newScope(function () { return _this.tcaux(fis.statement); });
                var res = new TypeScript.ForInStatement(fis.variableDeclaration, id, rval, guardBlock(id, bodyR.fst));
                return this.pkg(ast, res, TypeScript.TConstant.Void, bodyR.snd);
            }
            else {
                return unsafe("unexpected LHS");
            }
        };
        SoundTypeChecker.prototype.tcWhileStatement = function (ast) {
            var ws = ast;
            var cond = this.tc(ws.condition);
            var bodyR = this.tcaux(ws.statement);
            return this.pkg(ast, new TypeScript.WhileStatement(cond, bodyR.fst), TypeScript.TConstant.Void, bodyR.snd);
        };
        SoundTypeChecker.prototype.tcDoStatement = function (ast) {
            var dos = ast;
            var bodyR = this.tcaux(dos.statement);
            var cond = this.tc(dos.condition);
            return this.pkg(ast, new TypeScript.DoStatement(bodyR.fst, dos.whileKeyword, cond), TypeScript.TConstant.Void, bodyR.snd);
        };
        SoundTypeChecker.prototype.tcIfStatement = function (ast) {
            var cond = this.tc(ast.condition);
            var thenBodR = this.tcaux(ast.statement);
            var elseBodR = ast.elseClause ? this.tcaux(ast.elseClause) : null;
            return this.pkg(ast, new TypeScript.IfStatement(cond, thenBodR.fst, elseBodR ? elseBodR.fst : null), TypeScript.TConstant.Void, thenBodR.snd && elseBodR ? elseBodR.snd : true);
        };
        SoundTypeChecker.prototype.tcElseClause = function (ast) {
            var eR = this.tcaux(ast.statement);
            return this.pkg(ast, new TypeScript.ElseClause(eR.fst), TypeScript.TConstant.Void, eR.snd);
        };
        SoundTypeChecker.prototype.tcBlock = function (ast) {
            var _this = this;
            var out = [];
            var rr = this.tcenv.newScope(function () { return _this.tcaux(ast.statements); });
            var b = new TypeScript.Block(rr.fst, ast.closeBraceLeadingComments, ast.closeBraceToken);
            return this.pkg(ast, b, TypeScript.TConstant.Void, rr.snd);
        };
        SoundTypeChecker.prototype.tcVariableStatement = function (ast) {
            var vd = this.tc(ast.declaration);
            return this.pkg(ast, new TypeScript.VariableStatement(ast.modifiers, vd), vd.soundType);
        };
        SoundTypeChecker.prototype.tcWithStatement = function (ast) {
            return TypeScript.TcUtil.NYI("WithStatement");
        };
        SoundTypeChecker.prototype.tcTryStatement = function (ast) {
            var tryBodyR = this.tcaux(ast.block);
            var catch_clauseR = (ast.catchClause ? this.tcaux(ast.catchClause) : null);
            var finally_clauseR = (ast.finallyClause ? this.tcaux(ast.finallyClause) : null);
            return this.pkg(ast, new TypeScript.TryStatement(tryBodyR.fst, ast.catchClause ? catch_clauseR.fst : null, ast.finallyClause ? finally_clauseR.fst : null), TypeScript.TConstant.Void, tryBodyR.snd && (!catch_clauseR || catch_clauseR.snd) && (!finally_clauseR || finally_clauseR.snd));
        };
        SoundTypeChecker.prototype.tcCatchClause = function (ast) {
            var _this = this;
            var vd = ast.identifier;
            var err_t = TypeScript.TConstant.Any;
            var catch_bodyR = this.tcenv.withVariable(ast, vd.text(), err_t)(function () {
                return _this.tcaux(ast.block);
            });
            return this.pkg(ast, new TypeScript.CatchClause(vd, ast.typeAnnotation, catch_bodyR.fst), TypeScript.TConstant.Void, catch_bodyR.snd);
        };
        SoundTypeChecker.prototype.tcFinallyClause = function (ast) {
            var block = this.tcaux(ast.block);
            return this.pkg(ast, new TypeScript.FinallyClause(block.fst), TypeScript.TConstant.Void, block.snd);
        };
        SoundTypeChecker.prototype.tcReturnStatement = function (ast) {
            var result = ast.expression ? this.tc(ast.expression) : null;
            var result_t = result ? result.soundType : TypeScript.TConstant.Void;
            var sc = TypeScript.TypeRelations.subtype(result_t, this.result_t, TypeScript.TcUtil.allowDeepSubtyping(ast.expression));
            if (result && this.result_t && !sc.fst) {
                if (TypeScript.TypeRelations.assignable(this.result_t, result_t)) {
                    TypeScript.TcUtil.Logger.warning(TypeScript.DiagnosticCode.SEC_Implicit_coercion, [result_t.toString(), this.result_t.toString()], ast);
                    result = TypeScript.TcUtil.checkAndTag(result, result_t, this.result_t);
                }
                else {
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Function_return_type, [this.result_t.toString(), result_t.toString()], ast);
                    result = TypeScript.MkAST.unsafe(result);
                }
            }
            else if (result && sc.fst) {
                result = TypeScript.TcUtil.shallowTag(sc, result, this.result_t);
            }
            return this.pkg(ast, new TypeScript.ReturnStatement(result), result_t, true);
        };
        SoundTypeChecker.prototype.tcSwitchStatement = function (ast) {
            var _this = this;
            var guard = this.tc(ast.expression);
            switch (guard.soundType.unfold().typeName) {
                case TypeScript.TypeName.Enum:
                case TypeScript.TypeName.Number:
                case TypeScript.TypeName.String:
                case TypeScript.TypeName.Bool: break;
                default:
                    TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Switch_guard_not_primitive, [guard.soundType.toString()], ast.expression);
            }
            var clauses = [];
            var returns = false;
            return this.tcenv.newScope(function () {
                for (var i = 0; i < ast.switchClauses.childCount(); i++) {
                    var caseClauseR = _this.tcenv.newScope(function () { return _this.tcaux(ast.switchClauses.childAt(i)); });
                    if (caseClauseR.fst.kind() === TypeScript.SyntaxKind.CaseSwitchClause) {
                        var csc = caseClauseR.fst;
                        if (!TypeScript.TypeRelations.subtype(csc.expression.soundType, guard.soundType, TypeScript.TcUtil.allowDeepSubtyping(ast.switchClauses.childAt(i))).fst) {
                            TypeScript.TcUtil.Logger.error(TypeScript.DiagnosticCode.SEC_Switch_case_incompatible, [guard.soundType.toString(),
                                csc.expression.soundType.toString()], ast.switchClauses.childAt(i));
                        }
                    }
                    clauses.push(caseClauseR.fst);
                    if (i === ast.switchClauses.childCount() - 1) {
                        returns = (caseClauseR.fst.kind() === TypeScript.SyntaxKind.DefaultSwitchClause && caseClauseR.snd);
                    }
                }
                var switchClauses = new TypeScript.ISyntaxList2(_this.doc.fileName, clauses);
                return _this.pkg(ast, new TypeScript.SwitchStatement(guard, ast.closeParenToken, switchClauses), TypeScript.TConstant.Void, returns);
            });
        };
        SoundTypeChecker.prototype.tcCaseSwitchClause = function (ast) {
            var expr = this.tc(ast.expression);
            var st = this.tcaux(ast.statements);
            return this.pkg(ast, new TypeScript.CaseSwitchClause(expr, st.fst), TypeScript.TConstant.Void, st.snd);
        };
        SoundTypeChecker.prototype.tcDefaultSwitchClause = function (ast) {
            var st = this.tcaux(ast.statements);
            return this.pkg(ast, new TypeScript.DefaultSwitchClause(st.fst), TypeScript.TConstant.Void, st.snd);
        };
        SoundTypeChecker.prototype.tcContinueStatement = function (ast) {
            ast.soundType = TypeScript.TConstant.Void;
            return { fst: ast, snd: false };
        };
        SoundTypeChecker.prototype.tcBreakStatement = function (ast) {
            if (ast.identifier) {
                return TypeScript.TcUtil.NYI("'labeled statements'");
            }
            ast.soundType = TypeScript.TConstant.Void;
            return { fst: ast, snd: false };
        };
        SoundTypeChecker.prototype.tcLabeledStatement = function (ast) {
            var st = this.tc(ast.statement);
            return this.pkg(ast, new TypeScript.LabeledStatement(ast.identifier, st), TypeScript.TConstant.Void);
        };
        SoundTypeChecker.prototype.tcHeritageClause = function (ast) {
            var typeNames = this.tc(ast.typeNames);
            return this.pkg(ast, new TypeScript.HeritageClause(ast.kind(), typeNames));
        };
        SoundTypeChecker.emittedBaseClassHierarchy = false;
        SoundTypeChecker.globalEnv = null;
        SoundTypeChecker.compilationSettings = null;
        return SoundTypeChecker;
    }());
    TypeScript.SoundTypeChecker = SoundTypeChecker;
})(TypeScript || (TypeScript = {}));
var RT;
(function (RT) {
    function assert(b, m) {
        if (!b) {
            throw new Error("assert failure: " + m);
        }
    }
    function die(msg) {
        throw new Error(msg);
    }
    RT.die = die;
    var TT;
    (function (TT) {
        TT[TT["ANY"] = 0] = "ANY";
        TT[TT["NUMBER"] = 1] = "NUMBER";
        TT[TT["STRING"] = 2] = "STRING";
        TT[TT["BOOLEAN"] = 3] = "BOOLEAN";
        TT[TT["VOID"] = 4] = "VOID";
        TT[TT["ARRAY"] = 5] = "ARRAY";
        TT[TT["INSTANCE"] = 6] = "INSTANCE";
        TT[TT["INTERFACE"] = 7] = "INTERFACE";
        TT[TT["CLASS"] = 8] = "CLASS";
        TT[TT["INDEX_MAP"] = 9] = "INDEX_MAP";
        TT[TT["STRUCTURED_TYPE"] = 10] = "STRUCTURED_TYPE";
        TT[TT["JUST_TYPE"] = 11] = "JUST_TYPE";
        TT[TT["UN"] = 12] = "UN";
    })(TT = RT.TT || (RT.TT = {}));
    function eqOptionalMap(m1, m2) {
        if (m1 === m2) {
            return true;
        }
        if (!(m1 && m2)) {
            return false;
        }
        for (var i in m1) {
            if (!(m1[i] === m2[i])) {
                return false;
            }
        }
        for (var i in m2) {
            if (!(m1[i])) {
                return false;
            }
        }
        return true;
    }
    function prettyprint_a(a) {
        var s = "( ";
        for (var i = 0; i < a.args.length; ++i) {
            if (i > 0) {
                s += ", ";
            }
            s += prettyprint_t(a.args[i]);
            if (a.mandatoryArgs && i >= a.mandatoryArgs) {
                s += "?";
            }
        }
        if (a.varargs) {
            s += " , ..." + prettyprint_t(a.varargs);
        }
        s += " ) => " + prettyprint_t(a.result);
        return s;
    }
    function prettyprint_t(t) {
        if (isZero(t)) {
            return "zero";
        }
        switch (t.tt) {
            case TT.UN:
                return "Un";
            case TT.ANY:
                return "any";
            case TT.ARRAY:
                return prettyprint_t(t.elt) + "[]";
            case TT.BOOLEAN:
                return "boolean";
            case TT.CLASS:
                return t.name + "_Class";
            case TT.INDEX_MAP:
                return "[_:" + prettyprint_t(t.key) + "] :" + prettyprint_t(t.value);
            case TT.INSTANCE:
                return t.name;
            case TT.INTERFACE:
                return t.name;
            case TT.JUST_TYPE:
                return "dot " + prettyprint_t(t.base);
            case TT.NUMBER:
                return "number";
            case TT.STRING:
                return "string";
            case TT.STRUCTURED_TYPE:
                var s = "{ ";
                var first = true;
                var methods = t.methodTable;
                for (var m in methods) {
                    if (!first) {
                        s += ", ";
                    }
                    else {
                        first = false;
                    }
                    s += m + ":" + prettyprint_a(methods[m]);
                }
                var flds = t.fieldTable;
                first = true;
                s += ", ";
                for (var f in flds) {
                    if (!first) {
                        s += ", ";
                    }
                    else {
                        first = false;
                    }
                    s += f + ":" + prettyprint_t(flds[f]);
                }
                return (s += " }");
            case TT.VOID:
                return "void";
        }
        throw new Error("Impossible");
    }
    RT.prettyprint_t = prettyprint_t;
    function InstanceRepr(name, methods, fields, extendsList, functionObject, implementsList) {
        return { kind: TT.INSTANCE, name: name, methods: methods, fields: fields, extendsList: extendsList, functionObject: functionObject, implementsList: implementsList };
    }
    RT.InstanceRepr = InstanceRepr;
    function ClassRepr(name, methods, fields, extendsList, constr) {
        return { kind: TT.CLASS, name: name, methods: methods, fields: fields, extendsList: extendsList, constr: constr };
    }
    RT.ClassRepr = ClassRepr;
    function InterfaceRepr(name, methods, fields, extendsList, nominal) {
        if (nominal === void 0) { nominal = false; }
        return { kind: TT.INTERFACE, name: name, methods: methods, fields: fields, extendsList: extendsList };
    }
    RT.InterfaceRepr = InterfaceRepr;
    var registry = Object.create(null);
    function registerType(repr) {
        var name = repr.name;
        if (registry[name]) {
            throw new Error("Named type " + repr.name + " is already defined");
        }
        if (name === "String") {
            RT.Str.methodTable = repr.methods;
        }
        else if (name === "Object") {
            RT.objectMethods = repr.methods;
        }
        else if (name === "Number") {
            RT.Num.methodTable = repr.methods;
        }
        else {
            var named_type = namedTypesCache[name];
            if (!named_type) {
                if (repr.kind === TT.INTERFACE) {
                    named_type = InterfaceType(name);
                }
                else if (repr.kind === TT.CLASS) {
                    named_type = ClassType(name);
                }
                else if (repr.kind === TT.INSTANCE) {
                    named_type = InstanceType(name);
                }
            }
            named_type.fieldTable = repr.fields;
            named_type.methodTable = repr.methods;
            named_type.structuredType = StructuredType(repr.methods, repr.fields);
            named_type.structuredType.immutable = true;
            named_type.extendsList = repr.extendsList;
            if (repr.kind === TT.CLASS) {
                named_type.constr = repr.constr;
            }
            else if (repr.kind === TT.INSTANCE) {
                named_type.implementsList = repr.implementsList;
                named_type.functionObject = repr.functionObject;
            }
        }
        registry[name] = true;
    }
    RT.registerType = registerType;
    function registerClass(className, methods, fields, extendsC, implementsI, staticMethods, staticFields, constructorType, functionObject) {
        var instanceObject = InstanceRepr(className, methods, fields, (extendsC ? [extendsC] : []), functionObject, implementsI);
        var classObject = ClassRepr(className + "Class", staticMethods, staticFields, [], constructorType);
        registerType(instanceObject);
        registerType(classObject);
        return ClassType(className);
    }
    RT.registerClass = registerClass;
    var emptyFieldTable = RT.createEmptyMap();
    var emptyMethodTable = RT.createEmptyMap();
    RT.Un = {
        tt: TT.UN,
        fieldTable: emptyFieldTable,
        methodTable: emptyMethodTable
    };
    RT.Any = {
        tt: TT.ANY,
        fieldTable: emptyFieldTable,
        methodTable: emptyMethodTable,
    };
    RT.Num = {
        tt: TT.NUMBER,
        fieldTable: emptyFieldTable,
        methodTable: emptyMethodTable,
    };
    RT.Bool = {
        tt: TT.BOOLEAN,
        fieldTable: emptyFieldTable,
        methodTable: emptyMethodTable,
    };
    RT.Str = {
        tt: TT.STRING,
        fieldTable: { "length": RT.Num },
        methodTable: emptyMethodTable,
    };
    RT.Void = {
        tt: TT.VOID,
        fieldTable: emptyFieldTable,
        methodTable: emptyMethodTable,
    };
    var _;
    _ = Number.prototype.__rtti__ = RT.Num;
    _ = Boolean.prototype.__rtti__ = RT.Bool;
    _ = String.prototype.__rtti__ = RT.Str;
    _ = Object.prototype.__rtti__ = RT.Any;
    var namedTypesCache = {};
    function getNamedType(name, tt) {
        if (namedTypesCache[name]) {
            return namedTypesCache[name];
        }
        else {
            return (namedTypesCache[name] = { tt: tt, name: name, fieldTable: emptyFieldTable, methodTable: emptyMethodTable, structuredType: undefined });
        }
    }
    function InterfaceType(name) {
        return getNamedType(name, TT.INTERFACE);
    }
    RT.InterfaceType = InterfaceType;
    function InstanceType(name) {
        return getNamedType(name, TT.INSTANCE);
    }
    RT.InstanceType = InstanceType;
    function ClassType(name) {
        return getNamedType(name + "Class", TT.CLASS);
    }
    RT.ClassType = ClassType;
    function StructuredType(methods, fields) {
        methods.__proto__ = null;
        fields.__proto__ = null;
        return { tt: TT.STRUCTURED_TYPE, methodTable: methods, fieldTable: fields };
    }
    RT.StructuredType = StructuredType;
    function JustType(t) {
        return { tt: TT.JUST_TYPE, base: t, fieldTable: emptyFieldTable, methodTable: emptyMethodTable };
    }
    RT.JustType = JustType;
    function IndexMapType(key, value) {
        return { tt: TT.INDEX_MAP, key: key, value: value, fieldTable: emptyFieldTable, methodTable: emptyMethodTable };
    }
    RT.IndexMapType = IndexMapType;
    function ArrayType(elt) {
        return { tt: TT.ARRAY, elt: elt, fieldTable: { "length": RT.Num }, methodTable: emptyMethodTable };
    }
    RT.ArrayType = ArrayType;
    function ArrowType(args, result, varargs, mandatoryArgs) {
        var arrow = {
            args: args,
            result: result
        };
        if (varargs) {
            arrow.varargs = varargs;
        }
        if (!(mandatoryArgs === undefined)) {
            arrow.mandatoryArgs = mandatoryArgs;
        }
        return arrow;
    }
    RT.ArrowType = ArrowType;
    function LambdaType(arg, ret, varargs, mandatoryArgs) {
        return StructuredType({ "<call>": ArrowType(arg, ret, varargs, mandatoryArgs) }, {});
    }
    RT.LambdaType = LambdaType;
    function RecordType(flds) {
        return StructuredType({}, flds);
    }
    RT.RecordType = RecordType;
    var NameRelation;
    (function (NameRelation) {
        NameRelation[NameRelation["SUBTYPE"] = 0] = "SUBTYPE";
        NameRelation[NameRelation["EQUALITY"] = 1] = "EQUALITY";
    })(NameRelation || (NameRelation = {}));
    function extendContext(cxt, t1, t2, reln) {
        var n_cxt = {};
        for (var f in cxt) {
            n_cxt[f] = cxt[f];
        }
        var s = (reln === NameRelation.SUBTYPE) ? " <: " : " = ";
        n_cxt[t1.name + s + t2.name] = true;
        if (reln === NameRelation.EQUALITY) {
            n_cxt[t2.name + s + t1.name] = true;
        }
        return n_cxt;
    }
    function inContext(cxt, t1, t2, reln) {
        var s = (reln === NameRelation.SUBTYPE) ? " <: " : " = ";
        return cxt[t1.name + s + t2.name] === true;
    }
    var namedTypeRelationRegistry = (function () {
        var r = {};
        r.__proto__ = null;
        return r;
    })();
    function addToNamedTypeRelationRegistry(t1, t2, reln, d) {
        var s = (reln === NameRelation.SUBTYPE) ? " <: " : " = ";
        namedTypeRelationRegistry[t1.name + s + t2.name] = d;
        if (reln === NameRelation.EQUALITY) {
            namedTypeRelationRegistry[t2.name + s + t1.name] = d;
        }
    }
    function inNamedTypeRelationRegistry(t1, t2, reln) {
        var s = (reln === NameRelation.SUBTYPE) ? t1.name + " <: " + t2.name : t1.name + " = " + t2.name;
        return (namedTypeRelationRegistry[s] ? { fst: true, snd: namedTypeRelationRegistry[s] } : { fst: false, snd: zero });
    }
    function subtype(t1, t2, cxt) {
        var sub;
        if (t1 === t2) {
            return { fst: true, snd: zero };
        }
        switch (t2.tt) {
            case TT.ANY:
                switch (t1.tt) {
                    case TT.NUMBER:
                    case TT.BOOLEAN:
                    case TT.STRING:
                    case TT.VOID:
                    case TT.INSTANCE:
                        return { fst: true, snd: zero };
                    case TT.INTERFACE:
                    case TT.STRUCTURED_TYPE:
                    case TT.ARRAY:
                    case TT.INDEX_MAP:
                    case TT.CLASS:
                        return { fst: true, snd: t1 };
                    default:
                        return { fst: false, snd: zero };
                }
            case TT.INSTANCE:
                if (t1.tt === TT.INSTANCE) {
                    return {
                        fst: t1.functionObject.prototype instanceof t2.functionObject, snd: zero
                    };
                }
                else {
                    return { fst: false, snd: zero };
                }
            case TT.VOID:
                return { fst: true, snd: zero };
            case TT.INTERFACE:
                switch (t1.tt) {
                    case TT.INTERFACE:
                        if (t1.extendsList.indexOf(t2.name) !== -1) {
                            return { fst: true, snd: t1 };
                        }
                        if ((sub = inNamedTypeRelationRegistry(t1, t2, NameRelation.SUBTYPE)) && sub.fst) {
                            return sub;
                        }
                        if (inContext(cxt, t1, t2, NameRelation.SUBTYPE)) {
                            return { fst: true, snd: zero };
                        }
                        if (equalTypes(t1, t2, cxt)) {
                            return { fst: true, snd: zero };
                        }
                        sub = subtype(t1.structuredType, t2.structuredType, extendContext(cxt, t1, t2, NameRelation.SUBTYPE));
                        if (sub.fst) {
                            addToNamedTypeRelationRegistry(t1, t2, NameRelation.SUBTYPE, sub.snd);
                        }
                        return sub;
                    case TT.STRUCTURED_TYPE:
                        return subtype(t1, t2.structuredType, cxt);
                    case TT.INSTANCE:
                        if (t1.implementsList.indexOf(t2.name) !== -1) {
                            return { fst: true, snd: zero };
                        }
                        if ((sub = inNamedTypeRelationRegistry(t1, t2, NameRelation.SUBTYPE)) && sub.fst) {
                            return sub;
                        }
                        if (inContext(cxt, t1, t2, NameRelation.SUBTYPE)) {
                            return { fst: true, snd: zero };
                        }
                        sub = subtype(t1.structuredType, t2.structuredType, extendContext(cxt, t1, t2, NameRelation.SUBTYPE));
                        if (sub.fst) {
                            addToNamedTypeRelationRegistry(t1, t2, NameRelation.SUBTYPE, sub.snd);
                        }
                        return sub;
                    default:
                        return { fst: false, snd: zero };
                }
            case TT.ARRAY:
                if (t1.tt === TT.ARRAY) {
                    return { fst: equalTypes(t1.elt, t2.elt, cxt), snd: zero };
                }
                else {
                    return { fst: false, snd: zero };
                }
            case TT.INDEX_MAP:
                if (t1.tt === TT.INDEX_MAP) {
                    return { fst: equalTypes(t1.key, t2.key, cxt) && equalTypes(t1.value, t2.value, cxt), snd: zero };
                }
                else {
                    return { fst: false, snd: zero };
                }
            case TT.STRUCTURED_TYPE:
                switch (t1.tt) {
                    case TT.INTERFACE:
                        return subtype(t1.structuredType, t2, cxt);
                    case TT.INSTANCE:
                        return { fst: subtype(t1.structuredType, t2, cxt).fst, snd: zero };
                    case TT.STRUCTURED_TYPE:
                        var flds1 = t1.fieldTable;
                        var flds2 = t2.fieldTable;
                        var methods1 = t1.methodTable;
                        var methods2 = t2.methodTable;
                        for (var f in flds2) {
                            if (!flds1[f]) {
                                return { fst: false, snd: zero };
                            }
                            if (!(equalTypes(flds1[f], flds2[f], cxt))) {
                                return { fst: false, snd: zero };
                            }
                        }
                        for (var m in methods2) {
                            if (!methods1[m]) {
                                return { fst: false, snd: zero };
                            }
                            if (!(isArrowSubtype(methods1[m], methods2[m], cxt))) {
                                return { fst: false, snd: zero };
                            }
                        }
                        var forgotten_flds = {};
                        var optional_flds = {};
                        var forgotten_methods = {};
                        var zero_delta = true;
                        for (var f in flds1) {
                            if (!flds2[f]) {
                                zero_delta = true;
                                forgotten_flds[f] = flds1[f];
                            }
                        }
                        for (var m in methods1) {
                            if (!methods2[m] || !isArrowEqual(methods1[m], methods2[m], cxt)) {
                                zero_delta = true;
                                forgotten_methods[m] = methods1[m];
                            }
                        }
                        if (zero_delta) {
                            return { fst: true, snd: zero };
                        }
                        else {
                            return { fst: true, snd: StructuredType(forgotten_methods, forgotten_flds) };
                        }
                    default:
                        return { fst: false, snd: zero };
                }
            case TT.JUST_TYPE:
                return { fst: subtype(t1.tt === TT.JUST_TYPE ? t1.base : t1, t2.base, cxt).fst, snd: zero };
            default:
        }
        return { fst: false, snd: zero };
    }
    function isZeroSubtype(t1, t2) {
        var bd = subtype(t1, t2, {});
        return (bd.fst && isZero(bd.snd));
    }
    function isSubtype(t1, t2) {
        return subtype(t1, t2, {}).fst;
    }
    function isArrowSubtype(t1, t2, cxt) {
        if (!(t1.args.length === t2.args.length) || !(t1.mandatoryArgs === t2.mandatoryArgs)) {
            return false;
        }
        var sub;
        for (var i = t1.args.length; i--;) {
            sub = subtype(t2.args[i], t1.args[i], cxt);
            if (!(sub.fst && isZero(sub.snd))) {
                return false;
            }
        }
        sub = subtype(t1.result, t2.result, cxt);
        if (!(sub.fst && isZero(sub.snd))) {
            return false;
        }
        if (!((t1.varargs === undefined && t2.varargs === undefined) || (sub = subtype(t2.varargs, t1.varargs, cxt) && sub.fst && isZero(sub.snd)))) {
            return false;
        }
        return true;
    }
    function isArrowEqual(t1, t2, cxt) {
        if (!(t1.args.length === t2.args.length) || !(t1.mandatoryArgs === t2.mandatoryArgs)) {
            return false;
        }
        for (var i = t1.args.length; i--;) {
            if (!(equalTypes(t1.args[i], t2.args[i], cxt))) {
                return false;
            }
        }
        if (!(equalTypes(t1.varargs, t2.varargs, cxt))) {
            return false;
        }
        if (!(equalTypes(t1.result, t2.result, cxt))) {
            return false;
        }
        return true;
    }
    var zero = undefined;
    function isZero(d) {
        return d === zero;
    }
    function equalTypes(t1, t2, cxt) {
        var eqflds = function (flds1, flds2) {
            for (var f in flds1) {
                if (!flds2[f]) {
                    return false;
                }
                if (!equalTypes(flds1[f], flds2[f], cxt)) {
                    return false;
                }
            }
            for (var f in flds2) {
                if (!(flds1[f])) {
                    return false;
                }
            }
            return true;
        };
        var eqmethods = function (methods1, methods2) {
            for (var m in methods1) {
                if (!methods2[m]) {
                    return false;
                }
                if (!isArrowEqual(methods1[m], methods2[m], cxt)) {
                    return false;
                }
            }
            for (var m in methods2) {
                if (!(methods1[m])) {
                    return false;
                }
            }
            return true;
        };
        if (t1 === t2) {
            return true;
        }
        if (!(t1.tt === t2.tt)) {
            return false;
        }
        switch (t1.tt) {
            case TT.ARRAY:
                return equalTypes(t1.elt, t2.elt, cxt);
            case TT.INSTANCE:
            case TT.CLASS:
                return t1.name === t2.name;
            case TT.INTERFACE:
                if (t1.name === t2.name) {
                    return true;
                }
                if (inNamedTypeRelationRegistry(t1, t2, NameRelation.EQUALITY).fst) {
                    return true;
                }
                if (inContext(cxt, t1, t2, NameRelation.EQUALITY)) {
                    return true;
                }
                var b = equalTypes(t1.structuredType, t2.structuredType, extendContext(cxt, t1, t2, NameRelation.EQUALITY));
                if (b) {
                    addToNamedTypeRelationRegistry(t1, t2, NameRelation.EQUALITY, zero);
                }
                return b;
            case TT.INDEX_MAP:
                return equalTypes(t1.key, t1.key, cxt) && equalTypes(t1.value, t1.value, cxt);
            case TT.JUST_TYPE:
                return equalTypes(t1.base, t2.base, cxt);
            case TT.STRUCTURED_TYPE:
                return eqflds(t1.fieldTable, t2.fieldTable)
                    && eqmethods(t1.methodTable, t2.methodTable);
            default:
                throw new Error("Impossible");
        }
    }
    function primitive(t) {
        var k = t.tt;
        return k === TT.NUMBER || k === TT.STRING || k === TT.BOOLEAN || k === TT.VOID;
    }
    function clone(t) {
        var new_flds = {};
        var new_methods = {};
        var key;
        var keys;
        keys = Object.getOwnPropertyNames(t.fieldTable);
        for (var i = keys.length; i--;) {
            key = keys[i];
            new_flds[key] = t.fieldTable[key];
        }
        keys = Object.getOwnPropertyNames(t.methodTable);
        for (var i = keys.length; i--;) {
            key = keys[i];
            new_methods[key] = t.methodTable[key];
        }
        return StructuredType(new_methods, new_flds);
    }
    function combine(t1, t2) {
        if (t1.tt === TT.ANY) {
            return t2;
        }
        switch (t2.tt) {
            case TT.BOOLEAN:
            case TT.STRING:
            case TT.NUMBER:
            case TT.VOID:
            case TT.INSTANCE:
            case TT.ANY:
            case TT.CLASS:
            case TT.INDEX_MAP:
            case TT.ARRAY:
                return t1;
            case TT.INTERFACE:
                switch (t1.tt) {
                    case TT.INTERFACE:
                        var sub;
                        if (t1.name === t2.name) {
                            return t1;
                        }
                        if (t1.extendsList.indexOf(t2.name) !== -1) {
                            return t1;
                        }
                        if ((sub = inNamedTypeRelationRegistry(t1, t2, NameRelation.SUBTYPE)) && sub.fst) {
                            return t1;
                        }
                        return combine(t1.structuredType, t2.structuredType);
                    case TT.STRUCTURED_TYPE:
                        return combine(t1, t2.structuredType);
                    case TT.CLASS:
                    case TT.INSTANCE:
                    case TT.STRING:
                        return t1;
                    default:
                        throw new Error("Impossible");
                }
                throw new Error("Impossible");
            case TT.STRUCTURED_TYPE:
                switch (t1.tt) {
                    case TT.INSTANCE:
                    case TT.CLASS:
                        return t1;
                    case TT.INTERFACE:
                        return combine(t1.structuredType, t2);
                    case TT.STRUCTURED_TYPE:
                        if (t1.immutable) {
                            t1 = clone(t1);
                        }
                        var f1 = t1.fieldTable;
                        var f2 = t2.fieldTable;
                        for (var f in f2) {
                            f1[f] = f2[f];
                        }
                        var m1 = t1.methodTable;
                        var m2 = t2.methodTable;
                        for (var m in m2) {
                            if (m1[m]) {
                            }
                            else {
                                m1[m] = m2[m];
                            }
                        }
                        return t1;
                    default:
                        throw new Error("Impossible");
                }
            default:
                throw new Error("Impossible");
        }
        throw new Error("Impossible");
    }
    function shallowTagSwap(t, o) {
        return shallowTag(o, t);
    }
    RT.shallowTagSwap = shallowTagSwap;
    function shallowTag(o, t) {
        if (!o || !t) {
            return o;
        }
        var t_o;
        switch (t.tt) {
            case TT.ANY:
            case TT.INSTANCE:
            case TT.NUMBER:
            case TT.STRING:
            case TT.BOOLEAN:
            case TT.VOID:
                return o;
            case TT.ARRAY:
            case TT.INDEX_MAP:
            case TT.CLASS:
                o.__rtti__ = t;
                return o;
            case TT.INTERFACE:
            case TT.STRUCTURED_TYPE:
                t_o = o.__rtti__ || RT.Any;
                if (t_o.tt === TT.INSTANCE || t_o.tt === TT.INTERFACE) {
                    return o;
                }
                o.__rtti__ = combine(t_o, t);
                return o;
            default:
                throw new Error("Impossible");
        }
        throw new Error("Impossible");
    }
    RT.shallowTag = shallowTag;
    function checkInstance(v, to) {
        if (v === undefined || v === null) {
            return { fst: true, snd: v };
        }
        var t_v = v.__rtti__ || RT.Any;
        if (t_v.name == to.name) {
            return { fst: true, snd: v };
        }
        if (v instanceof to.functionObject) {
            return { fst: true, snd: v };
        }
        return { fst: false, snd: undefined };
    }
    RT.checkInstance = checkInstance;
    function checkAndTag(v, from, to) {
        if (v === undefined || v === null) {
            return v;
        }
        var t_v = v.__rtti__ || RT.Any;
        if (from.tt === TT.JUST_TYPE || from.tt === TT.UN) {
            throw new Error("checkAndTag from dot or un");
        }
        switch (to.tt) {
            case TT.BOOLEAN:
            case TT.NUMBER:
            case TT.STRING:
            case TT.VOID:
                if (t_v !== to) {
                    throw new Error("checkAndTag for primitive types mismatch: " + prettyprint_t(t_v) + " !== " + prettyprint_t(to));
                }
                return v;
            case TT.ANY:
                if (from.tt === TT.JUST_TYPE) {
                    throw new Error("checkAndTag to any undotted from check failure: " + prettyprint_t(from));
                }
                return v;
            case TT.INSTANCE:
                if (t_v.name === to.name) {
                    return v;
                }
                if (!(v instanceof to.functionObject)) {
                    throw new Error("checkAndTag to instance type " + to.name + " instanceof check failed, it's a " + prettyprint_t(t_v));
                }
                return v;
            case TT.ARRAY:
            case TT.CLASS:
            case TT.INDEX_MAP:
                t_v = t_v === RT.Any ? from : t_v;
                if (!(equalTypes(t_v, to, {}))) {
                    throw new Error("checkAndTag to fixed type failure: " + prettyprint_t(combine(t_v, from)) + " </: " + prettyprint_t(to));
                }
                return v;
            case TT.INTERFACE:
                switch (t_v.tt) {
                    case TT.INSTANCE:
                        if (!(isZeroSubtype(t_v, to))) {
                            throw new Error("checkAndTag to interface for a class instance must be subtype: " + prettyprint_t(t_v) + " </: " + prettyprint_t(to));
                        }
                        return v;
                    case TT.INTERFACE:
                        var sub;
                        if (t_v.name === to.name) {
                            return v;
                        }
                        if (t_v.extendsList.indexOf(to.name) !== -1) {
                            return v;
                        }
                        if ((sub = inNamedTypeRelationRegistry(t_v, to, NameRelation.SUBTYPE)) && sub.fst) {
                            return v;
                        }
                        return checkAndTag(v, from, to.structuredType);
                    default:
                        return checkAndTag(v, from, to.structuredType);
                }
                throw new Error("Impossible");
            case TT.STRUCTURED_TYPE:
                var curr = t_v.tt === TT.STRUCTURED_TYPE ? combine(clone(t_v), from) : combine(t_v, from);
                var sub = subtype(curr, to, {});
                if (sub.fst) {
                    return shallowTag(v, sub.snd);
                }
                if ((t_v.tt === TT.INSTANCE) || (t_v.tt === TT.CLASS)) {
                    throw new Error("checkAndTag to structured type from a fixed type failure: " + prettyprint_t(t_v) + " being tagged to: " + prettyprint_t(to));
                }
                var to_flds = to.fieldTable;
                var overlapping_flds = {};
                var new_flds = {};
                for (var f in to_flds) {
                    if (curr.fieldTable[f]) {
                        if (!(equalTypes(curr.fieldTable[f], to_flds[f], {}))) {
                            throw new Error("checkAndTag to structured type field overlapping failure: " + prettyprint_t(curr.fieldTable[f]) + " != " +
                                prettyprint_t(to_flds[f]));
                        }
                        overlapping_flds[f] = to_flds[f];
                    }
                    else {
                        new_flds[f] = to_flds[f];
                    }
                }
                sub = subtype(curr, StructuredType(to.methodTable, overlapping_flds), {});
                if (!(sub.fst)) {
                    throw new Error("checkAndTag to structured type subtyping from combine failure: " + prettyprint_t(curr) + " </: " +
                        StructuredType(to.methodTable, overlapping_flds));
                }
                shallowTag(v, sub.snd);
                v.__rtti__ = combine((v.__rtti__ || RT.Any), StructuredType({}, new_flds));
                for (f in new_flds) {
                    checkAndTag(v[f], RT.Any, new_flds[f]);
                }
                return v;
            case TT.JUST_TYPE:
                return checkAndTag(v, from, to.base);
            default:
                throw new Error("Impossible");
        }
    }
    RT.checkAndTag = checkAndTag;
    function getFieldTypeOptim(t, o, f) {
        if (t) {
            if (t.tt === undefined || t.tt === TT.JUST_TYPE) {
                throw new Error("readFieldOptim reading a method or field with dot type: " + prettyprint_t(t));
            }
            return t;
        }
        else {
            t = o.__rtti__;
            if (t.tt === TT.INDEX_MAP) {
                if (t.key.tt === TT.NUMBER) {
                    throw new Error("readFieldOptim index map index is number");
                }
                else {
                    t = t.value;
                    if (t.tt === TT.JUST_TYPE) {
                        throw new Error("readFieldOptim index map value type dotted");
                    }
                    else {
                        return t;
                    }
                }
            }
            else {
                return RT.Any;
            }
        }
    }
    RT.getFieldTypeOptim = getFieldTypeOptim;
    function readField(o, from, f) {
        if (!o) {
            throw new Error("readField reading from undefined/null");
        }
        var t_o = o.__rtti__ || RT.Any;
        var tt = t_o.tt;
        var t = tt === TT.ANY ? from : t_o;
        var t1;
        var fname = f + "";
        switch (t.tt) {
            case TT.INTERFACE:
            case TT.INSTANCE:
            case TT.CLASS:
                t1 = t.fieldTable[fname];
                if (t1 === undefined) {
                    if (t.methodTable[fname] || RT.objectMethods[fname]) {
                        throw new Error("readField reading method (instance and interface)");
                    }
                    t1 = RT.Any;
                }
                else if (t1.tt === TT.JUST_TYPE || t1.tt === TT.UN) {
                    throw new Error("readField from interface / instance reading dot type/un field");
                }
                return shallowTag(o[fname], t1);
            case TT.STRING:
                if (fname === "length") {
                    return o.length;
                }
                throw new Error("reading a field other than length from string: " + fname);
            case TT.ARRAY:
                if (fname === "length") {
                    return o.length;
                }
                t1 = t.elt;
                if (t1.tt === TT.JUST_TYPE || t1.tt === TT.UN) {
                    throw new Error("array readField elt type is dotted/un: " + prettyprint_t(t1));
                }
                return shallowTag(o[checkAndTag(f, RT.Any, RT.Num)], t1);
            case TT.STRUCTURED_TYPE:
                t1 = t.fieldTable[fname] || from.fieldTable[fname];
                if (t1 === undefined) {
                    if (t.methodTable[fname] || from.methodTable[fname] || RT.objectMethods[fname]) {
                        throw new Error("readField struct types reading method");
                    }
                    t1 = RT.Any;
                }
                else if (t1.tt === TT.JUST_TYPE || t1.tt === TT.UN) {
                    throw new Error("readField from struct reading dot/un type field");
                }
                return shallowTag(o[fname], t1);
            case TT.ANY:
                return o[fname];
            case TT.INDEX_MAP:
                tt = t.key.tt;
                t1 = t.value;
                if (t1.tt === TT.JUST_TYPE || t1.tt === TT.UN) {
                    throw new Error("indexMap readField value type not a subtype of any: " + prettyprint_t(t1));
                }
                if (tt === TT.NUMBER) {
                    return shallowTag(o[checkAndTag(f, RT.Any, RT.Num)], t1);
                }
                else {
                    if (RT.objectMethods[fname]) {
                        throw new Error("readField for indexMap reading Object method: " + fname);
                    }
                    return shallowTag(o[fname], t1);
                }
        }
        throw new Error("Impossible");
    }
    RT.readField = readField;
    function writeField(o, from, f, v, tv) {
        if (!o) {
            throw new Error("writeField writing to undefined/null");
        }
        var t_o = o.__rtti__ || RT.Any;
        var tt = t_o.tt;
        var t = tt === TT.ANY ? from : t_o;
        var t1;
        var fname = f + "";
        switch (t.tt) {
            case TT.INTERFACE:
            case TT.INSTANCE:
            case TT.CLASS:
                t1 = t.fieldTable[fname];
                if (t1 === undefined) {
                    if (t.methodTable[fname] || RT.objectMethods[fname]) {
                        throw new Error("writeField writing method (instance and interface)");
                    }
                    t1 = RT.Any;
                }
                else if (t1.tt === TT.JUST_TYPE || t1.tt === TT.UN) {
                    throw new Error("readField from interface / instance reading dot/un type field");
                }
                else {
                    v = checkAndTag(v, tv, t1);
                }
                return (o[fname] = v);
            case TT.ARRAY:
                if (fname === "length") {
                    return (o.length = v);
                }
                if (f === undefined || f === null || f.__rtti__ !== RT.Num) {
                    throw new Error("array writeField f can only be Num");
                }
                t1 = t.elt;
                if (t1.tt === TT.JUST_TYPE || t1.tt === TT.UN) {
                    throw new Error("array writeField elt type is dotted/un: " + prettyprint_t(t1));
                }
                else {
                    v = checkAndTag(v, tv, t1);
                }
                return (o[f] = v);
            case TT.STRUCTURED_TYPE:
                t1 = t.fieldTable[fname] || from.fieldTable[fname];
                if (t1 === undefined) {
                    if (t.methodTable[fname] || from.methodTable[fname] || RT.objectMethods[fname]) {
                        throw new Error("writeField struct types writing method");
                    }
                    t1 = RT.Any;
                }
                else if (t1.tt === TT.JUST_TYPE || t1.tt === TT.UN) {
                    throw new Error("writeField from struct writing dot/un type field");
                }
                else {
                    v = checkAndTag(v, tv, t1);
                }
                return (o[fname] = v);
            case TT.ANY:
                return (o[fname] = v);
            case TT.INDEX_MAP:
                tt = t.key.tt;
                t1 = t.value;
                if (t1.tt === TT.JUST_TYPE || t1.tt === TT.UN) {
                    throw new Error("indexMap writeField value type is dotted/un: " + prettyprint_t(t1));
                }
                else {
                    v = checkAndTag(v, tv, t1);
                }
                if (tt === TT.NUMBER) {
                    if (f === undefined || f === null || f.__rtti__ !== RT.Num) {
                        throw new Error("Indexmap writeField number index error");
                    }
                    return (o[f] = v);
                }
                else {
                    if (RT.objectMethods[fname]) {
                        throw new Error("writeField for indexMap writing Object method: " + fname);
                    }
                    return (o[fname] = v);
                }
        }
        throw new Error("Impossible");
    }
    RT.writeField = writeField;
    function resolveMethod(o, from, mname) {
        if (!o && (o === null || o === undefined)) {
            throw new Error("resolveMethod for undefined/null");
        }
        var t_o = o.__rtti__ || RT.Any;
        return t_o.methodTable[mname] || RT.objectMethods[mname] || from.methodTable[mname];
    }
    function callMethod(o, from, m, args, argTypes) {
        if (!o && (o === null || o === undefined)) {
            throw new Error("callMethod calling from undefined/null");
        }
        var t_o = o.__rtti__ || RT.Any;
        var t = from.tt === TT.ANY ? t_o : from;
        var mname = m + "";
        var t1 = resolveMethod(o, from, mname);
        if (t1 === undefined) {
            return callFunction(readField(o, from, m), RT.Any, args, argTypes);
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("callMethod return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs === undefined && args.length !== t1.args.length) {
            throw new Error("callMethod did not provide all mandatory arguments");
        }
        else if (args.length < t1.mandatoryArgs) {
            throw new Error("callMethod did not provide all mandatory arguments(2)");
        }
        var i;
        var length = t1.args.length;
        for (i = 0; i < length; ++i) {
            checkAndTag(args[i], argTypes[i], t1.args[i]);
        }
        if (args.length > i) {
            if (t1.varargs === undefined) {
                throw new Error("callMethod extra arguments provided to a non variadic method call");
            }
            for (; i < args.length; ++i) {
                checkAndTag(args[i], argTypes[i], t1.varargs);
            }
        }
        switch (args.length) {
            case 0:
                return shallowTag(o[mname](), t1.result);
            case 1:
                return shallowTag(o[mname](args[0]), t1.result);
            case 2:
                return shallowTag(o[mname](args[0], args[1]), t1.result);
            case 3:
                return shallowTag(o[mname](args[0], args[1], args[2]), t1.result);
            case 4:
                return shallowTag(o[mname](args[0], args[1], args[2], args[3]), t1.result);
            case 5:
                return shallowTag(o[mname](args[0], args[1], args[2], args[3], args[4]), t1.result);
            case 6:
                return shallowTag(o[mname](args[0], args[1], args[2], args[3], args[4], args[5]), t1.result);
            case 7:
                return shallowTag(o[mname](args[0], args[1], args[2], args[3], args[4], args[5], args[6]), t1.result);
            case 8:
                return shallowTag(o[mname](args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]), t1.result);
            case 9:
                return shallowTag(o[mname](args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]), t1.result);
            case 10:
                return shallowTag(o[mname](args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]), t1.result);
            default:
                throw new Error("callMethod only defined for upto 10 arguments");
        }
        throw new Error("Impossible");
    }
    RT.callMethod = callMethod;
    function checkMethodArgs(o, from, m, args, argTypes) {
        if (!o && (o === null || o === undefined)) {
            throw new Error("checkMethodArgs calling from undefined/null");
        }
        var t1 = resolveMethod(o, from, m);
        if (t1 === undefined) {
            return checkFunctionArgs(readField(o, from, m), args, argTypes);
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("checkMethodArgs return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs === undefined && args.length !== t1.args.length) {
            throw new Error("checkMethodArgs did not provide all mandatory arguments");
        }
        else if (args.length < t1.mandatoryArgs) {
            throw new Error("checkMethodArgs did not provide all mandatory arguments(2)");
        }
        var i;
        var length = t1.args.length;
        for (i = 0; i < length; ++i) {
            checkAndTag(args[i], argTypes[i], t1.args[i]);
        }
        if (args.length > i) {
            if (t1.varargs === undefined) {
                throw new Error("checkMethodArgs extra arguments provided to a non variadic method call");
            }
            for (; i < args.length; ++i) {
                checkAndTag(args[i], argTypes[i], t1.varargs);
            }
        }
        return t1.result;
    }
    RT.checkMethodArgs = checkMethodArgs;
    function checkMethodArgs0(o, from, m) {
        var t1 = resolveMethod(o, from, m);
        if (t1 === undefined) {
            return checkFunctionArgs0(readField(o, from, m));
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("checkMethodArgs0 return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs) {
            throw new Error("checkMethodArgs0 did not provide all mandatory arguments");
        }
        return t1.result;
    }
    RT.checkMethodArgs0 = checkMethodArgs0;
    function checkMethodArgs1(o, from, m, arg1, argType1) {
        var t1 = resolveMethod(o, from, m);
        if (t1 === undefined) {
            return checkFunctionArgs1(readField(o, from, m), arg1, argType1);
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("checkMethodArgs1 return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs > 1) {
            throw new Error("checkMethodArgs1 did not provide all mandatory arguments");
        }
        if (t1.args.length > 0) {
            checkAndTag(arg1, argType1, t1.args[0]);
        }
        else {
            var varargs_t = t1.varargs;
            if (varargs_t === undefined) {
                throw new Error("checkMethodArgs1 extra arguments provided to a non variadic method call");
            }
            checkAndTag(arg1, argType1, varargs_t);
        }
        return t1.result;
    }
    RT.checkMethodArgs1 = checkMethodArgs1;
    function checkMethodArgs2(o, from, m, arg1, arg2, argType1, argType2) {
        var t1 = resolveMethod(o, from, m);
        if (t1 === undefined) {
            return checkFunctionArgs2(readField(o, from, m), arg1, arg2, argType1, argType2);
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("checkMethodArgs2 return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs > 2) {
            throw new Error("checkMethodArgs2 did not provide all mandatory arguments");
        }
        var varargs_t;
        switch (t1.args.length) {
            case 0:
                varargs_t = t1.varargs;
                if (varargs_t === undefined) {
                    throw new Error("checkMethodArgs2 extra arguments provided to a non variadic method call");
                }
                checkAndTag(arg1, argType1, varargs_t);
                checkAndTag(arg2, argType2, varargs_t);
                break;
            case 1:
                varargs_t = t1.varargs;
                if (varargs_t === undefined) {
                    throw new Error("checkMethodArgs2 extra arguments provided to a non variadic method call");
                }
                checkAndTag(arg1, argType1, t1.args[0]);
                checkAndTag(arg2, argType2, varargs_t);
                break;
            case 2:
                checkAndTag(arg1, argType1, t1.args[0]);
                checkAndTag(arg2, argType2, t1.args[1]);
                break;
            default:
                throw new Error("Impossible");
        }
        return t1.result;
    }
    RT.checkMethodArgs2 = checkMethodArgs2;
    function checkMethodArgs3(o, from, m, arg1, arg2, arg3, argType1, argType2, argType3) {
        return checkMethodArgs(o, from, m, [arg1, arg2, arg3], [argType1, argType2, argType3]);
    }
    RT.checkMethodArgs3 = checkMethodArgs3;
    function checkMethodArgs4(o, from, m, arg1, arg2, arg3, arg4, argType1, argType2, argType3, argType4) {
        return checkMethodArgs(o, from, m, [arg1, arg2, arg3, arg4], [argType1, argType2, argType3, argType4]);
    }
    RT.checkMethodArgs4 = checkMethodArgs4;
    function checkMethodArgs5(o, from, m, arg1, arg2, arg3, arg4, arg5, argType1, argType2, argType3, argType4, argType5) {
        return checkMethodArgs(o, from, m, [arg1, arg2, arg3, arg4, arg5], [argType1, argType2, argType3, argType4, argType5]);
    }
    RT.checkMethodArgs5 = checkMethodArgs5;
    function checkMethodArgs6(o, from, m, arg1, arg2, arg3, arg4, arg5, arg6, argType1, argType2, argType3, argType4, argType5, argType6) {
        return checkMethodArgs(o, from, m, [arg1, arg2, arg3, arg4, arg5, arg6], [argType1, argType2, argType3, argType4, argType5, argType6]);
    }
    RT.checkMethodArgs6 = checkMethodArgs6;
    function checkFunctionArgs(o, args, argTypes) {
        if (!o && (o === null || o === undefined)) {
            throw new Error("checkFunctionArgs calling from undefined/null");
        }
        var t_o = o.__rtti__ || RT.Any;
        var t1 = t_o.methodTable["<call>"];
        if (t1 === undefined) {
            throw new Error("checkFunctionArgs <call> method not found");
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("checkFunctionArgs return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs === undefined && args.length !== t1.args.length) {
            throw new Error("checkFunctionArgs did not provide all mandatory arguments");
        }
        else if (args.length < t1.mandatoryArgs) {
            throw new Error("checkFunctionArgs did not provide all mandatory arguments(2)");
        }
        var i;
        var length = t1.args.length;
        for (i = 0; i < length; ++i) {
            checkAndTag(args[i], argTypes[i], t1.args[i]);
        }
        if (args.length > i) {
            if (t1.varargs === undefined) {
                throw new Error("checkFunctionArgs extra arguments provided to a non variadic method call");
            }
            for (; i < args.length; ++i) {
                checkAndTag(args[i], argTypes[i], t1.varargs);
            }
        }
        return t1.result;
    }
    RT.checkFunctionArgs = checkFunctionArgs;
    function checkFunctionArgs0(o) {
        return checkFunctionArgs(o, [], []);
    }
    RT.checkFunctionArgs0 = checkFunctionArgs0;
    function checkFunctionArgs1(o, arg1, argType1) {
        return checkFunctionArgs(o, [arg1], [argType1]);
    }
    RT.checkFunctionArgs1 = checkFunctionArgs1;
    function checkFunctionArgs2(o, arg1, arg2, argType1, argType2) {
        return checkFunctionArgs(o, [arg1, arg2], [argType1, argType2]);
    }
    RT.checkFunctionArgs2 = checkFunctionArgs2;
    function checkFunctionArgs3(o, arg1, arg2, arg3, argType1, argType2, argType3) {
        return checkFunctionArgs(o, [arg1, arg2, arg3], [argType1, argType2, argType3]);
    }
    RT.checkFunctionArgs3 = checkFunctionArgs3;
    function checkFunctionArgs4(o, arg1, arg2, arg3, arg4, argType1, argType2, argType3, argType4) {
        return checkFunctionArgs(o, [arg1, arg2, arg3, arg4], [argType1, argType2, argType3, argType4]);
    }
    RT.checkFunctionArgs4 = checkFunctionArgs4;
    function checkFunctionArgs5(o, arg1, arg2, arg3, arg4, arg5, argType1, argType2, argType3, argType4, argType5) {
        return checkFunctionArgs(o, [arg1, arg2, arg3, arg4, arg5], [argType1, argType2, argType3, argType4, argType5]);
    }
    RT.checkFunctionArgs5 = checkFunctionArgs5;
    function checkFunctionArgs6(o, arg1, arg2, arg3, arg4, arg5, arg6, argType1, argType2, argType3, argType4, argType5, argType6) {
        return checkFunctionArgs(o, [arg1, arg2, arg3, arg4, arg5, arg6], [argType1, argType2, argType3, argType4, argType5, argType6]);
    }
    RT.checkFunctionArgs6 = checkFunctionArgs6;
    function callMethod0(o, from, m) {
        var mname = m + "";
        var t1 = resolveMethod(o, from, mname);
        if (t1 === undefined) {
            return callFunction0(readField(o, from, m), RT.Any);
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("callMethod0 return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs) {
            throw new Error("callMethod0 did not provide all mandatory arguments");
        }
        return shallowTag(o[mname](), t1.result);
    }
    RT.callMethod0 = callMethod0;
    function callMethod1(o, from, m, arg1, argType1) {
        var mname = m + "";
        var t1 = resolveMethod(o, from, mname);
        if (t1 === undefined) {
            return callFunction1(readField(o, from, m), RT.Any, arg1, argType1);
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("callMethod1 return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs > 1) {
            throw new Error("callMethod1 did not provide all mandatory arguments");
        }
        if (t1.args.length > 0) {
            checkAndTag(arg1, argType1, t1.args[0]);
        }
        else {
            var varargs_t = t1.varargs;
            if (varargs_t === undefined) {
                throw new Error("callMethod1 extra arguments provided to a non variadic method call");
            }
            checkAndTag(arg1, argType1, varargs_t);
        }
        return shallowTag(o[mname](arg1), t1.result);
    }
    RT.callMethod1 = callMethod1;
    function callMethod2(o, from, m, arg1, arg2, argType1, argType2) {
        var mname = m + "";
        var t1 = resolveMethod(o, from, mname);
        if (t1 === undefined) {
            return callFunction2(readField(o, from, m), RT.Any, arg1, arg2, argType1, argType2);
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("callMethod2 return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs > 2) {
            throw new Error("callMethod2 did not provide all mandatory arguments");
        }
        var varargs_t;
        switch (t1.args.length) {
            case 0:
                varargs_t = t1.varargs;
                if (varargs_t === undefined) {
                    throw new Error("callMethod2 extra arguments provided to a non variadic method call");
                }
                checkAndTag(arg1, argType1, varargs_t);
                checkAndTag(arg2, argType2, varargs_t);
                break;
            case 1:
                varargs_t = t1.varargs;
                if (varargs_t === undefined) {
                    throw new Error("callMethod2 extra arguments provided to a non variadic method call");
                }
                checkAndTag(arg1, argType1, t1.args[0]);
                checkAndTag(arg2, argType2, varargs_t);
                break;
            case 2:
                checkAndTag(arg1, argType1, t1.args[0]);
                checkAndTag(arg2, argType2, t1.args[1]);
                break;
            default:
                throw new Error("Impossible");
        }
        return shallowTag(o[mname](arg1, arg2), t1.result);
    }
    RT.callMethod2 = callMethod2;
    function callMethod3(o, from, m, arg1, arg2, arg3, argType1, argType2, argType3) {
        var mname = m + "";
        var t1 = resolveMethod(o, from, mname);
        if (t1 === undefined) {
            return callFunction3(readField(o, from, m), RT.Any, arg1, arg2, arg3, argType1, argType2, argType3);
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("callMethod3 return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs > 3) {
            throw new Error("callMethod3 did not provide all mandatory arguments");
        }
        var varargs_t;
        switch (t1.args.length) {
            case 0:
                varargs_t = t1.varargs;
                if (varargs_t === undefined) {
                    throw new Error("callMethod3 extra arguments provided to a non variadic method call");
                }
                checkAndTag(arg1, argType1, varargs_t);
                checkAndTag(arg2, argType2, varargs_t);
                checkAndTag(arg3, argType3, varargs_t);
                break;
            case 1:
                varargs_t = t1.varargs;
                if (varargs_t === undefined) {
                    throw new Error("callMethod3 extra arguments provided to a non variadic method call");
                }
                checkAndTag(arg1, argType1, t1.args[0]);
                checkAndTag(arg2, argType2, varargs_t);
                checkAndTag(arg3, argType3, varargs_t);
                break;
            case 2:
                varargs_t = t1.varargs;
                if (varargs_t === undefined) {
                    throw new Error("callMethod3 extra arguments provided to a non variadic method call");
                }
                checkAndTag(arg1, argType1, t1.args[0]);
                checkAndTag(arg2, argType2, t1.args[1]);
                checkAndTag(arg3, argType3, varargs_t);
                break;
            case 3:
                checkAndTag(arg1, argType1, t1.args[0]);
                checkAndTag(arg2, argType2, t1.args[1]);
                checkAndTag(arg3, argType3, t1.args[2]);
                break;
            default:
                throw new Error("Impossible");
        }
        return shallowTag(o[mname](arg1, arg2, arg3), t1.result);
    }
    RT.callMethod3 = callMethod3;
    function callMethod4(o, from, m, arg1, arg2, arg3, arg4, argType1, argType2, argType3, argType4) {
        return callMethod(o, from, m, [arg1, arg2, arg3, arg4], [argType1, argType2, argType3, argType4]);
    }
    RT.callMethod4 = callMethod4;
    function callMethod5(o, from, m, arg1, arg2, arg3, arg4, arg5, argType1, argType2, argType3, argType4, argType5) {
        return callMethod(o, from, m, [arg1, arg2, arg3, arg4, arg5], [argType1, argType2, argType3, argType4, argType5]);
    }
    RT.callMethod5 = callMethod5;
    function callMethod6(o, from, m, arg1, arg2, arg3, arg4, arg5, arg6, argType1, argType2, argType3, argType4, argType5, argType6) {
        return callMethod(o, from, m, [arg1, arg2, arg3, arg4, arg5, arg6], [argType1, argType2, argType3, argType4, argType5, argType6]);
    }
    RT.callMethod6 = callMethod6;
    function callFunction(o, t_o, args, t_args) {
        if (!o && (o === null || o === undefined)) {
            throw new Error("callFunction calling from undefined/null");
        }
        var t1 = (o.__rtti__ && o.__rtti__.methodTable["<call>"]) || t_o.methodTable["<call>"];
        if (t1 === undefined) {
            throw new Error("callFunction <call> method not found");
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("callFunction return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs === undefined && args.length !== t1.args.length) {
            throw new Error("callFunction did not provide all mandatory arguments");
        }
        else if (args.length < t1.mandatoryArgs) {
            throw new Error("callFunction did not provide all mandatory arguments(2)");
        }
        var i;
        var length = t1.args.length;
        for (i = 0; i < length; ++i) {
            checkAndTag(args[i], t_args[i], t1.args[i]);
        }
        if (args.length > i) {
            if (t1.varargs === undefined) {
                throw new Error("callFunction extra arguments provided to a non variadic method call");
            }
            for (; i < args.length; ++i) {
                checkAndTag(args[i], t_args[i], t1.varargs);
            }
        }
        if (args.length == 0) {
            return shallowTag(o(), t1.result);
        }
        else if (args.length == 1) {
            return shallowTag(o(args[0]), t1.result);
        }
        else if (args.length == 2) {
            return shallowTag(o(args[0], args[1]), t1.result);
        }
        else if (args.length == 3) {
            return shallowTag(o(args[0], args[1], args[2]), t1.result);
        }
        else if (args.length == 4) {
            return shallowTag(o(args[0], args[1], args[2], args[3]), t1.result);
        }
        else if (args.length == 5) {
            return shallowTag(o(args[0], args[1], args[2], args[3], args[4]), t1.result);
        }
        else if (args.length == 6) {
            return shallowTag(o(args[0], args[1], args[2], args[3], args[4], args[5]), t1.result);
        }
        else if (args.length == 7) {
            return shallowTag(o(args[0], args[1], args[2], args[3], args[4], args[5], args[6]), t1.result);
        }
        else if (args.length == 8) {
            return shallowTag(o(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]), t1.result);
        }
        else if (args.length == 9) {
            return shallowTag(o(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]), t1.result);
        }
        else if (args.length == 10) {
            return shallowTag(o(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]), t1.result);
        }
        else {
            throw new Error("callFunction only defined for upto 10 arguments");
        }
        throw new Error("Impossible");
    }
    RT.callFunction = callFunction;
    function callFunction0(o, t_o) {
        if (!o && (o === null || o === undefined)) {
            throw new Error("callFunction0 calling from undefined/null");
        }
        var t1 = (o.__rtti__ && o.__rtti__.methodTable["<call>"]) || t_o.methodTable["<call>"];
        if (t1 === undefined) {
            throw new Error("callFunction0 <call> method not found");
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("callFunction0 return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs) {
            throw new Error("callFunction0 did not provide all mandatory arguments");
        }
        return shallowTag(o(), t1.result);
    }
    RT.callFunction0 = callFunction0;
    function callFunction1(o, t_o, arg1, argType1) {
        if (!o && (o === null || o === undefined)) {
            throw new Error("callFunction0 calling from undefined/null");
        }
        var t1 = (o.__rtti__ && o.__rtti__.methodTable["<call>"]) || t_o.methodTable["<call>"];
        if (t1 === undefined) {
            throw new Error("callFunction1 <call> method not found");
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("callFunction1 return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs > 1) {
            throw new Error("callFunction1 did not provide all mandatory arguments");
        }
        if (t1.args.length > 0) {
            checkAndTag(arg1, argType1, t1.args[0]);
        }
        else {
            var varargs_t = t1.varargs;
            if (varargs_t === undefined) {
                throw new Error("callFunction1 extra arguments provided to a non variadic method call");
            }
            checkAndTag(arg1, argType1, varargs_t);
        }
        return shallowTag(o(arg1), t1.result);
    }
    RT.callFunction1 = callFunction1;
    function callFunction2(o, t_o, arg1, arg2, argType1, argType2) {
        if (!o && (o === null || o === undefined)) {
            throw new Error("callFunction0 calling from undefined/null");
        }
        var t1 = (o.__rtti__ && o.__rtti__.methodTable["<call>"]) || t_o.methodTable["<call>"];
        if (t1 === undefined) {
            throw new Error("callFunction1 <call> method not found");
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("callFunction1 return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs > 2) {
            throw new Error("callMethod2 did not provide all mandatory arguments");
        }
        var varargs_t;
        switch (t1.args.length) {
            case 0:
                varargs_t = t1.varargs;
                if (varargs_t === undefined) {
                    throw new Error("callFunction2 extra arguments provided to a non variadic method call");
                }
                checkAndTag(arg1, argType1, varargs_t);
                checkAndTag(arg2, argType2, varargs_t);
                break;
            case 1:
                varargs_t = t1.varargs;
                if (varargs_t === undefined) {
                    throw new Error("callFunction2 extra arguments provided to a non variadic method call");
                }
                checkAndTag(arg1, argType1, t1.args[0]);
                checkAndTag(arg2, argType2, varargs_t);
                break;
            case 2:
                checkAndTag(arg1, argType1, t1.args[0]);
                checkAndTag(arg2, argType2, t1.args[1]);
                break;
            default:
                throw new Error("Impossible");
        }
        return shallowTag(o(arg1, arg2), t1.result);
    }
    RT.callFunction2 = callFunction2;
    function callFunction3(o, t_o, arg1, arg2, arg3, argType1, argType2, argType3) {
        if (!o && (o === null || o === undefined)) {
            throw new Error("callFunction0 calling from undefined/null");
        }
        var t1 = (o.__rtti__ && o.__rtti__.methodTable["<call>"]) || t_o.methodTable["<call>"];
        if (t1 === undefined) {
            throw new Error("callFunction1 <call> method not found");
        }
        if (t1.result.tt === TT.JUST_TYPE || t1.result.tt === TT.UN) {
            throw new Error("callFunction1 return type is not a subtype of any: " + prettyprint_t(t1.result));
        }
        if (t1.mandatoryArgs > 3) {
            throw new Error("callMethod3 did not provide all mandatory arguments");
        }
        var varargs_t;
        switch (t1.args.length) {
            case 0:
                varargs_t = t1.varargs;
                if (varargs_t === undefined) {
                    throw new Error("callMethod3 extra arguments provided to a non variadic method call");
                }
                checkAndTag(arg1, argType1, varargs_t);
                checkAndTag(arg2, argType2, varargs_t);
                checkAndTag(arg3, argType3, varargs_t);
                break;
            case 1:
                varargs_t = t1.varargs;
                if (varargs_t === undefined) {
                    throw new Error("callMethod3 extra arguments provided to a non variadic method call");
                }
                checkAndTag(arg1, argType1, t1.args[0]);
                checkAndTag(arg2, argType2, varargs_t);
                checkAndTag(arg3, argType3, varargs_t);
                break;
            case 2:
                varargs_t = t1.varargs;
                if (varargs_t === undefined) {
                    throw new Error("callMethod3 extra arguments provided to a non variadic method call");
                }
                checkAndTag(arg1, argType1, t1.args[0]);
                checkAndTag(arg2, argType2, t1.args[1]);
                checkAndTag(arg3, argType3, varargs_t);
                break;
            case 3:
                checkAndTag(arg1, argType1, t1.args[0]);
                checkAndTag(arg2, argType2, t1.args[1]);
                checkAndTag(arg3, argType3, t1.args[2]);
                break;
            default:
                throw new Error("Impossible");
        }
        return shallowTag(o(arg1, arg2, arg3), t1.result);
    }
    RT.callFunction3 = callFunction3;
    function callFunction4(o, from, arg1, arg2, arg3, arg4, argType1, argType2, argType3, argType4) {
        return callFunction(o, from, [arg1, arg2, arg3, arg4], [argType1, argType2, argType3, argType4]);
    }
    RT.callFunction4 = callFunction4;
    function callFunction5(o, from, arg1, arg2, arg3, arg4, arg5, argType1, argType2, argType3, argType4, argType5) {
        return callFunction(o, from, [arg1, arg2, arg3, arg4, arg5], [argType1, argType2, argType3, argType4, argType5]);
    }
    RT.callFunction5 = callFunction5;
    function callFunction6(o, from, arg1, arg2, arg3, arg4, arg5, arg6, argType1, argType2, argType3, argType4, argType5, argType6) {
        return callFunction(o, from, [arg1, arg2, arg3, arg4, arg5, arg6], [argType1, argType2, argType3, argType4, argType5, argType6]);
    }
    RT.callFunction6 = callFunction6;
    function assignmentWithUnaryOp(op, o, from, f) {
        if (!o) {
            throw new Error("assignmentWithUnaryOp on null/undefined/0");
        }
        var t_o = o.__rtti__ || RT.Any;
        var tt = t_o.tt;
        var t = tt === TT.ANY ? from : t_o;
        var t1;
        var fname = f + "";
        switch (t.tt) {
            case TT.ARRAY:
                if (fname === "length") {
                    t1 = RT.Num;
                }
                else {
                    t1 = t.elt;
                    fname = checkAndTag(f, RT.Any, RT.Num);
                }
                break;
            case TT.INSTANCE:
            case TT.INTERFACE:
            case TT.CLASS:
                t1 = t[fname];
                if (t1 === undefined) {
                    if (t.methodTable[fname] || RT.objectMethods[fname]) {
                        throw new Error("assignmentWithUnaryOp field is a method");
                    }
                    t1 = RT.Any;
                }
                break;
            case TT.STRUCTURED_TYPE:
                t1 = t.fieldTable[fname] || from.fieldTable[fname];
                if (t1 === undefined) {
                    if (t.methodTable[fname] || from.methodTable[fname] || RT.objectMethods[fname]) {
                        throw new Error("assignmentWithUnaryOp to structuredtype field is a method");
                    }
                    t1 = RT.Any;
                }
                break;
            case TT.INDEX_MAP:
                tt = t.key.tt;
                t1 = t.value;
                if (tt === TT.NUMBER) {
                    fname = checkAndTag(f, RT.Any, RT.Num);
                }
                else {
                    if (RT.objectMethods[fname]) {
                        throw new Error("assignmentWithUnaryOp to indexMap, field is a method");
                    }
                }
                break;
            default:
                throw new Error("Impossible");
        }
        if (!(t1 === RT.Num || t1 === RT.Any)) {
            throw new Error("assignmentWithUnaryOp field type is non-any and non-number");
        }
        switch (op) {
            case "PreIncrementExpression":
                return ++o[fname];
            case "PreDecrementExpression":
                return --o[fname];
            case "PostIncrementExpression":
                return o[fname]++;
            case "PostDecrementExpression":
                return o[fname]--;
            default:
                throw new Error("Impossible");
        }
    }
    RT.assignmentWithUnaryOp = assignmentWithUnaryOp;
    function assignmentWithOp(op, o, from, f, v) {
        if (!o) {
            throw new Error("assignmentWithUnaryOp on null/undefined/0");
        }
        var t_o = o.__rtti__ || RT.Any;
        var tt = t_o.tt;
        var t = tt === TT.ANY ? from : t_o;
        var t1;
        var fname = f + "";
        switch (t.tt) {
            case TT.ARRAY:
                if (fname === "length") {
                    t1 = RT.Num;
                }
                else {
                    t1 = t.elt;
                    fname = checkAndTag(f, RT.Any, RT.Num);
                }
                break;
            case TT.INSTANCE:
            case TT.INTERFACE:
            case TT.CLASS:
                t1 = t[fname];
                if (t1 === undefined) {
                    if (t.methodTable[fname] || RT.objectMethods[fname]) {
                        throw new Error("assignmentWithUnaryOp field is a method");
                    }
                    t1 = RT.Any;
                }
                break;
            case TT.STRUCTURED_TYPE:
                t1 = t.fieldTable[fname] || from.fieldTable[fname];
                if (t1 === undefined) {
                    if (t.methodTable[fname] || from.methodTable[fname] || RT.objectMethods[fname]) {
                        throw new Error("assignmentWithUnaryOp to structuredtype field is a method");
                    }
                    t1 = RT.Any;
                }
                break;
            case TT.INDEX_MAP:
                tt = t.key.tt;
                t1 = t.value;
                if (tt === TT.NUMBER) {
                    fname = checkAndTag(f, RT.Any, RT.Num);
                }
                else {
                    if (RT.objectMethods[fname]) {
                        throw new Error("assignmentWithUnaryOp to indexMap, field is a method");
                    }
                }
                break;
            default:
                throw new Error("Impossible");
        }
        if (op === "AddAssignmentExpression") {
            var val = o[fname] + v;
            if (t1 === RT.Num) {
                if (val.__rtti__ !== RT.Num) {
                    throw new Error("assignmentWithOp add error, expected a number");
                }
                else {
                    return (o[fname] = val);
                }
            }
            else if (t1 === RT.Str || t1 === RT.Any) {
                return (o[fname] = val);
            }
            else {
                throw new Error("assignmentWithOp add error, field not a number/any/string");
            }
        }
        if (!(t1 === RT.Num || t1 === RT.Any)) {
            throw new Error("assignmentWithOp non-add op field type is not any or number");
        }
        switch (op) {
            case "SubtractAssignmentExpression":
                return (o[fname] -= v);
            case "MultiplyAssignmentExpression":
                return (o[fname] *= v);
            case "DivideAssignmentExpression":
                return (o[fname] /= v);
            case "ModuloAssignmentExpression":
                return (o[fname] %= v);
            case "AndAssignmentExpression":
                return (o[fname] &= v);
            case "ExclusiveOrAssignmentExpression":
                return (o[fname] ^= v);
            case "OrAssignmentExpression":
                return (o[fname] |= v);
            case "LeftShiftAssignmentExpression":
                return (o[fname] <<= v);
            case "SignedRightShiftAssignmentExpression":
                return (o[fname] >>= v);
            case "UnsignedRightShiftAssignmentExpression":
                return (o[fname] >>>= v);
            default:
                throw new Error("assignmentExpression: unidentified op: " + op);
        }
    }
    RT.assignmentWithOp = assignmentWithOp;
    function setTag(v, t) {
        v.__rtti__ = t;
        return v;
    }
    RT.setTag = setTag;
})(RT || (RT = {}));
